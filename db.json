{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"themes/next/source/404.html","path":"404.html","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/images/aoliao.png","path":"images/aoliao.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"5e652c697695368023d2328d5b665e192b305d81","modified":1472264507000},{"_id":"source/CNAME","hash":"ca4676214e2f3f6bcb8b587ab85416a7eb090157","modified":1472256196000},{"_id":"source/googlee38c2abb211044a0.html","hash":"fbe1313cda7c1564b9d70a27983b2db89453eb7e","modified":1472264684000},{"_id":"source/robots.txt","hash":"795f358a2d43be3abdbc6e46af8d652d2520aaac","modified":1472263485000},{"_id":"themes/next/.bowerrc","hash":"2b3e52c128518d9b84b1580579f1fba87b3c6236","modified":1478959557000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1472256196000},{"_id":"themes/next/.gitignore","hash":"799a3a3ec3b7f9a5f3b584c25843e2d7fb2a8d56","modified":1478959612000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1472256196000},{"_id":"themes/next/.javascript_ignore","hash":"de73037693881ad2626e2962e8c5ab243f7b24d0","modified":1478959620000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1472256196000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1472256196000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1472256196000},{"_id":"themes/next/bower.json","hash":"023b5b945bc45c205129a18e26d304fb9caa15c7","modified":1478959629000},{"_id":"themes/next/gulpfile.coffee","hash":"26e5b1b945704c8bc78b928feede895c4c111c95","modified":1472256196000},{"_id":"themes/next/_config.yml","hash":"5f5569e159a9b31e60b732486ab3308029a2ce0f","modified":1485141322000},{"_id":"themes/next/package.json","hash":"63e9c0f1dd9e5d7f51b4ae383981ef939a2ed45d","modified":1472256196000},{"_id":"source/_posts/2016-summary.md","hash":"c931482b61b7e0b05e99bcef35e138ba6cadaf85","modified":1484503462000},{"_id":"source/_posts/Introduction-to-Algorithms-2.md","hash":"8cb7986852c87c2a704e471f01bc2da3a40e3930","modified":1472256196000},{"_id":"source/_posts/Introduction-to-Algorithms-4.md","hash":"6a68ece0d50e047521d42d3bbdbaa60ef628315e","modified":1472256196000},{"_id":"source/_posts/Introduction-to-Algorithms-6.md","hash":"7f29e70a4644cd6f608f8e242694e10a64ef9fc8","modified":1472256196000},{"_id":"source/_posts/Introduction-to-Algorithms-7.md","hash":"5c44332270d086540489a26d84abc066e9243b91","modified":1472256196000},{"_id":"source/_posts/asymmetric-cryptography.md","hash":"c18c5bba4aae56d8a10500ee35c993f3607471dd","modified":1478957028000},{"_id":"source/_posts/Introduction-to-Algorithms-8.md","hash":"6eb469d2a064727292ee37eabe788fd12c86c17e","modified":1472256196000},{"_id":"source/_posts/binomial-and-poisson-and-normal-distribution.md","hash":"7ea47ac4f9f38b6c5e7712ec5e59968ab229aafe","modified":1485179465000},{"_id":"source/_posts/binary-search-tree.md","hash":"24d16f2bf23a4fd79160054a5de32db5d22cca19","modified":1489757953000},{"_id":"source/_posts/calculus-fundamental-theorem-2.md","hash":"6a5c058e00e96f16df06cf4b23641eac0b7ed89e","modified":1489313652000},{"_id":"source/_posts/calculate-24-game.md","hash":"1eb69d28b8dc5236a9d51cf87c6e8c7c2d9be965","modified":1489757986000},{"_id":"source/_posts/captcha-by-node-canvas.md","hash":"3a0252c7b9a3057e9a0bc6c857d1b8b4458259cf","modified":1489762114000},{"_id":"source/_posts/central-limit-theorem.md","hash":"50866e2eebf75321bcbef746402e7572a465b204","modified":1485189238000},{"_id":"source/_posts/clock-operation.md","hash":"aa4f4ec0f3ee1d766c1258f3616cfb741c66f11a","modified":1485179575000},{"_id":"source/_posts/coefficient-of-determination.md","hash":"f462f42a524161d12b5150c16e8b8f16c97988c9","modified":1487603757000},{"_id":"source/_posts/common-derivation-formula.md","hash":"6cfc63fbf0e3bba9481f1b012687258091ac487b","modified":1488079605000},{"_id":"source/_posts/confidence-interval.md","hash":"5b77348c4cd33cde61f7cb927256dad0e9926e53","modified":1486627101000},{"_id":"source/_posts/currying.md","hash":"3a99f4cc4b03da116312f0b11ed7437064add78b","modified":1489757995000},{"_id":"source/_posts/data-capture.md","hash":"810f74e961d7d31ac9dad9f9e98ec913b1807ac4","modified":1489758000000},{"_id":"source/_posts/data-structures.md","hash":"637bcdb7c8615bd063c0d7a6606e48f6de9e83de","modified":1489758011000},{"_id":"source/_posts/data-structures-2.md","hash":"9865af50efbe60a071cd56eb1753ac4f6900a6ad","modified":1489758005000},{"_id":"source/_posts/diffie-hellman-key-exchange.md","hash":"40f4a17e7f347ae71a6eb27a7ccaa3fc52121c94","modified":1485179573000},{"_id":"source/_posts/exponentials-and-logarithms-derivative.md","hash":"9b1ff350415e945bdd90fe291090f240823e7e49","modified":1488082320000},{"_id":"source/_posts/express-permission.md","hash":"071f078052bbaea523f9cc8581e71b2cc70910a2","modified":1489758017000},{"_id":"source/_posts/five-in-a-row-game.md","hash":"83971d10fbe6f3dbb3163ad61dd833e4307052ba","modified":1489758023000},{"_id":"source/_posts/genetic-algorithm.md","hash":"e12e91d8aefb8c6acca00e1195559bfd37437996","modified":1482115658000},{"_id":"source/_posts/hexo-mathjax.md","hash":"7761542f1cc5a3939d014436e532fd150ab91356","modified":1485016296000},{"_id":"source/_posts/hypothesis-testing.md","hash":"1b2b554a594406c68bf1d2b458f9990e16a08579","modified":1487001541000},{"_id":"source/_posts/keng-in-hexo.md","hash":"3f1cc7212413564557d97f4330a7be4abdd863ae","modified":1489758030000},{"_id":"source/_posts/learn-from-rop.md","hash":"e02bb35b3c5eaa7bb4065cb2eb8ecb04bac83c8d","modified":1490065653000},{"_id":"source/_posts/implicit-differentiation.md","hash":"75001b3defc48d75bd358576a34713f0ff5efdf1","modified":1488032728000},{"_id":"source/_posts/learn-kafka.md","hash":"9e9a2bcf47578e03a9f50dc364b32a94767ebe44","modified":1489758039000},{"_id":"source/_posts/linear-regression.md","hash":"27bf253d9532207840b4140503b2d246d9d782f1","modified":1487088856000},{"_id":"source/_posts/natural-language-processing-1.md","hash":"00e92c9acbe5857167c809e82a8d992a3774cbb7","modified":1472256196000},{"_id":"source/_posts/power-series.md","hash":"bddde7fb17ea28cd03784d19d10e9d85a8a77680","modified":1490406101000},{"_id":"source/_posts/linear-and-quadratic-approximation.md","hash":"c3ea77b92ed755fae831c1b768a7c0e51b6e8e55","modified":1489287940000},{"_id":"source/_posts/newton-iteration-method.md","hash":"7c158f8b353c12d2a3227720156f83142748d297","modified":1489311338000},{"_id":"source/_posts/node-canvas-chinese.md","hash":"96f15aa470922c5b2779792d667722bae94ffbf6","modified":1489762089000},{"_id":"source/_posts/reverse-proxy-to-solve-cross-origin.md","hash":"08ce25e4eb904fd023920ddefa6878e73620fbaa","modified":1494681616000},{"_id":"source/_posts/project-development-process.md","hash":"1251db7b92407fd41773ce19966d2b0f4e1fb5bb","modified":1487065782000},{"_id":"source/_posts/react-router-dynamic.md","hash":"eed7103e2b82a0bdd0dfc8b85e7652271aa7ce0e","modified":1489758044000},{"_id":"source/_posts/red-black-tree.md","hash":"870510337a24f95e76509cd03c7ebb85c7e155f0","modified":1489758054000},{"_id":"source/_posts/thread-in-javascript.md","hash":"23d622f947517048eed3ad99d1cbee0c93819e51","modified":1489758060000},{"_id":"source/_posts/statistics-tendency.md","hash":"f017f65b6dc6250fa984b209be0cac38f71113f8","modified":1485139692000},{"_id":"source/_posts/update-gcc.md","hash":"646f55fad1323e5ffdba4755ce800f917c3a4beb","modified":1477453115000},{"_id":"source/_posts/use-svg-to-draw-line.md","hash":"b5d112f3324244e3e7f9246912e34d4b8edd21d0","modified":1489758067000},{"_id":"source/categories/index.md","hash":"febd887e2f4b7d531a03f6125152ec36416aacd7","modified":1472256196000},{"_id":"source/tags/index.md","hash":"3365be6aa2194cf67a2505b305458372491a2c54","modified":1472256196000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1472256196000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1472256196000},{"_id":"themes/next/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1472256196000},{"_id":"themes/next/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1472256196000},{"_id":"themes/next/languages/en.yml","hash":"f03799cbdb5a33064ead080bcac4baca1f6bc5f9","modified":1472256196000},{"_id":"themes/next/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1472256196000},{"_id":"themes/next/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1472256196000},{"_id":"themes/next/languages/id.yml","hash":"147c01e41b931085ad14250fa900c2249dcbbdd7","modified":1472256196000},{"_id":"themes/next/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1472256196000},{"_id":"themes/next/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1472256196000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"bea452bc49aed171a210d09bd6cddc4e846ea8ab","modified":1472256196000},{"_id":"themes/next/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1472256196000},{"_id":"themes/next/languages/zh-tw.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1472256196000},{"_id":"themes/next/layout/_layout.swig","hash":"74157f6cfd679ea11febec632542793f37c5e5d4","modified":1472256196000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1472256196000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1472256196000},{"_id":"themes/next/layout/index.swig","hash":"9f6922dad59a2c6370c4253a86dd21a7a0f857c3","modified":1472265382000},{"_id":"themes/next/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1472256196000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1472256196000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1472256196000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1472256196000},{"_id":"themes/next/source/404.html","hash":"3f0cfb0b8a15eec015e87738cbeffc2f205ce70e","modified":1472256196000},{"_id":"themes/next/test/.jshintrc","hash":"096ed6df627373edd820f24d46b8baf528dee61d","modified":1472256196000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1472256196000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1472256196000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472256196000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1472256196000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"b883289054ee54a374caad5d4883591beb94bd8b","modified":1472256196000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1472256196000},{"_id":"themes/next/layout/_macro/post.swig","hash":"1ca03011bed92614832b1343b65be92183957dc5","modified":1472256196000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1472256196000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"85327c2174d09c6d69c9033592e6c8f7eb7ac3ba","modified":1472256196000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"b73f9443bee2d3ea383aad52e49ffca8aa97dcc2","modified":1472256196000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"0ce71d8322ea7dea82d9371fa2fe13949aa870e3","modified":1472256196000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1472256196000},{"_id":"themes/next/layout/_partials/search.swig","hash":"011b9d6c9f0a2f4654908ea20b9391f9b7981271","modified":1472256196000},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b0c495b8154ef8b2d2cb0a554e164ff22cdc962","modified":1472256196000},{"_id":"themes/next/layout/_partials/header.swig","hash":"963a765dc00e6ac43cfc53ffaf5725eb854cf95e","modified":1472256196000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1472256196000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1472256196000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1472256196000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1472256196000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"82d060fe055d6e423bbc9199f82dfe5c68e74779","modified":1472256196000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1472256196000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1472256196000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1472256196000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1472256196000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1472256196000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1472256196000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1472256196000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1472256196000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1472256196000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1472256196000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1472256196000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1472256196000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1472256196000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1472256196000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1472256196000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1472256196000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472256196000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472256196000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472256196000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472256196000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472256196000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472256196000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472256196000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1472256196000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1472256196000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1472256196000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1472256196000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"c07f7b2f264e5215b8ed42d67e8cef2477558364","modified":1472256196000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"7ca5cb4daa58b3504e17f3e02975e794bc634658","modified":1472256196000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1472256196000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1472256196000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1472256196000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1472256196000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1472256196000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1472256196000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1472256196000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"1561bd0c107d725252c6d746e9ac177fc18f93bf","modified":1472256196000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"5bafc33f57508d1d04a9930165240f6e9efa8d6d","modified":1472256196000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1472256196000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1472256196000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1472256196000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1472256196000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1472256196000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"3ead77befa064d6327dc7afd0a5af7be59a5f196","modified":1472256196000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"17624186f7a1f28daddea258d044f8e03b2f4bea","modified":1472256196000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1472256196000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1472256196000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1472256196000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1472256196000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1472256196000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1472256196000},{"_id":"themes/next/source/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1472256196000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1472256196000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1472256196000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1472256196000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1472256196000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1472256196000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1472256196000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1472256196000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1472256196000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1472256196000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1472256196000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1472256196000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1472256196000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1472256196000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1472256196000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1472256196000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1472256196000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1472256196000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1472256196000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1472256196000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1472256196000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1472256196000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1472256196000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1472256196000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1472256196000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"f9c6ee91c2a615edd8ca26edcc8a66b71883c238","modified":1472256196000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1472256196000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1472256196000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1472256196000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1472256196000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"8c7af79407d223486fba72b8150fe045a553bf70","modified":1472256196000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"bff3b18f56175c53f3bc6d733166c4d998e08732","modified":1472256196000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1472256196000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1472256196000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1472256196000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1472256196000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1472256196000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1472256196000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6ed60cc621bac096c0ed7534fa25b1a52dc571d4","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"8d7cecde4933900c7df2db9d0a98f5f82f88dc93","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1472256196000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1472256196000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1472256196000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1472256196000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1472256196000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1472256196000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1472256196000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1472256196000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1472256196000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1472256196000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1472256196000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1472256196000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1472256196000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1472256196000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1472256196000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1472256196000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1472256196000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1472256196000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1472256196000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1472256196000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1472256196000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1472256196000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"90f8f9706cd7fe829cf06e9959a65fd3f8b994fa","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4da051c7f3924fa2db1e73c55b2baf1c2c150255","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d543d1377c1f61b70e3adb6da0eb12797552e5f2","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"3afc459442c132c480d1d832f1a872f1070bb048","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"795d94561888d31cb7a6ff4a125596809ea69b7d","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1472256196000},{"_id":"themes/next/source/images/aoliao.png","hash":"4cf2a2757bcf9b20a36af91d43835198ba6c3cba","modified":1472256196000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1472256196000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1472256196000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1472256196000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1472256196000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1472256196000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1472256196000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1472256196000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1472256196000},{"_id":"public/CNAME","hash":"ca4676214e2f3f6bcb8b587ab85416a7eb090157","modified":1494681667684},{"_id":"public/googlee38c2abb211044a0.html","hash":"6387656694aae83a0b53041b6fe80cce08fc2cf0","modified":1494681667715},{"_id":"public/baidusitemap.xml","hash":"5277fc2c94fc26ca56cf812050b75850fba3c888","modified":1494681667715},{"_id":"public/sitemap.xml","hash":"6c95aa3698cf0fdd88a4fe5a3e58f9e5f4c174b5","modified":1494681667715},{"_id":"public/categories/index.html","hash":"04f5baa63e2d888639e7e119f2a6602c40cff4f7","modified":1494681667804},{"_id":"public/tags/index.html","hash":"780dbdb00d7227b9431a05bb0e3c4a8cf6fbd434","modified":1494681667805},{"_id":"public/archives/2016/06/index.html","hash":"fc9f2f74b9969fc00d76dcfca7aebe44e52d4f36","modified":1494681667805},{"_id":"public/archives/2016/09/index.html","hash":"2d792c37c6b0a87b9a8aebc4796cbf868b5691d3","modified":1494681667805},{"_id":"public/archives/2016/10/index.html","hash":"65b781e3ae172d5d77cd86a62e801072b8042372","modified":1494681667805},{"_id":"public/archives/2016/12/index.html","hash":"8be85655bb089774e025407fa2119eb50f1968b2","modified":1494681667805},{"_id":"public/tags/总结/page/2/index.html","hash":"e1fd671f0c78ebfd93f07c3f9d4843212bd0a0e9","modified":1494681667805},{"_id":"public/tags/密码技术/index.html","hash":"d4b77c10245399cd175ab9ba794c06796a1610d6","modified":1494681667805},{"_id":"public/tags/数据结构/index.html","hash":"a39bb354fef20d86b019697780adf8f55a4ccba3","modified":1494681667805},{"_id":"public/tags/nodejs/index.html","hash":"48474f9338c3d7cf2efb9ad5678b47ee3a42230e","modified":1494681667805},{"_id":"public/tags/javascript/index.html","hash":"b54e8bb00dc84b7e34cadda5a1c453c3084f58bb","modified":1494681667805},{"_id":"public/tags/express/index.html","hash":"2a1ca06ad30fc6c927633a94a1f7a463b8eadcc1","modified":1494681667805},{"_id":"public/tags/hexo/index.html","hash":"1529f079e599b635c1ae233531516eef33de6bfd","modified":1494681667805},{"_id":"public/tags/kafka/index.html","hash":"5c840d2f57f3d9e2fc01ecd2973e59b6b5bfa18a","modified":1494681667805},{"_id":"public/tags/自然语言处理-读书笔记/index.html","hash":"c7b855d1d4dab979d5a97493004d5582791f9257","modified":1494681667805},{"_id":"public/tags/react/index.html","hash":"d49798aec9e4960381c083e6d84fe80aaea8fe1a","modified":1494681667806},{"_id":"public/tags/svg/index.html","hash":"77d2796d66d6ebbaffe21e93b8b667bcb8658e4f","modified":1494681667806},{"_id":"public/2017/03/25/power-series/index.html","hash":"e26a1a64bcd26b97de047aab02131bfc1ca1a274","modified":1494681667806},{"_id":"public/2017/03/17/learn-from-rop/index.html","hash":"a205552f28c09aea8349bde2e7ed89cc9df0d846","modified":1494681667806},{"_id":"public/2017/03/12/calculus-fundamental-theorem-2/index.html","hash":"f93e5553cc64fbe77c451c948002825c871e73cd","modified":1494681667806},{"_id":"public/2017/03/12/newton-iteration-method/index.html","hash":"ebb4db45f4e9f8d3efd72f8a0df784df9802ef04","modified":1494681667806},{"_id":"public/2017/03/12/linear-and-quadratic-approximation/index.html","hash":"778d5870c7fe392a1ce1cf4d9f1b3ad6dcd52542","modified":1494681667806},{"_id":"public/2017/02/25/exponentials-and-logarithms-derivative/index.html","hash":"0704cb582b4bdb6117132fc89921b1807586a4f9","modified":1494681667806},{"_id":"public/2017/02/25/implicit-differentiation/index.html","hash":"e65e2b8a74ef489f018b9a19844acf3bcb14b544","modified":1494681667806},{"_id":"public/2017/02/25/common-derivation-formula/index.html","hash":"e8afafebb3d23918b91014ef7e881aa60970bbec","modified":1494681667806},{"_id":"public/2017/02/20/coefficient-of-determination/index.html","hash":"ede510fd12deb3184ea716fb3b824b40bdd22915","modified":1494681667806},{"_id":"public/2017/02/14/linear-regression/index.html","hash":"77f274fd8eb2ecdcc9da7bdb719c6ed4bb7cf090","modified":1494681667806},{"_id":"public/2017/02/14/project-development-process/index.html","hash":"db1f46072f5062add0351614a3801e632d13d2ac","modified":1494681667806},{"_id":"public/2017/02/13/hypothesis-testing/index.html","hash":"c450512576868282271625953d44816ffd9d625e","modified":1494681667806},{"_id":"public/2017/01/27/confidence-interval/index.html","hash":"7b07b577f23cabb2f0d6cb652e8d835dcbf7cc72","modified":1494681667806},{"_id":"public/2017/01/23/central-limit-theorem/index.html","hash":"dc4f3d3b30d4600bde4fea5a450e88db37d1d09e","modified":1494681667806},{"_id":"public/2017/01/22/binomial-and-poisson-and-normal-distribution/index.html","hash":"79583029eafaf48abbfd651b77448b45aac43506","modified":1494681667806},{"_id":"public/2017/01/21/statistics-tendency/index.html","hash":"f50689b49af8df6dfaa5d472db37ddfa220605fa","modified":1494681667806},{"_id":"public/2017/01/21/hexo-mathjax/index.html","hash":"3f9c90c37efee5b5098a5c46089350a7f4600046","modified":1494681667806},{"_id":"public/2017/01/16/2016-summary/index.html","hash":"4d899e805d658cef1f7c4ff026482018fa07c2f6","modified":1494681667806},{"_id":"public/2016/12/08/genetic-algorithm/index.html","hash":"c892c599fddc82c937d33472230313a446c320ba","modified":1494681667806},{"_id":"public/2016/11/18/node-canvas-chinese/index.html","hash":"3148637a446d5273b91afb2fc0719071f911f8d0","modified":1494681667807},{"_id":"public/2016/11/17/captcha-by-node-canvas/index.html","hash":"34623a867b39674e79a3121d54d780f3865518aa","modified":1494681667807},{"_id":"public/2016/11/13/diffie-hellman-key-exchange/index.html","hash":"0ec664ba421aaaf76e309d955d446d3f2dec9fb0","modified":1494681667807},{"_id":"public/2016/11/10/clock-operation/index.html","hash":"9fe46d0ca3da1c5d5776e5c44b03b16a27bd1135","modified":1494681667807},{"_id":"public/2016/11/03/asymmetric-cryptography/index.html","hash":"53e305607ebc59256790e7a73e3cbfcf46293d0f","modified":1494681667807},{"_id":"public/2016/10/26/update-gcc/index.html","hash":"3de271d45fee3c6b6b28d306109374f4a602470e","modified":1494681667807},{"_id":"public/2016/10/25/express-permission/index.html","hash":"6c334de26be468f9ec7ecb3ec115e756d0e2acc7","modified":1494681667807},{"_id":"public/2016/10/12/react-router-dynamic/index.html","hash":"39f5fc250785e8732d3f1711f25c87f56b4cf272","modified":1494681667807},{"_id":"public/2016/09/30/learn-kafka/index.html","hash":"3d51d47053c0ae9a2f4ce3e2a97ca38977fc67a0","modified":1494681667807},{"_id":"public/2016/08/27/keng-in-hexo/index.html","hash":"db622fb3c387ebdde877704af9819358f22f725a","modified":1494681667808},{"_id":"public/2016/08/27/thread-in-javascript/index.html","hash":"b9315f6a11cf8c342992cde8505696ae63fbf8ea","modified":1494681667808},{"_id":"public/2016/08/12/data-capture/index.html","hash":"90d35b95b56532b72f0b05c5773b77c7c9296e33","modified":1494681667808},{"_id":"public/2016/08/07/red-black-tree/index.html","hash":"07305ce2c46747b27a45499786cad9790c7190a9","modified":1494681667808},{"_id":"public/2016/08/07/binary-search-tree/index.html","hash":"524c052abd04004f0193a405f853a211dbedb9c5","modified":1494681667808},{"_id":"public/2016/07/31/five-in-a-row-game/index.html","hash":"fad61a84abe7b422c3959ebc0cf8758731b19022","modified":1494681667808},{"_id":"public/2016/07/26/data-structures-2/index.html","hash":"dc5c7171d19e5fd76f0d4f4b75db1145993b2315","modified":1494681667808},{"_id":"public/2016/07/24/data-structures/index.html","hash":"226daaf2fdd7143f0d5d3ed93e0a2f711df30d6a","modified":1494681667808},{"_id":"public/2016/07/19/calculate-24-game/index.html","hash":"eb6fc5ebe96dd7a3ef50358c01f2dc3d1c85e435","modified":1494681667808},{"_id":"public/2016/07/10/natural-language-processing-1/index.html","hash":"930c286c775cb9f270c2782e54a9b7def8fdf673","modified":1494681667808},{"_id":"public/2016/07/09/Introduction-to-Algorithms-8/index.html","hash":"5ccce86b5212e66a0021a1a5f970abfa4c046665","modified":1494681667808},{"_id":"public/2016/07/07/Introduction-to-Algorithms-7/index.html","hash":"5b40c536fd0fc7c55c8e21cb8839548872d16f01","modified":1494681667808},{"_id":"public/2016/07/04/currying/index.html","hash":"a520d0ec42f351c66543b008bd8b5973db7acd96","modified":1494681667808},{"_id":"public/2016/07/03/Introduction-to-Algorithms-6/index.html","hash":"a5cf0a571a73610cd1e9db74619f19d41ec7f7f0","modified":1494681667809},{"_id":"public/2016/06/29/Introduction-to-Algorithms-4/index.html","hash":"b32294dd98d657128de955eb3ce6d9f31687c46f","modified":1494681667809},{"_id":"public/2016/06/28/use-svg-to-draw-line/index.html","hash":"26d65de9c5eb61174985265e1cfcd77847a1f888","modified":1494681667809},{"_id":"public/2016/06/27/Introduction-to-Algorithms-2/index.html","hash":"7dcf41b43015ba4b565882cce1e131c614f6dc01","modified":1494681667809},{"_id":"public/archives/index.html","hash":"e2bf4d2bf47bb87a0f31691d8349ae2d243731fe","modified":1494681667809},{"_id":"public/archives/page/2/index.html","hash":"0b5bb6eda84f4751fdba576a84fd4c42d07d884c","modified":1494681667809},{"_id":"public/archives/page/3/index.html","hash":"e801d08345b949b682b3b606f48e5db976a0291c","modified":1494681667809},{"_id":"public/archives/page/4/index.html","hash":"5903e747180740ac3cc7e7fb45615ecfb140eef3","modified":1494681667809},{"_id":"public/archives/page/5/index.html","hash":"ff8f877cba07fc13443ec8643a789ed3d6949b05","modified":1494681667809},{"_id":"public/archives/2016/index.html","hash":"022c91b6b63e84d7c13f789f3cdad77328d6e5b7","modified":1494681667809},{"_id":"public/archives/2016/page/2/index.html","hash":"2630d5e466fff8c926c50b8ddc040361379b2ac6","modified":1494681667809},{"_id":"public/archives/2016/page/3/index.html","hash":"aa340ac84b652e67bc0d0d3e6e1c621306e51260","modified":1494681667809},{"_id":"public/archives/2016/07/index.html","hash":"9a13dd1072d6c9fce415f42af55a08efde5d7646","modified":1494681667809},{"_id":"public/archives/2016/08/index.html","hash":"786afe105fec7505c58b923a20a8a8b981a51a6b","modified":1494681667809},{"_id":"public/archives/2016/11/index.html","hash":"648f1500d944d7960753151d937105261374bb9e","modified":1494681667809},{"_id":"public/archives/2017/index.html","hash":"e06363d247b67b3cea714df0561ef3d64be1f7e0","modified":1494681667809},{"_id":"public/archives/2017/page/2/index.html","hash":"447c43ed515350ef3d8ca39d121bc1c6269d4a93","modified":1494681667809},{"_id":"public/archives/2017/01/index.html","hash":"60d6f965abbe21e9f32abf05370bdb6ab9b49a07","modified":1494681667809},{"_id":"public/archives/2017/02/index.html","hash":"ae99d7d0d0cc8e8e41a359bfb5f3f2fef1e7b1bd","modified":1494681667810},{"_id":"public/archives/2017/03/index.html","hash":"9a7cb80b1017673dedff530490a1f8c2cab0ad03","modified":1494681667810},{"_id":"public/index.html","hash":"02314c315db3c9d8b1d6e892776220779d24d443","modified":1494681667810},{"_id":"public/page/2/index.html","hash":"3f7b6bdf11285f9753fe06a8bfde0268917ee948","modified":1494681667810},{"_id":"public/page/3/index.html","hash":"4c895effe89c12c918ac0251b883eb766af290fa","modified":1494681667810},{"_id":"public/page/4/index.html","hash":"1d5f82112f6c4a601d8411ddd24f1016575facc5","modified":1494681667810},{"_id":"public/page/5/index.html","hash":"5a63b9ebc5d51380d0fa187b47129bc23b05816e","modified":1494681667810},{"_id":"public/tags/总结/index.html","hash":"ca33d38e962ca51a666fe5c1181725ca5d7c4f57","modified":1494681667810},{"_id":"public/tags/读书笔记/index.html","hash":"c4f32fb2575e8f38ff30131af690055d87fabc59","modified":1494681667810},{"_id":"public/tags/算法/index.html","hash":"7d6b43dd8a43f8fa89fceaa490d327d8f3196549","modified":1494681667810},{"_id":"public/tags/统计学/index.html","hash":"dede545049fe651fb2d6dc3b489bfc130d76f79e","modified":1494681667810},{"_id":"public/tags/单变量微积分/index.html","hash":"7d98e97b450325e3028aab04370d849ca5cd61c1","modified":1494681667810},{"_id":"public/archives/2017/05/index.html","hash":"7e13cbc412dcc2344aed8676de4d4ba220c520ef","modified":1494681667817},{"_id":"public/tags/nginx/index.html","hash":"dbdacb739dfe21ddaa6fdd3355fb606908866fb2","modified":1494681667817},{"_id":"public/2017/05/13/reverse-proxy-to-solve-cross-origin/index.html","hash":"83c451eebb30606cb6841cb5ef5ceb01ca5eadc9","modified":1494681667817},{"_id":"public/robots.txt","hash":"795f358a2d43be3abdbc6e46af8d652d2520aaac","modified":1494681667822},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1494681667823},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1494681667823},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1494681667823},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1494681667823},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1494681667823},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1494681667823},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1494681667823},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1494681667823},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1494681667823},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1494681667824},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1494681667824},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1494681667824},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1494681667824},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1494681667824},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1494681667824},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1494681667824},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1494681667824},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1494681667824},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1494681667824},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1494681667824},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1494681667824},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1494681667824},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1494681667824},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1494681667824},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1494681668807},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1494681668811},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1494681668814},{"_id":"public/404.html","hash":"3f0cfb0b8a15eec015e87738cbeffc2f205ce70e","modified":1494681668825},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1494681668825},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1494681668826},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1494681668826},{"_id":"public/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1494681668826},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1494681668826},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1494681668826},{"_id":"public/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1494681668826},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1494681668826},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1494681668826},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1494681668826},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1494681668826},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1494681668826},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1494681668826},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1494681668826},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1494681668827},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1494681668827},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1494681668828},{"_id":"public/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1494681668828},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1494681668828},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1494681668828},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1494681668828},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1494681668828},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1494681668828},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1494681668828},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1494681668828},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1494681668828},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1494681668828},{"_id":"public/css/main.css","hash":"216cf5a7812951ad3956aba6ebfa5f5e64e31598","modified":1494681668828},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1494681668828},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1494681668828},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1494681668829},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1494681668829},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1494681668829},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1494681668829},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1494681668829},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1494681668829},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1494681668830},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1494681668830},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1494681668838},{"_id":"public/images/aoliao.png","hash":"4cf2a2757bcf9b20a36af91d43835198ba6c3cba","modified":1494681668843}],"Category":[],"Data":[],"Page":[{"layout":"false","_content":"\ngoogle-site-verification: googlee38c2abb211044a0.html","source":"googlee38c2abb211044a0.html","raw":"layout: false\n---\n\ngoogle-site-verification: googlee38c2abb211044a0.html","date":"2016-08-27T02:24:44.000Z","updated":"2016-08-27T02:24:44.000Z","path":"googlee38c2abb211044a0.html","title":"","comments":1,"_id":"cj2navcsf0000n927hgls49h3","content":"\ngoogle-site-verification: googlee38c2abb211044a0.html","excerpt":"","more":"\ngoogle-site-verification: googlee38c2abb211044a0.html"},{"title":"分类","date":"2016-06-29T06:43:40.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2016-06-29 14:43:40\ntype: \"categories\"\n---\n","updated":"2016-08-27T00:03:16.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cj2navcuh0002n927y6zj7qpy","content":"","excerpt":"","more":""},{"title":"标签","date":"2016-06-29T06:41:28.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2016-06-29 14:41:28\ntype: \"tags\"\n---\n","updated":"2016-08-27T00:03:16.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cj2navcuk0004n9279emlw944","content":"","excerpt":"","more":""}],"Post":[{"title":"2016 工作总结","date":"2017-01-15T18:00:00.000Z","_content":"\n不知不觉已经毕业半年了，时间如白驹过隙，忽然而已\n\n<!-- more -->\n\n### 做了哪些事情\n\n从 6 月底入职到现在有半年多，把这段时间做的事情可以划分成三类：\n\n1. 前端\n\n   刚来的时候参与做营销技术平台的前端，主要做的是在仁洪搭好的框架上完成功能开发\n\n   包括还有一段时间和国存做了一些老线索开放平台的前端\n\n   大概 8 月份的时候开始做鹰眼，做了鹰眼的前端\n\n2. nodejs 搭建后台\n\n   使用 nodejs 做了鹰眼的后台和线索开放平台的后台\n\n3. 数据抓取\n\n   除了上面两点，还有一个做的比较多的是用 nodejs 抓各个平台的数据\n\n总的来说这半年越来越多做 nodejs 方面的事情，或者应该说做了越来越多 javascript 的事情。\n\n技术上前端使用过了 reactjs 和 angularjs 框架，配合 webpack 现在一般都是写 es6 的代码。\n\n后端使用了 express 框架，顺带补了一些后端的知识点，捡了捡 mysql，认识了 redis，使用了 orm 框架等等。\n\n实际上做的事情不算多，反而看起来有些杂，有时候朋友半开玩笑的说你这是全栈的节奏啊。其实我并不觉得自己是在往全栈工程师去发展，实际上我一直还是把自己当做前端工程师，只是为了解决问题，去尝试使用更多的方法，既然 node 能抓数据，就用 node 去做，既然 node 能做后台，那正好能减少一个后台同学的成本。觉得与其刻意去做全栈，不如做一个能够解决问题的人吧。\n\n### 调研\n\n要说比较特别的地方，是做了一些技术的调研。其实我也并没有觉得自己调研方面有什么特长的地方，调研其实是一件很普通的事情，我们每天都在做调研：今天碰到什么问题啦，是不是这个框架有什么坑啦，这个功能用什么技术实现最优雅啦等等等，只是有时候对这些问题都是抱着解决即可的态度去查资料，浅尝即止，可能看了个百度知道就没了。\n\n所以归根结底还是态度的问题，首先要保持一种心态，调研这个技术一定是对自己有帮助的，而不是只是想解决一个 bug 或者什么，为了提高自己去调研才有学习的动力。然后调研的过程其实是一个自上而下的过程，根节点是你要调研的技术， 而这个技术往往（或者说必定）涉及到其他的技术，然后又会衍生出更多的技术，可能有的听都没听过，调研的深度其实就是这棵树的深度，调研的效果取决于你在哪一层放弃。\n\n### 不足\n\n其实做的东西杂有一个好处，好处也不言自喻：能学到更多的知识。但是同时也带来一个效应：知识圈越大，越觉得不会的东西越多。感觉到自己在很多方面都有很大不足，有种 **手足无措** 的感觉，就像面前摆了很多水果，先吃哪个，该吃多少。\n\n其实这还是一个规划和执行力的问题，这一点在这半年应该说做的不好，其实还有很多内容没有看到，一直都感觉自己各方面都还很不足。\n\n另外一方面，**独立组织代码结构** 还是有点问题，现在最直接的体验就是，可能写了五个脚本，项目能够跑起来，需求也能解决，但是这个项目结构很差，或者说可维护性差。\n\n针对这个问题，反省可能是设计方面知识的欠缺，因为 **框架不就是解决这个问题的吗！**所以最近打算看看设计模式的几本书，\n\n### 看书\n\n我终于发现手足无措要怎么治了，那就是——多看书。读书是一件非常充实的事情，如果觉得哪里做的不好，那就去看哪方面的书，非常有效。\n\n> 烦恼太多就是因为读书少，或者没睡好。\n>\n> —— 艾伦·麦席森·阿哲\n\n这半年看的书实在是太少了，令人发指的少，今年要有针对性的看书。\n\n把目前需要读的技术类书也划成四类：\n\n1. **纯技术类**\n\n   纯技术的书，比如《了不起的 nodejs》，这类书对日常工作有最直接的影响，可能项目遇到了什么问题，看完书就能解决了。\n\n2. **基础类**\n\n   更像是上学的时候应该掌握的内容，偏底层和理论，比如《HTTP 权威指南》、《javascript 设计模式》\n\n3. **算法类**\n\n   讲算法的书，比如《算法导论》，这类书对日常工作并没有直接的影响，但是对程序员生涯影响是比较大的，不了解几个算法好意思说自己是程序员吗？\n\n4. **兴趣类**\n\n   日常工作并不会用到的，完全凭兴趣了解的，比如《图解密码技术》\n\n不同阶段，这几类书的优先级应该是不同的。按这半年的体验来看，现在应该 1 > 2 > 3 > 4 来看，解决问题优先，优化其次。\n\n技术类的书是需要看的最多的，都以日常工作需要用到的为主，比如 nodejs，javascript 的书，基础类的以 web 开发的为主，http(s) 协议、tcp/ip 等等，算法类的穿插看，其实可以多看博客，兴趣类的闲着没事的时候看。","source":"_posts/2016-summary.md","raw":"---\ntitle: 2016 工作总结\ndate: 2017-01-16 02:00:00\ntags: [总结]\n---\n\n不知不觉已经毕业半年了，时间如白驹过隙，忽然而已\n\n<!-- more -->\n\n### 做了哪些事情\n\n从 6 月底入职到现在有半年多，把这段时间做的事情可以划分成三类：\n\n1. 前端\n\n   刚来的时候参与做营销技术平台的前端，主要做的是在仁洪搭好的框架上完成功能开发\n\n   包括还有一段时间和国存做了一些老线索开放平台的前端\n\n   大概 8 月份的时候开始做鹰眼，做了鹰眼的前端\n\n2. nodejs 搭建后台\n\n   使用 nodejs 做了鹰眼的后台和线索开放平台的后台\n\n3. 数据抓取\n\n   除了上面两点，还有一个做的比较多的是用 nodejs 抓各个平台的数据\n\n总的来说这半年越来越多做 nodejs 方面的事情，或者应该说做了越来越多 javascript 的事情。\n\n技术上前端使用过了 reactjs 和 angularjs 框架，配合 webpack 现在一般都是写 es6 的代码。\n\n后端使用了 express 框架，顺带补了一些后端的知识点，捡了捡 mysql，认识了 redis，使用了 orm 框架等等。\n\n实际上做的事情不算多，反而看起来有些杂，有时候朋友半开玩笑的说你这是全栈的节奏啊。其实我并不觉得自己是在往全栈工程师去发展，实际上我一直还是把自己当做前端工程师，只是为了解决问题，去尝试使用更多的方法，既然 node 能抓数据，就用 node 去做，既然 node 能做后台，那正好能减少一个后台同学的成本。觉得与其刻意去做全栈，不如做一个能够解决问题的人吧。\n\n### 调研\n\n要说比较特别的地方，是做了一些技术的调研。其实我也并没有觉得自己调研方面有什么特长的地方，调研其实是一件很普通的事情，我们每天都在做调研：今天碰到什么问题啦，是不是这个框架有什么坑啦，这个功能用什么技术实现最优雅啦等等等，只是有时候对这些问题都是抱着解决即可的态度去查资料，浅尝即止，可能看了个百度知道就没了。\n\n所以归根结底还是态度的问题，首先要保持一种心态，调研这个技术一定是对自己有帮助的，而不是只是想解决一个 bug 或者什么，为了提高自己去调研才有学习的动力。然后调研的过程其实是一个自上而下的过程，根节点是你要调研的技术， 而这个技术往往（或者说必定）涉及到其他的技术，然后又会衍生出更多的技术，可能有的听都没听过，调研的深度其实就是这棵树的深度，调研的效果取决于你在哪一层放弃。\n\n### 不足\n\n其实做的东西杂有一个好处，好处也不言自喻：能学到更多的知识。但是同时也带来一个效应：知识圈越大，越觉得不会的东西越多。感觉到自己在很多方面都有很大不足，有种 **手足无措** 的感觉，就像面前摆了很多水果，先吃哪个，该吃多少。\n\n其实这还是一个规划和执行力的问题，这一点在这半年应该说做的不好，其实还有很多内容没有看到，一直都感觉自己各方面都还很不足。\n\n另外一方面，**独立组织代码结构** 还是有点问题，现在最直接的体验就是，可能写了五个脚本，项目能够跑起来，需求也能解决，但是这个项目结构很差，或者说可维护性差。\n\n针对这个问题，反省可能是设计方面知识的欠缺，因为 **框架不就是解决这个问题的吗！**所以最近打算看看设计模式的几本书，\n\n### 看书\n\n我终于发现手足无措要怎么治了，那就是——多看书。读书是一件非常充实的事情，如果觉得哪里做的不好，那就去看哪方面的书，非常有效。\n\n> 烦恼太多就是因为读书少，或者没睡好。\n>\n> —— 艾伦·麦席森·阿哲\n\n这半年看的书实在是太少了，令人发指的少，今年要有针对性的看书。\n\n把目前需要读的技术类书也划成四类：\n\n1. **纯技术类**\n\n   纯技术的书，比如《了不起的 nodejs》，这类书对日常工作有最直接的影响，可能项目遇到了什么问题，看完书就能解决了。\n\n2. **基础类**\n\n   更像是上学的时候应该掌握的内容，偏底层和理论，比如《HTTP 权威指南》、《javascript 设计模式》\n\n3. **算法类**\n\n   讲算法的书，比如《算法导论》，这类书对日常工作并没有直接的影响，但是对程序员生涯影响是比较大的，不了解几个算法好意思说自己是程序员吗？\n\n4. **兴趣类**\n\n   日常工作并不会用到的，完全凭兴趣了解的，比如《图解密码技术》\n\n不同阶段，这几类书的优先级应该是不同的。按这半年的体验来看，现在应该 1 > 2 > 3 > 4 来看，解决问题优先，优化其次。\n\n技术类的书是需要看的最多的，都以日常工作需要用到的为主，比如 nodejs，javascript 的书，基础类的以 web 开发的为主，http(s) 协议、tcp/ip 等等，算法类的穿插看，其实可以多看博客，兴趣类的闲着没事的时候看。","slug":"2016-summary","published":1,"updated":"2017-01-15T18:04:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcu90001n927k6biviyc","content":"<p>不知不觉已经毕业半年了，时间如白驹过隙，忽然而已</p>\n<a id=\"more\"></a>\n<h3 id=\"做了哪些事情\"><a href=\"#做了哪些事情\" class=\"headerlink\" title=\"做了哪些事情\"></a>做了哪些事情</h3><p>从 6 月底入职到现在有半年多，把这段时间做的事情可以划分成三类：</p>\n<ol>\n<li><p>前端</p>\n<p>刚来的时候参与做营销技术平台的前端，主要做的是在仁洪搭好的框架上完成功能开发</p>\n<p>包括还有一段时间和国存做了一些老线索开放平台的前端</p>\n<p>大概 8 月份的时候开始做鹰眼，做了鹰眼的前端</p>\n</li>\n<li><p>nodejs 搭建后台</p>\n<p>使用 nodejs 做了鹰眼的后台和线索开放平台的后台</p>\n</li>\n<li><p>数据抓取</p>\n<p>除了上面两点，还有一个做的比较多的是用 nodejs 抓各个平台的数据</p>\n</li>\n</ol>\n<p>总的来说这半年越来越多做 nodejs 方面的事情，或者应该说做了越来越多 javascript 的事情。</p>\n<p>技术上前端使用过了 reactjs 和 angularjs 框架，配合 webpack 现在一般都是写 es6 的代码。</p>\n<p>后端使用了 express 框架，顺带补了一些后端的知识点，捡了捡 mysql，认识了 redis，使用了 orm 框架等等。</p>\n<p>实际上做的事情不算多，反而看起来有些杂，有时候朋友半开玩笑的说你这是全栈的节奏啊。其实我并不觉得自己是在往全栈工程师去发展，实际上我一直还是把自己当做前端工程师，只是为了解决问题，去尝试使用更多的方法，既然 node 能抓数据，就用 node 去做，既然 node 能做后台，那正好能减少一个后台同学的成本。觉得与其刻意去做全栈，不如做一个能够解决问题的人吧。</p>\n<h3 id=\"调研\"><a href=\"#调研\" class=\"headerlink\" title=\"调研\"></a>调研</h3><p>要说比较特别的地方，是做了一些技术的调研。其实我也并没有觉得自己调研方面有什么特长的地方，调研其实是一件很普通的事情，我们每天都在做调研：今天碰到什么问题啦，是不是这个框架有什么坑啦，这个功能用什么技术实现最优雅啦等等等，只是有时候对这些问题都是抱着解决即可的态度去查资料，浅尝即止，可能看了个百度知道就没了。</p>\n<p>所以归根结底还是态度的问题，首先要保持一种心态，调研这个技术一定是对自己有帮助的，而不是只是想解决一个 bug 或者什么，为了提高自己去调研才有学习的动力。然后调研的过程其实是一个自上而下的过程，根节点是你要调研的技术， 而这个技术往往（或者说必定）涉及到其他的技术，然后又会衍生出更多的技术，可能有的听都没听过，调研的深度其实就是这棵树的深度，调研的效果取决于你在哪一层放弃。</p>\n<h3 id=\"不足\"><a href=\"#不足\" class=\"headerlink\" title=\"不足\"></a>不足</h3><p>其实做的东西杂有一个好处，好处也不言自喻：能学到更多的知识。但是同时也带来一个效应：知识圈越大，越觉得不会的东西越多。感觉到自己在很多方面都有很大不足，有种 <strong>手足无措</strong> 的感觉，就像面前摆了很多水果，先吃哪个，该吃多少。</p>\n<p>其实这还是一个规划和执行力的问题，这一点在这半年应该说做的不好，其实还有很多内容没有看到，一直都感觉自己各方面都还很不足。</p>\n<p>另外一方面，<strong>独立组织代码结构</strong> 还是有点问题，现在最直接的体验就是，可能写了五个脚本，项目能够跑起来，需求也能解决，但是这个项目结构很差，或者说可维护性差。</p>\n<p>针对这个问题，反省可能是设计方面知识的欠缺，因为 <strong>框架不就是解决这个问题的吗！</strong>所以最近打算看看设计模式的几本书，</p>\n<h3 id=\"看书\"><a href=\"#看书\" class=\"headerlink\" title=\"看书\"></a>看书</h3><p>我终于发现手足无措要怎么治了，那就是——多看书。读书是一件非常充实的事情，如果觉得哪里做的不好，那就去看哪方面的书，非常有效。</p>\n<blockquote>\n<p>烦恼太多就是因为读书少，或者没睡好。</p>\n<p>—— 艾伦·麦席森·阿哲</p>\n</blockquote>\n<p>这半年看的书实在是太少了，令人发指的少，今年要有针对性的看书。</p>\n<p>把目前需要读的技术类书也划成四类：</p>\n<ol>\n<li><p><strong>纯技术类</strong></p>\n<p>纯技术的书，比如《了不起的 nodejs》，这类书对日常工作有最直接的影响，可能项目遇到了什么问题，看完书就能解决了。</p>\n</li>\n<li><p><strong>基础类</strong></p>\n<p>更像是上学的时候应该掌握的内容，偏底层和理论，比如《HTTP 权威指南》、《javascript 设计模式》</p>\n</li>\n<li><p><strong>算法类</strong></p>\n<p>讲算法的书，比如《算法导论》，这类书对日常工作并没有直接的影响，但是对程序员生涯影响是比较大的，不了解几个算法好意思说自己是程序员吗？</p>\n</li>\n<li><p><strong>兴趣类</strong></p>\n<p>日常工作并不会用到的，完全凭兴趣了解的，比如《图解密码技术》</p>\n</li>\n</ol>\n<p>不同阶段，这几类书的优先级应该是不同的。按这半年的体验来看，现在应该 1 &gt; 2 &gt; 3 &gt; 4 来看，解决问题优先，优化其次。</p>\n<p>技术类的书是需要看的最多的，都以日常工作需要用到的为主，比如 nodejs，javascript 的书，基础类的以 web 开发的为主，http(s) 协议、tcp/ip 等等，算法类的穿插看，其实可以多看博客，兴趣类的闲着没事的时候看。</p>\n","excerpt":"<p>不知不觉已经毕业半年了，时间如白驹过隙，忽然而已</p>","more":"<h3 id=\"做了哪些事情\"><a href=\"#做了哪些事情\" class=\"headerlink\" title=\"做了哪些事情\"></a>做了哪些事情</h3><p>从 6 月底入职到现在有半年多，把这段时间做的事情可以划分成三类：</p>\n<ol>\n<li><p>前端</p>\n<p>刚来的时候参与做营销技术平台的前端，主要做的是在仁洪搭好的框架上完成功能开发</p>\n<p>包括还有一段时间和国存做了一些老线索开放平台的前端</p>\n<p>大概 8 月份的时候开始做鹰眼，做了鹰眼的前端</p>\n</li>\n<li><p>nodejs 搭建后台</p>\n<p>使用 nodejs 做了鹰眼的后台和线索开放平台的后台</p>\n</li>\n<li><p>数据抓取</p>\n<p>除了上面两点，还有一个做的比较多的是用 nodejs 抓各个平台的数据</p>\n</li>\n</ol>\n<p>总的来说这半年越来越多做 nodejs 方面的事情，或者应该说做了越来越多 javascript 的事情。</p>\n<p>技术上前端使用过了 reactjs 和 angularjs 框架，配合 webpack 现在一般都是写 es6 的代码。</p>\n<p>后端使用了 express 框架，顺带补了一些后端的知识点，捡了捡 mysql，认识了 redis，使用了 orm 框架等等。</p>\n<p>实际上做的事情不算多，反而看起来有些杂，有时候朋友半开玩笑的说你这是全栈的节奏啊。其实我并不觉得自己是在往全栈工程师去发展，实际上我一直还是把自己当做前端工程师，只是为了解决问题，去尝试使用更多的方法，既然 node 能抓数据，就用 node 去做，既然 node 能做后台，那正好能减少一个后台同学的成本。觉得与其刻意去做全栈，不如做一个能够解决问题的人吧。</p>\n<h3 id=\"调研\"><a href=\"#调研\" class=\"headerlink\" title=\"调研\"></a>调研</h3><p>要说比较特别的地方，是做了一些技术的调研。其实我也并没有觉得自己调研方面有什么特长的地方，调研其实是一件很普通的事情，我们每天都在做调研：今天碰到什么问题啦，是不是这个框架有什么坑啦，这个功能用什么技术实现最优雅啦等等等，只是有时候对这些问题都是抱着解决即可的态度去查资料，浅尝即止，可能看了个百度知道就没了。</p>\n<p>所以归根结底还是态度的问题，首先要保持一种心态，调研这个技术一定是对自己有帮助的，而不是只是想解决一个 bug 或者什么，为了提高自己去调研才有学习的动力。然后调研的过程其实是一个自上而下的过程，根节点是你要调研的技术， 而这个技术往往（或者说必定）涉及到其他的技术，然后又会衍生出更多的技术，可能有的听都没听过，调研的深度其实就是这棵树的深度，调研的效果取决于你在哪一层放弃。</p>\n<h3 id=\"不足\"><a href=\"#不足\" class=\"headerlink\" title=\"不足\"></a>不足</h3><p>其实做的东西杂有一个好处，好处也不言自喻：能学到更多的知识。但是同时也带来一个效应：知识圈越大，越觉得不会的东西越多。感觉到自己在很多方面都有很大不足，有种 <strong>手足无措</strong> 的感觉，就像面前摆了很多水果，先吃哪个，该吃多少。</p>\n<p>其实这还是一个规划和执行力的问题，这一点在这半年应该说做的不好，其实还有很多内容没有看到，一直都感觉自己各方面都还很不足。</p>\n<p>另外一方面，<strong>独立组织代码结构</strong> 还是有点问题，现在最直接的体验就是，可能写了五个脚本，项目能够跑起来，需求也能解决，但是这个项目结构很差，或者说可维护性差。</p>\n<p>针对这个问题，反省可能是设计方面知识的欠缺，因为 <strong>框架不就是解决这个问题的吗！</strong>所以最近打算看看设计模式的几本书，</p>\n<h3 id=\"看书\"><a href=\"#看书\" class=\"headerlink\" title=\"看书\"></a>看书</h3><p>我终于发现手足无措要怎么治了，那就是——多看书。读书是一件非常充实的事情，如果觉得哪里做的不好，那就去看哪方面的书，非常有效。</p>\n<blockquote>\n<p>烦恼太多就是因为读书少，或者没睡好。</p>\n<p>—— 艾伦·麦席森·阿哲</p>\n</blockquote>\n<p>这半年看的书实在是太少了，令人发指的少，今年要有针对性的看书。</p>\n<p>把目前需要读的技术类书也划成四类：</p>\n<ol>\n<li><p><strong>纯技术类</strong></p>\n<p>纯技术的书，比如《了不起的 nodejs》，这类书对日常工作有最直接的影响，可能项目遇到了什么问题，看完书就能解决了。</p>\n</li>\n<li><p><strong>基础类</strong></p>\n<p>更像是上学的时候应该掌握的内容，偏底层和理论，比如《HTTP 权威指南》、《javascript 设计模式》</p>\n</li>\n<li><p><strong>算法类</strong></p>\n<p>讲算法的书，比如《算法导论》，这类书对日常工作并没有直接的影响，但是对程序员生涯影响是比较大的，不了解几个算法好意思说自己是程序员吗？</p>\n</li>\n<li><p><strong>兴趣类</strong></p>\n<p>日常工作并不会用到的，完全凭兴趣了解的，比如《图解密码技术》</p>\n</li>\n</ol>\n<p>不同阶段，这几类书的优先级应该是不同的。按这半年的体验来看，现在应该 1 &gt; 2 &gt; 3 &gt; 4 来看，解决问题优先，优化其次。</p>\n<p>技术类的书是需要看的最多的，都以日常工作需要用到的为主，比如 nodejs，javascript 的书，基础类的以 web 开发的为主，http(s) 协议、tcp/ip 等等，算法类的穿插看，其实可以多看博客，兴趣类的闲着没事的时候看。</p>"},{"title":"《算法导论》第四章：分治策略","date":"2016-06-29T14:59:14.000Z","_content":"在第二章的归并排序中已经使用了分治策略。在分治策略中，我们递归地求解一个问题，在每层递归中应用如下三个步骤：\n\n- **分解**步骤将问题划分为一些子问题，子问题的形式于原问题一样，只是规模更小。\n- **解决**步骤递归地求解出子问题。如果子问题的规模足够小，则停止递归，直接求解。\n- **合并**步骤将子问题的解组合成原问题的解。\n\n当问题足够大，需要递归求解时，我们称之为**递归情况**。当子问题变得足够小，不需要递归时，我们说递归已经“触底”，进入了**基本情况**。\n\n<!-- more -->\n\n## 最大子数组问题\n假设有以下数组：`[13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7]`，我们的目的是从中寻找一个连续子数组，使得数组元素之和是所有子数组中最大的。我们称这样的连续子数组为**最大子数组**。\n\n### 暴力求解方法\n我们当然可以通过暴力方法来求解：简单尝试所有可能的子数组，从中找出最大子数组。`n` 个元素一共有 `1 + 2 + 3 + ... + n` 个子数组，也就是这种方法的运行时间为 `Ω(n²)`。\n\n### 分治策略的求解方法\n假定我们要寻求子数组 A[low .. high] 的最大子数组，如果使用分治策略，这意味着我们需要把数组拆分成两个规模尽量相等的子数组，找到子数组的中点位置，假设为 `mid`，然后考虑求解两个子数组 A[low .. mid] 和 B[mid + 1 .. high。\n\n此时，A[low .. high] 的任何连续子数组 A[i .. j] 所处的位置必然是以下三种情况之一：\n\n- 完全位于子数组 A[low .. mid] 中，因此 low <= i <= j <= mid。\n- 完全位于子数组 A[mid + 1 .. high] 中，因此 mid <= i <= j <= high。\n- 跨越了中点，因此 low <= i <= mid < j <= high。\n\n所以，A[low .. high] 的最大子数组也必定是这三种情况之一，我们只需要找出这三种情况的最大值。我们可以递归地求解 A[low .. mid] 和 A[mid + 1 .. high] 的最大子数组，因为这两个子问题仍是最大子数组问题。接着寻找跨越中点的最大子数组，然后在三种情况中选取和最大者。\n\n要找出跨越中点的子数组很容易，因为它必定跨越中点，所以它一定由 A[i .. mid] 和 A[mid + 1 .. j] 组成，我们只需要找出两边最大的子数组，然后将其合并即可。\n\n过程 FIND-MAX-CROSSING-SUBARRAY 接收数组 A 和下标 low、mid 和 high 为输入，返回一个下标元组划定跨越中点的最大子数组的边界，并返回最大子数组的和。\n\nFIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)\n```\nleft-sum = -∞\nsum = 0\nfor i = mid downto low\n  sum = sum + A[i]\n  if sum > left-sum\n    left-sum = sum\n    max-left = i\nright-sum = -∞\nsum = 0\nfor j = mid + 1 to high\n  sum = sum + A[j]\n  if sum > right-sum\n    right-sum = sum\n    max-right = j\nreturn (max-left, max-right, left-sum + right-sum)\n```\n\n有了 FIND-MAX-CROSSING-SUBARRAY， 我们即可设计求解最大子数组问题的分治算法的伪代码了：\n\nFIND-MAXIMUM-SUBARRAY(A, low, high)\n```\nif high == low\n  return (low, high, A[low])\nelse\n  mid = [(low + high) / 2]\n  (left-low, left-high, left-sum) = FIND-MAXIMUM-SUBARRAY(A, low, mid)\n  (right-low, right-high, right-sum) = FIND-MAXIMUM-SUBARRAY(A, mid + 1, high)\n  (cross-low, cross-high, cross-sum) = FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)\n  if left-sum >= right-sum and left-sum >= cross-sum\n    return (left-low, left-high, left-sum)\n  else right-sum >= left-sum and right-sum >= cross-sum\n    return (right-low, right-high, right-sum)\n  else\n    return (cross-low, cross-high, cross-sum)\n```\n\n要理解为什么通过递归就能求出左子数组和右子数组的最大值，关键在于想明白**递归之后子数组问题会合并**。\n\n### Javascript 实现\n```javascript\nfunction findMaxCrossingSubarray(arr, low, mid, high) {\n  var leftIndex = 0, rightIndex = 0;\n  // left\n  var leftMax = -999;\n  var leftSum = 0;\n  for(var i = mid; i >= low; i--) {\n    leftSum += arr[i];\n    if(leftSum > leftMax) {\n      leftMax = leftSum;\n      leftIndex = i;\n    }\n  }\n\n  // right\n  var rightMax = -999;\n  var rightSum = 0;\n  for(var j = mid + 1; j <= high; j++) {\n    rightSum += arr[j];\n    if(rightSum > rightMax) {\n      rightMax = rightSum;\n      rightIndex = j;\n    }\n  }\n\n  return {\n    leftIndex: leftIndex,\n    rightIndex: rightIndex,\n    max: leftMax + rightMax\n  }\n}\n\nfunction findMaximumSubarray(arr, low, high) {\n  if(low == high) {\n    return {\n      leftIndex: low,\n      high: high,\n      max: arr[low]\n    }\n  } else {\n    var mid = Math.floor((low + high) / 2);\n    var left = findMaximumSubarray(arr, low, mid);\n    var right = findMaximumSubarray(arr, mid + 1, high);\n    var cross = findMaxCrossingSubarray(arr, low, mid, high);\n    if(left.max >= right.max && left.max >= cross.max) {\n      return left;\n    } else if (right.max >= left.max && right.max >= cross.max) {\n      return right;\n    } else {\n      return cross;\n    }\n  }\n}\n\nvar arr = [13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7];\nvar maxSubarray = findMaximumSubarray(arr, 0, arr.length - 1);\n/**\n * leftIndex: 7\n * max: 43\n * rightIndex: 10\n */\nconsole.log(maxSubarray);\n```\n\n### 分治算法分析\n和归并排序一样，FIND-MAXIMUM-SUBARRAY 的运行时间\n```\nT(n) = ⊙(1)              若 n = 1\nT(n) = 2T(n / 2) + ⊙(n)  若 n > 1\n```\n解为 `T(n) = ⊙(nlgn)`\n\n*最大子数组问题实际上还存在一个线性时间的算法，并未使用分治方法*\n","source":"_posts/Introduction-to-Algorithms-4.md","raw":"---\ntitle: 《算法导论》第四章：分治策略\ndate: 2016-06-29 22:59:14\ntags: [读书笔记, 算法]\n---\n在第二章的归并排序中已经使用了分治策略。在分治策略中，我们递归地求解一个问题，在每层递归中应用如下三个步骤：\n\n- **分解**步骤将问题划分为一些子问题，子问题的形式于原问题一样，只是规模更小。\n- **解决**步骤递归地求解出子问题。如果子问题的规模足够小，则停止递归，直接求解。\n- **合并**步骤将子问题的解组合成原问题的解。\n\n当问题足够大，需要递归求解时，我们称之为**递归情况**。当子问题变得足够小，不需要递归时，我们说递归已经“触底”，进入了**基本情况**。\n\n<!-- more -->\n\n## 最大子数组问题\n假设有以下数组：`[13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7]`，我们的目的是从中寻找一个连续子数组，使得数组元素之和是所有子数组中最大的。我们称这样的连续子数组为**最大子数组**。\n\n### 暴力求解方法\n我们当然可以通过暴力方法来求解：简单尝试所有可能的子数组，从中找出最大子数组。`n` 个元素一共有 `1 + 2 + 3 + ... + n` 个子数组，也就是这种方法的运行时间为 `Ω(n²)`。\n\n### 分治策略的求解方法\n假定我们要寻求子数组 A[low .. high] 的最大子数组，如果使用分治策略，这意味着我们需要把数组拆分成两个规模尽量相等的子数组，找到子数组的中点位置，假设为 `mid`，然后考虑求解两个子数组 A[low .. mid] 和 B[mid + 1 .. high。\n\n此时，A[low .. high] 的任何连续子数组 A[i .. j] 所处的位置必然是以下三种情况之一：\n\n- 完全位于子数组 A[low .. mid] 中，因此 low <= i <= j <= mid。\n- 完全位于子数组 A[mid + 1 .. high] 中，因此 mid <= i <= j <= high。\n- 跨越了中点，因此 low <= i <= mid < j <= high。\n\n所以，A[low .. high] 的最大子数组也必定是这三种情况之一，我们只需要找出这三种情况的最大值。我们可以递归地求解 A[low .. mid] 和 A[mid + 1 .. high] 的最大子数组，因为这两个子问题仍是最大子数组问题。接着寻找跨越中点的最大子数组，然后在三种情况中选取和最大者。\n\n要找出跨越中点的子数组很容易，因为它必定跨越中点，所以它一定由 A[i .. mid] 和 A[mid + 1 .. j] 组成，我们只需要找出两边最大的子数组，然后将其合并即可。\n\n过程 FIND-MAX-CROSSING-SUBARRAY 接收数组 A 和下标 low、mid 和 high 为输入，返回一个下标元组划定跨越中点的最大子数组的边界，并返回最大子数组的和。\n\nFIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)\n```\nleft-sum = -∞\nsum = 0\nfor i = mid downto low\n  sum = sum + A[i]\n  if sum > left-sum\n    left-sum = sum\n    max-left = i\nright-sum = -∞\nsum = 0\nfor j = mid + 1 to high\n  sum = sum + A[j]\n  if sum > right-sum\n    right-sum = sum\n    max-right = j\nreturn (max-left, max-right, left-sum + right-sum)\n```\n\n有了 FIND-MAX-CROSSING-SUBARRAY， 我们即可设计求解最大子数组问题的分治算法的伪代码了：\n\nFIND-MAXIMUM-SUBARRAY(A, low, high)\n```\nif high == low\n  return (low, high, A[low])\nelse\n  mid = [(low + high) / 2]\n  (left-low, left-high, left-sum) = FIND-MAXIMUM-SUBARRAY(A, low, mid)\n  (right-low, right-high, right-sum) = FIND-MAXIMUM-SUBARRAY(A, mid + 1, high)\n  (cross-low, cross-high, cross-sum) = FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)\n  if left-sum >= right-sum and left-sum >= cross-sum\n    return (left-low, left-high, left-sum)\n  else right-sum >= left-sum and right-sum >= cross-sum\n    return (right-low, right-high, right-sum)\n  else\n    return (cross-low, cross-high, cross-sum)\n```\n\n要理解为什么通过递归就能求出左子数组和右子数组的最大值，关键在于想明白**递归之后子数组问题会合并**。\n\n### Javascript 实现\n```javascript\nfunction findMaxCrossingSubarray(arr, low, mid, high) {\n  var leftIndex = 0, rightIndex = 0;\n  // left\n  var leftMax = -999;\n  var leftSum = 0;\n  for(var i = mid; i >= low; i--) {\n    leftSum += arr[i];\n    if(leftSum > leftMax) {\n      leftMax = leftSum;\n      leftIndex = i;\n    }\n  }\n\n  // right\n  var rightMax = -999;\n  var rightSum = 0;\n  for(var j = mid + 1; j <= high; j++) {\n    rightSum += arr[j];\n    if(rightSum > rightMax) {\n      rightMax = rightSum;\n      rightIndex = j;\n    }\n  }\n\n  return {\n    leftIndex: leftIndex,\n    rightIndex: rightIndex,\n    max: leftMax + rightMax\n  }\n}\n\nfunction findMaximumSubarray(arr, low, high) {\n  if(low == high) {\n    return {\n      leftIndex: low,\n      high: high,\n      max: arr[low]\n    }\n  } else {\n    var mid = Math.floor((low + high) / 2);\n    var left = findMaximumSubarray(arr, low, mid);\n    var right = findMaximumSubarray(arr, mid + 1, high);\n    var cross = findMaxCrossingSubarray(arr, low, mid, high);\n    if(left.max >= right.max && left.max >= cross.max) {\n      return left;\n    } else if (right.max >= left.max && right.max >= cross.max) {\n      return right;\n    } else {\n      return cross;\n    }\n  }\n}\n\nvar arr = [13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7];\nvar maxSubarray = findMaximumSubarray(arr, 0, arr.length - 1);\n/**\n * leftIndex: 7\n * max: 43\n * rightIndex: 10\n */\nconsole.log(maxSubarray);\n```\n\n### 分治算法分析\n和归并排序一样，FIND-MAXIMUM-SUBARRAY 的运行时间\n```\nT(n) = ⊙(1)              若 n = 1\nT(n) = 2T(n / 2) + ⊙(n)  若 n > 1\n```\n解为 `T(n) = ⊙(nlgn)`\n\n*最大子数组问题实际上还存在一个线性时间的算法，并未使用分治方法*\n","slug":"Introduction-to-Algorithms-4","published":1,"updated":"2016-08-27T00:03:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcui0003n92755xnou01","content":"<p>在第二章的归并排序中已经使用了分治策略。在分治策略中，我们递归地求解一个问题，在每层递归中应用如下三个步骤：</p>\n<ul>\n<li><strong>分解</strong>步骤将问题划分为一些子问题，子问题的形式于原问题一样，只是规模更小。</li>\n<li><strong>解决</strong>步骤递归地求解出子问题。如果子问题的规模足够小，则停止递归，直接求解。</li>\n<li><strong>合并</strong>步骤将子问题的解组合成原问题的解。</li>\n</ul>\n<p>当问题足够大，需要递归求解时，我们称之为<strong>递归情况</strong>。当子问题变得足够小，不需要递归时，我们说递归已经“触底”，进入了<strong>基本情况</strong>。</p>\n<a id=\"more\"></a>\n<h2 id=\"最大子数组问题\"><a href=\"#最大子数组问题\" class=\"headerlink\" title=\"最大子数组问题\"></a>最大子数组问题</h2><p>假设有以下数组：<code>[13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7]</code>，我们的目的是从中寻找一个连续子数组，使得数组元素之和是所有子数组中最大的。我们称这样的连续子数组为<strong>最大子数组</strong>。</p>\n<h3 id=\"暴力求解方法\"><a href=\"#暴力求解方法\" class=\"headerlink\" title=\"暴力求解方法\"></a>暴力求解方法</h3><p>我们当然可以通过暴力方法来求解：简单尝试所有可能的子数组，从中找出最大子数组。<code>n</code> 个元素一共有 <code>1 + 2 + 3 + ... + n</code> 个子数组，也就是这种方法的运行时间为 <code>Ω(n²)</code>。</p>\n<h3 id=\"分治策略的求解方法\"><a href=\"#分治策略的求解方法\" class=\"headerlink\" title=\"分治策略的求解方法\"></a>分治策略的求解方法</h3><p>假定我们要寻求子数组 A[low .. high] 的最大子数组，如果使用分治策略，这意味着我们需要把数组拆分成两个规模尽量相等的子数组，找到子数组的中点位置，假设为 <code>mid</code>，然后考虑求解两个子数组 A[low .. mid] 和 B[mid + 1 .. high。</p>\n<p>此时，A[low .. high] 的任何连续子数组 A[i .. j] 所处的位置必然是以下三种情况之一：</p>\n<ul>\n<li>完全位于子数组 A[low .. mid] 中，因此 low &lt;= i &lt;= j &lt;= mid。</li>\n<li>完全位于子数组 A[mid + 1 .. high] 中，因此 mid &lt;= i &lt;= j &lt;= high。</li>\n<li>跨越了中点，因此 low &lt;= i &lt;= mid &lt; j &lt;= high。</li>\n</ul>\n<p>所以，A[low .. high] 的最大子数组也必定是这三种情况之一，我们只需要找出这三种情况的最大值。我们可以递归地求解 A[low .. mid] 和 A[mid + 1 .. high] 的最大子数组，因为这两个子问题仍是最大子数组问题。接着寻找跨越中点的最大子数组，然后在三种情况中选取和最大者。</p>\n<p>要找出跨越中点的子数组很容易，因为它必定跨越中点，所以它一定由 A[i .. mid] 和 A[mid + 1 .. j] 组成，我们只需要找出两边最大的子数组，然后将其合并即可。</p>\n<p>过程 FIND-MAX-CROSSING-SUBARRAY 接收数组 A 和下标 low、mid 和 high 为输入，返回一个下标元组划定跨越中点的最大子数组的边界，并返回最大子数组的和。</p>\n<p>FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">left-sum = -∞</div><div class=\"line\">sum = 0</div><div class=\"line\">for i = mid downto low</div><div class=\"line\">  sum = sum + A[i]</div><div class=\"line\">  if sum &gt; left-sum</div><div class=\"line\">    left-sum = sum</div><div class=\"line\">    max-left = i</div><div class=\"line\">right-sum = -∞</div><div class=\"line\">sum = 0</div><div class=\"line\">for j = mid + 1 to high</div><div class=\"line\">  sum = sum + A[j]</div><div class=\"line\">  if sum &gt; right-sum</div><div class=\"line\">    right-sum = sum</div><div class=\"line\">    max-right = j</div><div class=\"line\">return (max-left, max-right, left-sum + right-sum)</div></pre></td></tr></table></figure></p>\n<p>有了 FIND-MAX-CROSSING-SUBARRAY， 我们即可设计求解最大子数组问题的分治算法的伪代码了：</p>\n<p>FIND-MAXIMUM-SUBARRAY(A, low, high)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">if high == low</div><div class=\"line\">  return (low, high, A[low])</div><div class=\"line\">else</div><div class=\"line\">  mid = [(low + high) / 2]</div><div class=\"line\">  (left-low, left-high, left-sum) = FIND-MAXIMUM-SUBARRAY(A, low, mid)</div><div class=\"line\">  (right-low, right-high, right-sum) = FIND-MAXIMUM-SUBARRAY(A, mid + 1, high)</div><div class=\"line\">  (cross-low, cross-high, cross-sum) = FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)</div><div class=\"line\">  if left-sum &gt;= right-sum and left-sum &gt;= cross-sum</div><div class=\"line\">    return (left-low, left-high, left-sum)</div><div class=\"line\">  else right-sum &gt;= left-sum and right-sum &gt;= cross-sum</div><div class=\"line\">    return (right-low, right-high, right-sum)</div><div class=\"line\">  else</div><div class=\"line\">    return (cross-low, cross-high, cross-sum)</div></pre></td></tr></table></figure></p>\n<p>要理解为什么通过递归就能求出左子数组和右子数组的最大值，关键在于想明白<strong>递归之后子数组问题会合并</strong>。</p>\n<h3 id=\"Javascript-实现\"><a href=\"#Javascript-实现\" class=\"headerlink\" title=\"Javascript 实现\"></a>Javascript 实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findMaxCrossingSubarray</span>(<span class=\"params\">arr, low, mid, high</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> leftIndex = <span class=\"number\">0</span>, rightIndex = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"comment\">// left</span></div><div class=\"line\">  <span class=\"keyword\">var</span> leftMax = <span class=\"number\">-999</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> leftSum = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = mid; i &gt;= low; i--) &#123;</div><div class=\"line\">    leftSum += arr[i];</div><div class=\"line\">    <span class=\"keyword\">if</span>(leftSum &gt; leftMax) &#123;</div><div class=\"line\">      leftMax = leftSum;</div><div class=\"line\">      leftIndex = i;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// right</span></div><div class=\"line\">  <span class=\"keyword\">var</span> rightMax = <span class=\"number\">-999</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> rightSum = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = mid + <span class=\"number\">1</span>; j &lt;= high; j++) &#123;</div><div class=\"line\">    rightSum += arr[j];</div><div class=\"line\">    <span class=\"keyword\">if</span>(rightSum &gt; rightMax) &#123;</div><div class=\"line\">      rightMax = rightSum;</div><div class=\"line\">      rightIndex = j;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"attr\">leftIndex</span>: leftIndex,</div><div class=\"line\">    <span class=\"attr\">rightIndex</span>: rightIndex,</div><div class=\"line\">    <span class=\"attr\">max</span>: leftMax + rightMax</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findMaximumSubarray</span>(<span class=\"params\">arr, low, high</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(low == high) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      <span class=\"attr\">leftIndex</span>: low,</div><div class=\"line\">      <span class=\"attr\">high</span>: high,</div><div class=\"line\">      <span class=\"attr\">max</span>: arr[low]</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> mid = <span class=\"built_in\">Math</span>.floor((low + high) / <span class=\"number\">2</span>);</div><div class=\"line\">    <span class=\"keyword\">var</span> left = findMaximumSubarray(arr, low, mid);</div><div class=\"line\">    <span class=\"keyword\">var</span> right = findMaximumSubarray(arr, mid + <span class=\"number\">1</span>, high);</div><div class=\"line\">    <span class=\"keyword\">var</span> cross = findMaxCrossingSubarray(arr, low, mid, high);</div><div class=\"line\">    <span class=\"keyword\">if</span>(left.max &gt;= right.max &amp;&amp; left.max &gt;= cross.max) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> left;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (right.max &gt;= left.max &amp;&amp; right.max &gt;= cross.max) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> right;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> cross;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">13</span>, <span class=\"number\">-3</span>, <span class=\"number\">-25</span>, <span class=\"number\">20</span>, <span class=\"number\">-3</span>, <span class=\"number\">-16</span>, <span class=\"number\">-23</span>, <span class=\"number\">18</span>, <span class=\"number\">20</span>, <span class=\"number\">-7</span>, <span class=\"number\">12</span>, <span class=\"number\">-5</span>, <span class=\"number\">-22</span>, <span class=\"number\">15</span>, <span class=\"number\">-4</span>, <span class=\"number\">7</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> maxSubarray = findMaximumSubarray(arr, <span class=\"number\">0</span>, arr.length - <span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * leftIndex: 7</div><div class=\"line\"> * max: 43</div><div class=\"line\"> * rightIndex: 10</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"built_in\">console</span>.log(maxSubarray);</div></pre></td></tr></table></figure>\n<h3 id=\"分治算法分析\"><a href=\"#分治算法分析\" class=\"headerlink\" title=\"分治算法分析\"></a>分治算法分析</h3><p>和归并排序一样，FIND-MAXIMUM-SUBARRAY 的运行时间<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">T(n) = ⊙(1)              若 n = 1</div><div class=\"line\">T(n) = 2T(n / 2) + ⊙(n)  若 n &gt; 1</div></pre></td></tr></table></figure></p>\n<p>解为 <code>T(n) = ⊙(nlgn)</code></p>\n<p><em>最大子数组问题实际上还存在一个线性时间的算法，并未使用分治方法</em></p>\n","excerpt":"<p>在第二章的归并排序中已经使用了分治策略。在分治策略中，我们递归地求解一个问题，在每层递归中应用如下三个步骤：</p>\n<ul>\n<li><strong>分解</strong>步骤将问题划分为一些子问题，子问题的形式于原问题一样，只是规模更小。</li>\n<li><strong>解决</strong>步骤递归地求解出子问题。如果子问题的规模足够小，则停止递归，直接求解。</li>\n<li><strong>合并</strong>步骤将子问题的解组合成原问题的解。</li>\n</ul>\n<p>当问题足够大，需要递归求解时，我们称之为<strong>递归情况</strong>。当子问题变得足够小，不需要递归时，我们说递归已经“触底”，进入了<strong>基本情况</strong>。</p>","more":"<h2 id=\"最大子数组问题\"><a href=\"#最大子数组问题\" class=\"headerlink\" title=\"最大子数组问题\"></a>最大子数组问题</h2><p>假设有以下数组：<code>[13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7]</code>，我们的目的是从中寻找一个连续子数组，使得数组元素之和是所有子数组中最大的。我们称这样的连续子数组为<strong>最大子数组</strong>。</p>\n<h3 id=\"暴力求解方法\"><a href=\"#暴力求解方法\" class=\"headerlink\" title=\"暴力求解方法\"></a>暴力求解方法</h3><p>我们当然可以通过暴力方法来求解：简单尝试所有可能的子数组，从中找出最大子数组。<code>n</code> 个元素一共有 <code>1 + 2 + 3 + ... + n</code> 个子数组，也就是这种方法的运行时间为 <code>Ω(n²)</code>。</p>\n<h3 id=\"分治策略的求解方法\"><a href=\"#分治策略的求解方法\" class=\"headerlink\" title=\"分治策略的求解方法\"></a>分治策略的求解方法</h3><p>假定我们要寻求子数组 A[low .. high] 的最大子数组，如果使用分治策略，这意味着我们需要把数组拆分成两个规模尽量相等的子数组，找到子数组的中点位置，假设为 <code>mid</code>，然后考虑求解两个子数组 A[low .. mid] 和 B[mid + 1 .. high。</p>\n<p>此时，A[low .. high] 的任何连续子数组 A[i .. j] 所处的位置必然是以下三种情况之一：</p>\n<ul>\n<li>完全位于子数组 A[low .. mid] 中，因此 low &lt;= i &lt;= j &lt;= mid。</li>\n<li>完全位于子数组 A[mid + 1 .. high] 中，因此 mid &lt;= i &lt;= j &lt;= high。</li>\n<li>跨越了中点，因此 low &lt;= i &lt;= mid &lt; j &lt;= high。</li>\n</ul>\n<p>所以，A[low .. high] 的最大子数组也必定是这三种情况之一，我们只需要找出这三种情况的最大值。我们可以递归地求解 A[low .. mid] 和 A[mid + 1 .. high] 的最大子数组，因为这两个子问题仍是最大子数组问题。接着寻找跨越中点的最大子数组，然后在三种情况中选取和最大者。</p>\n<p>要找出跨越中点的子数组很容易，因为它必定跨越中点，所以它一定由 A[i .. mid] 和 A[mid + 1 .. j] 组成，我们只需要找出两边最大的子数组，然后将其合并即可。</p>\n<p>过程 FIND-MAX-CROSSING-SUBARRAY 接收数组 A 和下标 low、mid 和 high 为输入，返回一个下标元组划定跨越中点的最大子数组的边界，并返回最大子数组的和。</p>\n<p>FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">left-sum = -∞</div><div class=\"line\">sum = 0</div><div class=\"line\">for i = mid downto low</div><div class=\"line\">  sum = sum + A[i]</div><div class=\"line\">  if sum &gt; left-sum</div><div class=\"line\">    left-sum = sum</div><div class=\"line\">    max-left = i</div><div class=\"line\">right-sum = -∞</div><div class=\"line\">sum = 0</div><div class=\"line\">for j = mid + 1 to high</div><div class=\"line\">  sum = sum + A[j]</div><div class=\"line\">  if sum &gt; right-sum</div><div class=\"line\">    right-sum = sum</div><div class=\"line\">    max-right = j</div><div class=\"line\">return (max-left, max-right, left-sum + right-sum)</div></pre></td></tr></table></figure></p>\n<p>有了 FIND-MAX-CROSSING-SUBARRAY， 我们即可设计求解最大子数组问题的分治算法的伪代码了：</p>\n<p>FIND-MAXIMUM-SUBARRAY(A, low, high)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">if high == low</div><div class=\"line\">  return (low, high, A[low])</div><div class=\"line\">else</div><div class=\"line\">  mid = [(low + high) / 2]</div><div class=\"line\">  (left-low, left-high, left-sum) = FIND-MAXIMUM-SUBARRAY(A, low, mid)</div><div class=\"line\">  (right-low, right-high, right-sum) = FIND-MAXIMUM-SUBARRAY(A, mid + 1, high)</div><div class=\"line\">  (cross-low, cross-high, cross-sum) = FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)</div><div class=\"line\">  if left-sum &gt;= right-sum and left-sum &gt;= cross-sum</div><div class=\"line\">    return (left-low, left-high, left-sum)</div><div class=\"line\">  else right-sum &gt;= left-sum and right-sum &gt;= cross-sum</div><div class=\"line\">    return (right-low, right-high, right-sum)</div><div class=\"line\">  else</div><div class=\"line\">    return (cross-low, cross-high, cross-sum)</div></pre></td></tr></table></figure></p>\n<p>要理解为什么通过递归就能求出左子数组和右子数组的最大值，关键在于想明白<strong>递归之后子数组问题会合并</strong>。</p>\n<h3 id=\"Javascript-实现\"><a href=\"#Javascript-实现\" class=\"headerlink\" title=\"Javascript 实现\"></a>Javascript 实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findMaxCrossingSubarray</span>(<span class=\"params\">arr, low, mid, high</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> leftIndex = <span class=\"number\">0</span>, rightIndex = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"comment\">// left</span></div><div class=\"line\">  <span class=\"keyword\">var</span> leftMax = <span class=\"number\">-999</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> leftSum = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = mid; i &gt;= low; i--) &#123;</div><div class=\"line\">    leftSum += arr[i];</div><div class=\"line\">    <span class=\"keyword\">if</span>(leftSum &gt; leftMax) &#123;</div><div class=\"line\">      leftMax = leftSum;</div><div class=\"line\">      leftIndex = i;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// right</span></div><div class=\"line\">  <span class=\"keyword\">var</span> rightMax = <span class=\"number\">-999</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> rightSum = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = mid + <span class=\"number\">1</span>; j &lt;= high; j++) &#123;</div><div class=\"line\">    rightSum += arr[j];</div><div class=\"line\">    <span class=\"keyword\">if</span>(rightSum &gt; rightMax) &#123;</div><div class=\"line\">      rightMax = rightSum;</div><div class=\"line\">      rightIndex = j;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"attr\">leftIndex</span>: leftIndex,</div><div class=\"line\">    <span class=\"attr\">rightIndex</span>: rightIndex,</div><div class=\"line\">    <span class=\"attr\">max</span>: leftMax + rightMax</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findMaximumSubarray</span>(<span class=\"params\">arr, low, high</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(low == high) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      <span class=\"attr\">leftIndex</span>: low,</div><div class=\"line\">      <span class=\"attr\">high</span>: high,</div><div class=\"line\">      <span class=\"attr\">max</span>: arr[low]</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> mid = <span class=\"built_in\">Math</span>.floor((low + high) / <span class=\"number\">2</span>);</div><div class=\"line\">    <span class=\"keyword\">var</span> left = findMaximumSubarray(arr, low, mid);</div><div class=\"line\">    <span class=\"keyword\">var</span> right = findMaximumSubarray(arr, mid + <span class=\"number\">1</span>, high);</div><div class=\"line\">    <span class=\"keyword\">var</span> cross = findMaxCrossingSubarray(arr, low, mid, high);</div><div class=\"line\">    <span class=\"keyword\">if</span>(left.max &gt;= right.max &amp;&amp; left.max &gt;= cross.max) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> left;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (right.max &gt;= left.max &amp;&amp; right.max &gt;= cross.max) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> right;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> cross;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">13</span>, <span class=\"number\">-3</span>, <span class=\"number\">-25</span>, <span class=\"number\">20</span>, <span class=\"number\">-3</span>, <span class=\"number\">-16</span>, <span class=\"number\">-23</span>, <span class=\"number\">18</span>, <span class=\"number\">20</span>, <span class=\"number\">-7</span>, <span class=\"number\">12</span>, <span class=\"number\">-5</span>, <span class=\"number\">-22</span>, <span class=\"number\">15</span>, <span class=\"number\">-4</span>, <span class=\"number\">7</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> maxSubarray = findMaximumSubarray(arr, <span class=\"number\">0</span>, arr.length - <span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * leftIndex: 7</div><div class=\"line\"> * max: 43</div><div class=\"line\"> * rightIndex: 10</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(maxSubarray);</div></pre></td></tr></table></figure>\n<h3 id=\"分治算法分析\"><a href=\"#分治算法分析\" class=\"headerlink\" title=\"分治算法分析\"></a>分治算法分析</h3><p>和归并排序一样，FIND-MAXIMUM-SUBARRAY 的运行时间<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">T(n) = ⊙(1)              若 n = 1</div><div class=\"line\">T(n) = 2T(n / 2) + ⊙(n)  若 n &gt; 1</div></pre></td></tr></table></figure></p>\n<p>解为 <code>T(n) = ⊙(nlgn)</code></p>\n<p><em>最大子数组问题实际上还存在一个线性时间的算法，并未使用分治方法</em></p>"},{"title":"《算法导论》第二章：算法基础","date":"2016-06-26T18:47:19.000Z","_content":"这一章考察求解了排序问题中的**插入排序**算法，并引用算法设计中的**分治法**来开发**归并排序**的算法。\n\n<!-- more -->\n\n## 插入排序\n\n插入排序的工作方式就像许多人排序一手扑克牌。开始时手中一张牌都没有，然后我们每起一次牌，都会将它与手中的牌作比较，从左到右（或者从右到左）来找到这张牌的正确位置，一直到起到最后一张。这个算法的关键之处就在于**你拿在手上的牌始终都是已经排好序的**。\n\n### 伪代码\nINSERTATION-SORT(A)\n```\nfor j = 2 to A.length\n  key = A[j]\n  // Insert A[j] into the sorted sequence A[1..j-1]\n  i = j - 1\n  while i > 0 and A[i] > key\n    A[i + 1] = A[i]\n    i = i - 1\n  A[i + 1] = key\n```\n*（伪代码的数组下标从1开始）*\n\n`for` 循环对应每一次起牌，`key` 代表起上的新牌，`while` 循环表示将新牌和手上的牌从右到左比较，直到找到比新牌小的牌的位置，最后将新牌放到这张牌的后面。\n\n### Javascript 实现\n```javascript\nfunction insertion_sort(arr) {\n  for(var i = 1; i < arr.length; i++) {\n    var key = arr[i];\n    var j = i - 1;\n\n    while(j >= 0 && arr[j] > key) {\n      arr[j + 1] = arr[j];\n      j--;\n    }\n    arr[j + 1] = key;\n  }\n  console.log(arr)\n}\n\nvar a = [3, 1, 4, 5, 7, 2, 11, 13, 0, 9];\ninsertion_sort(a); //[0, 1, 2, 3, 4, 5, 7, 9, 11, 13]\n```\n\n### 插入排序算法的分析\n在最好情况，也就是输入数组本身已经从小到大排序了，该算法运行时间为\n```\nT(n) = an + b\n```\n是** n 的线性函数**\n\n在最坏的情况，也就是输入数组完全按倒序排列，每一次起到新的牌，都需与手中所有的牌作比较。运行时间为\n```\nT(n) = an² + bn + c\n```\n是** n 的二次函数**\n\n我们记插入排序具有最坏情况运行时间 `θ(n²)`\n\n## 归并排序\n\n### 分治法\n归并排序在结构上是递归的，完全遵循分治模式，典型地符合分治法的思想：**将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。**\n\n### 伪代码\n归并排序将原数组拆分成两个序列，再将每个序列继续拆分成两个序列，直到拆成长度为 1，然后递归开始回升，两两序列合并为排序好的新序列，一直到合并成为新数组。\n\n归并排序的关键就在于合并两个已经排序好的序列，我们通过调用 `MERGE(A, p, q, r)` 来完成合并，其中 A 是数组，p, q, r 是数组的下标，且 p ≤ q ≤ r。该过程假设 A[p..q] 和 A[q + 1..r] 都已经排好序，也就是这个方法用于合并两个已排好序的序列。\n\nMERGE(A, p, q, r)\n```\nn1 = q - p + 1\nn2 = r - q\nlet L[1..n1 + 1] and R[1..n2 + 1] be new arrays\nfor i = 1 to n1\n  L[i] = A[p + i - 1]\nfor j = 1 to n2\n  R[j] = A[q + j]\nL[n1 + 1] = ∞\nL[n2 + 1] = ∞\ni = 1\nj = 1\nfor k = p to r\n  if L[i] <= R[j]\n    A[k] = L[i]\n    i = i + 1\n  else\n    A[k] = R[j]\n    j = j + 1\n```\n代码中在每个序列的最后插入了一个**哨兵**，用于简化代码，避免判断是否有堆为空（因为最后一个下标 ++ 完会越界）\n\n该方法只要执行 n 次，即能将两个序列合并为新序列。\n\n现在 MERGE 方法就能作为归并排序算法中的一个子程序，接下来需要对数组进行拆分。这个方法排序数组 A[p..r] 中的元素，如果 p ≥ r, 则该子数组最多有一个元素，所以已经排好序，否则，将 A[p..r] 分成 A[p..q] 和 A[q + 1..r]。\n\nMERGE-SORT(A, p, r)\n```\nif p < r\n  q = 「(p + r) / 2」\n  MERGE-SORT(A, p, q)\n  MERGE-SORT(A, q + 1, r)\n  MERGE(A, p, q, r)\n```\n\n### Javascript 实现\n```javascript\nfunction merge(arr, p, q, r) {\n  var n1 = q - p + 1;\n  var n2 = r - q;\n  var L = [], R = [];\n  for(var i = 0; i < n1; i++) {\n    L[i] = arr[p + i];\n  }\n\n  for(var j = 0; j < n2; j++) {\n    R[j] = arr[q + 1 + j];\n  }\n\n  // 合并\n  i = 0, j = 0;\n\n  for(var k = p; k <= r; k++) {\n    if(j >= n2 || L[i] <= R[j]) {\n      arr[k] = L[i];  \n      i++;\n    } else if(i >= n1 || L[i] > R[j]) {\n      arr[k] = R[j];\n      j++;\n    }\n  }\n}\n\nfunction merge_sort(arr, p, r) {\n  if(p < r) {\n    var q = Math.floor((p + r) / 2);\n    merge_sort(arr, p, q);\n    merge_sort(arr, q + 1, r);  \n    merge(arr, p, q, r);\n  }\n\n}\n\nvar arr = [3, 2, 6, 3, 11, 10, 17, 0, 1, 9];\nmerge_sort(arr, 0, a.length - 1)\nconsole.log(arr); // [0, 1, 2, 3, 3, 6, 9, 10, 11, 17]\n```\n\n### 归并排序算法的分析\n归并排序是将数组递归拆解再合并，可以将问题分解为一颗递归树，运行时间为 `θ(nlgn)`\n","source":"_posts/Introduction-to-Algorithms-2.md","raw":"---\ntitle: 《算法导论》第二章：算法基础\ndate: 2016-06-27 02:47:19\ntags: [读书笔记, 算法]\n---\n这一章考察求解了排序问题中的**插入排序**算法，并引用算法设计中的**分治法**来开发**归并排序**的算法。\n\n<!-- more -->\n\n## 插入排序\n\n插入排序的工作方式就像许多人排序一手扑克牌。开始时手中一张牌都没有，然后我们每起一次牌，都会将它与手中的牌作比较，从左到右（或者从右到左）来找到这张牌的正确位置，一直到起到最后一张。这个算法的关键之处就在于**你拿在手上的牌始终都是已经排好序的**。\n\n### 伪代码\nINSERTATION-SORT(A)\n```\nfor j = 2 to A.length\n  key = A[j]\n  // Insert A[j] into the sorted sequence A[1..j-1]\n  i = j - 1\n  while i > 0 and A[i] > key\n    A[i + 1] = A[i]\n    i = i - 1\n  A[i + 1] = key\n```\n*（伪代码的数组下标从1开始）*\n\n`for` 循环对应每一次起牌，`key` 代表起上的新牌，`while` 循环表示将新牌和手上的牌从右到左比较，直到找到比新牌小的牌的位置，最后将新牌放到这张牌的后面。\n\n### Javascript 实现\n```javascript\nfunction insertion_sort(arr) {\n  for(var i = 1; i < arr.length; i++) {\n    var key = arr[i];\n    var j = i - 1;\n\n    while(j >= 0 && arr[j] > key) {\n      arr[j + 1] = arr[j];\n      j--;\n    }\n    arr[j + 1] = key;\n  }\n  console.log(arr)\n}\n\nvar a = [3, 1, 4, 5, 7, 2, 11, 13, 0, 9];\ninsertion_sort(a); //[0, 1, 2, 3, 4, 5, 7, 9, 11, 13]\n```\n\n### 插入排序算法的分析\n在最好情况，也就是输入数组本身已经从小到大排序了，该算法运行时间为\n```\nT(n) = an + b\n```\n是** n 的线性函数**\n\n在最坏的情况，也就是输入数组完全按倒序排列，每一次起到新的牌，都需与手中所有的牌作比较。运行时间为\n```\nT(n) = an² + bn + c\n```\n是** n 的二次函数**\n\n我们记插入排序具有最坏情况运行时间 `θ(n²)`\n\n## 归并排序\n\n### 分治法\n归并排序在结构上是递归的，完全遵循分治模式，典型地符合分治法的思想：**将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。**\n\n### 伪代码\n归并排序将原数组拆分成两个序列，再将每个序列继续拆分成两个序列，直到拆成长度为 1，然后递归开始回升，两两序列合并为排序好的新序列，一直到合并成为新数组。\n\n归并排序的关键就在于合并两个已经排序好的序列，我们通过调用 `MERGE(A, p, q, r)` 来完成合并，其中 A 是数组，p, q, r 是数组的下标，且 p ≤ q ≤ r。该过程假设 A[p..q] 和 A[q + 1..r] 都已经排好序，也就是这个方法用于合并两个已排好序的序列。\n\nMERGE(A, p, q, r)\n```\nn1 = q - p + 1\nn2 = r - q\nlet L[1..n1 + 1] and R[1..n2 + 1] be new arrays\nfor i = 1 to n1\n  L[i] = A[p + i - 1]\nfor j = 1 to n2\n  R[j] = A[q + j]\nL[n1 + 1] = ∞\nL[n2 + 1] = ∞\ni = 1\nj = 1\nfor k = p to r\n  if L[i] <= R[j]\n    A[k] = L[i]\n    i = i + 1\n  else\n    A[k] = R[j]\n    j = j + 1\n```\n代码中在每个序列的最后插入了一个**哨兵**，用于简化代码，避免判断是否有堆为空（因为最后一个下标 ++ 完会越界）\n\n该方法只要执行 n 次，即能将两个序列合并为新序列。\n\n现在 MERGE 方法就能作为归并排序算法中的一个子程序，接下来需要对数组进行拆分。这个方法排序数组 A[p..r] 中的元素，如果 p ≥ r, 则该子数组最多有一个元素，所以已经排好序，否则，将 A[p..r] 分成 A[p..q] 和 A[q + 1..r]。\n\nMERGE-SORT(A, p, r)\n```\nif p < r\n  q = 「(p + r) / 2」\n  MERGE-SORT(A, p, q)\n  MERGE-SORT(A, q + 1, r)\n  MERGE(A, p, q, r)\n```\n\n### Javascript 实现\n```javascript\nfunction merge(arr, p, q, r) {\n  var n1 = q - p + 1;\n  var n2 = r - q;\n  var L = [], R = [];\n  for(var i = 0; i < n1; i++) {\n    L[i] = arr[p + i];\n  }\n\n  for(var j = 0; j < n2; j++) {\n    R[j] = arr[q + 1 + j];\n  }\n\n  // 合并\n  i = 0, j = 0;\n\n  for(var k = p; k <= r; k++) {\n    if(j >= n2 || L[i] <= R[j]) {\n      arr[k] = L[i];  \n      i++;\n    } else if(i >= n1 || L[i] > R[j]) {\n      arr[k] = R[j];\n      j++;\n    }\n  }\n}\n\nfunction merge_sort(arr, p, r) {\n  if(p < r) {\n    var q = Math.floor((p + r) / 2);\n    merge_sort(arr, p, q);\n    merge_sort(arr, q + 1, r);  \n    merge(arr, p, q, r);\n  }\n\n}\n\nvar arr = [3, 2, 6, 3, 11, 10, 17, 0, 1, 9];\nmerge_sort(arr, 0, a.length - 1)\nconsole.log(arr); // [0, 1, 2, 3, 3, 6, 9, 10, 11, 17]\n```\n\n### 归并排序算法的分析\n归并排序是将数组递归拆解再合并，可以将问题分解为一颗递归树，运行时间为 `θ(nlgn)`\n","slug":"Introduction-to-Algorithms-2","published":1,"updated":"2016-08-27T00:03:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcur0006n927z7i5mtwy","content":"<p>这一章考察求解了排序问题中的<strong>插入排序</strong>算法，并引用算法设计中的<strong>分治法</strong>来开发<strong>归并排序</strong>的算法。</p>\n<a id=\"more\"></a>\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p>插入排序的工作方式就像许多人排序一手扑克牌。开始时手中一张牌都没有，然后我们每起一次牌，都会将它与手中的牌作比较，从左到右（或者从右到左）来找到这张牌的正确位置，一直到起到最后一张。这个算法的关键之处就在于<strong>你拿在手上的牌始终都是已经排好序的</strong>。</p>\n<h3 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h3><p>INSERTATION-SORT(A)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">for j = 2 to A.length</div><div class=\"line\">  key = A[j]</div><div class=\"line\">  // Insert A[j] into the sorted sequence A[1..j-1]</div><div class=\"line\">  i = j - 1</div><div class=\"line\">  while i &gt; 0 and A[i] &gt; key</div><div class=\"line\">    A[i + 1] = A[i]</div><div class=\"line\">    i = i - 1</div><div class=\"line\">  A[i + 1] = key</div></pre></td></tr></table></figure></p>\n<p><em>（伪代码的数组下标从1开始）</em></p>\n<p><code>for</code> 循环对应每一次起牌，<code>key</code> 代表起上的新牌，<code>while</code> 循环表示将新牌和手上的牌从右到左比较，直到找到比新牌小的牌的位置，最后将新牌放到这张牌的后面。</p>\n<h3 id=\"Javascript-实现\"><a href=\"#Javascript-实现\" class=\"headerlink\" title=\"Javascript 实现\"></a>Javascript 实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertion_sort</span>(<span class=\"params\">arr</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; arr.length; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> key = arr[i];</div><div class=\"line\">    <span class=\"keyword\">var</span> j = i - <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(j &gt;= <span class=\"number\">0</span> &amp;&amp; arr[j] &gt; key) &#123;</div><div class=\"line\">      arr[j + <span class=\"number\">1</span>] = arr[j];</div><div class=\"line\">      j--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    arr[j + <span class=\"number\">1</span>] = key;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(arr)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>, <span class=\"number\">0</span>, <span class=\"number\">9</span>];</div><div class=\"line\">insertion_sort(a); <span class=\"comment\">//[0, 1, 2, 3, 4, 5, 7, 9, 11, 13]</span></div></pre></td></tr></table></figure>\n<h3 id=\"插入排序算法的分析\"><a href=\"#插入排序算法的分析\" class=\"headerlink\" title=\"插入排序算法的分析\"></a>插入排序算法的分析</h3><p>在最好情况，也就是输入数组本身已经从小到大排序了，该算法运行时间为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">T(n) = an + b</div></pre></td></tr></table></figure></p>\n<p>是<strong> n 的线性函数</strong></p>\n<p>在最坏的情况，也就是输入数组完全按倒序排列，每一次起到新的牌，都需与手中所有的牌作比较。运行时间为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">T(n) = an² + bn + c</div></pre></td></tr></table></figure></p>\n<p>是<strong> n 的二次函数</strong></p>\n<p>我们记插入排序具有最坏情况运行时间 <code>θ(n²)</code></p>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><h3 id=\"分治法\"><a href=\"#分治法\" class=\"headerlink\" title=\"分治法\"></a>分治法</h3><p>归并排序在结构上是递归的，完全遵循分治模式，典型地符合分治法的思想：<strong>将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。</strong></p>\n<h3 id=\"伪代码-1\"><a href=\"#伪代码-1\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h3><p>归并排序将原数组拆分成两个序列，再将每个序列继续拆分成两个序列，直到拆成长度为 1，然后递归开始回升，两两序列合并为排序好的新序列，一直到合并成为新数组。</p>\n<p>归并排序的关键就在于合并两个已经排序好的序列，我们通过调用 <code>MERGE(A, p, q, r)</code> 来完成合并，其中 A 是数组，p, q, r 是数组的下标，且 p ≤ q ≤ r。该过程假设 A[p..q] 和 A[q + 1..r] 都已经排好序，也就是这个方法用于合并两个已排好序的序列。</p>\n<p>MERGE(A, p, q, r)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">n1 = q - p + 1</div><div class=\"line\">n2 = r - q</div><div class=\"line\">let L[1..n1 + 1] and R[1..n2 + 1] be new arrays</div><div class=\"line\">for i = 1 to n1</div><div class=\"line\">  L[i] = A[p + i - 1]</div><div class=\"line\">for j = 1 to n2</div><div class=\"line\">  R[j] = A[q + j]</div><div class=\"line\">L[n1 + 1] = ∞</div><div class=\"line\">L[n2 + 1] = ∞</div><div class=\"line\">i = 1</div><div class=\"line\">j = 1</div><div class=\"line\">for k = p to r</div><div class=\"line\">  if L[i] &lt;= R[j]</div><div class=\"line\">    A[k] = L[i]</div><div class=\"line\">    i = i + 1</div><div class=\"line\">  else</div><div class=\"line\">    A[k] = R[j]</div><div class=\"line\">    j = j + 1</div></pre></td></tr></table></figure></p>\n<p>代码中在每个序列的最后插入了一个<strong>哨兵</strong>，用于简化代码，避免判断是否有堆为空（因为最后一个下标 ++ 完会越界）</p>\n<p>该方法只要执行 n 次，即能将两个序列合并为新序列。</p>\n<p>现在 MERGE 方法就能作为归并排序算法中的一个子程序，接下来需要对数组进行拆分。这个方法排序数组 A[p..r] 中的元素，如果 p ≥ r, 则该子数组最多有一个元素，所以已经排好序，否则，将 A[p..r] 分成 A[p..q] 和 A[q + 1..r]。</p>\n<p>MERGE-SORT(A, p, r)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">if p &lt; r</div><div class=\"line\">  q = 「(p + r) / 2」</div><div class=\"line\">  MERGE-SORT(A, p, q)</div><div class=\"line\">  MERGE-SORT(A, q + 1, r)</div><div class=\"line\">  MERGE(A, p, q, r)</div></pre></td></tr></table></figure></p>\n<h3 id=\"Javascript-实现-1\"><a href=\"#Javascript-实现-1\" class=\"headerlink\" title=\"Javascript 实现\"></a>Javascript 实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge</span>(<span class=\"params\">arr, p, q, r</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> n1 = q - p + <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> n2 = r - q;</div><div class=\"line\">  <span class=\"keyword\">var</span> L = [], R = [];</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; n1; i++) &#123;</div><div class=\"line\">    L[i] = arr[p + i];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; n2; j++) &#123;</div><div class=\"line\">    R[j] = arr[q + <span class=\"number\">1</span> + j];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 合并</span></div><div class=\"line\">  i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> k = p; k &lt;= r; k++) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(j &gt;= n2 || L[i] &lt;= R[j]) &#123;</div><div class=\"line\">      arr[k] = L[i];  </div><div class=\"line\">      i++;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(i &gt;= n1 || L[i] &gt; R[j]) &#123;</div><div class=\"line\">      arr[k] = R[j];</div><div class=\"line\">      j++;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge_sort</span>(<span class=\"params\">arr, p, r</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(p &lt; r) &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> q = <span class=\"built_in\">Math</span>.floor((p + r) / <span class=\"number\">2</span>);</div><div class=\"line\">    merge_sort(arr, p, q);</div><div class=\"line\">    merge_sort(arr, q + <span class=\"number\">1</span>, r);  </div><div class=\"line\">    merge(arr, p, q, r);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span>, <span class=\"number\">11</span>, <span class=\"number\">10</span>, <span class=\"number\">17</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>];</div><div class=\"line\">merge_sort(arr, <span class=\"number\">0</span>, a.length - <span class=\"number\">1</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [0, 1, 2, 3, 3, 6, 9, 10, 11, 17]</span></div></pre></td></tr></table></figure>\n<h3 id=\"归并排序算法的分析\"><a href=\"#归并排序算法的分析\" class=\"headerlink\" title=\"归并排序算法的分析\"></a>归并排序算法的分析</h3><p>归并排序是将数组递归拆解再合并，可以将问题分解为一颗递归树，运行时间为 <code>θ(nlgn)</code></p>\n","excerpt":"<p>这一章考察求解了排序问题中的<strong>插入排序</strong>算法，并引用算法设计中的<strong>分治法</strong>来开发<strong>归并排序</strong>的算法。</p>","more":"<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p>插入排序的工作方式就像许多人排序一手扑克牌。开始时手中一张牌都没有，然后我们每起一次牌，都会将它与手中的牌作比较，从左到右（或者从右到左）来找到这张牌的正确位置，一直到起到最后一张。这个算法的关键之处就在于<strong>你拿在手上的牌始终都是已经排好序的</strong>。</p>\n<h3 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h3><p>INSERTATION-SORT(A)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">for j = 2 to A.length</div><div class=\"line\">  key = A[j]</div><div class=\"line\">  // Insert A[j] into the sorted sequence A[1..j-1]</div><div class=\"line\">  i = j - 1</div><div class=\"line\">  while i &gt; 0 and A[i] &gt; key</div><div class=\"line\">    A[i + 1] = A[i]</div><div class=\"line\">    i = i - 1</div><div class=\"line\">  A[i + 1] = key</div></pre></td></tr></table></figure></p>\n<p><em>（伪代码的数组下标从1开始）</em></p>\n<p><code>for</code> 循环对应每一次起牌，<code>key</code> 代表起上的新牌，<code>while</code> 循环表示将新牌和手上的牌从右到左比较，直到找到比新牌小的牌的位置，最后将新牌放到这张牌的后面。</p>\n<h3 id=\"Javascript-实现\"><a href=\"#Javascript-实现\" class=\"headerlink\" title=\"Javascript 实现\"></a>Javascript 实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertion_sort</span>(<span class=\"params\">arr</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; arr.length; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> key = arr[i];</div><div class=\"line\">    <span class=\"keyword\">var</span> j = i - <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(j &gt;= <span class=\"number\">0</span> &amp;&amp; arr[j] &gt; key) &#123;</div><div class=\"line\">      arr[j + <span class=\"number\">1</span>] = arr[j];</div><div class=\"line\">      j--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    arr[j + <span class=\"number\">1</span>] = key;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(arr)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>, <span class=\"number\">0</span>, <span class=\"number\">9</span>];</div><div class=\"line\">insertion_sort(a); <span class=\"comment\">//[0, 1, 2, 3, 4, 5, 7, 9, 11, 13]</span></div></pre></td></tr></table></figure>\n<h3 id=\"插入排序算法的分析\"><a href=\"#插入排序算法的分析\" class=\"headerlink\" title=\"插入排序算法的分析\"></a>插入排序算法的分析</h3><p>在最好情况，也就是输入数组本身已经从小到大排序了，该算法运行时间为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">T(n) = an + b</div></pre></td></tr></table></figure></p>\n<p>是<strong> n 的线性函数</strong></p>\n<p>在最坏的情况，也就是输入数组完全按倒序排列，每一次起到新的牌，都需与手中所有的牌作比较。运行时间为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">T(n) = an² + bn + c</div></pre></td></tr></table></figure></p>\n<p>是<strong> n 的二次函数</strong></p>\n<p>我们记插入排序具有最坏情况运行时间 <code>θ(n²)</code></p>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><h3 id=\"分治法\"><a href=\"#分治法\" class=\"headerlink\" title=\"分治法\"></a>分治法</h3><p>归并排序在结构上是递归的，完全遵循分治模式，典型地符合分治法的思想：<strong>将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。</strong></p>\n<h3 id=\"伪代码-1\"><a href=\"#伪代码-1\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h3><p>归并排序将原数组拆分成两个序列，再将每个序列继续拆分成两个序列，直到拆成长度为 1，然后递归开始回升，两两序列合并为排序好的新序列，一直到合并成为新数组。</p>\n<p>归并排序的关键就在于合并两个已经排序好的序列，我们通过调用 <code>MERGE(A, p, q, r)</code> 来完成合并，其中 A 是数组，p, q, r 是数组的下标，且 p ≤ q ≤ r。该过程假设 A[p..q] 和 A[q + 1..r] 都已经排好序，也就是这个方法用于合并两个已排好序的序列。</p>\n<p>MERGE(A, p, q, r)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">n1 = q - p + 1</div><div class=\"line\">n2 = r - q</div><div class=\"line\">let L[1..n1 + 1] and R[1..n2 + 1] be new arrays</div><div class=\"line\">for i = 1 to n1</div><div class=\"line\">  L[i] = A[p + i - 1]</div><div class=\"line\">for j = 1 to n2</div><div class=\"line\">  R[j] = A[q + j]</div><div class=\"line\">L[n1 + 1] = ∞</div><div class=\"line\">L[n2 + 1] = ∞</div><div class=\"line\">i = 1</div><div class=\"line\">j = 1</div><div class=\"line\">for k = p to r</div><div class=\"line\">  if L[i] &lt;= R[j]</div><div class=\"line\">    A[k] = L[i]</div><div class=\"line\">    i = i + 1</div><div class=\"line\">  else</div><div class=\"line\">    A[k] = R[j]</div><div class=\"line\">    j = j + 1</div></pre></td></tr></table></figure></p>\n<p>代码中在每个序列的最后插入了一个<strong>哨兵</strong>，用于简化代码，避免判断是否有堆为空（因为最后一个下标 ++ 完会越界）</p>\n<p>该方法只要执行 n 次，即能将两个序列合并为新序列。</p>\n<p>现在 MERGE 方法就能作为归并排序算法中的一个子程序，接下来需要对数组进行拆分。这个方法排序数组 A[p..r] 中的元素，如果 p ≥ r, 则该子数组最多有一个元素，所以已经排好序，否则，将 A[p..r] 分成 A[p..q] 和 A[q + 1..r]。</p>\n<p>MERGE-SORT(A, p, r)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">if p &lt; r</div><div class=\"line\">  q = 「(p + r) / 2」</div><div class=\"line\">  MERGE-SORT(A, p, q)</div><div class=\"line\">  MERGE-SORT(A, q + 1, r)</div><div class=\"line\">  MERGE(A, p, q, r)</div></pre></td></tr></table></figure></p>\n<h3 id=\"Javascript-实现-1\"><a href=\"#Javascript-实现-1\" class=\"headerlink\" title=\"Javascript 实现\"></a>Javascript 实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge</span>(<span class=\"params\">arr, p, q, r</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> n1 = q - p + <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> n2 = r - q;</div><div class=\"line\">  <span class=\"keyword\">var</span> L = [], R = [];</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; n1; i++) &#123;</div><div class=\"line\">    L[i] = arr[p + i];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; n2; j++) &#123;</div><div class=\"line\">    R[j] = arr[q + <span class=\"number\">1</span> + j];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 合并</span></div><div class=\"line\">  i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> k = p; k &lt;= r; k++) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(j &gt;= n2 || L[i] &lt;= R[j]) &#123;</div><div class=\"line\">      arr[k] = L[i];  </div><div class=\"line\">      i++;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(i &gt;= n1 || L[i] &gt; R[j]) &#123;</div><div class=\"line\">      arr[k] = R[j];</div><div class=\"line\">      j++;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge_sort</span>(<span class=\"params\">arr, p, r</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(p &lt; r) &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> q = <span class=\"built_in\">Math</span>.floor((p + r) / <span class=\"number\">2</span>);</div><div class=\"line\">    merge_sort(arr, p, q);</div><div class=\"line\">    merge_sort(arr, q + <span class=\"number\">1</span>, r);  </div><div class=\"line\">    merge(arr, p, q, r);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span>, <span class=\"number\">11</span>, <span class=\"number\">10</span>, <span class=\"number\">17</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>];</div><div class=\"line\">merge_sort(arr, <span class=\"number\">0</span>, a.length - <span class=\"number\">1</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [0, 1, 2, 3, 3, 6, 9, 10, 11, 17]</span></div></pre></td></tr></table></figure>\n<h3 id=\"归并排序算法的分析\"><a href=\"#归并排序算法的分析\" class=\"headerlink\" title=\"归并排序算法的分析\"></a>归并排序算法的分析</h3><p>归并排序是将数组递归拆解再合并，可以将问题分解为一颗递归树，运行时间为 <code>θ(nlgn)</code></p>"},{"title":"《算法导论》第六章：堆排序","date":"2016-07-03T15:54:10.000Z","_content":"堆排序引入了另一种算法设计技巧：使用“堆”的数据结构来进行信息管理。堆不仅用在堆排序中，而且它也可以构造一种有效的优先队列。\n\n<!-- more -->\n\n## 堆排序\n如下图，（二叉）堆是一个数组，它可以被看成一个近似的完全二叉树：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-6/01.png)\n\n树的每一个节点，对应数组中的一个元素，除了最底层外，该树是完全充满的，而且是从左到右填充。\n\n我们给表示堆的数组 A 两个属性，`A.length` 和 `A.heap-size`\n\n- A.length: 数组元素的个数\n- A.heap-size: 表示有多少个堆元素存储在该数组中\n\n也就是说，A[1 .. A.length] 是整个数组，但只有 A[1 .. A.heap-size] 存放的是堆的有效元素。（0 <= A.heap-size <= A.length）\n\n树的根节点是 A[1], 这样给定一个节点下标 i， 那么它的父结点、左孩子、右孩子的下标为：\n\n```\n// 父节点下标\nPARENT(i)\n  return 向下取整(i / 2)\n\n// 左孩子下标\nLEFT(i)\n  return 2 * i\n\n// 右孩子下标\nRIGHT(i)\n  return 2 * i + 1\n```\n\n二叉堆可以分为两种形式：**最大堆** 和 **最小堆**。\n在最大堆中，**最大堆性质**是指除了根以外的所有结点 i 都要满足：\n```\nA[PARENT(i)] >= A[i]\n```\n也就是说，某个结点的值至多与其父结点一样大。堆的根节点保存的是堆的最大元素，而且在任一子树中，该子树所包含的所有结点都不大于该子树根结点的值。\n\n最小堆正好相反，**最小堆性质**是指除了根以外的所有结点 i 都有：\n```\nA[PARENT(i)] <= A[i]\n```\n\n在堆排序算法中，我们使用的是最大堆。\n\n### 构造最大堆\n\n#### step 1 维护最大堆性质\n\n要进行堆排序，首先要将数组构造成一颗最大堆。\n\nMAX-HEAPIFY 是用于维护最大堆性质的重要过程。它的输入为数组 A 和一个下标 i。在调用 MAX-HEAPIFY 时，我们假定**根结点为 LEFT(i) 和 RIGHT(i) 的二叉树都是最大堆**，当 A[i] 小于任一孩子时，则需要把 A[i] 和最大的孩子交换顺序。MAX-HEAPIFY 通过让 A[i] 的值在最大堆中“逐级下降”，从而使以下标为根结点的子树重新遵循最大堆的性质。\n\n*MAX-HEAPIFY(A, i) 伪代码*\n```\n// 左孩子下标\nl = LEFT(i)\n// 右孩子下标\nr = RIGHT(i)\n// 比较根结点和左孩子的大小\nif l <= A.heap-size and A[l] > A[i]\n  // 左孩子比根结点大\n  largest = l\nelse\n  largest = i\n// 比较根结点和右孩子的大小\nif r <= A.heap-size and A[r] > A[largest]\n  // 右孩子比左孩子和根结点都大\n  largest = r\n\nif largest != i\n  // 如果存在孩子比根结点大，让根结点和最大的孩子交换顺序\n  exchange A[i] with A[largest]\n  // 递归调用\n  MAX-HEAPIFY(A, largest)\n```\n\n#### step 2 构建最大堆\n\n利用 MAX-HEAPIFY，我们可以自底向上把大小为 n 的数组 A[1 .. n] 转换为最大堆，但实际上，子数组 a(N / 2 + 1 .. n) 中的元素都是树的叶子结点。每个叶子结点都可以看成只包含一个元素的堆。所以过程 MAX-HEAPIFY 只需对其他结点调用即可。\n\n*BUILD-MAX-HEAP(A) 伪代码*\n```\nA.heap-size = A.length\nfor i = 向下取整(A.length / 2) downto 1\n  MAX-HEAPIFY(A, i)\n```\n\n#### step 3 堆排序算法\n\n构建好最大堆之后，因为数组中最大元素总在根结点 A[1] 中，通过把根节点和 A[n] 进行互换，可以让该元素放在正确的位置，然后将结点 n 从堆中去掉（减少 A.heap-size 即可），在剩余结点中，继续维护最大堆的性质，不断重复这一过程，直到堆的大小降到 2。\n\n*HEAP-SORT(A) 伪代码*\n```\nBUILD-MAX-HEAP(A)\nfor(i = A.length downto 2)\n  // 将堆中最大的元素移动到正确的位置\n  exchange A[1] with A[i]\n  // 将刚才最大的元素剔除出堆\n  A.heap-size = A.heap-size - 1\n  // 维护最大堆性质\n  MAX-HEAPIFY(A, i)\n```\n\n### Javascript 实现\n```javascript\nfunction max_heapify(arr, i) {\n  var l = i * 2 + 1;\n  var r = i * 2 + 2;\n  var largest = i;\n\n  if(l < arr.heap_size && arr[l] > arr[i]) {\n    largest = l;\n  } else {\n    largest = i;\n  }\n\n  if(r < arr.heap_size && arr[r] > arr[largest]) {\n    largest = r;\n  }\n\n  if(largest != i) {\n    [arr[i], arr[largest]] = [arr[largest], arr[i]];\n    max_heapify(arr, largest);\n  }\n}\n\nfunction build_max_heap(arr) {\n  arr.heap_size = arr.length;\n  for(var i = Math.floor(arr.heap_size / 2) - 1; i >= 0; i--) {\n    max_heapify(arr, i);\n  }\n}\n\nfunction heap_sort(arr) {\n  build_max_heap(arr);\n  for(var i = arr.length - 1; i >= 1; i--) {\n    [arr[0], arr[i]] = [arr[i], arr[0]];\n    arr.heap_size = arr.heap_size - 1;\n    max_heapify(arr, 0);\n  }\n}\n\nvar arr = [16, 4, 10, 14, 7, 9, 3, 2, 8, 1];\nheap_sort(arr);\nconsole.log(arr); // [1, 2, 3, 4, 7, 8, 9, 10, 14, 16]\n```\n\n堆排序的时间复杂度是 `θ(nlgn)`。\n\n## 优先队列\n\n上面讲了使用堆实现堆排序算法，除此之外，堆还有一个常见的应用：作为高效的优先队列。\n\n和堆一样，优先队列也有两种形式：**最大优先队列**和**最小优先队列**。\n\n优先队列是一种用来维护由一组元素构成的集合 S 的数据结构，其中的每一个元素都有一个相关的值，称为**关键字**。\n\n一个最大优先队列支持以下操作：\n\n- INSERT(S, x): 把元素 x 插入集合 S 中。\n- MAXIMUM(S): 返回 S 中具有最大键字的元素。\n- EXTRACT-MAX(S): 去掉并返回 S 中的具有最大键字的元素。\n- INCREASE-KEY(S, x, k): 将元素 x 的关键字值增加到 k，这里假设 k 的值不小于 x 的原关键字值。\n\n最大优先队列的应用有很多，其中一个就是在共享计算机系统的作业调度。最大优先队列记录将要执行的各个作业以及它们之间的相对优先级。当一个作业完成或者被中断后，调度器调用 EXTRACT-MAX 从所有的等待作业中选出具有最高优先级的作业来执行。在任何时候，调度器可以调用 INSERT 把一个新作业加入到队列中来。\n\n相应地，**最小优先队列**支持的操作包括 `INSERT`、`MINIMUM`、`EXTRACT-MIN` 和 `DECREASE-KEY`。\n\n最小优先队列可以被用于基于事件驱动的模拟器。队列中保存要模拟的事件，每个事件都有一个发生时间作为其关键字。事件必须按照发生的时间顺序进行模拟，因为某一事件的模拟结果可能会触发对其他事件的模拟。在每一步，模拟程序调用 EXTRACT-MIN 来选择下一个要模拟的事件。当一个新事件产生时，模拟器通过调用 INSERT 将其插入最小优先级队列中。\n\n### MAXIMUM\n\n我们先讨论如何实现最大优先队列。首先，HEAP-MAXIMUM 可以实现 MAXIMUM 的操作。\n\n*HEAP-MAXIMUM(A)*\n```\n// 最大堆的根结点即最大优先队列中最大的关键字\nreturn A[1]\n```\n\n### EXTRACT-MAX\n\n过程 HEAP-EXTRACT-MAX 实现 EXTRACT-MAX 操作，它与 HEAPSORT 过程中的 `for` 循环体部分相似。\n\n*HEAP-EXTRACT-MAX(A)*\n```\nif A.heap-size < 1\n  error \"heap underflow\"\n// 堆的根结点即是最大值\nmax = A[1]\n// 将最后一个结点放到根结点\nA[1] = A[A.heap-size]\nA.heap-size = A.heap-size - 1\n// 维持最大堆性质\nMAX-HEAPIFY(A, 1)\n```\n\n### INCREASE-KEY\n\n过程 HEAP-INCREASE-KEY 实现 INCREASE-KEY 操作。当将元素 A[i] 的关键字更新为新值后，因为增大 A[i]坑内会让新的堆违反最大堆性质，所以在从当前结点到根结点的路径上，为新增的关键字寻找恰当的插入位置。当前元素会不断地与其父结点进行比较，如果当前元素的关键字较大，则当前元素与父结点进行交换。这一过程一直重复到当前元素的关键字小于其父结点为止。\n\n在优先队列中，我们更希望增加关键字的优先队列元素由对应的数组下标 i 来标识：\n\n*HEAP-INCREASE-KEY(A, i, key)*\n```\nif key < A[i]\n  error \"new key is smaller than current key\"\n// 替换对应的关键字\nA[i] = key\n// 为新增关键字寻找正确的位置\nwhile i > 1 and A[PARENT(i)] < A[i]\n  // 若新增关键字大于父结点值，交换它们\n  exchange A[i] and A[PARENT(i)]\n  i = PARENT(i)\n```\n\n### INSERT\n\n过程 MAX-HEAP-INSERT 实现 INSERT 操作。它的输入是要被插入到最大堆 A 中的新元素的关键字。MAX-HEAP-INSERT 首先通过增加一个关键字为 `-∞` 的叶结点来扩展最大堆，然后调用 HEAP-INCREASE-KEY 来将新结点设置为对应的关键字，同时保持最大堆的性质。\n\n*MAX-HEAP-INSERT(A, key)*\n```\n// 扩展最大堆\nA.heap-size = A.heap-size + 1\n// 给新结点赋值\nA[heap-size] = -∞\n// 将新结点的值替换成对应关键字\nHEAP-INCREASE-KEY(A, A.heap-size, key)\n```\n","source":"_posts/Introduction-to-Algorithms-6.md","raw":"---\ntitle: 《算法导论》第六章：堆排序\ndate: 2016-07-03 23:54:10\ntags: [读书笔记, 算法]\n---\n堆排序引入了另一种算法设计技巧：使用“堆”的数据结构来进行信息管理。堆不仅用在堆排序中，而且它也可以构造一种有效的优先队列。\n\n<!-- more -->\n\n## 堆排序\n如下图，（二叉）堆是一个数组，它可以被看成一个近似的完全二叉树：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-6/01.png)\n\n树的每一个节点，对应数组中的一个元素，除了最底层外，该树是完全充满的，而且是从左到右填充。\n\n我们给表示堆的数组 A 两个属性，`A.length` 和 `A.heap-size`\n\n- A.length: 数组元素的个数\n- A.heap-size: 表示有多少个堆元素存储在该数组中\n\n也就是说，A[1 .. A.length] 是整个数组，但只有 A[1 .. A.heap-size] 存放的是堆的有效元素。（0 <= A.heap-size <= A.length）\n\n树的根节点是 A[1], 这样给定一个节点下标 i， 那么它的父结点、左孩子、右孩子的下标为：\n\n```\n// 父节点下标\nPARENT(i)\n  return 向下取整(i / 2)\n\n// 左孩子下标\nLEFT(i)\n  return 2 * i\n\n// 右孩子下标\nRIGHT(i)\n  return 2 * i + 1\n```\n\n二叉堆可以分为两种形式：**最大堆** 和 **最小堆**。\n在最大堆中，**最大堆性质**是指除了根以外的所有结点 i 都要满足：\n```\nA[PARENT(i)] >= A[i]\n```\n也就是说，某个结点的值至多与其父结点一样大。堆的根节点保存的是堆的最大元素，而且在任一子树中，该子树所包含的所有结点都不大于该子树根结点的值。\n\n最小堆正好相反，**最小堆性质**是指除了根以外的所有结点 i 都有：\n```\nA[PARENT(i)] <= A[i]\n```\n\n在堆排序算法中，我们使用的是最大堆。\n\n### 构造最大堆\n\n#### step 1 维护最大堆性质\n\n要进行堆排序，首先要将数组构造成一颗最大堆。\n\nMAX-HEAPIFY 是用于维护最大堆性质的重要过程。它的输入为数组 A 和一个下标 i。在调用 MAX-HEAPIFY 时，我们假定**根结点为 LEFT(i) 和 RIGHT(i) 的二叉树都是最大堆**，当 A[i] 小于任一孩子时，则需要把 A[i] 和最大的孩子交换顺序。MAX-HEAPIFY 通过让 A[i] 的值在最大堆中“逐级下降”，从而使以下标为根结点的子树重新遵循最大堆的性质。\n\n*MAX-HEAPIFY(A, i) 伪代码*\n```\n// 左孩子下标\nl = LEFT(i)\n// 右孩子下标\nr = RIGHT(i)\n// 比较根结点和左孩子的大小\nif l <= A.heap-size and A[l] > A[i]\n  // 左孩子比根结点大\n  largest = l\nelse\n  largest = i\n// 比较根结点和右孩子的大小\nif r <= A.heap-size and A[r] > A[largest]\n  // 右孩子比左孩子和根结点都大\n  largest = r\n\nif largest != i\n  // 如果存在孩子比根结点大，让根结点和最大的孩子交换顺序\n  exchange A[i] with A[largest]\n  // 递归调用\n  MAX-HEAPIFY(A, largest)\n```\n\n#### step 2 构建最大堆\n\n利用 MAX-HEAPIFY，我们可以自底向上把大小为 n 的数组 A[1 .. n] 转换为最大堆，但实际上，子数组 a(N / 2 + 1 .. n) 中的元素都是树的叶子结点。每个叶子结点都可以看成只包含一个元素的堆。所以过程 MAX-HEAPIFY 只需对其他结点调用即可。\n\n*BUILD-MAX-HEAP(A) 伪代码*\n```\nA.heap-size = A.length\nfor i = 向下取整(A.length / 2) downto 1\n  MAX-HEAPIFY(A, i)\n```\n\n#### step 3 堆排序算法\n\n构建好最大堆之后，因为数组中最大元素总在根结点 A[1] 中，通过把根节点和 A[n] 进行互换，可以让该元素放在正确的位置，然后将结点 n 从堆中去掉（减少 A.heap-size 即可），在剩余结点中，继续维护最大堆的性质，不断重复这一过程，直到堆的大小降到 2。\n\n*HEAP-SORT(A) 伪代码*\n```\nBUILD-MAX-HEAP(A)\nfor(i = A.length downto 2)\n  // 将堆中最大的元素移动到正确的位置\n  exchange A[1] with A[i]\n  // 将刚才最大的元素剔除出堆\n  A.heap-size = A.heap-size - 1\n  // 维护最大堆性质\n  MAX-HEAPIFY(A, i)\n```\n\n### Javascript 实现\n```javascript\nfunction max_heapify(arr, i) {\n  var l = i * 2 + 1;\n  var r = i * 2 + 2;\n  var largest = i;\n\n  if(l < arr.heap_size && arr[l] > arr[i]) {\n    largest = l;\n  } else {\n    largest = i;\n  }\n\n  if(r < arr.heap_size && arr[r] > arr[largest]) {\n    largest = r;\n  }\n\n  if(largest != i) {\n    [arr[i], arr[largest]] = [arr[largest], arr[i]];\n    max_heapify(arr, largest);\n  }\n}\n\nfunction build_max_heap(arr) {\n  arr.heap_size = arr.length;\n  for(var i = Math.floor(arr.heap_size / 2) - 1; i >= 0; i--) {\n    max_heapify(arr, i);\n  }\n}\n\nfunction heap_sort(arr) {\n  build_max_heap(arr);\n  for(var i = arr.length - 1; i >= 1; i--) {\n    [arr[0], arr[i]] = [arr[i], arr[0]];\n    arr.heap_size = arr.heap_size - 1;\n    max_heapify(arr, 0);\n  }\n}\n\nvar arr = [16, 4, 10, 14, 7, 9, 3, 2, 8, 1];\nheap_sort(arr);\nconsole.log(arr); // [1, 2, 3, 4, 7, 8, 9, 10, 14, 16]\n```\n\n堆排序的时间复杂度是 `θ(nlgn)`。\n\n## 优先队列\n\n上面讲了使用堆实现堆排序算法，除此之外，堆还有一个常见的应用：作为高效的优先队列。\n\n和堆一样，优先队列也有两种形式：**最大优先队列**和**最小优先队列**。\n\n优先队列是一种用来维护由一组元素构成的集合 S 的数据结构，其中的每一个元素都有一个相关的值，称为**关键字**。\n\n一个最大优先队列支持以下操作：\n\n- INSERT(S, x): 把元素 x 插入集合 S 中。\n- MAXIMUM(S): 返回 S 中具有最大键字的元素。\n- EXTRACT-MAX(S): 去掉并返回 S 中的具有最大键字的元素。\n- INCREASE-KEY(S, x, k): 将元素 x 的关键字值增加到 k，这里假设 k 的值不小于 x 的原关键字值。\n\n最大优先队列的应用有很多，其中一个就是在共享计算机系统的作业调度。最大优先队列记录将要执行的各个作业以及它们之间的相对优先级。当一个作业完成或者被中断后，调度器调用 EXTRACT-MAX 从所有的等待作业中选出具有最高优先级的作业来执行。在任何时候，调度器可以调用 INSERT 把一个新作业加入到队列中来。\n\n相应地，**最小优先队列**支持的操作包括 `INSERT`、`MINIMUM`、`EXTRACT-MIN` 和 `DECREASE-KEY`。\n\n最小优先队列可以被用于基于事件驱动的模拟器。队列中保存要模拟的事件，每个事件都有一个发生时间作为其关键字。事件必须按照发生的时间顺序进行模拟，因为某一事件的模拟结果可能会触发对其他事件的模拟。在每一步，模拟程序调用 EXTRACT-MIN 来选择下一个要模拟的事件。当一个新事件产生时，模拟器通过调用 INSERT 将其插入最小优先级队列中。\n\n### MAXIMUM\n\n我们先讨论如何实现最大优先队列。首先，HEAP-MAXIMUM 可以实现 MAXIMUM 的操作。\n\n*HEAP-MAXIMUM(A)*\n```\n// 最大堆的根结点即最大优先队列中最大的关键字\nreturn A[1]\n```\n\n### EXTRACT-MAX\n\n过程 HEAP-EXTRACT-MAX 实现 EXTRACT-MAX 操作，它与 HEAPSORT 过程中的 `for` 循环体部分相似。\n\n*HEAP-EXTRACT-MAX(A)*\n```\nif A.heap-size < 1\n  error \"heap underflow\"\n// 堆的根结点即是最大值\nmax = A[1]\n// 将最后一个结点放到根结点\nA[1] = A[A.heap-size]\nA.heap-size = A.heap-size - 1\n// 维持最大堆性质\nMAX-HEAPIFY(A, 1)\n```\n\n### INCREASE-KEY\n\n过程 HEAP-INCREASE-KEY 实现 INCREASE-KEY 操作。当将元素 A[i] 的关键字更新为新值后，因为增大 A[i]坑内会让新的堆违反最大堆性质，所以在从当前结点到根结点的路径上，为新增的关键字寻找恰当的插入位置。当前元素会不断地与其父结点进行比较，如果当前元素的关键字较大，则当前元素与父结点进行交换。这一过程一直重复到当前元素的关键字小于其父结点为止。\n\n在优先队列中，我们更希望增加关键字的优先队列元素由对应的数组下标 i 来标识：\n\n*HEAP-INCREASE-KEY(A, i, key)*\n```\nif key < A[i]\n  error \"new key is smaller than current key\"\n// 替换对应的关键字\nA[i] = key\n// 为新增关键字寻找正确的位置\nwhile i > 1 and A[PARENT(i)] < A[i]\n  // 若新增关键字大于父结点值，交换它们\n  exchange A[i] and A[PARENT(i)]\n  i = PARENT(i)\n```\n\n### INSERT\n\n过程 MAX-HEAP-INSERT 实现 INSERT 操作。它的输入是要被插入到最大堆 A 中的新元素的关键字。MAX-HEAP-INSERT 首先通过增加一个关键字为 `-∞` 的叶结点来扩展最大堆，然后调用 HEAP-INCREASE-KEY 来将新结点设置为对应的关键字，同时保持最大堆的性质。\n\n*MAX-HEAP-INSERT(A, key)*\n```\n// 扩展最大堆\nA.heap-size = A.heap-size + 1\n// 给新结点赋值\nA[heap-size] = -∞\n// 将新结点的值替换成对应关键字\nHEAP-INCREASE-KEY(A, A.heap-size, key)\n```\n","slug":"Introduction-to-Algorithms-6","published":1,"updated":"2016-08-27T00:03:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcut0007n927kpzd7p3f","content":"<p>堆排序引入了另一种算法设计技巧：使用“堆”的数据结构来进行信息管理。堆不仅用在堆排序中，而且它也可以构造一种有效的优先队列。</p>\n<a id=\"more\"></a>\n<h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><p>如下图，（二叉）堆是一个数组，它可以被看成一个近似的完全二叉树：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-6/01.png\" alt=\"\"></p>\n<p>树的每一个节点，对应数组中的一个元素，除了最底层外，该树是完全充满的，而且是从左到右填充。</p>\n<p>我们给表示堆的数组 A 两个属性，<code>A.length</code> 和 <code>A.heap-size</code></p>\n<ul>\n<li>A.length: 数组元素的个数</li>\n<li>A.heap-size: 表示有多少个堆元素存储在该数组中</li>\n</ul>\n<p>也就是说，A[1 .. A.length] 是整个数组，但只有 A[1 .. A.heap-size] 存放的是堆的有效元素。（0 &lt;= A.heap-size &lt;= A.length）</p>\n<p>树的根节点是 A[1], 这样给定一个节点下标 i， 那么它的父结点、左孩子、右孩子的下标为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 父节点下标</div><div class=\"line\">PARENT(i)</div><div class=\"line\">  return 向下取整(i / 2)</div><div class=\"line\"></div><div class=\"line\">// 左孩子下标</div><div class=\"line\">LEFT(i)</div><div class=\"line\">  return 2 * i</div><div class=\"line\"></div><div class=\"line\">// 右孩子下标</div><div class=\"line\">RIGHT(i)</div><div class=\"line\">  return 2 * i + 1</div></pre></td></tr></table></figure>\n<p>二叉堆可以分为两种形式：<strong>最大堆</strong> 和 <strong>最小堆</strong>。<br>在最大堆中，<strong>最大堆性质</strong>是指除了根以外的所有结点 i 都要满足：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">A[PARENT(i)] &gt;= A[i]</div></pre></td></tr></table></figure></p>\n<p>也就是说，某个结点的值至多与其父结点一样大。堆的根节点保存的是堆的最大元素，而且在任一子树中，该子树所包含的所有结点都不大于该子树根结点的值。</p>\n<p>最小堆正好相反，<strong>最小堆性质</strong>是指除了根以外的所有结点 i 都有：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">A[PARENT(i)] &lt;= A[i]</div></pre></td></tr></table></figure></p>\n<p>在堆排序算法中，我们使用的是最大堆。</p>\n<h3 id=\"构造最大堆\"><a href=\"#构造最大堆\" class=\"headerlink\" title=\"构造最大堆\"></a>构造最大堆</h3><h4 id=\"step-1-维护最大堆性质\"><a href=\"#step-1-维护最大堆性质\" class=\"headerlink\" title=\"step 1 维护最大堆性质\"></a>step 1 维护最大堆性质</h4><p>要进行堆排序，首先要将数组构造成一颗最大堆。</p>\n<p>MAX-HEAPIFY 是用于维护最大堆性质的重要过程。它的输入为数组 A 和一个下标 i。在调用 MAX-HEAPIFY 时，我们假定<strong>根结点为 LEFT(i) 和 RIGHT(i) 的二叉树都是最大堆</strong>，当 A[i] 小于任一孩子时，则需要把 A[i] 和最大的孩子交换顺序。MAX-HEAPIFY 通过让 A[i] 的值在最大堆中“逐级下降”，从而使以下标为根结点的子树重新遵循最大堆的性质。</p>\n<p><em>MAX-HEAPIFY(A, i) 伪代码</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 左孩子下标</div><div class=\"line\">l = LEFT(i)</div><div class=\"line\">// 右孩子下标</div><div class=\"line\">r = RIGHT(i)</div><div class=\"line\">// 比较根结点和左孩子的大小</div><div class=\"line\">if l &lt;= A.heap-size and A[l] &gt; A[i]</div><div class=\"line\">  // 左孩子比根结点大</div><div class=\"line\">  largest = l</div><div class=\"line\">else</div><div class=\"line\">  largest = i</div><div class=\"line\">// 比较根结点和右孩子的大小</div><div class=\"line\">if r &lt;= A.heap-size and A[r] &gt; A[largest]</div><div class=\"line\">  // 右孩子比左孩子和根结点都大</div><div class=\"line\">  largest = r</div><div class=\"line\"></div><div class=\"line\">if largest != i</div><div class=\"line\">  // 如果存在孩子比根结点大，让根结点和最大的孩子交换顺序</div><div class=\"line\">  exchange A[i] with A[largest]</div><div class=\"line\">  // 递归调用</div><div class=\"line\">  MAX-HEAPIFY(A, largest)</div></pre></td></tr></table></figure></p>\n<h4 id=\"step-2-构建最大堆\"><a href=\"#step-2-构建最大堆\" class=\"headerlink\" title=\"step 2 构建最大堆\"></a>step 2 构建最大堆</h4><p>利用 MAX-HEAPIFY，我们可以自底向上把大小为 n 的数组 A[1 .. n] 转换为最大堆，但实际上，子数组 a(N / 2 + 1 .. n) 中的元素都是树的叶子结点。每个叶子结点都可以看成只包含一个元素的堆。所以过程 MAX-HEAPIFY 只需对其他结点调用即可。</p>\n<p><em>BUILD-MAX-HEAP(A) 伪代码</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">A.heap-size = A.length</div><div class=\"line\">for i = 向下取整(A.length / 2) downto 1</div><div class=\"line\">  MAX-HEAPIFY(A, i)</div></pre></td></tr></table></figure></p>\n<h4 id=\"step-3-堆排序算法\"><a href=\"#step-3-堆排序算法\" class=\"headerlink\" title=\"step 3 堆排序算法\"></a>step 3 堆排序算法</h4><p>构建好最大堆之后，因为数组中最大元素总在根结点 A[1] 中，通过把根节点和 A[n] 进行互换，可以让该元素放在正确的位置，然后将结点 n 从堆中去掉（减少 A.heap-size 即可），在剩余结点中，继续维护最大堆的性质，不断重复这一过程，直到堆的大小降到 2。</p>\n<p><em>HEAP-SORT(A) 伪代码</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">BUILD-MAX-HEAP(A)</div><div class=\"line\">for(i = A.length downto 2)</div><div class=\"line\">  // 将堆中最大的元素移动到正确的位置</div><div class=\"line\">  exchange A[1] with A[i]</div><div class=\"line\">  // 将刚才最大的元素剔除出堆</div><div class=\"line\">  A.heap-size = A.heap-size - 1</div><div class=\"line\">  // 维护最大堆性质</div><div class=\"line\">  MAX-HEAPIFY(A, i)</div></pre></td></tr></table></figure></p>\n<h3 id=\"Javascript-实现\"><a href=\"#Javascript-实现\" class=\"headerlink\" title=\"Javascript 实现\"></a>Javascript 实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">max_heapify</span>(<span class=\"params\">arr, i</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> l = i * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> r = i * <span class=\"number\">2</span> + <span class=\"number\">2</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> largest = i;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(l &lt; arr.heap_size &amp;&amp; arr[l] &gt; arr[i]) &#123;</div><div class=\"line\">    largest = l;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    largest = i;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(r &lt; arr.heap_size &amp;&amp; arr[r] &gt; arr[largest]) &#123;</div><div class=\"line\">    largest = r;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(largest != i) &#123;</div><div class=\"line\">    [arr[i], arr[largest]] = [arr[largest], arr[i]];</div><div class=\"line\">    max_heapify(arr, largest);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">build_max_heap</span>(<span class=\"params\">arr</span>) </span>&#123;</div><div class=\"line\">  arr.heap_size = arr.length;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"built_in\">Math</span>.floor(arr.heap_size / <span class=\"number\">2</span>) - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</div><div class=\"line\">    max_heapify(arr, i);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">heap_sort</span>(<span class=\"params\">arr</span>) </span>&#123;</div><div class=\"line\">  build_max_heap(arr);</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = arr.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">1</span>; i--) &#123;</div><div class=\"line\">    [arr[<span class=\"number\">0</span>], arr[i]] = [arr[i], arr[<span class=\"number\">0</span>]];</div><div class=\"line\">    arr.heap_size = arr.heap_size - <span class=\"number\">1</span>;</div><div class=\"line\">    max_heapify(arr, <span class=\"number\">0</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">16</span>, <span class=\"number\">4</span>, <span class=\"number\">10</span>, <span class=\"number\">14</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>, <span class=\"number\">1</span>];</div><div class=\"line\">heap_sort(arr);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [1, 2, 3, 4, 7, 8, 9, 10, 14, 16]</span></div></pre></td></tr></table></figure>\n<p>堆排序的时间复杂度是 <code>θ(nlgn)</code>。</p>\n<h2 id=\"优先队列\"><a href=\"#优先队列\" class=\"headerlink\" title=\"优先队列\"></a>优先队列</h2><p>上面讲了使用堆实现堆排序算法，除此之外，堆还有一个常见的应用：作为高效的优先队列。</p>\n<p>和堆一样，优先队列也有两种形式：<strong>最大优先队列</strong>和<strong>最小优先队列</strong>。</p>\n<p>优先队列是一种用来维护由一组元素构成的集合 S 的数据结构，其中的每一个元素都有一个相关的值，称为<strong>关键字</strong>。</p>\n<p>一个最大优先队列支持以下操作：</p>\n<ul>\n<li>INSERT(S, x): 把元素 x 插入集合 S 中。</li>\n<li>MAXIMUM(S): 返回 S 中具有最大键字的元素。</li>\n<li>EXTRACT-MAX(S): 去掉并返回 S 中的具有最大键字的元素。</li>\n<li>INCREASE-KEY(S, x, k): 将元素 x 的关键字值增加到 k，这里假设 k 的值不小于 x 的原关键字值。</li>\n</ul>\n<p>最大优先队列的应用有很多，其中一个就是在共享计算机系统的作业调度。最大优先队列记录将要执行的各个作业以及它们之间的相对优先级。当一个作业完成或者被中断后，调度器调用 EXTRACT-MAX 从所有的等待作业中选出具有最高优先级的作业来执行。在任何时候，调度器可以调用 INSERT 把一个新作业加入到队列中来。</p>\n<p>相应地，<strong>最小优先队列</strong>支持的操作包括 <code>INSERT</code>、<code>MINIMUM</code>、<code>EXTRACT-MIN</code> 和 <code>DECREASE-KEY</code>。</p>\n<p>最小优先队列可以被用于基于事件驱动的模拟器。队列中保存要模拟的事件，每个事件都有一个发生时间作为其关键字。事件必须按照发生的时间顺序进行模拟，因为某一事件的模拟结果可能会触发对其他事件的模拟。在每一步，模拟程序调用 EXTRACT-MIN 来选择下一个要模拟的事件。当一个新事件产生时，模拟器通过调用 INSERT 将其插入最小优先级队列中。</p>\n<h3 id=\"MAXIMUM\"><a href=\"#MAXIMUM\" class=\"headerlink\" title=\"MAXIMUM\"></a>MAXIMUM</h3><p>我们先讨论如何实现最大优先队列。首先，HEAP-MAXIMUM 可以实现 MAXIMUM 的操作。</p>\n<p><em>HEAP-MAXIMUM(A)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 最大堆的根结点即最大优先队列中最大的关键字</div><div class=\"line\">return A[1]</div></pre></td></tr></table></figure></p>\n<h3 id=\"EXTRACT-MAX\"><a href=\"#EXTRACT-MAX\" class=\"headerlink\" title=\"EXTRACT-MAX\"></a>EXTRACT-MAX</h3><p>过程 HEAP-EXTRACT-MAX 实现 EXTRACT-MAX 操作，它与 HEAPSORT 过程中的 <code>for</code> 循环体部分相似。</p>\n<p><em>HEAP-EXTRACT-MAX(A)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">if A.heap-size &lt; 1</div><div class=\"line\">  error &quot;heap underflow&quot;</div><div class=\"line\">// 堆的根结点即是最大值</div><div class=\"line\">max = A[1]</div><div class=\"line\">// 将最后一个结点放到根结点</div><div class=\"line\">A[1] = A[A.heap-size]</div><div class=\"line\">A.heap-size = A.heap-size - 1</div><div class=\"line\">// 维持最大堆性质</div><div class=\"line\">MAX-HEAPIFY(A, 1)</div></pre></td></tr></table></figure></p>\n<h3 id=\"INCREASE-KEY\"><a href=\"#INCREASE-KEY\" class=\"headerlink\" title=\"INCREASE-KEY\"></a>INCREASE-KEY</h3><p>过程 HEAP-INCREASE-KEY 实现 INCREASE-KEY 操作。当将元素 A[i] 的关键字更新为新值后，因为增大 A[i]坑内会让新的堆违反最大堆性质，所以在从当前结点到根结点的路径上，为新增的关键字寻找恰当的插入位置。当前元素会不断地与其父结点进行比较，如果当前元素的关键字较大，则当前元素与父结点进行交换。这一过程一直重复到当前元素的关键字小于其父结点为止。</p>\n<p>在优先队列中，我们更希望增加关键字的优先队列元素由对应的数组下标 i 来标识：</p>\n<p><em>HEAP-INCREASE-KEY(A, i, key)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">if key &lt; A[i]</div><div class=\"line\">  error &quot;new key is smaller than current key&quot;</div><div class=\"line\">// 替换对应的关键字</div><div class=\"line\">A[i] = key</div><div class=\"line\">// 为新增关键字寻找正确的位置</div><div class=\"line\">while i &gt; 1 and A[PARENT(i)] &lt; A[i]</div><div class=\"line\">  // 若新增关键字大于父结点值，交换它们</div><div class=\"line\">  exchange A[i] and A[PARENT(i)]</div><div class=\"line\">  i = PARENT(i)</div></pre></td></tr></table></figure></p>\n<h3 id=\"INSERT\"><a href=\"#INSERT\" class=\"headerlink\" title=\"INSERT\"></a>INSERT</h3><p>过程 MAX-HEAP-INSERT 实现 INSERT 操作。它的输入是要被插入到最大堆 A 中的新元素的关键字。MAX-HEAP-INSERT 首先通过增加一个关键字为 <code>-∞</code> 的叶结点来扩展最大堆，然后调用 HEAP-INCREASE-KEY 来将新结点设置为对应的关键字，同时保持最大堆的性质。</p>\n<p><em>MAX-HEAP-INSERT(A, key)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 扩展最大堆</div><div class=\"line\">A.heap-size = A.heap-size + 1</div><div class=\"line\">// 给新结点赋值</div><div class=\"line\">A[heap-size] = -∞</div><div class=\"line\">// 将新结点的值替换成对应关键字</div><div class=\"line\">HEAP-INCREASE-KEY(A, A.heap-size, key)</div></pre></td></tr></table></figure></p>\n","excerpt":"<p>堆排序引入了另一种算法设计技巧：使用“堆”的数据结构来进行信息管理。堆不仅用在堆排序中，而且它也可以构造一种有效的优先队列。</p>","more":"<h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><p>如下图，（二叉）堆是一个数组，它可以被看成一个近似的完全二叉树：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-6/01.png\" alt=\"\"></p>\n<p>树的每一个节点，对应数组中的一个元素，除了最底层外，该树是完全充满的，而且是从左到右填充。</p>\n<p>我们给表示堆的数组 A 两个属性，<code>A.length</code> 和 <code>A.heap-size</code></p>\n<ul>\n<li>A.length: 数组元素的个数</li>\n<li>A.heap-size: 表示有多少个堆元素存储在该数组中</li>\n</ul>\n<p>也就是说，A[1 .. A.length] 是整个数组，但只有 A[1 .. A.heap-size] 存放的是堆的有效元素。（0 &lt;= A.heap-size &lt;= A.length）</p>\n<p>树的根节点是 A[1], 这样给定一个节点下标 i， 那么它的父结点、左孩子、右孩子的下标为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 父节点下标</div><div class=\"line\">PARENT(i)</div><div class=\"line\">  return 向下取整(i / 2)</div><div class=\"line\"></div><div class=\"line\">// 左孩子下标</div><div class=\"line\">LEFT(i)</div><div class=\"line\">  return 2 * i</div><div class=\"line\"></div><div class=\"line\">// 右孩子下标</div><div class=\"line\">RIGHT(i)</div><div class=\"line\">  return 2 * i + 1</div></pre></td></tr></table></figure>\n<p>二叉堆可以分为两种形式：<strong>最大堆</strong> 和 <strong>最小堆</strong>。<br>在最大堆中，<strong>最大堆性质</strong>是指除了根以外的所有结点 i 都要满足：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">A[PARENT(i)] &gt;= A[i]</div></pre></td></tr></table></figure></p>\n<p>也就是说，某个结点的值至多与其父结点一样大。堆的根节点保存的是堆的最大元素，而且在任一子树中，该子树所包含的所有结点都不大于该子树根结点的值。</p>\n<p>最小堆正好相反，<strong>最小堆性质</strong>是指除了根以外的所有结点 i 都有：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">A[PARENT(i)] &lt;= A[i]</div></pre></td></tr></table></figure></p>\n<p>在堆排序算法中，我们使用的是最大堆。</p>\n<h3 id=\"构造最大堆\"><a href=\"#构造最大堆\" class=\"headerlink\" title=\"构造最大堆\"></a>构造最大堆</h3><h4 id=\"step-1-维护最大堆性质\"><a href=\"#step-1-维护最大堆性质\" class=\"headerlink\" title=\"step 1 维护最大堆性质\"></a>step 1 维护最大堆性质</h4><p>要进行堆排序，首先要将数组构造成一颗最大堆。</p>\n<p>MAX-HEAPIFY 是用于维护最大堆性质的重要过程。它的输入为数组 A 和一个下标 i。在调用 MAX-HEAPIFY 时，我们假定<strong>根结点为 LEFT(i) 和 RIGHT(i) 的二叉树都是最大堆</strong>，当 A[i] 小于任一孩子时，则需要把 A[i] 和最大的孩子交换顺序。MAX-HEAPIFY 通过让 A[i] 的值在最大堆中“逐级下降”，从而使以下标为根结点的子树重新遵循最大堆的性质。</p>\n<p><em>MAX-HEAPIFY(A, i) 伪代码</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 左孩子下标</div><div class=\"line\">l = LEFT(i)</div><div class=\"line\">// 右孩子下标</div><div class=\"line\">r = RIGHT(i)</div><div class=\"line\">// 比较根结点和左孩子的大小</div><div class=\"line\">if l &lt;= A.heap-size and A[l] &gt; A[i]</div><div class=\"line\">  // 左孩子比根结点大</div><div class=\"line\">  largest = l</div><div class=\"line\">else</div><div class=\"line\">  largest = i</div><div class=\"line\">// 比较根结点和右孩子的大小</div><div class=\"line\">if r &lt;= A.heap-size and A[r] &gt; A[largest]</div><div class=\"line\">  // 右孩子比左孩子和根结点都大</div><div class=\"line\">  largest = r</div><div class=\"line\"></div><div class=\"line\">if largest != i</div><div class=\"line\">  // 如果存在孩子比根结点大，让根结点和最大的孩子交换顺序</div><div class=\"line\">  exchange A[i] with A[largest]</div><div class=\"line\">  // 递归调用</div><div class=\"line\">  MAX-HEAPIFY(A, largest)</div></pre></td></tr></table></figure></p>\n<h4 id=\"step-2-构建最大堆\"><a href=\"#step-2-构建最大堆\" class=\"headerlink\" title=\"step 2 构建最大堆\"></a>step 2 构建最大堆</h4><p>利用 MAX-HEAPIFY，我们可以自底向上把大小为 n 的数组 A[1 .. n] 转换为最大堆，但实际上，子数组 a(N / 2 + 1 .. n) 中的元素都是树的叶子结点。每个叶子结点都可以看成只包含一个元素的堆。所以过程 MAX-HEAPIFY 只需对其他结点调用即可。</p>\n<p><em>BUILD-MAX-HEAP(A) 伪代码</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">A.heap-size = A.length</div><div class=\"line\">for i = 向下取整(A.length / 2) downto 1</div><div class=\"line\">  MAX-HEAPIFY(A, i)</div></pre></td></tr></table></figure></p>\n<h4 id=\"step-3-堆排序算法\"><a href=\"#step-3-堆排序算法\" class=\"headerlink\" title=\"step 3 堆排序算法\"></a>step 3 堆排序算法</h4><p>构建好最大堆之后，因为数组中最大元素总在根结点 A[1] 中，通过把根节点和 A[n] 进行互换，可以让该元素放在正确的位置，然后将结点 n 从堆中去掉（减少 A.heap-size 即可），在剩余结点中，继续维护最大堆的性质，不断重复这一过程，直到堆的大小降到 2。</p>\n<p><em>HEAP-SORT(A) 伪代码</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">BUILD-MAX-HEAP(A)</div><div class=\"line\">for(i = A.length downto 2)</div><div class=\"line\">  // 将堆中最大的元素移动到正确的位置</div><div class=\"line\">  exchange A[1] with A[i]</div><div class=\"line\">  // 将刚才最大的元素剔除出堆</div><div class=\"line\">  A.heap-size = A.heap-size - 1</div><div class=\"line\">  // 维护最大堆性质</div><div class=\"line\">  MAX-HEAPIFY(A, i)</div></pre></td></tr></table></figure></p>\n<h3 id=\"Javascript-实现\"><a href=\"#Javascript-实现\" class=\"headerlink\" title=\"Javascript 实现\"></a>Javascript 实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">max_heapify</span>(<span class=\"params\">arr, i</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> l = i * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> r = i * <span class=\"number\">2</span> + <span class=\"number\">2</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> largest = i;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(l &lt; arr.heap_size &amp;&amp; arr[l] &gt; arr[i]) &#123;</div><div class=\"line\">    largest = l;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    largest = i;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(r &lt; arr.heap_size &amp;&amp; arr[r] &gt; arr[largest]) &#123;</div><div class=\"line\">    largest = r;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(largest != i) &#123;</div><div class=\"line\">    [arr[i], arr[largest]] = [arr[largest], arr[i]];</div><div class=\"line\">    max_heapify(arr, largest);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">build_max_heap</span>(<span class=\"params\">arr</span>) </span>&#123;</div><div class=\"line\">  arr.heap_size = arr.length;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"built_in\">Math</span>.floor(arr.heap_size / <span class=\"number\">2</span>) - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</div><div class=\"line\">    max_heapify(arr, i);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">heap_sort</span>(<span class=\"params\">arr</span>) </span>&#123;</div><div class=\"line\">  build_max_heap(arr);</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = arr.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">1</span>; i--) &#123;</div><div class=\"line\">    [arr[<span class=\"number\">0</span>], arr[i]] = [arr[i], arr[<span class=\"number\">0</span>]];</div><div class=\"line\">    arr.heap_size = arr.heap_size - <span class=\"number\">1</span>;</div><div class=\"line\">    max_heapify(arr, <span class=\"number\">0</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">16</span>, <span class=\"number\">4</span>, <span class=\"number\">10</span>, <span class=\"number\">14</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>, <span class=\"number\">1</span>];</div><div class=\"line\">heap_sort(arr);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [1, 2, 3, 4, 7, 8, 9, 10, 14, 16]</span></div></pre></td></tr></table></figure>\n<p>堆排序的时间复杂度是 <code>θ(nlgn)</code>。</p>\n<h2 id=\"优先队列\"><a href=\"#优先队列\" class=\"headerlink\" title=\"优先队列\"></a>优先队列</h2><p>上面讲了使用堆实现堆排序算法，除此之外，堆还有一个常见的应用：作为高效的优先队列。</p>\n<p>和堆一样，优先队列也有两种形式：<strong>最大优先队列</strong>和<strong>最小优先队列</strong>。</p>\n<p>优先队列是一种用来维护由一组元素构成的集合 S 的数据结构，其中的每一个元素都有一个相关的值，称为<strong>关键字</strong>。</p>\n<p>一个最大优先队列支持以下操作：</p>\n<ul>\n<li>INSERT(S, x): 把元素 x 插入集合 S 中。</li>\n<li>MAXIMUM(S): 返回 S 中具有最大键字的元素。</li>\n<li>EXTRACT-MAX(S): 去掉并返回 S 中的具有最大键字的元素。</li>\n<li>INCREASE-KEY(S, x, k): 将元素 x 的关键字值增加到 k，这里假设 k 的值不小于 x 的原关键字值。</li>\n</ul>\n<p>最大优先队列的应用有很多，其中一个就是在共享计算机系统的作业调度。最大优先队列记录将要执行的各个作业以及它们之间的相对优先级。当一个作业完成或者被中断后，调度器调用 EXTRACT-MAX 从所有的等待作业中选出具有最高优先级的作业来执行。在任何时候，调度器可以调用 INSERT 把一个新作业加入到队列中来。</p>\n<p>相应地，<strong>最小优先队列</strong>支持的操作包括 <code>INSERT</code>、<code>MINIMUM</code>、<code>EXTRACT-MIN</code> 和 <code>DECREASE-KEY</code>。</p>\n<p>最小优先队列可以被用于基于事件驱动的模拟器。队列中保存要模拟的事件，每个事件都有一个发生时间作为其关键字。事件必须按照发生的时间顺序进行模拟，因为某一事件的模拟结果可能会触发对其他事件的模拟。在每一步，模拟程序调用 EXTRACT-MIN 来选择下一个要模拟的事件。当一个新事件产生时，模拟器通过调用 INSERT 将其插入最小优先级队列中。</p>\n<h3 id=\"MAXIMUM\"><a href=\"#MAXIMUM\" class=\"headerlink\" title=\"MAXIMUM\"></a>MAXIMUM</h3><p>我们先讨论如何实现最大优先队列。首先，HEAP-MAXIMUM 可以实现 MAXIMUM 的操作。</p>\n<p><em>HEAP-MAXIMUM(A)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 最大堆的根结点即最大优先队列中最大的关键字</div><div class=\"line\">return A[1]</div></pre></td></tr></table></figure></p>\n<h3 id=\"EXTRACT-MAX\"><a href=\"#EXTRACT-MAX\" class=\"headerlink\" title=\"EXTRACT-MAX\"></a>EXTRACT-MAX</h3><p>过程 HEAP-EXTRACT-MAX 实现 EXTRACT-MAX 操作，它与 HEAPSORT 过程中的 <code>for</code> 循环体部分相似。</p>\n<p><em>HEAP-EXTRACT-MAX(A)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">if A.heap-size &lt; 1</div><div class=\"line\">  error &quot;heap underflow&quot;</div><div class=\"line\">// 堆的根结点即是最大值</div><div class=\"line\">max = A[1]</div><div class=\"line\">// 将最后一个结点放到根结点</div><div class=\"line\">A[1] = A[A.heap-size]</div><div class=\"line\">A.heap-size = A.heap-size - 1</div><div class=\"line\">// 维持最大堆性质</div><div class=\"line\">MAX-HEAPIFY(A, 1)</div></pre></td></tr></table></figure></p>\n<h3 id=\"INCREASE-KEY\"><a href=\"#INCREASE-KEY\" class=\"headerlink\" title=\"INCREASE-KEY\"></a>INCREASE-KEY</h3><p>过程 HEAP-INCREASE-KEY 实现 INCREASE-KEY 操作。当将元素 A[i] 的关键字更新为新值后，因为增大 A[i]坑内会让新的堆违反最大堆性质，所以在从当前结点到根结点的路径上，为新增的关键字寻找恰当的插入位置。当前元素会不断地与其父结点进行比较，如果当前元素的关键字较大，则当前元素与父结点进行交换。这一过程一直重复到当前元素的关键字小于其父结点为止。</p>\n<p>在优先队列中，我们更希望增加关键字的优先队列元素由对应的数组下标 i 来标识：</p>\n<p><em>HEAP-INCREASE-KEY(A, i, key)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">if key &lt; A[i]</div><div class=\"line\">  error &quot;new key is smaller than current key&quot;</div><div class=\"line\">// 替换对应的关键字</div><div class=\"line\">A[i] = key</div><div class=\"line\">// 为新增关键字寻找正确的位置</div><div class=\"line\">while i &gt; 1 and A[PARENT(i)] &lt; A[i]</div><div class=\"line\">  // 若新增关键字大于父结点值，交换它们</div><div class=\"line\">  exchange A[i] and A[PARENT(i)]</div><div class=\"line\">  i = PARENT(i)</div></pre></td></tr></table></figure></p>\n<h3 id=\"INSERT\"><a href=\"#INSERT\" class=\"headerlink\" title=\"INSERT\"></a>INSERT</h3><p>过程 MAX-HEAP-INSERT 实现 INSERT 操作。它的输入是要被插入到最大堆 A 中的新元素的关键字。MAX-HEAP-INSERT 首先通过增加一个关键字为 <code>-∞</code> 的叶结点来扩展最大堆，然后调用 HEAP-INCREASE-KEY 来将新结点设置为对应的关键字，同时保持最大堆的性质。</p>\n<p><em>MAX-HEAP-INSERT(A, key)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 扩展最大堆</div><div class=\"line\">A.heap-size = A.heap-size + 1</div><div class=\"line\">// 给新结点赋值</div><div class=\"line\">A[heap-size] = -∞</div><div class=\"line\">// 将新结点的值替换成对应关键字</div><div class=\"line\">HEAP-INCREASE-KEY(A, A.heap-size, key)</div></pre></td></tr></table></figure></p>"},{"title":"《算法导论》第七章：快速排序","date":"2016-07-07T14:48:08.000Z","_content":"\n快速排序和归并排序一样，使用了分治思想。回顾一下归并排序，归并排序是将数组递归拆分，然后两两合并成已排序的数组，一直到合并成为新数组。\n\n快速排序的思想有点相似，但快速排序能够进行原址排序，而不用占用大量的额外空间。\n\n<!-- more -->\n\n对于数组 `A[p .. r]` 快速排序的三步分治过程如下：\n\n- 分解：数组 `A[p .. r]` 被划分为两个（可能为空）子数组 `A[p .. q - 1]` 和 `A[q + 1 .. r]`，使得 `A[p .. q - 1]` 中的每一个元素都小于等于 `A[q]`，而 `A[q]` 也小于等于 `A[q + 1 .. r]` 中的每个元素。其中，计算下标 q 也是划分过程的一部分。\n- 解决：通过递归调用快速排序，对子数组 `A[p .. q - 1]` 和 `A[q + 1 .. r]` 进行排序。\n- 合并：因为子数组都是原址排序的，所以不需要合并操作：数组 `A[p .. r]` 已经有序。\n\n核心就在于我们选出了一个主元（即 `A[q]`），将数组划分为了两个子数组，一边小于等于 `A[q]`，一边大于等于 `A[q]`，再分别对两个子数组执行相同操作，一直到不可拆分为止。\n\n伪代码：\n*QUICKSORT(A, p, r)*\n```\nif p < r\n  // 找到分界点 A[q] 的位置\n  q = PARTITION(A, p, r);\n  // 递归调用 A[q] 左边的数组\n  QUICKSORT(A, p, q - 1);\n  // 递归调用 A[q] 右边的数组\n  QUICKSORT(A, q + 1, r);\n```\n\n所以算法的关键步骤就是 `PARTITION` 过程，它实现对子数组 `A[p .. r]` 的原址重排。\n\n*PARTITION(A, p, r)*\n```\n// 数组的最后一个元素（主元）\nx = A[r]\n// i 是小元素数组的右界\ni = p - 1;\n// 遍历数组\nfor j = p to r - 1\n  if A[j] <= x\n    // 如果该元素比 x 小，小元素数组长度加 1\n    i = i + 1\n    // 将该元素挪到小元素数组范围里去\n    exchange A[i] with A[j]\n// 将主元放到大小数组中间\nexchange A[i + 1] with A[j]\n// 主元的位置\nreturn i + 1\n```\n\n快速排序算法的过程涉及到 4 个变量：`p`, `r`, `i`, `j`。将 `A[p .. r]` 数组划分为了四个部分。\n\n1. `p` 到 `i` 之间为第一部分，其值都不大于主元\n2. `i + 1` 到 `j - 1` 之间为第二部分，其值都不小于主元\n3. `j` 到 `r - 1` 之间是第三部分，其元素等待被分配\n4. `r` 处为主元（数组的最后一个元素）\n\n当循环开始时，`j` 从左往右对数组进行扫描，当发现有比主元小的元素时，将 `i` 往右移，并该元素放到 `i` 处，这样循环结束后，整个数组中，`p` 到 `i` 为不大于主元的元素，`i + 1` 到 `r - 1` 为不小于主元的元素，`r` 处为主元，最后我们将 `i + 1` 处的元素和主元交换位置，这样主元就位于了两部分之间。最后，我们对两个子数组进行同样的操作。\n\njavascript 实现\n```javascript\nfunction quickSort(arr, p, r) {\n  if(p < r) {\n    let q = partition(arr, p, r);\n    quickSort(arr, p, q - 1);\n    quickSort(arr, q + 1, r);\n  }\n}\n\nfunction partition(arr, p, r) {\n  let x = arr[r];\n  let i = p - 1;\n  for(var j = p; j < r; j++) {\n    if(arr[j] <= x) {\n      i++;\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n  }\n  [arr[i + 1], arr[r]] = [arr[r], arr[i + 1]];\n  return i + 1;\n}\n\nlet arr = [13, 19, 9, 5, 12, 8, 7, 4, 21, 2, 6, 11];\nquickSort(arr, 0, arr.length - 1);\nconsole.log(arr); // [2, 4, 5, 6, 7, 8, 9, 11, 12, 13, 19, 21]\n```\n","source":"_posts/Introduction-to-Algorithms-7.md","raw":"---\ntitle: 《算法导论》第七章：快速排序\ndate: 2016-07-07 22:48:08\ntags: [读书笔记, 算法]\n---\n\n快速排序和归并排序一样，使用了分治思想。回顾一下归并排序，归并排序是将数组递归拆分，然后两两合并成已排序的数组，一直到合并成为新数组。\n\n快速排序的思想有点相似，但快速排序能够进行原址排序，而不用占用大量的额外空间。\n\n<!-- more -->\n\n对于数组 `A[p .. r]` 快速排序的三步分治过程如下：\n\n- 分解：数组 `A[p .. r]` 被划分为两个（可能为空）子数组 `A[p .. q - 1]` 和 `A[q + 1 .. r]`，使得 `A[p .. q - 1]` 中的每一个元素都小于等于 `A[q]`，而 `A[q]` 也小于等于 `A[q + 1 .. r]` 中的每个元素。其中，计算下标 q 也是划分过程的一部分。\n- 解决：通过递归调用快速排序，对子数组 `A[p .. q - 1]` 和 `A[q + 1 .. r]` 进行排序。\n- 合并：因为子数组都是原址排序的，所以不需要合并操作：数组 `A[p .. r]` 已经有序。\n\n核心就在于我们选出了一个主元（即 `A[q]`），将数组划分为了两个子数组，一边小于等于 `A[q]`，一边大于等于 `A[q]`，再分别对两个子数组执行相同操作，一直到不可拆分为止。\n\n伪代码：\n*QUICKSORT(A, p, r)*\n```\nif p < r\n  // 找到分界点 A[q] 的位置\n  q = PARTITION(A, p, r);\n  // 递归调用 A[q] 左边的数组\n  QUICKSORT(A, p, q - 1);\n  // 递归调用 A[q] 右边的数组\n  QUICKSORT(A, q + 1, r);\n```\n\n所以算法的关键步骤就是 `PARTITION` 过程，它实现对子数组 `A[p .. r]` 的原址重排。\n\n*PARTITION(A, p, r)*\n```\n// 数组的最后一个元素（主元）\nx = A[r]\n// i 是小元素数组的右界\ni = p - 1;\n// 遍历数组\nfor j = p to r - 1\n  if A[j] <= x\n    // 如果该元素比 x 小，小元素数组长度加 1\n    i = i + 1\n    // 将该元素挪到小元素数组范围里去\n    exchange A[i] with A[j]\n// 将主元放到大小数组中间\nexchange A[i + 1] with A[j]\n// 主元的位置\nreturn i + 1\n```\n\n快速排序算法的过程涉及到 4 个变量：`p`, `r`, `i`, `j`。将 `A[p .. r]` 数组划分为了四个部分。\n\n1. `p` 到 `i` 之间为第一部分，其值都不大于主元\n2. `i + 1` 到 `j - 1` 之间为第二部分，其值都不小于主元\n3. `j` 到 `r - 1` 之间是第三部分，其元素等待被分配\n4. `r` 处为主元（数组的最后一个元素）\n\n当循环开始时，`j` 从左往右对数组进行扫描，当发现有比主元小的元素时，将 `i` 往右移，并该元素放到 `i` 处，这样循环结束后，整个数组中，`p` 到 `i` 为不大于主元的元素，`i + 1` 到 `r - 1` 为不小于主元的元素，`r` 处为主元，最后我们将 `i + 1` 处的元素和主元交换位置，这样主元就位于了两部分之间。最后，我们对两个子数组进行同样的操作。\n\njavascript 实现\n```javascript\nfunction quickSort(arr, p, r) {\n  if(p < r) {\n    let q = partition(arr, p, r);\n    quickSort(arr, p, q - 1);\n    quickSort(arr, q + 1, r);\n  }\n}\n\nfunction partition(arr, p, r) {\n  let x = arr[r];\n  let i = p - 1;\n  for(var j = p; j < r; j++) {\n    if(arr[j] <= x) {\n      i++;\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n  }\n  [arr[i + 1], arr[r]] = [arr[r], arr[i + 1]];\n  return i + 1;\n}\n\nlet arr = [13, 19, 9, 5, 12, 8, 7, 4, 21, 2, 6, 11];\nquickSort(arr, 0, arr.length - 1);\nconsole.log(arr); // [2, 4, 5, 6, 7, 8, 9, 11, 12, 13, 19, 21]\n```\n","slug":"Introduction-to-Algorithms-7","published":1,"updated":"2016-08-27T00:03:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcuv0008n927rvcl2055","content":"<p>快速排序和归并排序一样，使用了分治思想。回顾一下归并排序，归并排序是将数组递归拆分，然后两两合并成已排序的数组，一直到合并成为新数组。</p>\n<p>快速排序的思想有点相似，但快速排序能够进行原址排序，而不用占用大量的额外空间。</p>\n<a id=\"more\"></a>\n<p>对于数组 <code>A[p .. r]</code> 快速排序的三步分治过程如下：</p>\n<ul>\n<li>分解：数组 <code>A[p .. r]</code> 被划分为两个（可能为空）子数组 <code>A[p .. q - 1]</code> 和 <code>A[q + 1 .. r]</code>，使得 <code>A[p .. q - 1]</code> 中的每一个元素都小于等于 <code>A[q]</code>，而 <code>A[q]</code> 也小于等于 <code>A[q + 1 .. r]</code> 中的每个元素。其中，计算下标 q 也是划分过程的一部分。</li>\n<li>解决：通过递归调用快速排序，对子数组 <code>A[p .. q - 1]</code> 和 <code>A[q + 1 .. r]</code> 进行排序。</li>\n<li>合并：因为子数组都是原址排序的，所以不需要合并操作：数组 <code>A[p .. r]</code> 已经有序。</li>\n</ul>\n<p>核心就在于我们选出了一个主元（即 <code>A[q]</code>），将数组划分为了两个子数组，一边小于等于 <code>A[q]</code>，一边大于等于 <code>A[q]</code>，再分别对两个子数组执行相同操作，一直到不可拆分为止。</p>\n<p>伪代码：<br><em>QUICKSORT(A, p, r)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">if p &lt; r</div><div class=\"line\">  // 找到分界点 A[q] 的位置</div><div class=\"line\">  q = PARTITION(A, p, r);</div><div class=\"line\">  // 递归调用 A[q] 左边的数组</div><div class=\"line\">  QUICKSORT(A, p, q - 1);</div><div class=\"line\">  // 递归调用 A[q] 右边的数组</div><div class=\"line\">  QUICKSORT(A, q + 1, r);</div></pre></td></tr></table></figure></p>\n<p>所以算法的关键步骤就是 <code>PARTITION</code> 过程，它实现对子数组 <code>A[p .. r]</code> 的原址重排。</p>\n<p><em>PARTITION(A, p, r)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 数组的最后一个元素（主元）</div><div class=\"line\">x = A[r]</div><div class=\"line\">// i 是小元素数组的右界</div><div class=\"line\">i = p - 1;</div><div class=\"line\">// 遍历数组</div><div class=\"line\">for j = p to r - 1</div><div class=\"line\">  if A[j] &lt;= x</div><div class=\"line\">    // 如果该元素比 x 小，小元素数组长度加 1</div><div class=\"line\">    i = i + 1</div><div class=\"line\">    // 将该元素挪到小元素数组范围里去</div><div class=\"line\">    exchange A[i] with A[j]</div><div class=\"line\">// 将主元放到大小数组中间</div><div class=\"line\">exchange A[i + 1] with A[j]</div><div class=\"line\">// 主元的位置</div><div class=\"line\">return i + 1</div></pre></td></tr></table></figure></p>\n<p>快速排序算法的过程涉及到 4 个变量：<code>p</code>, <code>r</code>, <code>i</code>, <code>j</code>。将 <code>A[p .. r]</code> 数组划分为了四个部分。</p>\n<ol>\n<li><code>p</code> 到 <code>i</code> 之间为第一部分，其值都不大于主元</li>\n<li><code>i + 1</code> 到 <code>j - 1</code> 之间为第二部分，其值都不小于主元</li>\n<li><code>j</code> 到 <code>r - 1</code> 之间是第三部分，其元素等待被分配</li>\n<li><code>r</code> 处为主元（数组的最后一个元素）</li>\n</ol>\n<p>当循环开始时，<code>j</code> 从左往右对数组进行扫描，当发现有比主元小的元素时，将 <code>i</code> 往右移，并该元素放到 <code>i</code> 处，这样循环结束后，整个数组中，<code>p</code> 到 <code>i</code> 为不大于主元的元素，<code>i + 1</code> 到 <code>r - 1</code> 为不小于主元的元素，<code>r</code> 处为主元，最后我们将 <code>i + 1</code> 处的元素和主元交换位置，这样主元就位于了两部分之间。最后，我们对两个子数组进行同样的操作。</p>\n<p>javascript 实现<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quickSort</span>(<span class=\"params\">arr, p, r</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(p &lt; r) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> q = partition(arr, p, r);</div><div class=\"line\">    quickSort(arr, p, q - <span class=\"number\">1</span>);</div><div class=\"line\">    quickSort(arr, q + <span class=\"number\">1</span>, r);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">partition</span>(<span class=\"params\">arr, p, r</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> x = arr[r];</div><div class=\"line\">  <span class=\"keyword\">let</span> i = p - <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = p; j &lt; r; j++) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(arr[j] &lt;= x) &#123;</div><div class=\"line\">      i++;</div><div class=\"line\">      [arr[i], arr[j]] = [arr[j], arr[i]];</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  [arr[i + <span class=\"number\">1</span>], arr[r]] = [arr[r], arr[i + <span class=\"number\">1</span>]];</div><div class=\"line\">  <span class=\"keyword\">return</span> i + <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">13</span>, <span class=\"number\">19</span>, <span class=\"number\">9</span>, <span class=\"number\">5</span>, <span class=\"number\">12</span>, <span class=\"number\">8</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>, <span class=\"number\">21</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">11</span>];</div><div class=\"line\">quickSort(arr, <span class=\"number\">0</span>, arr.length - <span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [2, 4, 5, 6, 7, 8, 9, 11, 12, 13, 19, 21]</span></div></pre></td></tr></table></figure></p>\n","excerpt":"<p>快速排序和归并排序一样，使用了分治思想。回顾一下归并排序，归并排序是将数组递归拆分，然后两两合并成已排序的数组，一直到合并成为新数组。</p>\n<p>快速排序的思想有点相似，但快速排序能够进行原址排序，而不用占用大量的额外空间。</p>","more":"<p>对于数组 <code>A[p .. r]</code> 快速排序的三步分治过程如下：</p>\n<ul>\n<li>分解：数组 <code>A[p .. r]</code> 被划分为两个（可能为空）子数组 <code>A[p .. q - 1]</code> 和 <code>A[q + 1 .. r]</code>，使得 <code>A[p .. q - 1]</code> 中的每一个元素都小于等于 <code>A[q]</code>，而 <code>A[q]</code> 也小于等于 <code>A[q + 1 .. r]</code> 中的每个元素。其中，计算下标 q 也是划分过程的一部分。</li>\n<li>解决：通过递归调用快速排序，对子数组 <code>A[p .. q - 1]</code> 和 <code>A[q + 1 .. r]</code> 进行排序。</li>\n<li>合并：因为子数组都是原址排序的，所以不需要合并操作：数组 <code>A[p .. r]</code> 已经有序。</li>\n</ul>\n<p>核心就在于我们选出了一个主元（即 <code>A[q]</code>），将数组划分为了两个子数组，一边小于等于 <code>A[q]</code>，一边大于等于 <code>A[q]</code>，再分别对两个子数组执行相同操作，一直到不可拆分为止。</p>\n<p>伪代码：<br><em>QUICKSORT(A, p, r)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">if p &lt; r</div><div class=\"line\">  // 找到分界点 A[q] 的位置</div><div class=\"line\">  q = PARTITION(A, p, r);</div><div class=\"line\">  // 递归调用 A[q] 左边的数组</div><div class=\"line\">  QUICKSORT(A, p, q - 1);</div><div class=\"line\">  // 递归调用 A[q] 右边的数组</div><div class=\"line\">  QUICKSORT(A, q + 1, r);</div></pre></td></tr></table></figure></p>\n<p>所以算法的关键步骤就是 <code>PARTITION</code> 过程，它实现对子数组 <code>A[p .. r]</code> 的原址重排。</p>\n<p><em>PARTITION(A, p, r)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 数组的最后一个元素（主元）</div><div class=\"line\">x = A[r]</div><div class=\"line\">// i 是小元素数组的右界</div><div class=\"line\">i = p - 1;</div><div class=\"line\">// 遍历数组</div><div class=\"line\">for j = p to r - 1</div><div class=\"line\">  if A[j] &lt;= x</div><div class=\"line\">    // 如果该元素比 x 小，小元素数组长度加 1</div><div class=\"line\">    i = i + 1</div><div class=\"line\">    // 将该元素挪到小元素数组范围里去</div><div class=\"line\">    exchange A[i] with A[j]</div><div class=\"line\">// 将主元放到大小数组中间</div><div class=\"line\">exchange A[i + 1] with A[j]</div><div class=\"line\">// 主元的位置</div><div class=\"line\">return i + 1</div></pre></td></tr></table></figure></p>\n<p>快速排序算法的过程涉及到 4 个变量：<code>p</code>, <code>r</code>, <code>i</code>, <code>j</code>。将 <code>A[p .. r]</code> 数组划分为了四个部分。</p>\n<ol>\n<li><code>p</code> 到 <code>i</code> 之间为第一部分，其值都不大于主元</li>\n<li><code>i + 1</code> 到 <code>j - 1</code> 之间为第二部分，其值都不小于主元</li>\n<li><code>j</code> 到 <code>r - 1</code> 之间是第三部分，其元素等待被分配</li>\n<li><code>r</code> 处为主元（数组的最后一个元素）</li>\n</ol>\n<p>当循环开始时，<code>j</code> 从左往右对数组进行扫描，当发现有比主元小的元素时，将 <code>i</code> 往右移，并该元素放到 <code>i</code> 处，这样循环结束后，整个数组中，<code>p</code> 到 <code>i</code> 为不大于主元的元素，<code>i + 1</code> 到 <code>r - 1</code> 为不小于主元的元素，<code>r</code> 处为主元，最后我们将 <code>i + 1</code> 处的元素和主元交换位置，这样主元就位于了两部分之间。最后，我们对两个子数组进行同样的操作。</p>\n<p>javascript 实现<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quickSort</span>(<span class=\"params\">arr, p, r</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(p &lt; r) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> q = partition(arr, p, r);</div><div class=\"line\">    quickSort(arr, p, q - <span class=\"number\">1</span>);</div><div class=\"line\">    quickSort(arr, q + <span class=\"number\">1</span>, r);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">partition</span>(<span class=\"params\">arr, p, r</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> x = arr[r];</div><div class=\"line\">  <span class=\"keyword\">let</span> i = p - <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = p; j &lt; r; j++) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(arr[j] &lt;= x) &#123;</div><div class=\"line\">      i++;</div><div class=\"line\">      [arr[i], arr[j]] = [arr[j], arr[i]];</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  [arr[i + <span class=\"number\">1</span>], arr[r]] = [arr[r], arr[i + <span class=\"number\">1</span>]];</div><div class=\"line\">  <span class=\"keyword\">return</span> i + <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">13</span>, <span class=\"number\">19</span>, <span class=\"number\">9</span>, <span class=\"number\">5</span>, <span class=\"number\">12</span>, <span class=\"number\">8</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>, <span class=\"number\">21</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">11</span>];</div><div class=\"line\">quickSort(arr, <span class=\"number\">0</span>, arr.length - <span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [2, 4, 5, 6, 7, 8, 9, 11, 12, 13, 19, 21]</span></div></pre></td></tr></table></figure></p>"},{"title":"公钥密码","date":"2016-11-02T17:00:00.000Z","_content":"\n使用 git 的时候，每次换机器，都需要向 git 服务器提供 ssh 公钥，当有些机器上并没有的时候，可以使用命令生成一份，命令执行完后，会多两个文件，一个叫 `id_rsa.pub`，一个叫 `id_rsa`，前者称为 ssh 公钥，是需要提供给 git 服务器的，后者是私钥，一般我们就不会管了，但这个文件其实是不能泄露给他人的。\n\n所以一直都有这些疑惑：\n\n- 什么是公钥，什么是私钥？\n- 为什么公钥能够公开，私钥必须保存？\n- 公钥和私钥在通信过程中发挥了怎样的作用？\n\n<!-- more -->\n\n公钥又称为加密密钥，私钥又称为解密密钥，他们都是 **公钥密码** 中的密钥。在通信中，发送者通过公钥对消息进行加密，接受者通过私钥对消息进行解密，从而保证消息的 **机密性**。\n\n说到公钥密码，就不能不先提一下 **对称密码**。\n\n## 对称密码\n\n当我们说要给一段消息加密的时候，最简单的想法可能就是发送者通过一个密钥给消息加密，接受者拿到消息后再根据这个密钥给消息解密。\n\n举个栗子，好比发送者有一段为 `midnight` 的消息要发送给接受者，首先，我们对消息进行编码，取出消息中每个字母的 ASCII：\n\n```\nm -> 01101101\ni -> 01101001\nd -> 01100100\nn -> 01101110\ni -> 01101001\ng -> 01100111\nh -> 01101000\nt -> 01110100\n```\n\n编码完之后，这段消息也就是：`0110110101101001011001000110111001101001011001110110100001110100`，然后发送者随机生成一个与消息等长的密钥，假设是 `01010101010101010101010101010101010101010101010101010101010101`，然后将消息和密钥进行 XOR 运算，生成的结果也就是密文。\n\n```\n明文 0110110101101001011001000110111001101001011001110110100001110100\n密钥 0101010101010101010101010101010101010101010101010101010101010101\n密文 0011100000111100001100010011101100111100001100100011110100100001\n```\n\n当接收者得到密文后，也与密钥进行 XOR 运算，即能得到明文。\n\n在这个过程中，发送者加密时使用的密钥，和接收者解密时使用的密钥是一样的，这种密码算法就称为 **对称密码**。\n\n与之不同的是，**公钥密码** 在加密和解密中使用了不同的密钥，也就是我们开头提到的公钥和私钥，因此，公钥密码又称为 **非对称密码**。\n\n*另外，对称密码又称为私钥密码。*\n\n## 公钥密码\n\n了解了对称密码之后，你一定也有一个巨大的疑惑，就是接收者收到密文之后，是需要发送方的密钥来解密的，但是密钥怎么配送呢？\n\n这也就是 **密钥配送问题**：**假如发送者能安全地把密钥发送给接收者，那为什么不通过这种方式把明文发送给接收者呢？**\n\n好在，通过公钥密码可以解决这个问题。\n\n公钥密码将密钥分为了 **加密密钥** 和 **解密密钥**，发送者通过加密密钥对消息进行加密，接收者通过解密密钥对消息进行解密，也就是说，解密密钥是一开始就由接收者自己保管的，因此只需要接收者将加密密钥发送给发送者就可以解决密钥配送问题了：因为根本不需要配送解密密钥！\n\n流程图如下： \n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/asymmetric-cryptography/01.png)\n\n从图中我们可以得到以下信息：\n\n- 发送者只需要公钥\n- 接收者只需要私钥\n- 私钥不能被窃听者获取\n- 公钥被窃听者获取也没问题\n- 通过公钥加密的消息，能够被私钥解密，但公钥无法解密密文\n\n公钥和私钥是一一对应的，一对公钥和私钥统称为 **密钥对**。由公钥加密的密文必须使用与该公钥配对的私钥才能够解密。密钥对中的两个密钥之间具有非常密切的关系——数学上的关系——因此公钥和私钥是不能分别单独生成的。\n\n在公钥密码中，使用最广泛的公钥密码算法是 RSA 加密算法。（TODO）","source":"_posts/asymmetric-cryptography.md","raw":"---\ntitle: 公钥密码\ndate: 2016-11-03 01:00:00\ntags: [密码技术]\n---\n\n使用 git 的时候，每次换机器，都需要向 git 服务器提供 ssh 公钥，当有些机器上并没有的时候，可以使用命令生成一份，命令执行完后，会多两个文件，一个叫 `id_rsa.pub`，一个叫 `id_rsa`，前者称为 ssh 公钥，是需要提供给 git 服务器的，后者是私钥，一般我们就不会管了，但这个文件其实是不能泄露给他人的。\n\n所以一直都有这些疑惑：\n\n- 什么是公钥，什么是私钥？\n- 为什么公钥能够公开，私钥必须保存？\n- 公钥和私钥在通信过程中发挥了怎样的作用？\n\n<!-- more -->\n\n公钥又称为加密密钥，私钥又称为解密密钥，他们都是 **公钥密码** 中的密钥。在通信中，发送者通过公钥对消息进行加密，接受者通过私钥对消息进行解密，从而保证消息的 **机密性**。\n\n说到公钥密码，就不能不先提一下 **对称密码**。\n\n## 对称密码\n\n当我们说要给一段消息加密的时候，最简单的想法可能就是发送者通过一个密钥给消息加密，接受者拿到消息后再根据这个密钥给消息解密。\n\n举个栗子，好比发送者有一段为 `midnight` 的消息要发送给接受者，首先，我们对消息进行编码，取出消息中每个字母的 ASCII：\n\n```\nm -> 01101101\ni -> 01101001\nd -> 01100100\nn -> 01101110\ni -> 01101001\ng -> 01100111\nh -> 01101000\nt -> 01110100\n```\n\n编码完之后，这段消息也就是：`0110110101101001011001000110111001101001011001110110100001110100`，然后发送者随机生成一个与消息等长的密钥，假设是 `01010101010101010101010101010101010101010101010101010101010101`，然后将消息和密钥进行 XOR 运算，生成的结果也就是密文。\n\n```\n明文 0110110101101001011001000110111001101001011001110110100001110100\n密钥 0101010101010101010101010101010101010101010101010101010101010101\n密文 0011100000111100001100010011101100111100001100100011110100100001\n```\n\n当接收者得到密文后，也与密钥进行 XOR 运算，即能得到明文。\n\n在这个过程中，发送者加密时使用的密钥，和接收者解密时使用的密钥是一样的，这种密码算法就称为 **对称密码**。\n\n与之不同的是，**公钥密码** 在加密和解密中使用了不同的密钥，也就是我们开头提到的公钥和私钥，因此，公钥密码又称为 **非对称密码**。\n\n*另外，对称密码又称为私钥密码。*\n\n## 公钥密码\n\n了解了对称密码之后，你一定也有一个巨大的疑惑，就是接收者收到密文之后，是需要发送方的密钥来解密的，但是密钥怎么配送呢？\n\n这也就是 **密钥配送问题**：**假如发送者能安全地把密钥发送给接收者，那为什么不通过这种方式把明文发送给接收者呢？**\n\n好在，通过公钥密码可以解决这个问题。\n\n公钥密码将密钥分为了 **加密密钥** 和 **解密密钥**，发送者通过加密密钥对消息进行加密，接收者通过解密密钥对消息进行解密，也就是说，解密密钥是一开始就由接收者自己保管的，因此只需要接收者将加密密钥发送给发送者就可以解决密钥配送问题了：因为根本不需要配送解密密钥！\n\n流程图如下： \n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/asymmetric-cryptography/01.png)\n\n从图中我们可以得到以下信息：\n\n- 发送者只需要公钥\n- 接收者只需要私钥\n- 私钥不能被窃听者获取\n- 公钥被窃听者获取也没问题\n- 通过公钥加密的消息，能够被私钥解密，但公钥无法解密密文\n\n公钥和私钥是一一对应的，一对公钥和私钥统称为 **密钥对**。由公钥加密的密文必须使用与该公钥配对的私钥才能够解密。密钥对中的两个密钥之间具有非常密切的关系——数学上的关系——因此公钥和私钥是不能分别单独生成的。\n\n在公钥密码中，使用最广泛的公钥密码算法是 RSA 加密算法。（TODO）","slug":"asymmetric-cryptography","published":1,"updated":"2016-11-12T13:23:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcuy000bn9278b88mo0h","content":"<p>使用 git 的时候，每次换机器，都需要向 git 服务器提供 ssh 公钥，当有些机器上并没有的时候，可以使用命令生成一份，命令执行完后，会多两个文件，一个叫 <code>id_rsa.pub</code>，一个叫 <code>id_rsa</code>，前者称为 ssh 公钥，是需要提供给 git 服务器的，后者是私钥，一般我们就不会管了，但这个文件其实是不能泄露给他人的。</p>\n<p>所以一直都有这些疑惑：</p>\n<ul>\n<li>什么是公钥，什么是私钥？</li>\n<li>为什么公钥能够公开，私钥必须保存？</li>\n<li>公钥和私钥在通信过程中发挥了怎样的作用？</li>\n</ul>\n<a id=\"more\"></a>\n<p>公钥又称为加密密钥，私钥又称为解密密钥，他们都是 <strong>公钥密码</strong> 中的密钥。在通信中，发送者通过公钥对消息进行加密，接受者通过私钥对消息进行解密，从而保证消息的 <strong>机密性</strong>。</p>\n<p>说到公钥密码，就不能不先提一下 <strong>对称密码</strong>。</p>\n<h2 id=\"对称密码\"><a href=\"#对称密码\" class=\"headerlink\" title=\"对称密码\"></a>对称密码</h2><p>当我们说要给一段消息加密的时候，最简单的想法可能就是发送者通过一个密钥给消息加密，接受者拿到消息后再根据这个密钥给消息解密。</p>\n<p>举个栗子，好比发送者有一段为 <code>midnight</code> 的消息要发送给接受者，首先，我们对消息进行编码，取出消息中每个字母的 ASCII：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">m -&gt; 01101101</div><div class=\"line\">i -&gt; 01101001</div><div class=\"line\">d -&gt; 01100100</div><div class=\"line\">n -&gt; 01101110</div><div class=\"line\">i -&gt; 01101001</div><div class=\"line\">g -&gt; 01100111</div><div class=\"line\">h -&gt; 01101000</div><div class=\"line\">t -&gt; 01110100</div></pre></td></tr></table></figure>\n<p>编码完之后，这段消息也就是：<code>0110110101101001011001000110111001101001011001110110100001110100</code>，然后发送者随机生成一个与消息等长的密钥，假设是 <code>01010101010101010101010101010101010101010101010101010101010101</code>，然后将消息和密钥进行 XOR 运算，生成的结果也就是密文。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">明文 0110110101101001011001000110111001101001011001110110100001110100</div><div class=\"line\">密钥 0101010101010101010101010101010101010101010101010101010101010101</div><div class=\"line\">密文 0011100000111100001100010011101100111100001100100011110100100001</div></pre></td></tr></table></figure>\n<p>当接收者得到密文后，也与密钥进行 XOR 运算，即能得到明文。</p>\n<p>在这个过程中，发送者加密时使用的密钥，和接收者解密时使用的密钥是一样的，这种密码算法就称为 <strong>对称密码</strong>。</p>\n<p>与之不同的是，<strong>公钥密码</strong> 在加密和解密中使用了不同的密钥，也就是我们开头提到的公钥和私钥，因此，公钥密码又称为 <strong>非对称密码</strong>。</p>\n<p><em>另外，对称密码又称为私钥密码。</em></p>\n<h2 id=\"公钥密码\"><a href=\"#公钥密码\" class=\"headerlink\" title=\"公钥密码\"></a>公钥密码</h2><p>了解了对称密码之后，你一定也有一个巨大的疑惑，就是接收者收到密文之后，是需要发送方的密钥来解密的，但是密钥怎么配送呢？</p>\n<p>这也就是 <strong>密钥配送问题</strong>：<strong>假如发送者能安全地把密钥发送给接收者，那为什么不通过这种方式把明文发送给接收者呢？</strong></p>\n<p>好在，通过公钥密码可以解决这个问题。</p>\n<p>公钥密码将密钥分为了 <strong>加密密钥</strong> 和 <strong>解密密钥</strong>，发送者通过加密密钥对消息进行加密，接收者通过解密密钥对消息进行解密，也就是说，解密密钥是一开始就由接收者自己保管的，因此只需要接收者将加密密钥发送给发送者就可以解决密钥配送问题了：因为根本不需要配送解密密钥！</p>\n<p>流程图如下： </p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/asymmetric-cryptography/01.png\" alt=\"\"></p>\n<p>从图中我们可以得到以下信息：</p>\n<ul>\n<li>发送者只需要公钥</li>\n<li>接收者只需要私钥</li>\n<li>私钥不能被窃听者获取</li>\n<li>公钥被窃听者获取也没问题</li>\n<li>通过公钥加密的消息，能够被私钥解密，但公钥无法解密密文</li>\n</ul>\n<p>公钥和私钥是一一对应的，一对公钥和私钥统称为 <strong>密钥对</strong>。由公钥加密的密文必须使用与该公钥配对的私钥才能够解密。密钥对中的两个密钥之间具有非常密切的关系——数学上的关系——因此公钥和私钥是不能分别单独生成的。</p>\n<p>在公钥密码中，使用最广泛的公钥密码算法是 RSA 加密算法。（TODO）</p>\n","excerpt":"<p>使用 git 的时候，每次换机器，都需要向 git 服务器提供 ssh 公钥，当有些机器上并没有的时候，可以使用命令生成一份，命令执行完后，会多两个文件，一个叫 <code>id_rsa.pub</code>，一个叫 <code>id_rsa</code>，前者称为 ssh 公钥，是需要提供给 git 服务器的，后者是私钥，一般我们就不会管了，但这个文件其实是不能泄露给他人的。</p>\n<p>所以一直都有这些疑惑：</p>\n<ul>\n<li>什么是公钥，什么是私钥？</li>\n<li>为什么公钥能够公开，私钥必须保存？</li>\n<li>公钥和私钥在通信过程中发挥了怎样的作用？</li>\n</ul>","more":"<p>公钥又称为加密密钥，私钥又称为解密密钥，他们都是 <strong>公钥密码</strong> 中的密钥。在通信中，发送者通过公钥对消息进行加密，接受者通过私钥对消息进行解密，从而保证消息的 <strong>机密性</strong>。</p>\n<p>说到公钥密码，就不能不先提一下 <strong>对称密码</strong>。</p>\n<h2 id=\"对称密码\"><a href=\"#对称密码\" class=\"headerlink\" title=\"对称密码\"></a>对称密码</h2><p>当我们说要给一段消息加密的时候，最简单的想法可能就是发送者通过一个密钥给消息加密，接受者拿到消息后再根据这个密钥给消息解密。</p>\n<p>举个栗子，好比发送者有一段为 <code>midnight</code> 的消息要发送给接受者，首先，我们对消息进行编码，取出消息中每个字母的 ASCII：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">m -&gt; 01101101</div><div class=\"line\">i -&gt; 01101001</div><div class=\"line\">d -&gt; 01100100</div><div class=\"line\">n -&gt; 01101110</div><div class=\"line\">i -&gt; 01101001</div><div class=\"line\">g -&gt; 01100111</div><div class=\"line\">h -&gt; 01101000</div><div class=\"line\">t -&gt; 01110100</div></pre></td></tr></table></figure>\n<p>编码完之后，这段消息也就是：<code>0110110101101001011001000110111001101001011001110110100001110100</code>，然后发送者随机生成一个与消息等长的密钥，假设是 <code>01010101010101010101010101010101010101010101010101010101010101</code>，然后将消息和密钥进行 XOR 运算，生成的结果也就是密文。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">明文 0110110101101001011001000110111001101001011001110110100001110100</div><div class=\"line\">密钥 0101010101010101010101010101010101010101010101010101010101010101</div><div class=\"line\">密文 0011100000111100001100010011101100111100001100100011110100100001</div></pre></td></tr></table></figure>\n<p>当接收者得到密文后，也与密钥进行 XOR 运算，即能得到明文。</p>\n<p>在这个过程中，发送者加密时使用的密钥，和接收者解密时使用的密钥是一样的，这种密码算法就称为 <strong>对称密码</strong>。</p>\n<p>与之不同的是，<strong>公钥密码</strong> 在加密和解密中使用了不同的密钥，也就是我们开头提到的公钥和私钥，因此，公钥密码又称为 <strong>非对称密码</strong>。</p>\n<p><em>另外，对称密码又称为私钥密码。</em></p>\n<h2 id=\"公钥密码\"><a href=\"#公钥密码\" class=\"headerlink\" title=\"公钥密码\"></a>公钥密码</h2><p>了解了对称密码之后，你一定也有一个巨大的疑惑，就是接收者收到密文之后，是需要发送方的密钥来解密的，但是密钥怎么配送呢？</p>\n<p>这也就是 <strong>密钥配送问题</strong>：<strong>假如发送者能安全地把密钥发送给接收者，那为什么不通过这种方式把明文发送给接收者呢？</strong></p>\n<p>好在，通过公钥密码可以解决这个问题。</p>\n<p>公钥密码将密钥分为了 <strong>加密密钥</strong> 和 <strong>解密密钥</strong>，发送者通过加密密钥对消息进行加密，接收者通过解密密钥对消息进行解密，也就是说，解密密钥是一开始就由接收者自己保管的，因此只需要接收者将加密密钥发送给发送者就可以解决密钥配送问题了：因为根本不需要配送解密密钥！</p>\n<p>流程图如下： </p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/asymmetric-cryptography/01.png\" alt=\"\"></p>\n<p>从图中我们可以得到以下信息：</p>\n<ul>\n<li>发送者只需要公钥</li>\n<li>接收者只需要私钥</li>\n<li>私钥不能被窃听者获取</li>\n<li>公钥被窃听者获取也没问题</li>\n<li>通过公钥加密的消息，能够被私钥解密，但公钥无法解密密文</li>\n</ul>\n<p>公钥和私钥是一一对应的，一对公钥和私钥统称为 <strong>密钥对</strong>。由公钥加密的密文必须使用与该公钥配对的私钥才能够解密。密钥对中的两个密钥之间具有非常密切的关系——数学上的关系——因此公钥和私钥是不能分别单独生成的。</p>\n<p>在公钥密码中，使用最广泛的公钥密码算法是 RSA 加密算法。（TODO）</p>"},{"title":"《算法导论》第八章：线性时间排序","date":"2016-07-09T13:59:26.000Z","_content":"\n在前面几章总共介绍了*插入排序、归并排序、堆排序和快速排序*，这些算法都有一个有趣的性质：**在排序的最终结果中，各元素的次序依赖于它们之间的比较**。我们把这类排序算法成为比较排序。\n\n接下来讨论三种线性时间复杂度的排序算法：计数排序、基数排序和桶排序，它们使用运算而不是比较来确定排序顺序。\n\n<!-- more -->\n\n## 排序顺序的下界\n在一个比较排序中，我们只使用元素间的比较来获得输入序列 `<a1, a2, ..., an>` 中的元素间次序的信息。也就是给定两个元素 `ai` 和 `aj`，我们执行比较操作来确定它们之间的相对次序。\n\n### 决策树模型\n比较排序可以被抽象为一颗决策树。\n\n决策树是一颗**完全二叉树**，它可以表示在给定输入规模情况下，某一特定排序算法对所有元素的比较操作。其中，控制、数据移动等其他操作都被忽略了。\n\n在决策树中，每个内部结点都以 `i : j` 标记，其中，`i` 和 `j` 满足 `1 <= i <= j <= n`，`n` 是输入序列中的元素个数。每个叶结点上都标注一个序列 `<π(1), π(2), ..., π(n)`。\n\n排序算法的执行对应于一条从树的根结点到叶结点的路径。每一个内部结点表示比较一次 `ai` 和 `aj`。\n\n每当到达一个叶结点的时候，代表排序算法已经确定了一个顺序。对于一个正确的比较排序算法来说，`n` 个元素的 `n!` 种可能的排列都应该出现在决策树的叶结点上。而且，每一个叶结点都必须是可以从根结点经由某条路径到达的，该路径对应于比较排序的一次实际执行过程（我们称这种叶结点为“可达的”）。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-8/01.png)\n\n如上图，这是一颗作用于三个元素的插入排序决策树。根节点表示第一个元素和第二个元素进行了比较，当第一个元素小于等于第二个元素时，进入根节点的左孩子，将第二个元素和第三个元素进行比较，以此类推。最后，如果第三个孩子小于第一个孩子小于第二个孩子，则排序结果是 `<3, 1, 2>`。\n\n### 最坏情况的下界\n\n对于一颗每个排列都是一个可达叶结点的决策树来说，树的高度完全可以被确定。考虑一颗高度为 `h`，具有 `l` 个可达叶结点的决策树，它对应一个对 `n` 个元素所做的比较排序。\n\n因为输入数据的 `n!` 种可能的排列都是叶结点，所以有 `n! <= l`。\n\n由于在一棵高度为 `h` 的二叉树中，叶结点的数目不多于 `2^h`，所以有 `l <= 2^h`。\n\n我们即得到 `n! <= l <= 2^h`。\n\n两边取对数，有\n\n> h >= lg(n!) = Ω(nlgn)\n\n我们即得到定理：*在最坏情况下，任何比较排序算法都需要做 Ω(nlgn) 次比较*\n\n## 计数排序\n\n上面说完比较排序的最坏下界，我们现在开始讨论线性时间复杂度的排序算法。\n\n**计数排序假设 `n` 个输入元素中的每一个都是在 `0` 到 `k` 区间内的一个整数，其中 `k` 为某个整数**。当 `k = O(n)` 时，排序的运行时间为 `Θ(n)`。\n\n### 思想\n\n计数排序的思想是：对每一个输入元素 `x`，确定小于 `x` 的元素个数。这样，当需要排序元素 `x` 时，只需把 `x` 直接放到它在输出数组中的位置了。\n\n比如如果有 `17` 个元素小于 `x`，则 `x` 应该被放到第十八个输出位置上。当有几个元素相同时，这一方案要略作修改，因为不能把它们放到同一个位置。\n\n### 伪代码\n\n在计数排序的算法中，假设输入是一个数组 `A[1 .. n]`，`A.length = n`。我们还需要两个数组：`B[1 .. n]` 存放输出数组， `C[0 .. k]` 存放个数信息。\n\n*COUNTING-SORT(A, B, k)*\n```\n// C 数组长度为输入数组的最大值\nlet C[0 .. k] be a new array\n// 将 C 数组的元素全部赋值为 0\nfor i = 0 to k\n  C[i] = 0\n// 遍历输入数组，并将 C 元素中对应的值个数加一\nfor j = 1 to A.length\n  C[A[j]] = C[A[j]] + 1\n// 此时 C 数组中存放的是下标在输入数组中的个数\n// C[i] now contains the number of elements equal to i\n// 遍历 C 数组，将个数转变为小于等于下标的个数\nfor i = 1 to k\n  C[i] = C[i] + C[i - 1]\n// C[i] now contains the number of elements less than or equal to i\n// 将输入数组中的元素放入输出数组中对应的位置\nfor j = A.length downto 1\n  B[C[A[j]]] = A[j]\n  C[A[j]] = C[A[j]] - 1\n```\n\n### 排序过程\n\n假设数组 `A` 元素为：`2, 5, 3, 0, 2, 3, 0, 3`\n\n1) 因为输入数组最大元素为 `5`，所以初始化 `C` 数组长度为 `5`。\n\n2) 遍历 `A` 数组，将 `C` 数组中下标为遍历到的元素大小的元素加 1。\n\n3) 步骤 2 结束后 `C` 数组元素为：`2, 0, 2, 3, 0, 1`，代表 `A` 数组中 `0` 个数为 `2`，'1' 个数为 `0`，以此类推。\n\n4) 遍历 `C` 数组，将元素大小置为当前元素大小加前一元素大小。\n\n5) 步骤 4 结束后，`C` 数组元素为：`2, 2, 4, 7, 7, 8`，代表 `A` 数组中小于等于 `0` 个数为 `2`，小于等于 '1' 个数为 `2`，小于等于 '2' 个数为 `4`，以此类推。\n\n6) 遍历 `A` 数组，利用 `C` 数组中的信息将元素放置到对应的位置，需要注意每放置完一个元素需要将对应的小于等于个数减一。\n\n计数排序的总时间代价是 `Θ(k + n)`，当 `k = O(n)` 时，我们一般采用计数排序，此时运行时间为 `Θ(n)`。\n\n计数排序的另一个重要性质是它是**稳定的**：具有相同大小的元素，在输入数组中先出现的，在输出数组中也位于前面。\n\n### javascript 实现\n```javascript\nunction countingSort(arr, k) {\n  var B = [], C = [0];\n  for(var i = 0; i < k; i++, C[i] = 0) {/*empty*/}\n\n  for(var i = 0; i < arr.length; i++) {\n    C[arr[i]] = C[arr[i]] + 1;\n  }\n\n  for(var i = 1; i < C.length; i++) {\n    C[i] = C[i] + C[i - 1];\n  }\n\n  for(var i = arr.length - 1; i >= 0; i--) {\n    // -1 是因为小于等于该元素的个数包括该元素\n    B[C[arr[i]] - 1] = arr[i];\n    C[arr[i]] = C[arr[i]] - 1;\n  }\n\n  return B;\n}\n\nvar arr = [2, 5, 3, 0, 2, 3, 0, 3];\ncountingSort(arr, 5); // [0, 0, 2, 2, 3, 3, 3, 5]\n```\n\n## 基数排序\n\n基数排序用于排序 `n` 个 `d` 位数，先按最低有效位进行排序，然后按次低有效位，直到对所有的 `d` 位数都进行了排序。\n\n基数排序的代码是非常直观的，假设 `n` 个 `d` 位的元素存放在数组 `A` 中，其中第 `1` 位是最低位，第 `d` 位是最高位。如果我们希望元素排序完之后顺序不会被改变，那么在排序有效位过程中需要使用一种稳定的排序算法。\n\n*RADIX-SORT(A, d)*\n```\nfor i = 1 to d\n  use a stable sort to sort array A on digit d\n```\n\n以 8 个 3 位数举例，排序过程如下：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-8/02.jpg)\n\n对于 `n` 个 `d` 位数，其中每一个数位有 k 个可能的取值。如果 `RADIX-SORT` 使用的稳定排序方法耗时 `Θ(n + k)`，那么它就可以在 `Θ(d(n + k))` 时间内将这些数排好序。\n\n## 桶排序\n\n桶排序假设输入数据服从均匀分布，平均情况下它的时间代价为 `O(n)`。\n\n桶排序将 `[0, 1)` 划分为 `n` 个相同大小的子区间，称为桶。然后，将 n 个输入数分别放到桶中，因为输入数据是均匀、独立地分布在 `[0, 1)` 上，所以一般不会出现很多数落在同一个桶中的情况。为了得到输出结果，我们先对每个桶中的数进行排序，然后遍历每个桶，按照次序把各个桶中的元素列出来即可。\n\n算法需要一个临时数组 `B[0 .. n-1]` 来存放链表（即桶），并假设存在一种用于维护这些链表的机制。\n\n### 排序过程\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-8/03.jpg)\n","source":"_posts/Introduction-to-Algorithms-8.md","raw":"---\ntitle: 《算法导论》第八章：线性时间排序\ndate: 2016-07-09 21:59:26\ntags: [读书笔记, 算法]\n---\n\n在前面几章总共介绍了*插入排序、归并排序、堆排序和快速排序*，这些算法都有一个有趣的性质：**在排序的最终结果中，各元素的次序依赖于它们之间的比较**。我们把这类排序算法成为比较排序。\n\n接下来讨论三种线性时间复杂度的排序算法：计数排序、基数排序和桶排序，它们使用运算而不是比较来确定排序顺序。\n\n<!-- more -->\n\n## 排序顺序的下界\n在一个比较排序中，我们只使用元素间的比较来获得输入序列 `<a1, a2, ..., an>` 中的元素间次序的信息。也就是给定两个元素 `ai` 和 `aj`，我们执行比较操作来确定它们之间的相对次序。\n\n### 决策树模型\n比较排序可以被抽象为一颗决策树。\n\n决策树是一颗**完全二叉树**，它可以表示在给定输入规模情况下，某一特定排序算法对所有元素的比较操作。其中，控制、数据移动等其他操作都被忽略了。\n\n在决策树中，每个内部结点都以 `i : j` 标记，其中，`i` 和 `j` 满足 `1 <= i <= j <= n`，`n` 是输入序列中的元素个数。每个叶结点上都标注一个序列 `<π(1), π(2), ..., π(n)`。\n\n排序算法的执行对应于一条从树的根结点到叶结点的路径。每一个内部结点表示比较一次 `ai` 和 `aj`。\n\n每当到达一个叶结点的时候，代表排序算法已经确定了一个顺序。对于一个正确的比较排序算法来说，`n` 个元素的 `n!` 种可能的排列都应该出现在决策树的叶结点上。而且，每一个叶结点都必须是可以从根结点经由某条路径到达的，该路径对应于比较排序的一次实际执行过程（我们称这种叶结点为“可达的”）。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-8/01.png)\n\n如上图，这是一颗作用于三个元素的插入排序决策树。根节点表示第一个元素和第二个元素进行了比较，当第一个元素小于等于第二个元素时，进入根节点的左孩子，将第二个元素和第三个元素进行比较，以此类推。最后，如果第三个孩子小于第一个孩子小于第二个孩子，则排序结果是 `<3, 1, 2>`。\n\n### 最坏情况的下界\n\n对于一颗每个排列都是一个可达叶结点的决策树来说，树的高度完全可以被确定。考虑一颗高度为 `h`，具有 `l` 个可达叶结点的决策树，它对应一个对 `n` 个元素所做的比较排序。\n\n因为输入数据的 `n!` 种可能的排列都是叶结点，所以有 `n! <= l`。\n\n由于在一棵高度为 `h` 的二叉树中，叶结点的数目不多于 `2^h`，所以有 `l <= 2^h`。\n\n我们即得到 `n! <= l <= 2^h`。\n\n两边取对数，有\n\n> h >= lg(n!) = Ω(nlgn)\n\n我们即得到定理：*在最坏情况下，任何比较排序算法都需要做 Ω(nlgn) 次比较*\n\n## 计数排序\n\n上面说完比较排序的最坏下界，我们现在开始讨论线性时间复杂度的排序算法。\n\n**计数排序假设 `n` 个输入元素中的每一个都是在 `0` 到 `k` 区间内的一个整数，其中 `k` 为某个整数**。当 `k = O(n)` 时，排序的运行时间为 `Θ(n)`。\n\n### 思想\n\n计数排序的思想是：对每一个输入元素 `x`，确定小于 `x` 的元素个数。这样，当需要排序元素 `x` 时，只需把 `x` 直接放到它在输出数组中的位置了。\n\n比如如果有 `17` 个元素小于 `x`，则 `x` 应该被放到第十八个输出位置上。当有几个元素相同时，这一方案要略作修改，因为不能把它们放到同一个位置。\n\n### 伪代码\n\n在计数排序的算法中，假设输入是一个数组 `A[1 .. n]`，`A.length = n`。我们还需要两个数组：`B[1 .. n]` 存放输出数组， `C[0 .. k]` 存放个数信息。\n\n*COUNTING-SORT(A, B, k)*\n```\n// C 数组长度为输入数组的最大值\nlet C[0 .. k] be a new array\n// 将 C 数组的元素全部赋值为 0\nfor i = 0 to k\n  C[i] = 0\n// 遍历输入数组，并将 C 元素中对应的值个数加一\nfor j = 1 to A.length\n  C[A[j]] = C[A[j]] + 1\n// 此时 C 数组中存放的是下标在输入数组中的个数\n// C[i] now contains the number of elements equal to i\n// 遍历 C 数组，将个数转变为小于等于下标的个数\nfor i = 1 to k\n  C[i] = C[i] + C[i - 1]\n// C[i] now contains the number of elements less than or equal to i\n// 将输入数组中的元素放入输出数组中对应的位置\nfor j = A.length downto 1\n  B[C[A[j]]] = A[j]\n  C[A[j]] = C[A[j]] - 1\n```\n\n### 排序过程\n\n假设数组 `A` 元素为：`2, 5, 3, 0, 2, 3, 0, 3`\n\n1) 因为输入数组最大元素为 `5`，所以初始化 `C` 数组长度为 `5`。\n\n2) 遍历 `A` 数组，将 `C` 数组中下标为遍历到的元素大小的元素加 1。\n\n3) 步骤 2 结束后 `C` 数组元素为：`2, 0, 2, 3, 0, 1`，代表 `A` 数组中 `0` 个数为 `2`，'1' 个数为 `0`，以此类推。\n\n4) 遍历 `C` 数组，将元素大小置为当前元素大小加前一元素大小。\n\n5) 步骤 4 结束后，`C` 数组元素为：`2, 2, 4, 7, 7, 8`，代表 `A` 数组中小于等于 `0` 个数为 `2`，小于等于 '1' 个数为 `2`，小于等于 '2' 个数为 `4`，以此类推。\n\n6) 遍历 `A` 数组，利用 `C` 数组中的信息将元素放置到对应的位置，需要注意每放置完一个元素需要将对应的小于等于个数减一。\n\n计数排序的总时间代价是 `Θ(k + n)`，当 `k = O(n)` 时，我们一般采用计数排序，此时运行时间为 `Θ(n)`。\n\n计数排序的另一个重要性质是它是**稳定的**：具有相同大小的元素，在输入数组中先出现的，在输出数组中也位于前面。\n\n### javascript 实现\n```javascript\nunction countingSort(arr, k) {\n  var B = [], C = [0];\n  for(var i = 0; i < k; i++, C[i] = 0) {/*empty*/}\n\n  for(var i = 0; i < arr.length; i++) {\n    C[arr[i]] = C[arr[i]] + 1;\n  }\n\n  for(var i = 1; i < C.length; i++) {\n    C[i] = C[i] + C[i - 1];\n  }\n\n  for(var i = arr.length - 1; i >= 0; i--) {\n    // -1 是因为小于等于该元素的个数包括该元素\n    B[C[arr[i]] - 1] = arr[i];\n    C[arr[i]] = C[arr[i]] - 1;\n  }\n\n  return B;\n}\n\nvar arr = [2, 5, 3, 0, 2, 3, 0, 3];\ncountingSort(arr, 5); // [0, 0, 2, 2, 3, 3, 3, 5]\n```\n\n## 基数排序\n\n基数排序用于排序 `n` 个 `d` 位数，先按最低有效位进行排序，然后按次低有效位，直到对所有的 `d` 位数都进行了排序。\n\n基数排序的代码是非常直观的，假设 `n` 个 `d` 位的元素存放在数组 `A` 中，其中第 `1` 位是最低位，第 `d` 位是最高位。如果我们希望元素排序完之后顺序不会被改变，那么在排序有效位过程中需要使用一种稳定的排序算法。\n\n*RADIX-SORT(A, d)*\n```\nfor i = 1 to d\n  use a stable sort to sort array A on digit d\n```\n\n以 8 个 3 位数举例，排序过程如下：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-8/02.jpg)\n\n对于 `n` 个 `d` 位数，其中每一个数位有 k 个可能的取值。如果 `RADIX-SORT` 使用的稳定排序方法耗时 `Θ(n + k)`，那么它就可以在 `Θ(d(n + k))` 时间内将这些数排好序。\n\n## 桶排序\n\n桶排序假设输入数据服从均匀分布，平均情况下它的时间代价为 `O(n)`。\n\n桶排序将 `[0, 1)` 划分为 `n` 个相同大小的子区间，称为桶。然后，将 n 个输入数分别放到桶中，因为输入数据是均匀、独立地分布在 `[0, 1)` 上，所以一般不会出现很多数落在同一个桶中的情况。为了得到输出结果，我们先对每个桶中的数进行排序，然后遍历每个桶，按照次序把各个桶中的元素列出来即可。\n\n算法需要一个临时数组 `B[0 .. n-1]` 来存放链表（即桶），并假设存在一种用于维护这些链表的机制。\n\n### 排序过程\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-8/03.jpg)\n","slug":"Introduction-to-Algorithms-8","published":1,"updated":"2016-08-27T00:03:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcv0000cn927rppfubx9","content":"<p>在前面几章总共介绍了<em>插入排序、归并排序、堆排序和快速排序</em>，这些算法都有一个有趣的性质：<strong>在排序的最终结果中，各元素的次序依赖于它们之间的比较</strong>。我们把这类排序算法成为比较排序。</p>\n<p>接下来讨论三种线性时间复杂度的排序算法：计数排序、基数排序和桶排序，它们使用运算而不是比较来确定排序顺序。</p>\n<a id=\"more\"></a>\n<h2 id=\"排序顺序的下界\"><a href=\"#排序顺序的下界\" class=\"headerlink\" title=\"排序顺序的下界\"></a>排序顺序的下界</h2><p>在一个比较排序中，我们只使用元素间的比较来获得输入序列 <code>&lt;a1, a2, ..., an&gt;</code> 中的元素间次序的信息。也就是给定两个元素 <code>ai</code> 和 <code>aj</code>，我们执行比较操作来确定它们之间的相对次序。</p>\n<h3 id=\"决策树模型\"><a href=\"#决策树模型\" class=\"headerlink\" title=\"决策树模型\"></a>决策树模型</h3><p>比较排序可以被抽象为一颗决策树。</p>\n<p>决策树是一颗<strong>完全二叉树</strong>，它可以表示在给定输入规模情况下，某一特定排序算法对所有元素的比较操作。其中，控制、数据移动等其他操作都被忽略了。</p>\n<p>在决策树中，每个内部结点都以 <code>i : j</code> 标记，其中，<code>i</code> 和 <code>j</code> 满足 <code>1 &lt;= i &lt;= j &lt;= n</code>，<code>n</code> 是输入序列中的元素个数。每个叶结点上都标注一个序列 <code>&lt;π(1), π(2), ..., π(n)</code>。</p>\n<p>排序算法的执行对应于一条从树的根结点到叶结点的路径。每一个内部结点表示比较一次 <code>ai</code> 和 <code>aj</code>。</p>\n<p>每当到达一个叶结点的时候，代表排序算法已经确定了一个顺序。对于一个正确的比较排序算法来说，<code>n</code> 个元素的 <code>n!</code> 种可能的排列都应该出现在决策树的叶结点上。而且，每一个叶结点都必须是可以从根结点经由某条路径到达的，该路径对应于比较排序的一次实际执行过程（我们称这种叶结点为“可达的”）。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-8/01.png\" alt=\"\"></p>\n<p>如上图，这是一颗作用于三个元素的插入排序决策树。根节点表示第一个元素和第二个元素进行了比较，当第一个元素小于等于第二个元素时，进入根节点的左孩子，将第二个元素和第三个元素进行比较，以此类推。最后，如果第三个孩子小于第一个孩子小于第二个孩子，则排序结果是 <code>&lt;3, 1, 2&gt;</code>。</p>\n<h3 id=\"最坏情况的下界\"><a href=\"#最坏情况的下界\" class=\"headerlink\" title=\"最坏情况的下界\"></a>最坏情况的下界</h3><p>对于一颗每个排列都是一个可达叶结点的决策树来说，树的高度完全可以被确定。考虑一颗高度为 <code>h</code>，具有 <code>l</code> 个可达叶结点的决策树，它对应一个对 <code>n</code> 个元素所做的比较排序。</p>\n<p>因为输入数据的 <code>n!</code> 种可能的排列都是叶结点，所以有 <code>n! &lt;= l</code>。</p>\n<p>由于在一棵高度为 <code>h</code> 的二叉树中，叶结点的数目不多于 <code>2^h</code>，所以有 <code>l &lt;= 2^h</code>。</p>\n<p>我们即得到 <code>n! &lt;= l &lt;= 2^h</code>。</p>\n<p>两边取对数，有</p>\n<blockquote>\n<p>h &gt;= lg(n!) = Ω(nlgn)</p>\n</blockquote>\n<p>我们即得到定理：<em>在最坏情况下，任何比较排序算法都需要做 Ω(nlgn) 次比较</em></p>\n<h2 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h2><p>上面说完比较排序的最坏下界，我们现在开始讨论线性时间复杂度的排序算法。</p>\n<p><strong>计数排序假设 <code>n</code> 个输入元素中的每一个都是在 <code>0</code> 到 <code>k</code> 区间内的一个整数，其中 <code>k</code> 为某个整数</strong>。当 <code>k = O(n)</code> 时，排序的运行时间为 <code>Θ(n)</code>。</p>\n<h3 id=\"思想\"><a href=\"#思想\" class=\"headerlink\" title=\"思想\"></a>思想</h3><p>计数排序的思想是：对每一个输入元素 <code>x</code>，确定小于 <code>x</code> 的元素个数。这样，当需要排序元素 <code>x</code> 时，只需把 <code>x</code> 直接放到它在输出数组中的位置了。</p>\n<p>比如如果有 <code>17</code> 个元素小于 <code>x</code>，则 <code>x</code> 应该被放到第十八个输出位置上。当有几个元素相同时，这一方案要略作修改，因为不能把它们放到同一个位置。</p>\n<h3 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h3><p>在计数排序的算法中，假设输入是一个数组 <code>A[1 .. n]</code>，<code>A.length = n</code>。我们还需要两个数组：<code>B[1 .. n]</code> 存放输出数组， <code>C[0 .. k]</code> 存放个数信息。</p>\n<p><em>COUNTING-SORT(A, B, k)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">// C 数组长度为输入数组的最大值</div><div class=\"line\">let C[0 .. k] be a new array</div><div class=\"line\">// 将 C 数组的元素全部赋值为 0</div><div class=\"line\">for i = 0 to k</div><div class=\"line\">  C[i] = 0</div><div class=\"line\">// 遍历输入数组，并将 C 元素中对应的值个数加一</div><div class=\"line\">for j = 1 to A.length</div><div class=\"line\">  C[A[j]] = C[A[j]] + 1</div><div class=\"line\">// 此时 C 数组中存放的是下标在输入数组中的个数</div><div class=\"line\">// C[i] now contains the number of elements equal to i</div><div class=\"line\">// 遍历 C 数组，将个数转变为小于等于下标的个数</div><div class=\"line\">for i = 1 to k</div><div class=\"line\">  C[i] = C[i] + C[i - 1]</div><div class=\"line\">// C[i] now contains the number of elements less than or equal to i</div><div class=\"line\">// 将输入数组中的元素放入输出数组中对应的位置</div><div class=\"line\">for j = A.length downto 1</div><div class=\"line\">  B[C[A[j]]] = A[j]</div><div class=\"line\">  C[A[j]] = C[A[j]] - 1</div></pre></td></tr></table></figure></p>\n<h3 id=\"排序过程\"><a href=\"#排序过程\" class=\"headerlink\" title=\"排序过程\"></a>排序过程</h3><p>假设数组 <code>A</code> 元素为：<code>2, 5, 3, 0, 2, 3, 0, 3</code></p>\n<p>1) 因为输入数组最大元素为 <code>5</code>，所以初始化 <code>C</code> 数组长度为 <code>5</code>。</p>\n<p>2) 遍历 <code>A</code> 数组，将 <code>C</code> 数组中下标为遍历到的元素大小的元素加 1。</p>\n<p>3) 步骤 2 结束后 <code>C</code> 数组元素为：<code>2, 0, 2, 3, 0, 1</code>，代表 <code>A</code> 数组中 <code>0</code> 个数为 <code>2</code>，’1’ 个数为 <code>0</code>，以此类推。</p>\n<p>4) 遍历 <code>C</code> 数组，将元素大小置为当前元素大小加前一元素大小。</p>\n<p>5) 步骤 4 结束后，<code>C</code> 数组元素为：<code>2, 2, 4, 7, 7, 8</code>，代表 <code>A</code> 数组中小于等于 <code>0</code> 个数为 <code>2</code>，小于等于 ‘1’ 个数为 <code>2</code>，小于等于 ‘2’ 个数为 <code>4</code>，以此类推。</p>\n<p>6) 遍历 <code>A</code> 数组，利用 <code>C</code> 数组中的信息将元素放置到对应的位置，需要注意每放置完一个元素需要将对应的小于等于个数减一。</p>\n<p>计数排序的总时间代价是 <code>Θ(k + n)</code>，当 <code>k = O(n)</code> 时，我们一般采用计数排序，此时运行时间为 <code>Θ(n)</code>。</p>\n<p>计数排序的另一个重要性质是它是<strong>稳定的</strong>：具有相同大小的元素，在输入数组中先出现的，在输出数组中也位于前面。</p>\n<h3 id=\"javascript-实现\"><a href=\"#javascript-实现\" class=\"headerlink\" title=\"javascript 实现\"></a>javascript 实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">unction countingSort(arr, k) &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> B = [], C = [<span class=\"number\">0</span>];</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; k; i++, C[i] = <span class=\"number\">0</span>) &#123;<span class=\"comment\">/*empty*/</span>&#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</div><div class=\"line\">    C[arr[i]] = C[arr[i]] + <span class=\"number\">1</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; C.length; i++) &#123;</div><div class=\"line\">    C[i] = C[i] + C[i - <span class=\"number\">1</span>];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = arr.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</div><div class=\"line\">    <span class=\"comment\">// -1 是因为小于等于该元素的个数包括该元素</span></div><div class=\"line\">    B[C[arr[i]] - <span class=\"number\">1</span>] = arr[i];</div><div class=\"line\">    C[arr[i]] = C[arr[i]] - <span class=\"number\">1</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> B;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>];</div><div class=\"line\">countingSort(arr, <span class=\"number\">5</span>); <span class=\"comment\">// [0, 0, 2, 2, 3, 3, 3, 5]</span></div></pre></td></tr></table></figure>\n<h2 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h2><p>基数排序用于排序 <code>n</code> 个 <code>d</code> 位数，先按最低有效位进行排序，然后按次低有效位，直到对所有的 <code>d</code> 位数都进行了排序。</p>\n<p>基数排序的代码是非常直观的，假设 <code>n</code> 个 <code>d</code> 位的元素存放在数组 <code>A</code> 中，其中第 <code>1</code> 位是最低位，第 <code>d</code> 位是最高位。如果我们希望元素排序完之后顺序不会被改变，那么在排序有效位过程中需要使用一种稳定的排序算法。</p>\n<p><em>RADIX-SORT(A, d)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">for i = 1 to d</div><div class=\"line\">  use a stable sort to sort array A on digit d</div></pre></td></tr></table></figure></p>\n<p>以 8 个 3 位数举例，排序过程如下：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-8/02.jpg\" alt=\"\"></p>\n<p>对于 <code>n</code> 个 <code>d</code> 位数，其中每一个数位有 k 个可能的取值。如果 <code>RADIX-SORT</code> 使用的稳定排序方法耗时 <code>Θ(n + k)</code>，那么它就可以在 <code>Θ(d(n + k))</code> 时间内将这些数排好序。</p>\n<h2 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h2><p>桶排序假设输入数据服从均匀分布，平均情况下它的时间代价为 <code>O(n)</code>。</p>\n<p>桶排序将 <code>[0, 1)</code> 划分为 <code>n</code> 个相同大小的子区间，称为桶。然后，将 n 个输入数分别放到桶中，因为输入数据是均匀、独立地分布在 <code>[0, 1)</code> 上，所以一般不会出现很多数落在同一个桶中的情况。为了得到输出结果，我们先对每个桶中的数进行排序，然后遍历每个桶，按照次序把各个桶中的元素列出来即可。</p>\n<p>算法需要一个临时数组 <code>B[0 .. n-1]</code> 来存放链表（即桶），并假设存在一种用于维护这些链表的机制。</p>\n<h3 id=\"排序过程-1\"><a href=\"#排序过程-1\" class=\"headerlink\" title=\"排序过程\"></a>排序过程</h3><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-8/03.jpg\" alt=\"\"></p>\n","excerpt":"<p>在前面几章总共介绍了<em>插入排序、归并排序、堆排序和快速排序</em>，这些算法都有一个有趣的性质：<strong>在排序的最终结果中，各元素的次序依赖于它们之间的比较</strong>。我们把这类排序算法成为比较排序。</p>\n<p>接下来讨论三种线性时间复杂度的排序算法：计数排序、基数排序和桶排序，它们使用运算而不是比较来确定排序顺序。</p>","more":"<h2 id=\"排序顺序的下界\"><a href=\"#排序顺序的下界\" class=\"headerlink\" title=\"排序顺序的下界\"></a>排序顺序的下界</h2><p>在一个比较排序中，我们只使用元素间的比较来获得输入序列 <code>&lt;a1, a2, ..., an&gt;</code> 中的元素间次序的信息。也就是给定两个元素 <code>ai</code> 和 <code>aj</code>，我们执行比较操作来确定它们之间的相对次序。</p>\n<h3 id=\"决策树模型\"><a href=\"#决策树模型\" class=\"headerlink\" title=\"决策树模型\"></a>决策树模型</h3><p>比较排序可以被抽象为一颗决策树。</p>\n<p>决策树是一颗<strong>完全二叉树</strong>，它可以表示在给定输入规模情况下，某一特定排序算法对所有元素的比较操作。其中，控制、数据移动等其他操作都被忽略了。</p>\n<p>在决策树中，每个内部结点都以 <code>i : j</code> 标记，其中，<code>i</code> 和 <code>j</code> 满足 <code>1 &lt;= i &lt;= j &lt;= n</code>，<code>n</code> 是输入序列中的元素个数。每个叶结点上都标注一个序列 <code>&lt;π(1), π(2), ..., π(n)</code>。</p>\n<p>排序算法的执行对应于一条从树的根结点到叶结点的路径。每一个内部结点表示比较一次 <code>ai</code> 和 <code>aj</code>。</p>\n<p>每当到达一个叶结点的时候，代表排序算法已经确定了一个顺序。对于一个正确的比较排序算法来说，<code>n</code> 个元素的 <code>n!</code> 种可能的排列都应该出现在决策树的叶结点上。而且，每一个叶结点都必须是可以从根结点经由某条路径到达的，该路径对应于比较排序的一次实际执行过程（我们称这种叶结点为“可达的”）。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-8/01.png\" alt=\"\"></p>\n<p>如上图，这是一颗作用于三个元素的插入排序决策树。根节点表示第一个元素和第二个元素进行了比较，当第一个元素小于等于第二个元素时，进入根节点的左孩子，将第二个元素和第三个元素进行比较，以此类推。最后，如果第三个孩子小于第一个孩子小于第二个孩子，则排序结果是 <code>&lt;3, 1, 2&gt;</code>。</p>\n<h3 id=\"最坏情况的下界\"><a href=\"#最坏情况的下界\" class=\"headerlink\" title=\"最坏情况的下界\"></a>最坏情况的下界</h3><p>对于一颗每个排列都是一个可达叶结点的决策树来说，树的高度完全可以被确定。考虑一颗高度为 <code>h</code>，具有 <code>l</code> 个可达叶结点的决策树，它对应一个对 <code>n</code> 个元素所做的比较排序。</p>\n<p>因为输入数据的 <code>n!</code> 种可能的排列都是叶结点，所以有 <code>n! &lt;= l</code>。</p>\n<p>由于在一棵高度为 <code>h</code> 的二叉树中，叶结点的数目不多于 <code>2^h</code>，所以有 <code>l &lt;= 2^h</code>。</p>\n<p>我们即得到 <code>n! &lt;= l &lt;= 2^h</code>。</p>\n<p>两边取对数，有</p>\n<blockquote>\n<p>h &gt;= lg(n!) = Ω(nlgn)</p>\n</blockquote>\n<p>我们即得到定理：<em>在最坏情况下，任何比较排序算法都需要做 Ω(nlgn) 次比较</em></p>\n<h2 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h2><p>上面说完比较排序的最坏下界，我们现在开始讨论线性时间复杂度的排序算法。</p>\n<p><strong>计数排序假设 <code>n</code> 个输入元素中的每一个都是在 <code>0</code> 到 <code>k</code> 区间内的一个整数，其中 <code>k</code> 为某个整数</strong>。当 <code>k = O(n)</code> 时，排序的运行时间为 <code>Θ(n)</code>。</p>\n<h3 id=\"思想\"><a href=\"#思想\" class=\"headerlink\" title=\"思想\"></a>思想</h3><p>计数排序的思想是：对每一个输入元素 <code>x</code>，确定小于 <code>x</code> 的元素个数。这样，当需要排序元素 <code>x</code> 时，只需把 <code>x</code> 直接放到它在输出数组中的位置了。</p>\n<p>比如如果有 <code>17</code> 个元素小于 <code>x</code>，则 <code>x</code> 应该被放到第十八个输出位置上。当有几个元素相同时，这一方案要略作修改，因为不能把它们放到同一个位置。</p>\n<h3 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h3><p>在计数排序的算法中，假设输入是一个数组 <code>A[1 .. n]</code>，<code>A.length = n</code>。我们还需要两个数组：<code>B[1 .. n]</code> 存放输出数组， <code>C[0 .. k]</code> 存放个数信息。</p>\n<p><em>COUNTING-SORT(A, B, k)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">// C 数组长度为输入数组的最大值</div><div class=\"line\">let C[0 .. k] be a new array</div><div class=\"line\">// 将 C 数组的元素全部赋值为 0</div><div class=\"line\">for i = 0 to k</div><div class=\"line\">  C[i] = 0</div><div class=\"line\">// 遍历输入数组，并将 C 元素中对应的值个数加一</div><div class=\"line\">for j = 1 to A.length</div><div class=\"line\">  C[A[j]] = C[A[j]] + 1</div><div class=\"line\">// 此时 C 数组中存放的是下标在输入数组中的个数</div><div class=\"line\">// C[i] now contains the number of elements equal to i</div><div class=\"line\">// 遍历 C 数组，将个数转变为小于等于下标的个数</div><div class=\"line\">for i = 1 to k</div><div class=\"line\">  C[i] = C[i] + C[i - 1]</div><div class=\"line\">// C[i] now contains the number of elements less than or equal to i</div><div class=\"line\">// 将输入数组中的元素放入输出数组中对应的位置</div><div class=\"line\">for j = A.length downto 1</div><div class=\"line\">  B[C[A[j]]] = A[j]</div><div class=\"line\">  C[A[j]] = C[A[j]] - 1</div></pre></td></tr></table></figure></p>\n<h3 id=\"排序过程\"><a href=\"#排序过程\" class=\"headerlink\" title=\"排序过程\"></a>排序过程</h3><p>假设数组 <code>A</code> 元素为：<code>2, 5, 3, 0, 2, 3, 0, 3</code></p>\n<p>1) 因为输入数组最大元素为 <code>5</code>，所以初始化 <code>C</code> 数组长度为 <code>5</code>。</p>\n<p>2) 遍历 <code>A</code> 数组，将 <code>C</code> 数组中下标为遍历到的元素大小的元素加 1。</p>\n<p>3) 步骤 2 结束后 <code>C</code> 数组元素为：<code>2, 0, 2, 3, 0, 1</code>，代表 <code>A</code> 数组中 <code>0</code> 个数为 <code>2</code>，’1’ 个数为 <code>0</code>，以此类推。</p>\n<p>4) 遍历 <code>C</code> 数组，将元素大小置为当前元素大小加前一元素大小。</p>\n<p>5) 步骤 4 结束后，<code>C</code> 数组元素为：<code>2, 2, 4, 7, 7, 8</code>，代表 <code>A</code> 数组中小于等于 <code>0</code> 个数为 <code>2</code>，小于等于 ‘1’ 个数为 <code>2</code>，小于等于 ‘2’ 个数为 <code>4</code>，以此类推。</p>\n<p>6) 遍历 <code>A</code> 数组，利用 <code>C</code> 数组中的信息将元素放置到对应的位置，需要注意每放置完一个元素需要将对应的小于等于个数减一。</p>\n<p>计数排序的总时间代价是 <code>Θ(k + n)</code>，当 <code>k = O(n)</code> 时，我们一般采用计数排序，此时运行时间为 <code>Θ(n)</code>。</p>\n<p>计数排序的另一个重要性质是它是<strong>稳定的</strong>：具有相同大小的元素，在输入数组中先出现的，在输出数组中也位于前面。</p>\n<h3 id=\"javascript-实现\"><a href=\"#javascript-实现\" class=\"headerlink\" title=\"javascript 实现\"></a>javascript 实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">unction countingSort(arr, k) &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> B = [], C = [<span class=\"number\">0</span>];</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; k; i++, C[i] = <span class=\"number\">0</span>) &#123;<span class=\"comment\">/*empty*/</span>&#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</div><div class=\"line\">    C[arr[i]] = C[arr[i]] + <span class=\"number\">1</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; C.length; i++) &#123;</div><div class=\"line\">    C[i] = C[i] + C[i - <span class=\"number\">1</span>];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = arr.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</div><div class=\"line\">    <span class=\"comment\">// -1 是因为小于等于该元素的个数包括该元素</span></div><div class=\"line\">    B[C[arr[i]] - <span class=\"number\">1</span>] = arr[i];</div><div class=\"line\">    C[arr[i]] = C[arr[i]] - <span class=\"number\">1</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> B;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>];</div><div class=\"line\">countingSort(arr, <span class=\"number\">5</span>); <span class=\"comment\">// [0, 0, 2, 2, 3, 3, 3, 5]</span></div></pre></td></tr></table></figure>\n<h2 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h2><p>基数排序用于排序 <code>n</code> 个 <code>d</code> 位数，先按最低有效位进行排序，然后按次低有效位，直到对所有的 <code>d</code> 位数都进行了排序。</p>\n<p>基数排序的代码是非常直观的，假设 <code>n</code> 个 <code>d</code> 位的元素存放在数组 <code>A</code> 中，其中第 <code>1</code> 位是最低位，第 <code>d</code> 位是最高位。如果我们希望元素排序完之后顺序不会被改变，那么在排序有效位过程中需要使用一种稳定的排序算法。</p>\n<p><em>RADIX-SORT(A, d)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">for i = 1 to d</div><div class=\"line\">  use a stable sort to sort array A on digit d</div></pre></td></tr></table></figure></p>\n<p>以 8 个 3 位数举例，排序过程如下：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-8/02.jpg\" alt=\"\"></p>\n<p>对于 <code>n</code> 个 <code>d</code> 位数，其中每一个数位有 k 个可能的取值。如果 <code>RADIX-SORT</code> 使用的稳定排序方法耗时 <code>Θ(n + k)</code>，那么它就可以在 <code>Θ(d(n + k))</code> 时间内将这些数排好序。</p>\n<h2 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h2><p>桶排序假设输入数据服从均匀分布，平均情况下它的时间代价为 <code>O(n)</code>。</p>\n<p>桶排序将 <code>[0, 1)</code> 划分为 <code>n</code> 个相同大小的子区间，称为桶。然后，将 n 个输入数分别放到桶中，因为输入数据是均匀、独立地分布在 <code>[0, 1)</code> 上，所以一般不会出现很多数落在同一个桶中的情况。为了得到输出结果，我们先对每个桶中的数进行排序，然后遍历每个桶，按照次序把各个桶中的元素列出来即可。</p>\n<p>算法需要一个临时数组 <code>B[0 .. n-1]</code> 来存放链表（即桶），并假设存在一种用于维护这些链表的机制。</p>\n<h3 id=\"排序过程-1\"><a href=\"#排序过程-1\" class=\"headerlink\" title=\"排序过程\"></a>排序过程</h3><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-8/03.jpg\" alt=\"\"></p>"},{"title":"二项分布、泊松分布、正态分布","date":"2017-01-22T14:28:45.000Z","_content":"\n**二项分布、泊松分布和正态分布** 是统计学中十分重要的三个分布，也和我们的生活息息相关。\n\n<!--more-->\n\n## 二项分布\n\n> 二项分布是 n 个独立的是/非试验中成功的次数的离散概率分布，其中每次试验的成功概率为 p\n\n二项分布比较简单也比较常见，在此不作详细说明。\n\n如给定一枚均匀的硬币，掷到正面的概率 p 和掷到反面的概率 1 - p 都是 0.5。设 X 为掷 n 次硬币中出现正面硬币的个数，那么\n$$\nP(X = k) = \\binom{n}{k}p^k(1-p)^{n-k}\n$$\n\n其中，对于$k = 0, 1, 2, ... n$，$\\binom{n}{k} = \\frac{n!}{(n-k)!k!}$\n\n### 期望\n\n期望是指试验中每次可能结果的概率乘以其结果的总和，对于二项分布而言，期望 $E(X) = \\sum_{k=0}^nk\\binom{n}{k}p^k(1-p)^{n-k}$\n\n而当 k = 0 时，$0 \\times \\binom{n}{0}p^0(1-p)^n = 0$，所以可以把第一项省略，于是\n\n$$\n\\begin{align}\nE(X) & = \\sum\\_{k=1}^nk\\binom{n}{k}p^k(1-p)^{n-k} \\\\\\\n& = \\sum\\_{k=1}^nk\\frac{n!}{k!(n-k)!}p^k(1-p)^{n-k} \\\\\\\n& = \\sum\\_{k=1}^n\\frac{n!}{(k-1)!(n-k)!}pp^{k-1}(1-p)^{n-k} \\\\\\\n& = np\\sum\\_{k=1}^n\\frac{(n-1)!}{(k-1)!(n-k)!}p^{k-1}(1-p)^{n-k} \\\\\\\n\\end{align}\n$$\n\n令 a = k - 1，b = n - 1，则 n - k = b - a。从 k = 1 到 n 则可以替换为 a = 0 到  n - 1，即 a = 0 到 b\n\n$$\n\\begin{align}\n& = np\\sum\\_{a=0}^b\\frac{b!}{a!(b-a)!}p^a(1-p)^{b-a} \\\\\\\n& = np \\times 1 \\\\\\\n& = np\n\\end{align}\n$$\n\n即 $E(X) = np$\n\n## 泊松分布\n\n> 在二项分布中，如果试验次数 n 很大，二项分布的概率 p 很小，且乘积 $\\lambda = np$ 比较适中，则事件出现的次数的概率可以用泊松分布来逼近。事实上，二项分布可以看作泊松分布在离散时间上的对应物。\n\n假设你是一名交通工程师，你测出了每小时通过大桥的车辆为 $\\lambda$ 辆，现在想知道每小时通过大桥的车是 k 辆的概率。\n\n根据测量，实际上可以得出每分钟通过的车辆数，也就是 $\\frac{\\lambda}{60}$，事实上这可以看做 **每分钟有车通过的概率**\n\n要想求出每小时通过大桥车辆数为 k 的概率 $P(X=k)$，利用上面讨论的二项分布，即有\n\n$$\nP(X=k) = \\binom{60}{k}(\\frac{\\lambda}{60})^k(1 - \\frac{\\lambda}{60})^{60-k}\n$$\n\n这也有个问题，倘若每分钟有多辆车通过呢？一旦 k 超过 60，计算就有问题了，那么可以将 “每分钟” 换成 “每秒”，减少时间间隔。\n\n$$\nP(X=k) = \\binom{3600}{k}(\\frac{\\lambda}{3600})^k(1 - \\frac{\\lambda}{3600})^{3600-k}\n$$\n\n当时间间隔越小，小到无限小的时候，可以引出泊松分布的形式：\n\n$$\nP(X=k) = \\lim\\_{n \\to \\infty}\\binom{n}{k}(\\frac{\\lambda}{n})^k(1 - \\frac{\\lambda}{n})^{n-k}\n$$\n\n时间间隔无限小，也就是 n 趋近于正无穷。\n\n$$\n\\begin{align}\nP(X=k) & = \\lim\\_{n \\to \\infty}\\binom{n}{k}(\\frac{\\lambda}{n})^k(1 - \\frac{\\lambda}{n})^{n-k} \\\\\\\n& = \\lim\\_{n \\to \\infty}\\frac{n!}{k!(n-k)!}\\frac{\\lambda^k}{n^k}(1 - \\frac{\\lambda}{n})^{n}(1 - \\frac{\\lambda}{n})^{-k} \\\\\\\n& = \\lim\\_{n \\to \\infty}\\frac{n(n-1)(n-2)\\cdots(n-k+1)}{n^k}\\frac{\\lambda^k}{k!}(1 - \\frac{\\lambda}{n})^{n}(1 - \\frac{\\lambda}{n})^{-k}\n\\end{align}\n$$\n\n\n而 $\\lim\\_{n \\to \\infty}\\frac{n(n-1)(n-2)\\cdots(n-k+1)}{n^k} = 1，\n\\lim\\_{n \\to \\infty}(1 - \\frac{\\lambda}{n})^n = e^{-\\lambda}，\n\\lim\\_{n \\to \\infty}(1 - \\frac{\\lambda}{n})^{-k} = 1$\n\n所以，\n$$\n\\begin{align}\nP(X=k) & = 1 \\times \\frac{\\lambda^k}{k!} e^{-\\lambda} \\times 1 \\\\\\\n& = \\frac{\\lambda^k}{k!} e^{-\\lambda}\n\\end{align}\n$$\n\n## 正态分布\n\n正态分布又名高斯分布，其概率密度函数为\n\n$$\nP(X) = \\frac{1}{\\sigma\\sqrt{2\\pi}}e^{-\\frac{1}{2}(\\frac{x-\\mu}{\\sigma})^2}\n$$\n\n其中 $\\mu$ 为期望值，$\\sigma$ 为标准差，之前也提到过。\n\n另外，$\\frac{x-\\mu}{\\sigma}$ 称为标准分数（z-score），代表 **距离平均数有多少个标准差**。\n\n### 经验法则\n\n经验法则又名 68-95-99.7 法则，表明了几个特殊区间的概率值。\n\n$(\\mu - \\sigma, \\mu + \\sigma)$ 发生的概率为 68%\n$(\\mu - 2\\sigma, \\mu + 2\\sigma)$ 发生的概率为 95%\n$(\\mu - 3\\sigma, \\mu + 3\\sigma)$ 发生的概率为 99.7%\n\n## 结语\n\n需要注意的是二项分布和泊松分布都是离散分布，正态分布为连续分布。这三者存在紧密的联系，从图像上来看三者也是非常接近。\n\n如果二项分布的实验次数 n 很大而每次试验的成功概率 p 很小时，泊松分布可作为二项分布的极限近似。当实验次数 n 再变大，几乎可以看成连续时，二项分布和泊松分布都可以用正态分布来代替。","source":"_posts/binomial-and-poisson-and-normal-distribution.md","raw":"---\ntitle: 二项分布、泊松分布、正态分布\ndate: 2017-01-22 22:28:45\ntags: [统计学]\n---\n\n**二项分布、泊松分布和正态分布** 是统计学中十分重要的三个分布，也和我们的生活息息相关。\n\n<!--more-->\n\n## 二项分布\n\n> 二项分布是 n 个独立的是/非试验中成功的次数的离散概率分布，其中每次试验的成功概率为 p\n\n二项分布比较简单也比较常见，在此不作详细说明。\n\n如给定一枚均匀的硬币，掷到正面的概率 p 和掷到反面的概率 1 - p 都是 0.5。设 X 为掷 n 次硬币中出现正面硬币的个数，那么\n$$\nP(X = k) = \\binom{n}{k}p^k(1-p)^{n-k}\n$$\n\n其中，对于$k = 0, 1, 2, ... n$，$\\binom{n}{k} = \\frac{n!}{(n-k)!k!}$\n\n### 期望\n\n期望是指试验中每次可能结果的概率乘以其结果的总和，对于二项分布而言，期望 $E(X) = \\sum_{k=0}^nk\\binom{n}{k}p^k(1-p)^{n-k}$\n\n而当 k = 0 时，$0 \\times \\binom{n}{0}p^0(1-p)^n = 0$，所以可以把第一项省略，于是\n\n$$\n\\begin{align}\nE(X) & = \\sum\\_{k=1}^nk\\binom{n}{k}p^k(1-p)^{n-k} \\\\\\\n& = \\sum\\_{k=1}^nk\\frac{n!}{k!(n-k)!}p^k(1-p)^{n-k} \\\\\\\n& = \\sum\\_{k=1}^n\\frac{n!}{(k-1)!(n-k)!}pp^{k-1}(1-p)^{n-k} \\\\\\\n& = np\\sum\\_{k=1}^n\\frac{(n-1)!}{(k-1)!(n-k)!}p^{k-1}(1-p)^{n-k} \\\\\\\n\\end{align}\n$$\n\n令 a = k - 1，b = n - 1，则 n - k = b - a。从 k = 1 到 n 则可以替换为 a = 0 到  n - 1，即 a = 0 到 b\n\n$$\n\\begin{align}\n& = np\\sum\\_{a=0}^b\\frac{b!}{a!(b-a)!}p^a(1-p)^{b-a} \\\\\\\n& = np \\times 1 \\\\\\\n& = np\n\\end{align}\n$$\n\n即 $E(X) = np$\n\n## 泊松分布\n\n> 在二项分布中，如果试验次数 n 很大，二项分布的概率 p 很小，且乘积 $\\lambda = np$ 比较适中，则事件出现的次数的概率可以用泊松分布来逼近。事实上，二项分布可以看作泊松分布在离散时间上的对应物。\n\n假设你是一名交通工程师，你测出了每小时通过大桥的车辆为 $\\lambda$ 辆，现在想知道每小时通过大桥的车是 k 辆的概率。\n\n根据测量，实际上可以得出每分钟通过的车辆数，也就是 $\\frac{\\lambda}{60}$，事实上这可以看做 **每分钟有车通过的概率**\n\n要想求出每小时通过大桥车辆数为 k 的概率 $P(X=k)$，利用上面讨论的二项分布，即有\n\n$$\nP(X=k) = \\binom{60}{k}(\\frac{\\lambda}{60})^k(1 - \\frac{\\lambda}{60})^{60-k}\n$$\n\n这也有个问题，倘若每分钟有多辆车通过呢？一旦 k 超过 60，计算就有问题了，那么可以将 “每分钟” 换成 “每秒”，减少时间间隔。\n\n$$\nP(X=k) = \\binom{3600}{k}(\\frac{\\lambda}{3600})^k(1 - \\frac{\\lambda}{3600})^{3600-k}\n$$\n\n当时间间隔越小，小到无限小的时候，可以引出泊松分布的形式：\n\n$$\nP(X=k) = \\lim\\_{n \\to \\infty}\\binom{n}{k}(\\frac{\\lambda}{n})^k(1 - \\frac{\\lambda}{n})^{n-k}\n$$\n\n时间间隔无限小，也就是 n 趋近于正无穷。\n\n$$\n\\begin{align}\nP(X=k) & = \\lim\\_{n \\to \\infty}\\binom{n}{k}(\\frac{\\lambda}{n})^k(1 - \\frac{\\lambda}{n})^{n-k} \\\\\\\n& = \\lim\\_{n \\to \\infty}\\frac{n!}{k!(n-k)!}\\frac{\\lambda^k}{n^k}(1 - \\frac{\\lambda}{n})^{n}(1 - \\frac{\\lambda}{n})^{-k} \\\\\\\n& = \\lim\\_{n \\to \\infty}\\frac{n(n-1)(n-2)\\cdots(n-k+1)}{n^k}\\frac{\\lambda^k}{k!}(1 - \\frac{\\lambda}{n})^{n}(1 - \\frac{\\lambda}{n})^{-k}\n\\end{align}\n$$\n\n\n而 $\\lim\\_{n \\to \\infty}\\frac{n(n-1)(n-2)\\cdots(n-k+1)}{n^k} = 1，\n\\lim\\_{n \\to \\infty}(1 - \\frac{\\lambda}{n})^n = e^{-\\lambda}，\n\\lim\\_{n \\to \\infty}(1 - \\frac{\\lambda}{n})^{-k} = 1$\n\n所以，\n$$\n\\begin{align}\nP(X=k) & = 1 \\times \\frac{\\lambda^k}{k!} e^{-\\lambda} \\times 1 \\\\\\\n& = \\frac{\\lambda^k}{k!} e^{-\\lambda}\n\\end{align}\n$$\n\n## 正态分布\n\n正态分布又名高斯分布，其概率密度函数为\n\n$$\nP(X) = \\frac{1}{\\sigma\\sqrt{2\\pi}}e^{-\\frac{1}{2}(\\frac{x-\\mu}{\\sigma})^2}\n$$\n\n其中 $\\mu$ 为期望值，$\\sigma$ 为标准差，之前也提到过。\n\n另外，$\\frac{x-\\mu}{\\sigma}$ 称为标准分数（z-score），代表 **距离平均数有多少个标准差**。\n\n### 经验法则\n\n经验法则又名 68-95-99.7 法则，表明了几个特殊区间的概率值。\n\n$(\\mu - \\sigma, \\mu + \\sigma)$ 发生的概率为 68%\n$(\\mu - 2\\sigma, \\mu + 2\\sigma)$ 发生的概率为 95%\n$(\\mu - 3\\sigma, \\mu + 3\\sigma)$ 发生的概率为 99.7%\n\n## 结语\n\n需要注意的是二项分布和泊松分布都是离散分布，正态分布为连续分布。这三者存在紧密的联系，从图像上来看三者也是非常接近。\n\n如果二项分布的实验次数 n 很大而每次试验的成功概率 p 很小时，泊松分布可作为二项分布的极限近似。当实验次数 n 再变大，几乎可以看成连续时，二项分布和泊松分布都可以用正态分布来代替。","slug":"binomial-and-poisson-and-normal-distribution","published":1,"updated":"2017-01-23T13:51:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcv2000en927y7q9itiu","content":"<p><strong>二项分布、泊松分布和正态分布</strong> 是统计学中十分重要的三个分布，也和我们的生活息息相关。</p>\n<a id=\"more\"></a>\n<h2 id=\"二项分布\"><a href=\"#二项分布\" class=\"headerlink\" title=\"二项分布\"></a>二项分布</h2><blockquote>\n<p>二项分布是 n 个独立的是/非试验中成功的次数的离散概率分布，其中每次试验的成功概率为 p</p>\n</blockquote>\n<p>二项分布比较简单也比较常见，在此不作详细说明。</p>\n<p>如给定一枚均匀的硬币，掷到正面的概率 p 和掷到反面的概率 1 - p 都是 0.5。设 X 为掷 n 次硬币中出现正面硬币的个数，那么<br>$$<br>P(X = k) = \\binom{n}{k}p^k(1-p)^{n-k}<br>$$</p>\n<p>其中，对于$k = 0, 1, 2, … n$，$\\binom{n}{k} = \\frac{n!}{(n-k)!k!}$</p>\n<h3 id=\"期望\"><a href=\"#期望\" class=\"headerlink\" title=\"期望\"></a>期望</h3><p>期望是指试验中每次可能结果的概率乘以其结果的总和，对于二项分布而言，期望 $E(X) = \\sum_{k=0}^nk\\binom{n}{k}p^k(1-p)^{n-k}$</p>\n<p>而当 k = 0 时，$0 \\times \\binom{n}{0}p^0(1-p)^n = 0$，所以可以把第一项省略，于是</p>\n<p>$$<br>\\begin{align}<br>E(X) &amp; = \\sum_{k=1}^nk\\binom{n}{k}p^k(1-p)^{n-k} \\\\<br>&amp; = \\sum_{k=1}^nk\\frac{n!}{k!(n-k)!}p^k(1-p)^{n-k} \\\\<br>&amp; = \\sum_{k=1}^n\\frac{n!}{(k-1)!(n-k)!}pp^{k-1}(1-p)^{n-k} \\\\<br>&amp; = np\\sum_{k=1}^n\\frac{(n-1)!}{(k-1)!(n-k)!}p^{k-1}(1-p)^{n-k} \\\\<br>\\end{align}<br>$$</p>\n<p>令 a = k - 1，b = n - 1，则 n - k = b - a。从 k = 1 到 n 则可以替换为 a = 0 到  n - 1，即 a = 0 到 b</p>\n<p>$$<br>\\begin{align}<br>&amp; = np\\sum_{a=0}^b\\frac{b!}{a!(b-a)!}p^a(1-p)^{b-a} \\\\<br>&amp; = np \\times 1 \\\\<br>&amp; = np<br>\\end{align}<br>$$</p>\n<p>即 $E(X) = np$</p>\n<h2 id=\"泊松分布\"><a href=\"#泊松分布\" class=\"headerlink\" title=\"泊松分布\"></a>泊松分布</h2><blockquote>\n<p>在二项分布中，如果试验次数 n 很大，二项分布的概率 p 很小，且乘积 $\\lambda = np$ 比较适中，则事件出现的次数的概率可以用泊松分布来逼近。事实上，二项分布可以看作泊松分布在离散时间上的对应物。</p>\n</blockquote>\n<p>假设你是一名交通工程师，你测出了每小时通过大桥的车辆为 $\\lambda$ 辆，现在想知道每小时通过大桥的车是 k 辆的概率。</p>\n<p>根据测量，实际上可以得出每分钟通过的车辆数，也就是 $\\frac{\\lambda}{60}$，事实上这可以看做 <strong>每分钟有车通过的概率</strong></p>\n<p>要想求出每小时通过大桥车辆数为 k 的概率 $P(X=k)$，利用上面讨论的二项分布，即有</p>\n<p>$$<br>P(X=k) = \\binom{60}{k}(\\frac{\\lambda}{60})^k(1 - \\frac{\\lambda}{60})^{60-k}<br>$$</p>\n<p>这也有个问题，倘若每分钟有多辆车通过呢？一旦 k 超过 60，计算就有问题了，那么可以将 “每分钟” 换成 “每秒”，减少时间间隔。</p>\n<p>$$<br>P(X=k) = \\binom{3600}{k}(\\frac{\\lambda}{3600})^k(1 - \\frac{\\lambda}{3600})^{3600-k}<br>$$</p>\n<p>当时间间隔越小，小到无限小的时候，可以引出泊松分布的形式：</p>\n<p>$$<br>P(X=k) = \\lim_{n \\to \\infty}\\binom{n}{k}(\\frac{\\lambda}{n})^k(1 - \\frac{\\lambda}{n})^{n-k}<br>$$</p>\n<p>时间间隔无限小，也就是 n 趋近于正无穷。</p>\n<p>$$<br>\\begin{align}<br>P(X=k) &amp; = \\lim_{n \\to \\infty}\\binom{n}{k}(\\frac{\\lambda}{n})^k(1 - \\frac{\\lambda}{n})^{n-k} \\\\<br>&amp; = \\lim_{n \\to \\infty}\\frac{n!}{k!(n-k)!}\\frac{\\lambda^k}{n^k}(1 - \\frac{\\lambda}{n})^{n}(1 - \\frac{\\lambda}{n})^{-k} \\\\<br>&amp; = \\lim_{n \\to \\infty}\\frac{n(n-1)(n-2)\\cdots(n-k+1)}{n^k}\\frac{\\lambda^k}{k!}(1 - \\frac{\\lambda}{n})^{n}(1 - \\frac{\\lambda}{n})^{-k}<br>\\end{align}<br>$$</p>\n<p>而 $\\lim_{n \\to \\infty}\\frac{n(n-1)(n-2)\\cdots(n-k+1)}{n^k} = 1，<br>\\lim_{n \\to \\infty}(1 - \\frac{\\lambda}{n})^n = e^{-\\lambda}，<br>\\lim_{n \\to \\infty}(1 - \\frac{\\lambda}{n})^{-k} = 1$</p>\n<p>所以，<br>$$<br>\\begin{align}<br>P(X=k) &amp; = 1 \\times \\frac{\\lambda^k}{k!} e^{-\\lambda} \\times 1 \\\\<br>&amp; = \\frac{\\lambda^k}{k!} e^{-\\lambda}<br>\\end{align}<br>$$</p>\n<h2 id=\"正态分布\"><a href=\"#正态分布\" class=\"headerlink\" title=\"正态分布\"></a>正态分布</h2><p>正态分布又名高斯分布，其概率密度函数为</p>\n<p>$$<br>P(X) = \\frac{1}{\\sigma\\sqrt{2\\pi}}e^{-\\frac{1}{2}(\\frac{x-\\mu}{\\sigma})^2}<br>$$</p>\n<p>其中 $\\mu$ 为期望值，$\\sigma$ 为标准差，之前也提到过。</p>\n<p>另外，$\\frac{x-\\mu}{\\sigma}$ 称为标准分数（z-score），代表 <strong>距离平均数有多少个标准差</strong>。</p>\n<h3 id=\"经验法则\"><a href=\"#经验法则\" class=\"headerlink\" title=\"经验法则\"></a>经验法则</h3><p>经验法则又名 68-95-99.7 法则，表明了几个特殊区间的概率值。</p>\n<p>$(\\mu - \\sigma, \\mu + \\sigma)$ 发生的概率为 68%<br>$(\\mu - 2\\sigma, \\mu + 2\\sigma)$ 发生的概率为 95%<br>$(\\mu - 3\\sigma, \\mu + 3\\sigma)$ 发生的概率为 99.7%</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>需要注意的是二项分布和泊松分布都是离散分布，正态分布为连续分布。这三者存在紧密的联系，从图像上来看三者也是非常接近。</p>\n<p>如果二项分布的实验次数 n 很大而每次试验的成功概率 p 很小时，泊松分布可作为二项分布的极限近似。当实验次数 n 再变大，几乎可以看成连续时，二项分布和泊松分布都可以用正态分布来代替。</p>\n","excerpt":"<p><strong>二项分布、泊松分布和正态分布</strong> 是统计学中十分重要的三个分布，也和我们的生活息息相关。</p>","more":"<h2 id=\"二项分布\"><a href=\"#二项分布\" class=\"headerlink\" title=\"二项分布\"></a>二项分布</h2><blockquote>\n<p>二项分布是 n 个独立的是/非试验中成功的次数的离散概率分布，其中每次试验的成功概率为 p</p>\n</blockquote>\n<p>二项分布比较简单也比较常见，在此不作详细说明。</p>\n<p>如给定一枚均匀的硬币，掷到正面的概率 p 和掷到反面的概率 1 - p 都是 0.5。设 X 为掷 n 次硬币中出现正面硬币的个数，那么<br>$$<br>P(X = k) = \\binom{n}{k}p^k(1-p)^{n-k}<br>$$</p>\n<p>其中，对于$k = 0, 1, 2, … n$，$\\binom{n}{k} = \\frac{n!}{(n-k)!k!}$</p>\n<h3 id=\"期望\"><a href=\"#期望\" class=\"headerlink\" title=\"期望\"></a>期望</h3><p>期望是指试验中每次可能结果的概率乘以其结果的总和，对于二项分布而言，期望 $E(X) = \\sum_{k=0}^nk\\binom{n}{k}p^k(1-p)^{n-k}$</p>\n<p>而当 k = 0 时，$0 \\times \\binom{n}{0}p^0(1-p)^n = 0$，所以可以把第一项省略，于是</p>\n<p>$$<br>\\begin{align}<br>E(X) &amp; = \\sum_{k=1}^nk\\binom{n}{k}p^k(1-p)^{n-k} \\\\<br>&amp; = \\sum_{k=1}^nk\\frac{n!}{k!(n-k)!}p^k(1-p)^{n-k} \\\\<br>&amp; = \\sum_{k=1}^n\\frac{n!}{(k-1)!(n-k)!}pp^{k-1}(1-p)^{n-k} \\\\<br>&amp; = np\\sum_{k=1}^n\\frac{(n-1)!}{(k-1)!(n-k)!}p^{k-1}(1-p)^{n-k} \\\\<br>\\end{align}<br>$$</p>\n<p>令 a = k - 1，b = n - 1，则 n - k = b - a。从 k = 1 到 n 则可以替换为 a = 0 到  n - 1，即 a = 0 到 b</p>\n<p>$$<br>\\begin{align}<br>&amp; = np\\sum_{a=0}^b\\frac{b!}{a!(b-a)!}p^a(1-p)^{b-a} \\\\<br>&amp; = np \\times 1 \\\\<br>&amp; = np<br>\\end{align}<br>$$</p>\n<p>即 $E(X) = np$</p>\n<h2 id=\"泊松分布\"><a href=\"#泊松分布\" class=\"headerlink\" title=\"泊松分布\"></a>泊松分布</h2><blockquote>\n<p>在二项分布中，如果试验次数 n 很大，二项分布的概率 p 很小，且乘积 $\\lambda = np$ 比较适中，则事件出现的次数的概率可以用泊松分布来逼近。事实上，二项分布可以看作泊松分布在离散时间上的对应物。</p>\n</blockquote>\n<p>假设你是一名交通工程师，你测出了每小时通过大桥的车辆为 $\\lambda$ 辆，现在想知道每小时通过大桥的车是 k 辆的概率。</p>\n<p>根据测量，实际上可以得出每分钟通过的车辆数，也就是 $\\frac{\\lambda}{60}$，事实上这可以看做 <strong>每分钟有车通过的概率</strong></p>\n<p>要想求出每小时通过大桥车辆数为 k 的概率 $P(X=k)$，利用上面讨论的二项分布，即有</p>\n<p>$$<br>P(X=k) = \\binom{60}{k}(\\frac{\\lambda}{60})^k(1 - \\frac{\\lambda}{60})^{60-k}<br>$$</p>\n<p>这也有个问题，倘若每分钟有多辆车通过呢？一旦 k 超过 60，计算就有问题了，那么可以将 “每分钟” 换成 “每秒”，减少时间间隔。</p>\n<p>$$<br>P(X=k) = \\binom{3600}{k}(\\frac{\\lambda}{3600})^k(1 - \\frac{\\lambda}{3600})^{3600-k}<br>$$</p>\n<p>当时间间隔越小，小到无限小的时候，可以引出泊松分布的形式：</p>\n<p>$$<br>P(X=k) = \\lim_{n \\to \\infty}\\binom{n}{k}(\\frac{\\lambda}{n})^k(1 - \\frac{\\lambda}{n})^{n-k}<br>$$</p>\n<p>时间间隔无限小，也就是 n 趋近于正无穷。</p>\n<p>$$<br>\\begin{align}<br>P(X=k) &amp; = \\lim_{n \\to \\infty}\\binom{n}{k}(\\frac{\\lambda}{n})^k(1 - \\frac{\\lambda}{n})^{n-k} \\\\<br>&amp; = \\lim_{n \\to \\infty}\\frac{n!}{k!(n-k)!}\\frac{\\lambda^k}{n^k}(1 - \\frac{\\lambda}{n})^{n}(1 - \\frac{\\lambda}{n})^{-k} \\\\<br>&amp; = \\lim_{n \\to \\infty}\\frac{n(n-1)(n-2)\\cdots(n-k+1)}{n^k}\\frac{\\lambda^k}{k!}(1 - \\frac{\\lambda}{n})^{n}(1 - \\frac{\\lambda}{n})^{-k}<br>\\end{align}<br>$$</p>\n<p>而 $\\lim_{n \\to \\infty}\\frac{n(n-1)(n-2)\\cdots(n-k+1)}{n^k} = 1，<br>\\lim_{n \\to \\infty}(1 - \\frac{\\lambda}{n})^n = e^{-\\lambda}，<br>\\lim_{n \\to \\infty}(1 - \\frac{\\lambda}{n})^{-k} = 1$</p>\n<p>所以，<br>$$<br>\\begin{align}<br>P(X=k) &amp; = 1 \\times \\frac{\\lambda^k}{k!} e^{-\\lambda} \\times 1 \\\\<br>&amp; = \\frac{\\lambda^k}{k!} e^{-\\lambda}<br>\\end{align}<br>$$</p>\n<h2 id=\"正态分布\"><a href=\"#正态分布\" class=\"headerlink\" title=\"正态分布\"></a>正态分布</h2><p>正态分布又名高斯分布，其概率密度函数为</p>\n<p>$$<br>P(X) = \\frac{1}{\\sigma\\sqrt{2\\pi}}e^{-\\frac{1}{2}(\\frac{x-\\mu}{\\sigma})^2}<br>$$</p>\n<p>其中 $\\mu$ 为期望值，$\\sigma$ 为标准差，之前也提到过。</p>\n<p>另外，$\\frac{x-\\mu}{\\sigma}$ 称为标准分数（z-score），代表 <strong>距离平均数有多少个标准差</strong>。</p>\n<h3 id=\"经验法则\"><a href=\"#经验法则\" class=\"headerlink\" title=\"经验法则\"></a>经验法则</h3><p>经验法则又名 68-95-99.7 法则，表明了几个特殊区间的概率值。</p>\n<p>$(\\mu - \\sigma, \\mu + \\sigma)$ 发生的概率为 68%<br>$(\\mu - 2\\sigma, \\mu + 2\\sigma)$ 发生的概率为 95%<br>$(\\mu - 3\\sigma, \\mu + 3\\sigma)$ 发生的概率为 99.7%</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>需要注意的是二项分布和泊松分布都是离散分布，正态分布为连续分布。这三者存在紧密的联系，从图像上来看三者也是非常接近。</p>\n<p>如果二项分布的实验次数 n 很大而每次试验的成功概率 p 很小时，泊松分布可作为二项分布的极限近似。当实验次数 n 再变大，几乎可以看成连续时，二项分布和泊松分布都可以用正态分布来代替。</p>"},{"title":"二叉搜索树","date":"2016-08-07T03:36:57.000Z","_content":"\n二叉搜索树(BST)是二叉树的一种，但是它只允许在左侧结点存储比父结点小的值，在右侧结点存储比父结点大或等于的值。\n\n<!-- more -->\n\n## 二叉树的基本结构\n\n术语：\n\n- 深度：结点的深度取决于它的祖先结点的数量。\n- 高度：树的高度取决于所有结点深度的最大值。\n- 层：根结点在第 0 层，它的子结点在第 1 层，以此类推。\n\n```javascript\n// 结点类\nclass TreeNode {\n  constructor(key) {\n    this.key = key;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// 二叉树\nclass Tree {\n  constructor() {\n    this.root = null;\n  }\n}\n```\n\n## 构建 BST\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/insert.gif)\n\n上图直观地展示了一颗二叉搜索树构建的过程，每次插入结点时，从根结点开始比较结点间大小，然后将结点插入到正确的位置。\n\n```javascript\nclass BinarySearchTree {\n  constructor() {\n    this.root = null;\n  }\n\n  insert(key) {\n    let curNode = this.root;\n\n    if(curNode === null) {\n      this.root = new TreeNode(key);\n      return;\n    } else {\n      while(curNode !== null) {\n        if(key > curNode.key) {\n          if(curNode.right === null) {\n            curNode.right = new TreeNode(key);\n            return;\n          }\n          curNode = curNode.right;\n        } else if(key < curNode.key) {\n          if(curNode.left === null) {\n            curNode.left = new TreeNode(key);\n            return;\n          }\n          curNode = curNode.left;\n        }\n      }\n    }\n  }\n}\n```\n\n## 查找\n\n### 树的遍历\n\n访问树的结点有三种方法：中序、前序和后序。\n\n- 中序遍历是指先访问结点的左孩子，然后访问结点自己，最后访问结点的右孩子。对每个孩子而言，规则也是一样的。\n- 前序遍历是指先访问结点自己，然后访问结点的左孩子，最后访问结点的右孩子。\n- 后序遍历是指先访问结点的左孩子，然后访问结点的右孩子，最后访问结点自己。\n\n#### 中序遍历\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/inorder.png)\n\n```javascript\ninOrderTraverse(callback) {\n\n  traverse(this.root);\n\n  function traverse(node) {\n    if(node == null) {\n      return;\n    }\n    traverse(node.left);\n    callback(node);\n    traverse(node.right);\n  }\n}\n```\n\n#### 前序遍历\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/preorder.png)\n\n```javascript\npreOrderTraverse(callback) {\n\n  traverse(this.root);\n\n  function traverse(node) {\n    if(node == null) {\n      return;\n    }\n    callback(node);\n    traverse(node.left);\n    traverse(node.right);\n  }\n}\n```\n\n#### 后序遍历\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/postorder.png)\n\n```javascript\npostOrderTraverse(callback) {\n\n  traverse(this.root);\n\n  function traverse(node) {\n    if(node == null) {\n      return;\n    }\n    traverse(node.left);\n    traverse(node.right);\n    callback(node);\n  }\n}\n```\n\n### BST 的最小值和最大值\n\n因为二叉搜索树会把比结点小的存在结点左边，把比结点大的存在结点右边，所以对二叉搜索树而言，树中的最小值在树的最左结点，树的最大值在树的最右结点。\n\n#### 获取最小结点\n\n```javascript\nmin(node) {\n  let curNode = node || this.root;\n  if(curNode !== null) {\n    while(curNode && curNode.left !== null) {\n      curNode = curNode.left;\n    }\n    return curNode;\n  }\n  \n  return null;\n}\n```\n\n#### 获取最大结点\n\n```javascript\nmax(node) {\n  let curNode = node || this.root;\n  if(curNode !== null) {\n    while(curNode && curNode.right !== null) {\n      curNode = curNode.right;\n    }\n    return curNode;\n  }\n  \n  return null;\n}\n```\n\n### 搜素 BST 中的值\n\n在二叉搜索树中进行搜索，和插入时一样进行比较即可。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/search.gif)\n\n```javascript\nsearch(key) {\n  let curNode = this.root;\n  while(curNode !== null) {\n    if(key < curNode.key) {\n      curNode = curNode.left;\n    } else if (key > curNode.key) {\n      curNode = curNode.right;\n    } else {\n      return curNode;\n    }\n  }\n  return null;\n}\n```\n\n## 移除结点\n\n移除结点包含了几种不同的运行场景，根据不同的情况，我们需要在移除后进行一些操作。\n\n### 移除叶结点\n\n移除叶结点不会对树产生影响，所以直接移除即可：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/remove_0.png)\n\n### 移除只有一个孩子的结点\n\n因为该结点只有一个孩子，所以将该结点移除后，需要用孩子来填补该结点的位置：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/remove_1.png)\n\n### 移除有两个孩子的结点\n\n这种情况相对以上两种要复杂一点，移除这个结点，需要执行三个步骤：\n\n1. 找到该结点右子树的最小结点。\n2. 用该结点右子树的最小结点的键更新该结点的键。\n3. 移除该结点右子树的最小结点。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/remove_2.png)\n\n### 实现\n```javascript\nremove(key) {\n\n  let removeNode = (node, key) => {\n    if(node == null) {\n      return null;\n    }\n\n    if(key < node.key) {\n      node.left = removeNode(node.left, key);\n      return node;\n    } else if(key > node.key) {\n      node.right = removeNode(node.right, key);\n      return node;\n    } else {\n      if(node.left == null && node.right == null) {\n        node = null;\n        return null;\n      }\n\n      if(node.left == null) {\n        node = node.right;\n        return node;\n      }\n\n      if(node.right == null) {\n        node = node.left;\n        return node;\n      }\n\n      // 找到右子树的最小结点\n      let n = this.min(node.right);\n      // 将该结点的值替换掉\n      node.key = n.key;\n      // 移除右子树的最小结点\n      node.right = removeNode(node.right, n.key);\n\n      return node;\n    }\n  }\n\n  removeNode(this.root, key);\n}\n```","source":"_posts/binary-search-tree.md","raw":"---\ntitle: 二叉搜索树\ndate: 2016-08-07 11:36:57\ntags: [数据结构]\n---\n\n二叉搜索树(BST)是二叉树的一种，但是它只允许在左侧结点存储比父结点小的值，在右侧结点存储比父结点大或等于的值。\n\n<!-- more -->\n\n## 二叉树的基本结构\n\n术语：\n\n- 深度：结点的深度取决于它的祖先结点的数量。\n- 高度：树的高度取决于所有结点深度的最大值。\n- 层：根结点在第 0 层，它的子结点在第 1 层，以此类推。\n\n```javascript\n// 结点类\nclass TreeNode {\n  constructor(key) {\n    this.key = key;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// 二叉树\nclass Tree {\n  constructor() {\n    this.root = null;\n  }\n}\n```\n\n## 构建 BST\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/insert.gif)\n\n上图直观地展示了一颗二叉搜索树构建的过程，每次插入结点时，从根结点开始比较结点间大小，然后将结点插入到正确的位置。\n\n```javascript\nclass BinarySearchTree {\n  constructor() {\n    this.root = null;\n  }\n\n  insert(key) {\n    let curNode = this.root;\n\n    if(curNode === null) {\n      this.root = new TreeNode(key);\n      return;\n    } else {\n      while(curNode !== null) {\n        if(key > curNode.key) {\n          if(curNode.right === null) {\n            curNode.right = new TreeNode(key);\n            return;\n          }\n          curNode = curNode.right;\n        } else if(key < curNode.key) {\n          if(curNode.left === null) {\n            curNode.left = new TreeNode(key);\n            return;\n          }\n          curNode = curNode.left;\n        }\n      }\n    }\n  }\n}\n```\n\n## 查找\n\n### 树的遍历\n\n访问树的结点有三种方法：中序、前序和后序。\n\n- 中序遍历是指先访问结点的左孩子，然后访问结点自己，最后访问结点的右孩子。对每个孩子而言，规则也是一样的。\n- 前序遍历是指先访问结点自己，然后访问结点的左孩子，最后访问结点的右孩子。\n- 后序遍历是指先访问结点的左孩子，然后访问结点的右孩子，最后访问结点自己。\n\n#### 中序遍历\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/inorder.png)\n\n```javascript\ninOrderTraverse(callback) {\n\n  traverse(this.root);\n\n  function traverse(node) {\n    if(node == null) {\n      return;\n    }\n    traverse(node.left);\n    callback(node);\n    traverse(node.right);\n  }\n}\n```\n\n#### 前序遍历\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/preorder.png)\n\n```javascript\npreOrderTraverse(callback) {\n\n  traverse(this.root);\n\n  function traverse(node) {\n    if(node == null) {\n      return;\n    }\n    callback(node);\n    traverse(node.left);\n    traverse(node.right);\n  }\n}\n```\n\n#### 后序遍历\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/postorder.png)\n\n```javascript\npostOrderTraverse(callback) {\n\n  traverse(this.root);\n\n  function traverse(node) {\n    if(node == null) {\n      return;\n    }\n    traverse(node.left);\n    traverse(node.right);\n    callback(node);\n  }\n}\n```\n\n### BST 的最小值和最大值\n\n因为二叉搜索树会把比结点小的存在结点左边，把比结点大的存在结点右边，所以对二叉搜索树而言，树中的最小值在树的最左结点，树的最大值在树的最右结点。\n\n#### 获取最小结点\n\n```javascript\nmin(node) {\n  let curNode = node || this.root;\n  if(curNode !== null) {\n    while(curNode && curNode.left !== null) {\n      curNode = curNode.left;\n    }\n    return curNode;\n  }\n  \n  return null;\n}\n```\n\n#### 获取最大结点\n\n```javascript\nmax(node) {\n  let curNode = node || this.root;\n  if(curNode !== null) {\n    while(curNode && curNode.right !== null) {\n      curNode = curNode.right;\n    }\n    return curNode;\n  }\n  \n  return null;\n}\n```\n\n### 搜素 BST 中的值\n\n在二叉搜索树中进行搜索，和插入时一样进行比较即可。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/search.gif)\n\n```javascript\nsearch(key) {\n  let curNode = this.root;\n  while(curNode !== null) {\n    if(key < curNode.key) {\n      curNode = curNode.left;\n    } else if (key > curNode.key) {\n      curNode = curNode.right;\n    } else {\n      return curNode;\n    }\n  }\n  return null;\n}\n```\n\n## 移除结点\n\n移除结点包含了几种不同的运行场景，根据不同的情况，我们需要在移除后进行一些操作。\n\n### 移除叶结点\n\n移除叶结点不会对树产生影响，所以直接移除即可：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/remove_0.png)\n\n### 移除只有一个孩子的结点\n\n因为该结点只有一个孩子，所以将该结点移除后，需要用孩子来填补该结点的位置：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/remove_1.png)\n\n### 移除有两个孩子的结点\n\n这种情况相对以上两种要复杂一点，移除这个结点，需要执行三个步骤：\n\n1. 找到该结点右子树的最小结点。\n2. 用该结点右子树的最小结点的键更新该结点的键。\n3. 移除该结点右子树的最小结点。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/remove_2.png)\n\n### 实现\n```javascript\nremove(key) {\n\n  let removeNode = (node, key) => {\n    if(node == null) {\n      return null;\n    }\n\n    if(key < node.key) {\n      node.left = removeNode(node.left, key);\n      return node;\n    } else if(key > node.key) {\n      node.right = removeNode(node.right, key);\n      return node;\n    } else {\n      if(node.left == null && node.right == null) {\n        node = null;\n        return null;\n      }\n\n      if(node.left == null) {\n        node = node.right;\n        return node;\n      }\n\n      if(node.right == null) {\n        node = node.left;\n        return node;\n      }\n\n      // 找到右子树的最小结点\n      let n = this.min(node.right);\n      // 将该结点的值替换掉\n      node.key = n.key;\n      // 移除右子树的最小结点\n      node.right = removeNode(node.right, n.key);\n\n      return node;\n    }\n  }\n\n  removeNode(this.root, key);\n}\n```","slug":"binary-search-tree","published":1,"updated":"2017-03-17T13:39:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcv3000fn927fkmn7ypn","content":"<p>二叉搜索树(BST)是二叉树的一种，但是它只允许在左侧结点存储比父结点小的值，在右侧结点存储比父结点大或等于的值。</p>\n<a id=\"more\"></a>\n<h2 id=\"二叉树的基本结构\"><a href=\"#二叉树的基本结构\" class=\"headerlink\" title=\"二叉树的基本结构\"></a>二叉树的基本结构</h2><p>术语：</p>\n<ul>\n<li>深度：结点的深度取决于它的祖先结点的数量。</li>\n<li>高度：树的高度取决于所有结点深度的最大值。</li>\n<li>层：根结点在第 0 层，它的子结点在第 1 层，以此类推。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 结点类</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.key = key;</div><div class=\"line\">    <span class=\"keyword\">this</span>.left = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.right = <span class=\"literal\">null</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 二叉树</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tree</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.root = <span class=\"literal\">null</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"构建-BST\"><a href=\"#构建-BST\" class=\"headerlink\" title=\"构建 BST\"></a>构建 BST</h2><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/insert.gif\" alt=\"\"></p>\n<p>上图直观地展示了一颗二叉搜索树构建的过程，每次插入结点时，从根结点开始比较结点间大小，然后将结点插入到正确的位置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinarySearchTree</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.root = <span class=\"literal\">null</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  insert(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.root;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(curNode === <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.root = <span class=\"keyword\">new</span> TreeNode(key);</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">while</span>(curNode !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(key &gt; curNode.key) &#123;</div><div class=\"line\">          <span class=\"keyword\">if</span>(curNode.right === <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">            curNode.right = <span class=\"keyword\">new</span> TreeNode(key);</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">          &#125;</div><div class=\"line\">          curNode = curNode.right;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(key &lt; curNode.key) &#123;</div><div class=\"line\">          <span class=\"keyword\">if</span>(curNode.left === <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">            curNode.left = <span class=\"keyword\">new</span> TreeNode(key);</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">          &#125;</div><div class=\"line\">          curNode = curNode.left;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h2><h3 id=\"树的遍历\"><a href=\"#树的遍历\" class=\"headerlink\" title=\"树的遍历\"></a>树的遍历</h3><p>访问树的结点有三种方法：中序、前序和后序。</p>\n<ul>\n<li>中序遍历是指先访问结点的左孩子，然后访问结点自己，最后访问结点的右孩子。对每个孩子而言，规则也是一样的。</li>\n<li>前序遍历是指先访问结点自己，然后访问结点的左孩子，最后访问结点的右孩子。</li>\n<li>后序遍历是指先访问结点的左孩子，然后访问结点的右孩子，最后访问结点自己。</li>\n</ul>\n<h4 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h4><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/inorder.png\" alt=\"\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">inOrderTraverse(callback) &#123;</div><div class=\"line\"></div><div class=\"line\">  traverse(<span class=\"keyword\">this</span>.root);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">traverse</span>(<span class=\"params\">node</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(node == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    traverse(node.left);</div><div class=\"line\">    callback(node);</div><div class=\"line\">    traverse(node.right);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h4><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/preorder.png\" alt=\"\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">preOrderTraverse(callback) &#123;</div><div class=\"line\"></div><div class=\"line\">  traverse(<span class=\"keyword\">this</span>.root);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">traverse</span>(<span class=\"params\">node</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(node == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    callback(node);</div><div class=\"line\">    traverse(node.left);</div><div class=\"line\">    traverse(node.right);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h4><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/postorder.png\" alt=\"\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">postOrderTraverse(callback) &#123;</div><div class=\"line\"></div><div class=\"line\">  traverse(<span class=\"keyword\">this</span>.root);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">traverse</span>(<span class=\"params\">node</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(node == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    traverse(node.left);</div><div class=\"line\">    traverse(node.right);</div><div class=\"line\">    callback(node);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"BST-的最小值和最大值\"><a href=\"#BST-的最小值和最大值\" class=\"headerlink\" title=\"BST 的最小值和最大值\"></a>BST 的最小值和最大值</h3><p>因为二叉搜索树会把比结点小的存在结点左边，把比结点大的存在结点右边，所以对二叉搜索树而言，树中的最小值在树的最左结点，树的最大值在树的最右结点。</p>\n<h4 id=\"获取最小结点\"><a href=\"#获取最小结点\" class=\"headerlink\" title=\"获取最小结点\"></a>获取最小结点</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">min(node) &#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> curNode = node || <span class=\"keyword\">this</span>.root;</div><div class=\"line\">  <span class=\"keyword\">if</span>(curNode !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">while</span>(curNode &amp;&amp; curNode.left !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      curNode = curNode.left;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> curNode;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"获取最大结点\"><a href=\"#获取最大结点\" class=\"headerlink\" title=\"获取最大结点\"></a>获取最大结点</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">max(node) &#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> curNode = node || <span class=\"keyword\">this</span>.root;</div><div class=\"line\">  <span class=\"keyword\">if</span>(curNode !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">while</span>(curNode &amp;&amp; curNode.right !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      curNode = curNode.right;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> curNode;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"搜素-BST-中的值\"><a href=\"#搜素-BST-中的值\" class=\"headerlink\" title=\"搜素 BST 中的值\"></a>搜素 BST 中的值</h3><p>在二叉搜索树中进行搜索，和插入时一样进行比较即可。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/search.gif\" alt=\"\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">search(key) &#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.root;</div><div class=\"line\">  <span class=\"keyword\">while</span>(curNode !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(key &lt; curNode.key) &#123;</div><div class=\"line\">      curNode = curNode.left;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &gt; curNode.key) &#123;</div><div class=\"line\">      curNode = curNode.right;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> curNode;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"移除结点\"><a href=\"#移除结点\" class=\"headerlink\" title=\"移除结点\"></a>移除结点</h2><p>移除结点包含了几种不同的运行场景，根据不同的情况，我们需要在移除后进行一些操作。</p>\n<h3 id=\"移除叶结点\"><a href=\"#移除叶结点\" class=\"headerlink\" title=\"移除叶结点\"></a>移除叶结点</h3><p>移除叶结点不会对树产生影响，所以直接移除即可：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/remove_0.png\" alt=\"\"></p>\n<h3 id=\"移除只有一个孩子的结点\"><a href=\"#移除只有一个孩子的结点\" class=\"headerlink\" title=\"移除只有一个孩子的结点\"></a>移除只有一个孩子的结点</h3><p>因为该结点只有一个孩子，所以将该结点移除后，需要用孩子来填补该结点的位置：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/remove_1.png\" alt=\"\"></p>\n<h3 id=\"移除有两个孩子的结点\"><a href=\"#移除有两个孩子的结点\" class=\"headerlink\" title=\"移除有两个孩子的结点\"></a>移除有两个孩子的结点</h3><p>这种情况相对以上两种要复杂一点，移除这个结点，需要执行三个步骤：</p>\n<ol>\n<li>找到该结点右子树的最小结点。</li>\n<li>用该结点右子树的最小结点的键更新该结点的键。</li>\n<li>移除该结点右子树的最小结点。</li>\n</ol>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/remove_2.png\" alt=\"\"></p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">remove(key) &#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">let</span> removeNode = <span class=\"function\">(<span class=\"params\">node, key</span>) =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(node == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(key &lt; node.key) &#123;</div><div class=\"line\">      node.left = removeNode(node.left, key);</div><div class=\"line\">      <span class=\"keyword\">return</span> node;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(key &gt; node.key) &#123;</div><div class=\"line\">      node.right = removeNode(node.right, key);</div><div class=\"line\">      <span class=\"keyword\">return</span> node;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(node.left == <span class=\"literal\">null</span> &amp;&amp; node.right == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        node = <span class=\"literal\">null</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span>(node.left == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        node = node.right;</div><div class=\"line\">        <span class=\"keyword\">return</span> node;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span>(node.right == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        node = node.left;</div><div class=\"line\">        <span class=\"keyword\">return</span> node;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// 找到右子树的最小结点</span></div><div class=\"line\">      <span class=\"keyword\">let</span> n = <span class=\"keyword\">this</span>.min(node.right);</div><div class=\"line\">      <span class=\"comment\">// 将该结点的值替换掉</span></div><div class=\"line\">      node.key = n.key;</div><div class=\"line\">      <span class=\"comment\">// 移除右子树的最小结点</span></div><div class=\"line\">      node.right = removeNode(node.right, n.key);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">return</span> node;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  removeNode(<span class=\"keyword\">this</span>.root, key);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","excerpt":"<p>二叉搜索树(BST)是二叉树的一种，但是它只允许在左侧结点存储比父结点小的值，在右侧结点存储比父结点大或等于的值。</p>","more":"<h2 id=\"二叉树的基本结构\"><a href=\"#二叉树的基本结构\" class=\"headerlink\" title=\"二叉树的基本结构\"></a>二叉树的基本结构</h2><p>术语：</p>\n<ul>\n<li>深度：结点的深度取决于它的祖先结点的数量。</li>\n<li>高度：树的高度取决于所有结点深度的最大值。</li>\n<li>层：根结点在第 0 层，它的子结点在第 1 层，以此类推。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 结点类</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.key = key;</div><div class=\"line\">    <span class=\"keyword\">this</span>.left = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.right = <span class=\"literal\">null</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 二叉树</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tree</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.root = <span class=\"literal\">null</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"构建-BST\"><a href=\"#构建-BST\" class=\"headerlink\" title=\"构建 BST\"></a>构建 BST</h2><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/insert.gif\" alt=\"\"></p>\n<p>上图直观地展示了一颗二叉搜索树构建的过程，每次插入结点时，从根结点开始比较结点间大小，然后将结点插入到正确的位置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinarySearchTree</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.root = <span class=\"literal\">null</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  insert(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.root;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(curNode === <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.root = <span class=\"keyword\">new</span> TreeNode(key);</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">while</span>(curNode !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(key &gt; curNode.key) &#123;</div><div class=\"line\">          <span class=\"keyword\">if</span>(curNode.right === <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">            curNode.right = <span class=\"keyword\">new</span> TreeNode(key);</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">          &#125;</div><div class=\"line\">          curNode = curNode.right;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(key &lt; curNode.key) &#123;</div><div class=\"line\">          <span class=\"keyword\">if</span>(curNode.left === <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">            curNode.left = <span class=\"keyword\">new</span> TreeNode(key);</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">          &#125;</div><div class=\"line\">          curNode = curNode.left;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h2><h3 id=\"树的遍历\"><a href=\"#树的遍历\" class=\"headerlink\" title=\"树的遍历\"></a>树的遍历</h3><p>访问树的结点有三种方法：中序、前序和后序。</p>\n<ul>\n<li>中序遍历是指先访问结点的左孩子，然后访问结点自己，最后访问结点的右孩子。对每个孩子而言，规则也是一样的。</li>\n<li>前序遍历是指先访问结点自己，然后访问结点的左孩子，最后访问结点的右孩子。</li>\n<li>后序遍历是指先访问结点的左孩子，然后访问结点的右孩子，最后访问结点自己。</li>\n</ul>\n<h4 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h4><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/inorder.png\" alt=\"\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">inOrderTraverse(callback) &#123;</div><div class=\"line\"></div><div class=\"line\">  traverse(<span class=\"keyword\">this</span>.root);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">traverse</span>(<span class=\"params\">node</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(node == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    traverse(node.left);</div><div class=\"line\">    callback(node);</div><div class=\"line\">    traverse(node.right);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h4><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/preorder.png\" alt=\"\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">preOrderTraverse(callback) &#123;</div><div class=\"line\"></div><div class=\"line\">  traverse(<span class=\"keyword\">this</span>.root);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">traverse</span>(<span class=\"params\">node</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(node == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    callback(node);</div><div class=\"line\">    traverse(node.left);</div><div class=\"line\">    traverse(node.right);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h4><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/postorder.png\" alt=\"\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">postOrderTraverse(callback) &#123;</div><div class=\"line\"></div><div class=\"line\">  traverse(<span class=\"keyword\">this</span>.root);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">traverse</span>(<span class=\"params\">node</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(node == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    traverse(node.left);</div><div class=\"line\">    traverse(node.right);</div><div class=\"line\">    callback(node);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"BST-的最小值和最大值\"><a href=\"#BST-的最小值和最大值\" class=\"headerlink\" title=\"BST 的最小值和最大值\"></a>BST 的最小值和最大值</h3><p>因为二叉搜索树会把比结点小的存在结点左边，把比结点大的存在结点右边，所以对二叉搜索树而言，树中的最小值在树的最左结点，树的最大值在树的最右结点。</p>\n<h4 id=\"获取最小结点\"><a href=\"#获取最小结点\" class=\"headerlink\" title=\"获取最小结点\"></a>获取最小结点</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">min(node) &#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> curNode = node || <span class=\"keyword\">this</span>.root;</div><div class=\"line\">  <span class=\"keyword\">if</span>(curNode !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">while</span>(curNode &amp;&amp; curNode.left !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      curNode = curNode.left;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> curNode;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"获取最大结点\"><a href=\"#获取最大结点\" class=\"headerlink\" title=\"获取最大结点\"></a>获取最大结点</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">max(node) &#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> curNode = node || <span class=\"keyword\">this</span>.root;</div><div class=\"line\">  <span class=\"keyword\">if</span>(curNode !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">while</span>(curNode &amp;&amp; curNode.right !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      curNode = curNode.right;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> curNode;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"搜素-BST-中的值\"><a href=\"#搜素-BST-中的值\" class=\"headerlink\" title=\"搜素 BST 中的值\"></a>搜素 BST 中的值</h3><p>在二叉搜索树中进行搜索，和插入时一样进行比较即可。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/search.gif\" alt=\"\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">search(key) &#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.root;</div><div class=\"line\">  <span class=\"keyword\">while</span>(curNode !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(key &lt; curNode.key) &#123;</div><div class=\"line\">      curNode = curNode.left;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &gt; curNode.key) &#123;</div><div class=\"line\">      curNode = curNode.right;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> curNode;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"移除结点\"><a href=\"#移除结点\" class=\"headerlink\" title=\"移除结点\"></a>移除结点</h2><p>移除结点包含了几种不同的运行场景，根据不同的情况，我们需要在移除后进行一些操作。</p>\n<h3 id=\"移除叶结点\"><a href=\"#移除叶结点\" class=\"headerlink\" title=\"移除叶结点\"></a>移除叶结点</h3><p>移除叶结点不会对树产生影响，所以直接移除即可：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/remove_0.png\" alt=\"\"></p>\n<h3 id=\"移除只有一个孩子的结点\"><a href=\"#移除只有一个孩子的结点\" class=\"headerlink\" title=\"移除只有一个孩子的结点\"></a>移除只有一个孩子的结点</h3><p>因为该结点只有一个孩子，所以将该结点移除后，需要用孩子来填补该结点的位置：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/remove_1.png\" alt=\"\"></p>\n<h3 id=\"移除有两个孩子的结点\"><a href=\"#移除有两个孩子的结点\" class=\"headerlink\" title=\"移除有两个孩子的结点\"></a>移除有两个孩子的结点</h3><p>这种情况相对以上两种要复杂一点，移除这个结点，需要执行三个步骤：</p>\n<ol>\n<li>找到该结点右子树的最小结点。</li>\n<li>用该结点右子树的最小结点的键更新该结点的键。</li>\n<li>移除该结点右子树的最小结点。</li>\n</ol>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/remove_2.png\" alt=\"\"></p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">remove(key) &#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">let</span> removeNode = <span class=\"function\">(<span class=\"params\">node, key</span>) =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(node == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(key &lt; node.key) &#123;</div><div class=\"line\">      node.left = removeNode(node.left, key);</div><div class=\"line\">      <span class=\"keyword\">return</span> node;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(key &gt; node.key) &#123;</div><div class=\"line\">      node.right = removeNode(node.right, key);</div><div class=\"line\">      <span class=\"keyword\">return</span> node;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(node.left == <span class=\"literal\">null</span> &amp;&amp; node.right == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        node = <span class=\"literal\">null</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span>(node.left == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        node = node.right;</div><div class=\"line\">        <span class=\"keyword\">return</span> node;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span>(node.right == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        node = node.left;</div><div class=\"line\">        <span class=\"keyword\">return</span> node;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// 找到右子树的最小结点</span></div><div class=\"line\">      <span class=\"keyword\">let</span> n = <span class=\"keyword\">this</span>.min(node.right);</div><div class=\"line\">      <span class=\"comment\">// 将该结点的值替换掉</span></div><div class=\"line\">      node.key = n.key;</div><div class=\"line\">      <span class=\"comment\">// 移除右子树的最小结点</span></div><div class=\"line\">      node.right = removeNode(node.right, n.key);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">return</span> node;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  removeNode(<span class=\"keyword\">this</span>.root, key);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"微积分第二基本定理","date":"2017-03-12T08:46:20.000Z","_content":"\n> 如果 f 连续，且 $G(x) = \\int\\_a^xf(t)dt$，那么 $G'(x) = f(x)$。$(a \\leqslant t \\leqslant x)$\n\n<!-- more -->\n\n另一种表述形式即对 f 积分再求导，会得到函数本身：$\\cfrac{d}{dx}\\int\\_a^xf(t)dt = f(x)$\n\n微积分第二基本定理的意义在于 G(x) 可以用来求解微分方程 y' = f，初始条件为 y(a) = 0。\n\n## 几何意义\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/calculus-fundamental-theorem-2/1.png)\n\n如图，$G(x)$ 为 $f(x)$ 在 a 到 x 之间的积分，设 $\\Delta G$ 为 f(x) 在 x 到 $\\Delta x$ 之间的积分。\n\n则 $\\Delta G \\approx \\Delta x \\cdot f(x)$，即 $\\lim\\_{\\Delta x \\to 0} \\cfrac{\\Delta G}{\\Delta x} = f(x)$\n\n## 举例\n\n### 例一\n\n求 $\\cfrac{d}{dx}\\int\\_1^x \\cfrac{dt}{t^2}$\n\n即求 $\\cfrac{d}{dx}G(x) = G'(x) = f(x) = \\cfrac{1}{x^2}$\n\n### 例二\n\n设 $L(x) = \\int\\_1^x \\cfrac{dt}{t}$，证 $L(ab) = L(a) + L(b)$\n\n$$\n\\begin{align}\nL(ab) &= \\int\\_1^{ab}\\cfrac{dt}{t} \\\\\\\n&= \\int\\_1^{a}\\cfrac{dt}{t} + \\int\\_a^{ab}\\cfrac{dt}{t} \\\\\\\n&= L(a) + \\int\\_a^{ab}\\cfrac{dt}{t}\n\\end{align}\n$$\n\n即证 $\\int\\_a^{ab}\\cfrac{dt}{t} = L(b)$\n\n令 $t = au$，则 $dt = adu$，代入上式\n\n$\\int\\_a^{ab}\\cfrac{dt}{t} = \\int\\_1^{b}\\cfrac{adu}{au} = \\int\\_1^{b}\\cfrac{du}{u} = L(b)$\n\n另外，根据微积分第二基本定理，可以快速得到 $L(1) = 0$，$L'(x) = \\cfrac{1}{x}$，则 $L'(1) = 1$，$L''(x) = -\\cfrac{1}{x^2}$\n\n可以画出 L(x) 图像的趋势，其实即对数函数\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/calculus-fundamental-theorem-2/2.png)\n\n### 例三\n\n$F(x) = \\int\\_0^x e^{-t^2}dt$\n\n根据微积分第二基本定理，$F(0) = 0$，$F'(x) = e^{-x^2}$，所以 $F'(0) = 1$，$F''(x) = -2xe^{-x^2}$\n\n$$\nF''(x)\n\\begin{cases}\n\\> 0,  & \\text{$x < 0$} \\\\\\\n< 0, & \\text{x > 0}  \\\\\\\n\\end{cases}\n$$\n\n可得 $F(x)$ 的函数趋势为一个奇函数，而 $F'(x)$ 的函数图像为\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/calculus-fundamental-theorem-2/3.png)\n\n是概率论中常见的钟形函数。\n","source":"_posts/calculus-fundamental-theorem-2.md","raw":"---\ntitle: 微积分第二基本定理\ndate: 2017-03-12 16:46:20\ntags: [单变量微积分]\n---\n\n> 如果 f 连续，且 $G(x) = \\int\\_a^xf(t)dt$，那么 $G'(x) = f(x)$。$(a \\leqslant t \\leqslant x)$\n\n<!-- more -->\n\n另一种表述形式即对 f 积分再求导，会得到函数本身：$\\cfrac{d}{dx}\\int\\_a^xf(t)dt = f(x)$\n\n微积分第二基本定理的意义在于 G(x) 可以用来求解微分方程 y' = f，初始条件为 y(a) = 0。\n\n## 几何意义\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/calculus-fundamental-theorem-2/1.png)\n\n如图，$G(x)$ 为 $f(x)$ 在 a 到 x 之间的积分，设 $\\Delta G$ 为 f(x) 在 x 到 $\\Delta x$ 之间的积分。\n\n则 $\\Delta G \\approx \\Delta x \\cdot f(x)$，即 $\\lim\\_{\\Delta x \\to 0} \\cfrac{\\Delta G}{\\Delta x} = f(x)$\n\n## 举例\n\n### 例一\n\n求 $\\cfrac{d}{dx}\\int\\_1^x \\cfrac{dt}{t^2}$\n\n即求 $\\cfrac{d}{dx}G(x) = G'(x) = f(x) = \\cfrac{1}{x^2}$\n\n### 例二\n\n设 $L(x) = \\int\\_1^x \\cfrac{dt}{t}$，证 $L(ab) = L(a) + L(b)$\n\n$$\n\\begin{align}\nL(ab) &= \\int\\_1^{ab}\\cfrac{dt}{t} \\\\\\\n&= \\int\\_1^{a}\\cfrac{dt}{t} + \\int\\_a^{ab}\\cfrac{dt}{t} \\\\\\\n&= L(a) + \\int\\_a^{ab}\\cfrac{dt}{t}\n\\end{align}\n$$\n\n即证 $\\int\\_a^{ab}\\cfrac{dt}{t} = L(b)$\n\n令 $t = au$，则 $dt = adu$，代入上式\n\n$\\int\\_a^{ab}\\cfrac{dt}{t} = \\int\\_1^{b}\\cfrac{adu}{au} = \\int\\_1^{b}\\cfrac{du}{u} = L(b)$\n\n另外，根据微积分第二基本定理，可以快速得到 $L(1) = 0$，$L'(x) = \\cfrac{1}{x}$，则 $L'(1) = 1$，$L''(x) = -\\cfrac{1}{x^2}$\n\n可以画出 L(x) 图像的趋势，其实即对数函数\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/calculus-fundamental-theorem-2/2.png)\n\n### 例三\n\n$F(x) = \\int\\_0^x e^{-t^2}dt$\n\n根据微积分第二基本定理，$F(0) = 0$，$F'(x) = e^{-x^2}$，所以 $F'(0) = 1$，$F''(x) = -2xe^{-x^2}$\n\n$$\nF''(x)\n\\begin{cases}\n\\> 0,  & \\text{$x < 0$} \\\\\\\n< 0, & \\text{x > 0}  \\\\\\\n\\end{cases}\n$$\n\n可得 $F(x)$ 的函数趋势为一个奇函数，而 $F'(x)$ 的函数图像为\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/calculus-fundamental-theorem-2/3.png)\n\n是概率论中常见的钟形函数。\n","slug":"calculus-fundamental-theorem-2","published":1,"updated":"2017-03-12T10:14:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcv7000hn927wjp9qtd8","content":"<blockquote>\n<p>如果 f 连续，且 $G(x) = \\int_a^xf(t)dt$，那么 $G’(x) = f(x)$。$(a \\leqslant t \\leqslant x)$</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>另一种表述形式即对 f 积分再求导，会得到函数本身：$\\cfrac{d}{dx}\\int_a^xf(t)dt = f(x)$</p>\n<p>微积分第二基本定理的意义在于 G(x) 可以用来求解微分方程 y’ = f，初始条件为 y(a) = 0。</p>\n<h2 id=\"几何意义\"><a href=\"#几何意义\" class=\"headerlink\" title=\"几何意义\"></a>几何意义</h2><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/calculus-fundamental-theorem-2/1.png\" alt=\"\"></p>\n<p>如图，$G(x)$ 为 $f(x)$ 在 a 到 x 之间的积分，设 $\\Delta G$ 为 f(x) 在 x 到 $\\Delta x$ 之间的积分。</p>\n<p>则 $\\Delta G \\approx \\Delta x \\cdot f(x)$，即 $\\lim_{\\Delta x \\to 0} \\cfrac{\\Delta G}{\\Delta x} = f(x)$</p>\n<h2 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h2><h3 id=\"例一\"><a href=\"#例一\" class=\"headerlink\" title=\"例一\"></a>例一</h3><p>求 $\\cfrac{d}{dx}\\int_1^x \\cfrac{dt}{t^2}$</p>\n<p>即求 $\\cfrac{d}{dx}G(x) = G’(x) = f(x) = \\cfrac{1}{x^2}$</p>\n<h3 id=\"例二\"><a href=\"#例二\" class=\"headerlink\" title=\"例二\"></a>例二</h3><p>设 $L(x) = \\int_1^x \\cfrac{dt}{t}$，证 $L(ab) = L(a) + L(b)$</p>\n<p>$$<br>\\begin{align}<br>L(ab) &amp;= \\int_1^{ab}\\cfrac{dt}{t} \\\\<br>&amp;= \\int_1^{a}\\cfrac{dt}{t} + \\int_a^{ab}\\cfrac{dt}{t} \\\\<br>&amp;= L(a) + \\int_a^{ab}\\cfrac{dt}{t}<br>\\end{align}<br>$$</p>\n<p>即证 $\\int_a^{ab}\\cfrac{dt}{t} = L(b)$</p>\n<p>令 $t = au$，则 $dt = adu$，代入上式</p>\n<p>$\\int_a^{ab}\\cfrac{dt}{t} = \\int_1^{b}\\cfrac{adu}{au} = \\int_1^{b}\\cfrac{du}{u} = L(b)$</p>\n<p>另外，根据微积分第二基本定理，可以快速得到 $L(1) = 0$，$L’(x) = \\cfrac{1}{x}$，则 $L’(1) = 1$，$L’’(x) = -\\cfrac{1}{x^2}$</p>\n<p>可以画出 L(x) 图像的趋势，其实即对数函数</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/calculus-fundamental-theorem-2/2.png\" alt=\"\"></p>\n<h3 id=\"例三\"><a href=\"#例三\" class=\"headerlink\" title=\"例三\"></a>例三</h3><p>$F(x) = \\int_0^x e^{-t^2}dt$</p>\n<p>根据微积分第二基本定理，$F(0) = 0$，$F’(x) = e^{-x^2}$，所以 $F’(0) = 1$，$F’’(x) = -2xe^{-x^2}$</p>\n<p>$$<br>F’’(x)<br>\\begin{cases}<br>> 0,  &amp; \\text{$x &lt; 0$} \\\\<br>&lt; 0, &amp; \\text{x &gt; 0}  \\\\<br>\\end{cases}<br>$$</p>\n<p>可得 $F(x)$ 的函数趋势为一个奇函数，而 $F’(x)$ 的函数图像为</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/calculus-fundamental-theorem-2/3.png\" alt=\"\"></p>\n<p>是概率论中常见的钟形函数。</p>\n","excerpt":"<blockquote>\n<p>如果 f 连续，且 $G(x) = \\int_a^xf(t)dt$，那么 $G’(x) = f(x)$。$(a \\leqslant t \\leqslant x)$</p>\n</blockquote>","more":"<p>另一种表述形式即对 f 积分再求导，会得到函数本身：$\\cfrac{d}{dx}\\int_a^xf(t)dt = f(x)$</p>\n<p>微积分第二基本定理的意义在于 G(x) 可以用来求解微分方程 y’ = f，初始条件为 y(a) = 0。</p>\n<h2 id=\"几何意义\"><a href=\"#几何意义\" class=\"headerlink\" title=\"几何意义\"></a>几何意义</h2><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/calculus-fundamental-theorem-2/1.png\" alt=\"\"></p>\n<p>如图，$G(x)$ 为 $f(x)$ 在 a 到 x 之间的积分，设 $\\Delta G$ 为 f(x) 在 x 到 $\\Delta x$ 之间的积分。</p>\n<p>则 $\\Delta G \\approx \\Delta x \\cdot f(x)$，即 $\\lim_{\\Delta x \\to 0} \\cfrac{\\Delta G}{\\Delta x} = f(x)$</p>\n<h2 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h2><h3 id=\"例一\"><a href=\"#例一\" class=\"headerlink\" title=\"例一\"></a>例一</h3><p>求 $\\cfrac{d}{dx}\\int_1^x \\cfrac{dt}{t^2}$</p>\n<p>即求 $\\cfrac{d}{dx}G(x) = G’(x) = f(x) = \\cfrac{1}{x^2}$</p>\n<h3 id=\"例二\"><a href=\"#例二\" class=\"headerlink\" title=\"例二\"></a>例二</h3><p>设 $L(x) = \\int_1^x \\cfrac{dt}{t}$，证 $L(ab) = L(a) + L(b)$</p>\n<p>$$<br>\\begin{align}<br>L(ab) &amp;= \\int_1^{ab}\\cfrac{dt}{t} \\\\<br>&amp;= \\int_1^{a}\\cfrac{dt}{t} + \\int_a^{ab}\\cfrac{dt}{t} \\\\<br>&amp;= L(a) + \\int_a^{ab}\\cfrac{dt}{t}<br>\\end{align}<br>$$</p>\n<p>即证 $\\int_a^{ab}\\cfrac{dt}{t} = L(b)$</p>\n<p>令 $t = au$，则 $dt = adu$，代入上式</p>\n<p>$\\int_a^{ab}\\cfrac{dt}{t} = \\int_1^{b}\\cfrac{adu}{au} = \\int_1^{b}\\cfrac{du}{u} = L(b)$</p>\n<p>另外，根据微积分第二基本定理，可以快速得到 $L(1) = 0$，$L’(x) = \\cfrac{1}{x}$，则 $L’(1) = 1$，$L’’(x) = -\\cfrac{1}{x^2}$</p>\n<p>可以画出 L(x) 图像的趋势，其实即对数函数</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/calculus-fundamental-theorem-2/2.png\" alt=\"\"></p>\n<h3 id=\"例三\"><a href=\"#例三\" class=\"headerlink\" title=\"例三\"></a>例三</h3><p>$F(x) = \\int_0^x e^{-t^2}dt$</p>\n<p>根据微积分第二基本定理，$F(0) = 0$，$F’(x) = e^{-x^2}$，所以 $F’(0) = 1$，$F’’(x) = -2xe^{-x^2}$</p>\n<p>$$<br>F’’(x)<br>\\begin{cases}<br>> 0,  &amp; \\text{$x &lt; 0$} \\\\<br>&lt; 0, &amp; \\text{x &gt; 0}  \\\\<br>\\end{cases}<br>$$</p>\n<p>可得 $F(x)$ 的函数趋势为一个奇函数，而 $F’(x)$ 的函数图像为</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/calculus-fundamental-theorem-2/3.png\" alt=\"\"></p>\n<p>是概率论中常见的钟形函数。</p>"},{"title":"24点","date":"2016-07-19T09:15:34.000Z","_content":"\n从北戴河回来的时候，和水哥在火车上玩 24 点，玩着玩着就聊到了求 24 点的实现（可怕的程序猿\n\n先考虑简单实现，即只有加减乘除四则运算。很直接的思路就是列出所有可能的表达式，依次求和，最后找出结果等于 24 的情况。\n\n这里涉及到两个关键点，一个是通过数字求出所有表达式，另一个是根据式子计算结果。\n\n求所有表达式可以理解为求四个数字的排列，然后插入运算符即可；根据式子计算结果我们可以利用前缀表达式做到。\n\n<!-- more -->\n\n## 前缀表达式\n\n我们平常使用的式子比如 `3*(5+9)-4`，称为中缀表达式，运算符夹在数字的中间，是人类易于理解的表达式。而计算机很难识别这种表达式，一是括号改变了式子的运行顺序，另外各种运算符之间存在优先级大小关系。\n\n相比而言，前缀表达式是计算机容易计算的，像上面这个例子，如果用前缀表达式来描述则是 `-*3+594`。可以看到前缀表达式中去掉了括号，运算符跑到了计算数字的左边。\n\n### 中缀表达式转换为前缀表达式\n\n中缀表达式转换为前缀表达式需要经过以下步骤：\n1. 从右至左扫描中缀表达式，从右边第一个字符开始判断\n  - 如果当前字符是数字，则将数字直接输出。\n  - 如果是运算符，栈顶也是运算符，则比较优先级：如果当前运算符的优先级大于等于栈顶运算符的优先级，运算符入栈，如果当前运算符的优先级小于栈顶运算符的优先级，将栈顶运算符弹出并输出，直到当前运算符的优先级大于等于栈顶运算符的优先级。\n  - 如果是运算符，栈顶为括号或栈为空，入栈。\n  - 如果是右括号，则入栈。\n  - 如果是左括号，将所有的运算符全部出栈并输出，直到栈顶为右括号，最后将左右的两括号一起删除。\n2. 重复上述操作直至扫描结束，将栈内剩余运算符全部出栈并输出，最后逆序输出字符串。\n\n以 `3*(5+9)-4` 为例，过程如下：\n1. 字符为 4\n  > 如果当前字符是数字，则将数字直接输出。\n\n  - 输出序列：4\n  - 栈：[]\n\n2. 字符为 -\n  > 如果是运算符，栈顶为括号或栈为空，入栈。\n\n  - 输出序列：4\n  - 栈：[-]\n\n3. 字符为 )\n  > 如果是右括号，则入栈。\n\n  - 输出序列：4\n  - 栈：[-, )]\n\n4. 字符为 9\n\n  - 输出序列：49\n  - 栈：[-, )]\n\n5. 字符为 +\n  > 如果是运算符，栈顶为括号或栈为空，入栈。\n\n  - 输出序列：49\n  - 栈：[-, ), +]\n\n6. 字符为 5\n\n  - 输出序列：495\n  - 栈：[-, ), +]\n\n7. 字符为 (\n  > 如果是左括号，将所有的运算符全部出栈并输出，直到栈顶为右括号，最后将左右的两括号一起删除。\n\n  输出序列：495+\n  栈：[-]\n\n8. 字符为 *\n  > 如果当前运算符的优先级大于等于栈顶运算符的优先级，运算符入栈\n\n  - 输出序列：495+\n  - 栈：[-, \\*]\n\n9. 字符为 3\n  - 输出序列：495+3\n  - 栈：[-, \\*]\n\n10. 结束\n  > 将栈内剩余运算符全部出栈并输出，最后逆序输出字符串。\n\n  - 输出序列：`495+3*-`\n  - 逆序：`-*3+594`\n\n所以最后结果为 `-*3+594`。\n\njavascript实现如下：\n\n```javascript\n/**\n * 中缀表达式转前缀表达式\n * @param  {string} inExpress 中缀表达式\n * @return {string}           前缀表达式\n */\nfunction translate(inExpress) {\n  if(inExpress == '') {\n    throw new Error('表达式为空');\n  }\n  // 输出前缀表达式\n  let output = [];\n  // 反转\n  let chars = inExpress.match(/(\\d+)|[^\\d]/g).reverse();\n  // 存放运算符的栈\n  let stack = [];\n  for(let ele of chars) {\n    if(/\\d+/.test(ele)) {\n      // 如果是数字，直接输出\n      output.push(ele);\n    } else if(/[\\+\\-]/.test(ele)) {\n      // 栈顶元素\n      let topEle = stack[stack.length - 1];\n      if(/[\\*\\/]/.test(topEle)) {\n        // 如果栈顶元素优先级比加减高，依次将优先级高的运算符弹出\n        while(stack.length > 0 && /[\\*\\/]/.test(topEle)) {\n          output.push(stack.pop());\n          topEle = stack[stack.length - 1];\n        }\n      }\n      stack.push(ele);\n    } else if(/[\\*\\/\\)]/.test(ele)) {\n      // 如果是乘除或右括号，入栈\n      stack.push(ele);\n    } else {\n\n      // 如果是左括号，依次弹出至右括号\n      let topEle = stack.pop();\n      while(topEle !== ')') {\n        output.push(topEle);\n        topEle = stack.pop();\n      }\n    }\n  }\n\n  // 将栈剩余的元素依次弹出\n  while(stack.length > 0) {\n    output.push(stack.pop());\n  }\n\n  return output.reverse().join(',');\n}\n```\n\n### 计算前缀表达式\n\n前缀表达式的计算也使用到了栈，规则如下：\n\n1. 从右至左扫描表达式\n  - 如果当前字符是数字，入栈\n  - 如果当前字符是运算符，栈弹出两个元素，进行运算，并将结果入栈\n2. 重复上述过程，直到扫描结束\n\n继续以 `-*3+594` 为例，计算如下：\n\n1. 栈:[4]\n2. 栈:[4, 9]\n3. 栈:[4, 9, 5]\n4. 计算 `5 + 9`，得到结果 14 压入栈中。栈:[4, 14]\n5. 栈:[4, 14, 3]\n6. 计算 `3 * 14`，得到结果 42 压入栈中。栈:[4, 42]\n7. 计算 `42 - 4`，得到结果 38 压入栈中。栈:[38]\n\n最后结果即为 48。\n\njavascript 实现：\n```javascript\n/**\n * 计算前缀表达式\n * @param  {string} preExpress 前缀表达式\n * @return {number}            结果\n */\nfunction calculate(preExpress) {\n  let chars = preExpress.split(',');\n  let nums = [];\n  while(chars.length > 0) {\n    let ele = chars.pop();\n    if(/\\d+/.test(ele)) {\n      nums.push(ele);\n    } else {\n      let left = +nums.pop();\n      let right = +nums.pop();\n      switch (ele) {\n        case '+':\n          nums.push(left + right);\n          break;\n        case '-':\n          nums.push(left - right);\n          break;\n        case '*':\n          nums.push(left * right);\n          break;\n        case '/':\n          nums.push(left / right);\n          break;\n      }\n    }\n  }\n  return nums[0];\n}\n```\n\n## 排列\n对于 `1, 2, 3, 4`，四个数字，我们知道一共有 `4! = 24` 种排列。\n\n而事实上，这二十四种排列是从第一个数字开始，依次与后面的数字交换而来的。\n\n- 1, 2 交换: `2, 1, 3, 4`\n- 1, 3 交换：`2, 3, 1, 4`\n- 1, 4 交换：`2, 3, 4, 1`\n- 1, 2 交换：`1, 3, 4, 2`\n- 1, 3 交换：`3, 1, 4, 2`\n- ...依次类推\n\n所以只要在 `n!` 时间内，就能得出所有可能情况\n\njavascript 实现\n```javascript\nfunction createExpress(nums) {\n  let noBraket = [], oneBraket = [], twoBraket = [];\n\n  let swapIndex = 0;\n  for(let i = 0; i < 24; i++) {\n    swap(swapIndex);\n    swapIndex == nums.length - 1 ? swapIndex = 0 : swapIndex++;\n    // nums 即为一个排列\n  }\n\n  function swap(i) {\n    if(i < nums.length - 1) {\n      [nums[i], nums[i + 1]] = [nums[i + 1], nums[i]];\n    } else {\n      [nums[i], nums[0]] = [nums[0], nums[i]];\n    }\n  }\n}\n```\n\n## 添加括号\n\n式子列出之后，需要给表达式添加括号，实际上有括号的可能情况只有两种: 只有一个括号和有两个括号。而每种情况都只有 5 种情况。\n\n1. 一个括号\n  - (1 2) 3 4\n  - (1 2 3) 4\n  - 1 (2 3) 4\n  - 1 (2 3 4)\n  - 1 2 (3 4)\n2. 两个括号\n  - (1 2) (3 4)\n  - ((1 2) 3) 4\n  - (1 (2 3)) 4\n  - 1 ((2 3) 4)\n  - 1 (2 (3 4))\n\n## TODO\n\n解决了以上问题之后，基本能算出所有的可能情况了，剩下的问题在于如何去除重复，和判断重复情况。\n\n比如 `(1 + 2 + 3) * 5` 和 `5 * (1 + 2 + 3)` 应该判断为同一种情况。\n\n## 所有代码\n```javascript\nlet nums = process.argv.slice(2, 6);\n\ncreateExpress(nums);\n// translate('(3+(3+4)*5');\n\nfunction createExpress(nums) {\n  let noBraket = [], oneBraket = [], twoBraket = [];\n\n  let swapIndex = 0;\n  for(let i = 0; i < 24; i++) {\n    swap(swapIndex);\n    swapIndex == nums.length - 1 ? swapIndex = 0 : swapIndex++;\n\n    // 表达式\n    let operTypes = ['+', '-', '*', '/'];\n    for (let j = 0; j < operTypes.length; j++) {\n      for (let k = 0; k < operTypes.length; k++) {\n        for (let l = 0; l < operTypes.length; l++) {\n          let express = `${nums[0]}${operTypes[j]}${nums[1]}${operTypes[k]}${nums[2]}${operTypes[l]}${nums[3]}`;\n          // console.log(express)\n          noBraket.push(express);\n\n          // 当不是全部都是同样优先级时才加括号\n          if(!isSamePriority(operTypes[j], operTypes[k], operTypes[l])) {\n            // 加一个括号\n            oneBraket.push(addBraket(express, {\n              0: '(',\n              4: ')'\n            }));\n            oneBraket.push(addBraket(express, {\n              2: '(',\n              6: ')'\n            }));\n            oneBraket.push(addBraket(express, {\n              4: '(',\n              8: ')'\n            }));\n            oneBraket.push(addBraket(express, {\n              0: '(',\n              6: ')'\n            }));\n            oneBraket.push(addBraket(express, {\n              2: '(',\n              8: ')'\n            }));\n\n            // 加两个括号\n            twoBraket.push(addBraket(express, {\n              0: '(',\n              4: ')',\n              6: '(',\n              10: ')'\n            }));\n            twoBraket.push(addBraket(express, {\n              0: '(',\n              1: '(',\n              5: ')',\n              8: ')'\n            }));\n            twoBraket.push(addBraket(express, {\n              2: '(',\n              3: '(',\n              7: ')',\n              10: ')'\n            }));\n            twoBraket.push(addBraket(express, {\n              0: '(',\n              3: '(',\n              7: ')',\n              8: ')'\n            }));\n            twoBraket.push(addBraket(express, {\n              2: '(',\n              5: '(',\n              9: ')',\n              10: ')'\n            }));\n          }\n        }\n      }\n    }\n\n    let expresses = noBraket.concat(oneBraket).concat(twoBraket);\n    for (let i = 0; i < expresses.length; i++) {\n      // if(expresses[i] == '')\n      // console.log(expresses[i], calculate(translate(expresses[i])))\n      if(calculate(translate(expresses[i])) == 24) {\n        console.log(expresses[i]);\n      }\n    }\n  }\n\n  function isSamePriority() {\n    let opers = Array.from(arguments).join('');\n    if((opers.match(/[\\+\\-]/g) && opers.match(/[\\+\\-]/g).length == opers.length)\n      || (opers.match(/[\\*\\/]/g) && opers.match(/[\\*\\/]/g).length == opers.length)) {\n      return true;\n    }\n    return false;\n  }\n\n  function addBraket(express, param) {\n    let chars = express.match(/(\\d+)|[^\\d]/g);\n    for(let pos in param) {\n      chars.splice(+pos, 0, param[pos]);\n    }\n    return chars.join('');\n  }\n\n  function swap(i) {\n    if(i < nums.length - 1) {\n      [nums[i], nums[i + 1]] = [nums[i + 1], nums[i]];\n    } else {\n      [nums[i], nums[0]] = [nums[0], nums[i]];\n    }\n  }\n}\n\n/**\n * 中缀表达式转前缀表达式\n * @param  {string} inExpress 中缀表达式\n * @return {string}           前缀表达式\n */\nfunction translate(inExpress) {\n  if(inExpress == '') {\n    throw new Error('表达式为空');\n  }\n  // 输出前缀表达式\n  let output = [];\n  // 反转\n  let chars = inExpress.match(/(\\d+)|[^\\d]/g).reverse();\n  // 存放运算符的栈\n  let stack = [];\n  for(let ele of chars) {\n    if(/\\d+/.test(ele)) {\n      // 如果是数字，直接输出\n      output.push(ele);\n    } else if(/[\\+\\-]/.test(ele)) {\n      // 栈顶元素\n      let topEle = stack[stack.length - 1];\n      if(/[\\*\\/]/.test(topEle)) {\n        // 如果栈顶元素优先级比加减高，依次将优先级高的运算符弹出\n        while(stack.length > 0 && /[\\*\\/]/.test(topEle)) {\n          output.push(stack.pop());\n          topEle = stack[stack.length - 1];\n        }\n      }\n      stack.push(ele);\n    } else if(/[\\*\\/\\)]/.test(ele)) {\n      // 如果是乘除或右括号，入栈\n      stack.push(ele);\n    } else {\n\n      // 如果是左括号，依次弹出至右括号\n      let topEle = stack.pop();\n      while(topEle !== ')') {\n        output.push(topEle);\n        topEle = stack.pop();\n      }\n    }\n  }\n\n  // 将栈剩余的元素依次弹出\n  while(stack.length > 0) {\n    output.push(stack.pop());\n  }\n\n  return output.reverse().join(',');\n}\n\n/**\n * 计算前缀表达式\n * @param  {string} preExpress 前缀表达式\n * @return {number}            结果\n */\nfunction calculate(preExpress) {\n  let chars = preExpress.split(',');\n  let nums = [];\n  while(chars.length > 0) {\n    let ele = chars.pop();\n    if(/\\d+/.test(ele)) {\n      nums.push(ele);\n    } else {\n      let left = +nums.pop();\n      let right = +nums.pop();\n      switch (ele) {\n        case '+':\n          nums.push(left + right);\n          break;\n        case '-':\n          nums.push(left - right);\n          break;\n        case '*':\n          nums.push(left * right);\n          break;\n        case '/':\n          nums.push(left / right);\n          break;\n      }\n    }\n  }\n  return nums[0];\n}\n```\n","source":"_posts/calculate-24-game.md","raw":"---\ntitle: 24点\ndate: 2016-07-19 17:15:34\ntags: [总结]\n---\n\n从北戴河回来的时候，和水哥在火车上玩 24 点，玩着玩着就聊到了求 24 点的实现（可怕的程序猿\n\n先考虑简单实现，即只有加减乘除四则运算。很直接的思路就是列出所有可能的表达式，依次求和，最后找出结果等于 24 的情况。\n\n这里涉及到两个关键点，一个是通过数字求出所有表达式，另一个是根据式子计算结果。\n\n求所有表达式可以理解为求四个数字的排列，然后插入运算符即可；根据式子计算结果我们可以利用前缀表达式做到。\n\n<!-- more -->\n\n## 前缀表达式\n\n我们平常使用的式子比如 `3*(5+9)-4`，称为中缀表达式，运算符夹在数字的中间，是人类易于理解的表达式。而计算机很难识别这种表达式，一是括号改变了式子的运行顺序，另外各种运算符之间存在优先级大小关系。\n\n相比而言，前缀表达式是计算机容易计算的，像上面这个例子，如果用前缀表达式来描述则是 `-*3+594`。可以看到前缀表达式中去掉了括号，运算符跑到了计算数字的左边。\n\n### 中缀表达式转换为前缀表达式\n\n中缀表达式转换为前缀表达式需要经过以下步骤：\n1. 从右至左扫描中缀表达式，从右边第一个字符开始判断\n  - 如果当前字符是数字，则将数字直接输出。\n  - 如果是运算符，栈顶也是运算符，则比较优先级：如果当前运算符的优先级大于等于栈顶运算符的优先级，运算符入栈，如果当前运算符的优先级小于栈顶运算符的优先级，将栈顶运算符弹出并输出，直到当前运算符的优先级大于等于栈顶运算符的优先级。\n  - 如果是运算符，栈顶为括号或栈为空，入栈。\n  - 如果是右括号，则入栈。\n  - 如果是左括号，将所有的运算符全部出栈并输出，直到栈顶为右括号，最后将左右的两括号一起删除。\n2. 重复上述操作直至扫描结束，将栈内剩余运算符全部出栈并输出，最后逆序输出字符串。\n\n以 `3*(5+9)-4` 为例，过程如下：\n1. 字符为 4\n  > 如果当前字符是数字，则将数字直接输出。\n\n  - 输出序列：4\n  - 栈：[]\n\n2. 字符为 -\n  > 如果是运算符，栈顶为括号或栈为空，入栈。\n\n  - 输出序列：4\n  - 栈：[-]\n\n3. 字符为 )\n  > 如果是右括号，则入栈。\n\n  - 输出序列：4\n  - 栈：[-, )]\n\n4. 字符为 9\n\n  - 输出序列：49\n  - 栈：[-, )]\n\n5. 字符为 +\n  > 如果是运算符，栈顶为括号或栈为空，入栈。\n\n  - 输出序列：49\n  - 栈：[-, ), +]\n\n6. 字符为 5\n\n  - 输出序列：495\n  - 栈：[-, ), +]\n\n7. 字符为 (\n  > 如果是左括号，将所有的运算符全部出栈并输出，直到栈顶为右括号，最后将左右的两括号一起删除。\n\n  输出序列：495+\n  栈：[-]\n\n8. 字符为 *\n  > 如果当前运算符的优先级大于等于栈顶运算符的优先级，运算符入栈\n\n  - 输出序列：495+\n  - 栈：[-, \\*]\n\n9. 字符为 3\n  - 输出序列：495+3\n  - 栈：[-, \\*]\n\n10. 结束\n  > 将栈内剩余运算符全部出栈并输出，最后逆序输出字符串。\n\n  - 输出序列：`495+3*-`\n  - 逆序：`-*3+594`\n\n所以最后结果为 `-*3+594`。\n\njavascript实现如下：\n\n```javascript\n/**\n * 中缀表达式转前缀表达式\n * @param  {string} inExpress 中缀表达式\n * @return {string}           前缀表达式\n */\nfunction translate(inExpress) {\n  if(inExpress == '') {\n    throw new Error('表达式为空');\n  }\n  // 输出前缀表达式\n  let output = [];\n  // 反转\n  let chars = inExpress.match(/(\\d+)|[^\\d]/g).reverse();\n  // 存放运算符的栈\n  let stack = [];\n  for(let ele of chars) {\n    if(/\\d+/.test(ele)) {\n      // 如果是数字，直接输出\n      output.push(ele);\n    } else if(/[\\+\\-]/.test(ele)) {\n      // 栈顶元素\n      let topEle = stack[stack.length - 1];\n      if(/[\\*\\/]/.test(topEle)) {\n        // 如果栈顶元素优先级比加减高，依次将优先级高的运算符弹出\n        while(stack.length > 0 && /[\\*\\/]/.test(topEle)) {\n          output.push(stack.pop());\n          topEle = stack[stack.length - 1];\n        }\n      }\n      stack.push(ele);\n    } else if(/[\\*\\/\\)]/.test(ele)) {\n      // 如果是乘除或右括号，入栈\n      stack.push(ele);\n    } else {\n\n      // 如果是左括号，依次弹出至右括号\n      let topEle = stack.pop();\n      while(topEle !== ')') {\n        output.push(topEle);\n        topEle = stack.pop();\n      }\n    }\n  }\n\n  // 将栈剩余的元素依次弹出\n  while(stack.length > 0) {\n    output.push(stack.pop());\n  }\n\n  return output.reverse().join(',');\n}\n```\n\n### 计算前缀表达式\n\n前缀表达式的计算也使用到了栈，规则如下：\n\n1. 从右至左扫描表达式\n  - 如果当前字符是数字，入栈\n  - 如果当前字符是运算符，栈弹出两个元素，进行运算，并将结果入栈\n2. 重复上述过程，直到扫描结束\n\n继续以 `-*3+594` 为例，计算如下：\n\n1. 栈:[4]\n2. 栈:[4, 9]\n3. 栈:[4, 9, 5]\n4. 计算 `5 + 9`，得到结果 14 压入栈中。栈:[4, 14]\n5. 栈:[4, 14, 3]\n6. 计算 `3 * 14`，得到结果 42 压入栈中。栈:[4, 42]\n7. 计算 `42 - 4`，得到结果 38 压入栈中。栈:[38]\n\n最后结果即为 48。\n\njavascript 实现：\n```javascript\n/**\n * 计算前缀表达式\n * @param  {string} preExpress 前缀表达式\n * @return {number}            结果\n */\nfunction calculate(preExpress) {\n  let chars = preExpress.split(',');\n  let nums = [];\n  while(chars.length > 0) {\n    let ele = chars.pop();\n    if(/\\d+/.test(ele)) {\n      nums.push(ele);\n    } else {\n      let left = +nums.pop();\n      let right = +nums.pop();\n      switch (ele) {\n        case '+':\n          nums.push(left + right);\n          break;\n        case '-':\n          nums.push(left - right);\n          break;\n        case '*':\n          nums.push(left * right);\n          break;\n        case '/':\n          nums.push(left / right);\n          break;\n      }\n    }\n  }\n  return nums[0];\n}\n```\n\n## 排列\n对于 `1, 2, 3, 4`，四个数字，我们知道一共有 `4! = 24` 种排列。\n\n而事实上，这二十四种排列是从第一个数字开始，依次与后面的数字交换而来的。\n\n- 1, 2 交换: `2, 1, 3, 4`\n- 1, 3 交换：`2, 3, 1, 4`\n- 1, 4 交换：`2, 3, 4, 1`\n- 1, 2 交换：`1, 3, 4, 2`\n- 1, 3 交换：`3, 1, 4, 2`\n- ...依次类推\n\n所以只要在 `n!` 时间内，就能得出所有可能情况\n\njavascript 实现\n```javascript\nfunction createExpress(nums) {\n  let noBraket = [], oneBraket = [], twoBraket = [];\n\n  let swapIndex = 0;\n  for(let i = 0; i < 24; i++) {\n    swap(swapIndex);\n    swapIndex == nums.length - 1 ? swapIndex = 0 : swapIndex++;\n    // nums 即为一个排列\n  }\n\n  function swap(i) {\n    if(i < nums.length - 1) {\n      [nums[i], nums[i + 1]] = [nums[i + 1], nums[i]];\n    } else {\n      [nums[i], nums[0]] = [nums[0], nums[i]];\n    }\n  }\n}\n```\n\n## 添加括号\n\n式子列出之后，需要给表达式添加括号，实际上有括号的可能情况只有两种: 只有一个括号和有两个括号。而每种情况都只有 5 种情况。\n\n1. 一个括号\n  - (1 2) 3 4\n  - (1 2 3) 4\n  - 1 (2 3) 4\n  - 1 (2 3 4)\n  - 1 2 (3 4)\n2. 两个括号\n  - (1 2) (3 4)\n  - ((1 2) 3) 4\n  - (1 (2 3)) 4\n  - 1 ((2 3) 4)\n  - 1 (2 (3 4))\n\n## TODO\n\n解决了以上问题之后，基本能算出所有的可能情况了，剩下的问题在于如何去除重复，和判断重复情况。\n\n比如 `(1 + 2 + 3) * 5` 和 `5 * (1 + 2 + 3)` 应该判断为同一种情况。\n\n## 所有代码\n```javascript\nlet nums = process.argv.slice(2, 6);\n\ncreateExpress(nums);\n// translate('(3+(3+4)*5');\n\nfunction createExpress(nums) {\n  let noBraket = [], oneBraket = [], twoBraket = [];\n\n  let swapIndex = 0;\n  for(let i = 0; i < 24; i++) {\n    swap(swapIndex);\n    swapIndex == nums.length - 1 ? swapIndex = 0 : swapIndex++;\n\n    // 表达式\n    let operTypes = ['+', '-', '*', '/'];\n    for (let j = 0; j < operTypes.length; j++) {\n      for (let k = 0; k < operTypes.length; k++) {\n        for (let l = 0; l < operTypes.length; l++) {\n          let express = `${nums[0]}${operTypes[j]}${nums[1]}${operTypes[k]}${nums[2]}${operTypes[l]}${nums[3]}`;\n          // console.log(express)\n          noBraket.push(express);\n\n          // 当不是全部都是同样优先级时才加括号\n          if(!isSamePriority(operTypes[j], operTypes[k], operTypes[l])) {\n            // 加一个括号\n            oneBraket.push(addBraket(express, {\n              0: '(',\n              4: ')'\n            }));\n            oneBraket.push(addBraket(express, {\n              2: '(',\n              6: ')'\n            }));\n            oneBraket.push(addBraket(express, {\n              4: '(',\n              8: ')'\n            }));\n            oneBraket.push(addBraket(express, {\n              0: '(',\n              6: ')'\n            }));\n            oneBraket.push(addBraket(express, {\n              2: '(',\n              8: ')'\n            }));\n\n            // 加两个括号\n            twoBraket.push(addBraket(express, {\n              0: '(',\n              4: ')',\n              6: '(',\n              10: ')'\n            }));\n            twoBraket.push(addBraket(express, {\n              0: '(',\n              1: '(',\n              5: ')',\n              8: ')'\n            }));\n            twoBraket.push(addBraket(express, {\n              2: '(',\n              3: '(',\n              7: ')',\n              10: ')'\n            }));\n            twoBraket.push(addBraket(express, {\n              0: '(',\n              3: '(',\n              7: ')',\n              8: ')'\n            }));\n            twoBraket.push(addBraket(express, {\n              2: '(',\n              5: '(',\n              9: ')',\n              10: ')'\n            }));\n          }\n        }\n      }\n    }\n\n    let expresses = noBraket.concat(oneBraket).concat(twoBraket);\n    for (let i = 0; i < expresses.length; i++) {\n      // if(expresses[i] == '')\n      // console.log(expresses[i], calculate(translate(expresses[i])))\n      if(calculate(translate(expresses[i])) == 24) {\n        console.log(expresses[i]);\n      }\n    }\n  }\n\n  function isSamePriority() {\n    let opers = Array.from(arguments).join('');\n    if((opers.match(/[\\+\\-]/g) && opers.match(/[\\+\\-]/g).length == opers.length)\n      || (opers.match(/[\\*\\/]/g) && opers.match(/[\\*\\/]/g).length == opers.length)) {\n      return true;\n    }\n    return false;\n  }\n\n  function addBraket(express, param) {\n    let chars = express.match(/(\\d+)|[^\\d]/g);\n    for(let pos in param) {\n      chars.splice(+pos, 0, param[pos]);\n    }\n    return chars.join('');\n  }\n\n  function swap(i) {\n    if(i < nums.length - 1) {\n      [nums[i], nums[i + 1]] = [nums[i + 1], nums[i]];\n    } else {\n      [nums[i], nums[0]] = [nums[0], nums[i]];\n    }\n  }\n}\n\n/**\n * 中缀表达式转前缀表达式\n * @param  {string} inExpress 中缀表达式\n * @return {string}           前缀表达式\n */\nfunction translate(inExpress) {\n  if(inExpress == '') {\n    throw new Error('表达式为空');\n  }\n  // 输出前缀表达式\n  let output = [];\n  // 反转\n  let chars = inExpress.match(/(\\d+)|[^\\d]/g).reverse();\n  // 存放运算符的栈\n  let stack = [];\n  for(let ele of chars) {\n    if(/\\d+/.test(ele)) {\n      // 如果是数字，直接输出\n      output.push(ele);\n    } else if(/[\\+\\-]/.test(ele)) {\n      // 栈顶元素\n      let topEle = stack[stack.length - 1];\n      if(/[\\*\\/]/.test(topEle)) {\n        // 如果栈顶元素优先级比加减高，依次将优先级高的运算符弹出\n        while(stack.length > 0 && /[\\*\\/]/.test(topEle)) {\n          output.push(stack.pop());\n          topEle = stack[stack.length - 1];\n        }\n      }\n      stack.push(ele);\n    } else if(/[\\*\\/\\)]/.test(ele)) {\n      // 如果是乘除或右括号，入栈\n      stack.push(ele);\n    } else {\n\n      // 如果是左括号，依次弹出至右括号\n      let topEle = stack.pop();\n      while(topEle !== ')') {\n        output.push(topEle);\n        topEle = stack.pop();\n      }\n    }\n  }\n\n  // 将栈剩余的元素依次弹出\n  while(stack.length > 0) {\n    output.push(stack.pop());\n  }\n\n  return output.reverse().join(',');\n}\n\n/**\n * 计算前缀表达式\n * @param  {string} preExpress 前缀表达式\n * @return {number}            结果\n */\nfunction calculate(preExpress) {\n  let chars = preExpress.split(',');\n  let nums = [];\n  while(chars.length > 0) {\n    let ele = chars.pop();\n    if(/\\d+/.test(ele)) {\n      nums.push(ele);\n    } else {\n      let left = +nums.pop();\n      let right = +nums.pop();\n      switch (ele) {\n        case '+':\n          nums.push(left + right);\n          break;\n        case '-':\n          nums.push(left - right);\n          break;\n        case '*':\n          nums.push(left * right);\n          break;\n        case '/':\n          nums.push(left / right);\n          break;\n      }\n    }\n  }\n  return nums[0];\n}\n```\n","slug":"calculate-24-game","published":1,"updated":"2017-03-17T13:39:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcv8000jn927my3hb8jf","content":"<p>从北戴河回来的时候，和水哥在火车上玩 24 点，玩着玩着就聊到了求 24 点的实现（可怕的程序猿</p>\n<p>先考虑简单实现，即只有加减乘除四则运算。很直接的思路就是列出所有可能的表达式，依次求和，最后找出结果等于 24 的情况。</p>\n<p>这里涉及到两个关键点，一个是通过数字求出所有表达式，另一个是根据式子计算结果。</p>\n<p>求所有表达式可以理解为求四个数字的排列，然后插入运算符即可；根据式子计算结果我们可以利用前缀表达式做到。</p>\n<a id=\"more\"></a>\n<h2 id=\"前缀表达式\"><a href=\"#前缀表达式\" class=\"headerlink\" title=\"前缀表达式\"></a>前缀表达式</h2><p>我们平常使用的式子比如 <code>3*(5+9)-4</code>，称为中缀表达式，运算符夹在数字的中间，是人类易于理解的表达式。而计算机很难识别这种表达式，一是括号改变了式子的运行顺序，另外各种运算符之间存在优先级大小关系。</p>\n<p>相比而言，前缀表达式是计算机容易计算的，像上面这个例子，如果用前缀表达式来描述则是 <code>-*3+594</code>。可以看到前缀表达式中去掉了括号，运算符跑到了计算数字的左边。</p>\n<h3 id=\"中缀表达式转换为前缀表达式\"><a href=\"#中缀表达式转换为前缀表达式\" class=\"headerlink\" title=\"中缀表达式转换为前缀表达式\"></a>中缀表达式转换为前缀表达式</h3><p>中缀表达式转换为前缀表达式需要经过以下步骤：</p>\n<ol>\n<li>从右至左扫描中缀表达式，从右边第一个字符开始判断<ul>\n<li>如果当前字符是数字，则将数字直接输出。</li>\n<li>如果是运算符，栈顶也是运算符，则比较优先级：如果当前运算符的优先级大于等于栈顶运算符的优先级，运算符入栈，如果当前运算符的优先级小于栈顶运算符的优先级，将栈顶运算符弹出并输出，直到当前运算符的优先级大于等于栈顶运算符的优先级。</li>\n<li>如果是运算符，栈顶为括号或栈为空，入栈。</li>\n<li>如果是右括号，则入栈。</li>\n<li>如果是左括号，将所有的运算符全部出栈并输出，直到栈顶为右括号，最后将左右的两括号一起删除。</li>\n</ul>\n</li>\n<li>重复上述操作直至扫描结束，将栈内剩余运算符全部出栈并输出，最后逆序输出字符串。</li>\n</ol>\n<p>以 <code>3*(5+9)-4</code> 为例，过程如下：</p>\n<ol>\n<li><p>字符为 4</p>\n<blockquote>\n<p>如果当前字符是数字，则将数字直接输出。</p>\n</blockquote>\n<ul>\n<li>输出序列：4</li>\n<li>栈：[]</li>\n</ul>\n</li>\n<li><p>字符为 -</p>\n<blockquote>\n<p>如果是运算符，栈顶为括号或栈为空，入栈。</p>\n</blockquote>\n<ul>\n<li>输出序列：4</li>\n<li>栈：[-]</li>\n</ul>\n</li>\n<li><p>字符为 )</p>\n<blockquote>\n<p>如果是右括号，则入栈。</p>\n</blockquote>\n<ul>\n<li>输出序列：4</li>\n<li>栈：[-, )]</li>\n</ul>\n</li>\n<li><p>字符为 9</p>\n<ul>\n<li>输出序列：49</li>\n<li>栈：[-, )]</li>\n</ul>\n</li>\n<li><p>字符为 +</p>\n<blockquote>\n<p>如果是运算符，栈顶为括号或栈为空，入栈。</p>\n</blockquote>\n<ul>\n<li>输出序列：49</li>\n<li>栈：[-, ), +]</li>\n</ul>\n</li>\n<li><p>字符为 5</p>\n<ul>\n<li>输出序列：495</li>\n<li>栈：[-, ), +]</li>\n</ul>\n</li>\n<li><p>字符为 (</p>\n<blockquote>\n<p>如果是左括号，将所有的运算符全部出栈并输出，直到栈顶为右括号，最后将左右的两括号一起删除。</p>\n</blockquote>\n<p>输出序列：495+<br>栈：[-]</p>\n</li>\n<li><p>字符为 *</p>\n<blockquote>\n<p>如果当前运算符的优先级大于等于栈顶运算符的优先级，运算符入栈</p>\n</blockquote>\n<ul>\n<li>输出序列：495+</li>\n<li>栈：[-, *]</li>\n</ul>\n</li>\n<li><p>字符为 3</p>\n<ul>\n<li>输出序列：495+3</li>\n<li>栈：[-, *]</li>\n</ul>\n</li>\n<li><p>结束</p>\n<blockquote>\n<p>将栈内剩余运算符全部出栈并输出，最后逆序输出字符串。</p>\n</blockquote>\n<ul>\n<li>输出序列：<code>495+3*-</code></li>\n<li>逆序：<code>-*3+594</code></li>\n</ul>\n</li>\n</ol>\n<p>所以最后结果为 <code>-*3+594</code>。</p>\n<p>javascript实现如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 中缀表达式转前缀表达式</div><div class=\"line\"> * @param  &#123;string&#125; inExpress 中缀表达式</div><div class=\"line\"> * @return &#123;string&#125;           前缀表达式</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">translate</span>(<span class=\"params\">inExpress</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(inExpress == <span class=\"string\">''</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'表达式为空'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 输出前缀表达式</span></div><div class=\"line\">  <span class=\"keyword\">let</span> output = [];</div><div class=\"line\">  <span class=\"comment\">// 反转</span></div><div class=\"line\">  <span class=\"keyword\">let</span> chars = inExpress.match(<span class=\"regexp\">/(\\d+)|[^\\d]/g</span>).reverse();</div><div class=\"line\">  <span class=\"comment\">// 存放运算符的栈</span></div><div class=\"line\">  <span class=\"keyword\">let</span> stack = [];</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> ele <span class=\"keyword\">of</span> chars) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"regexp\">/\\d+/</span>.test(ele)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果是数字，直接输出</span></div><div class=\"line\">      output.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"regexp\">/[\\+\\-]/</span>.test(ele)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 栈顶元素</span></div><div class=\"line\">      <span class=\"keyword\">let</span> topEle = stack[stack.length - <span class=\"number\">1</span>];</div><div class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"regexp\">/[\\*\\/]/</span>.test(topEle)) &#123;</div><div class=\"line\">        <span class=\"comment\">// 如果栈顶元素优先级比加减高，依次将优先级高的运算符弹出</span></div><div class=\"line\">        <span class=\"keyword\">while</span>(stack.length &gt; <span class=\"number\">0</span> &amp;&amp; <span class=\"regexp\">/[\\*\\/]/</span>.test(topEle)) &#123;</div><div class=\"line\">          output.push(stack.pop());</div><div class=\"line\">          topEle = stack[stack.length - <span class=\"number\">1</span>];</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      stack.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"regexp\">/[\\*\\/\\)]/</span>.test(ele)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果是乘除或右括号，入栈</span></div><div class=\"line\">      stack.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// 如果是左括号，依次弹出至右括号</span></div><div class=\"line\">      <span class=\"keyword\">let</span> topEle = stack.pop();</div><div class=\"line\">      <span class=\"keyword\">while</span>(topEle !== <span class=\"string\">')'</span>) &#123;</div><div class=\"line\">        output.push(topEle);</div><div class=\"line\">        topEle = stack.pop();</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 将栈剩余的元素依次弹出</span></div><div class=\"line\">  <span class=\"keyword\">while</span>(stack.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    output.push(stack.pop());</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> output.reverse().join(<span class=\"string\">','</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"计算前缀表达式\"><a href=\"#计算前缀表达式\" class=\"headerlink\" title=\"计算前缀表达式\"></a>计算前缀表达式</h3><p>前缀表达式的计算也使用到了栈，规则如下：</p>\n<ol>\n<li>从右至左扫描表达式<ul>\n<li>如果当前字符是数字，入栈</li>\n<li>如果当前字符是运算符，栈弹出两个元素，进行运算，并将结果入栈</li>\n</ul>\n</li>\n<li>重复上述过程，直到扫描结束</li>\n</ol>\n<p>继续以 <code>-*3+594</code> 为例，计算如下：</p>\n<ol>\n<li>栈:[4]</li>\n<li>栈:[4, 9]</li>\n<li>栈:[4, 9, 5]</li>\n<li>计算 <code>5 + 9</code>，得到结果 14 压入栈中。栈:[4, 14]</li>\n<li>栈:[4, 14, 3]</li>\n<li>计算 <code>3 * 14</code>，得到结果 42 压入栈中。栈:[4, 42]</li>\n<li>计算 <code>42 - 4</code>，得到结果 38 压入栈中。栈:[38]</li>\n</ol>\n<p>最后结果即为 48。</p>\n<p>javascript 实现：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 计算前缀表达式</div><div class=\"line\"> * @param  &#123;string&#125; preExpress 前缀表达式</div><div class=\"line\"> * @return &#123;number&#125;            结果</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">calculate</span>(<span class=\"params\">preExpress</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> chars = preExpress.split(<span class=\"string\">','</span>);</div><div class=\"line\">  <span class=\"keyword\">let</span> nums = [];</div><div class=\"line\">  <span class=\"keyword\">while</span>(chars.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> ele = chars.pop();</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"regexp\">/\\d+/</span>.test(ele)) &#123;</div><div class=\"line\">      nums.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> left = +nums.pop();</div><div class=\"line\">      <span class=\"keyword\">let</span> right = +nums.pop();</div><div class=\"line\">      <span class=\"keyword\">switch</span> (ele) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'+'</span>:</div><div class=\"line\">          nums.push(left + right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'-'</span>:</div><div class=\"line\">          nums.push(left - right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'*'</span>:</div><div class=\"line\">          nums.push(left * right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'/'</span>:</div><div class=\"line\">          nums.push(left / right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"排列\"><a href=\"#排列\" class=\"headerlink\" title=\"排列\"></a>排列</h2><p>对于 <code>1, 2, 3, 4</code>，四个数字，我们知道一共有 <code>4! = 24</code> 种排列。</p>\n<p>而事实上，这二十四种排列是从第一个数字开始，依次与后面的数字交换而来的。</p>\n<ul>\n<li>1, 2 交换: <code>2, 1, 3, 4</code></li>\n<li>1, 3 交换：<code>2, 3, 1, 4</code></li>\n<li>1, 4 交换：<code>2, 3, 4, 1</code></li>\n<li>1, 2 交换：<code>1, 3, 4, 2</code></li>\n<li>1, 3 交换：<code>3, 1, 4, 2</code></li>\n<li>…依次类推</li>\n</ul>\n<p>所以只要在 <code>n!</code> 时间内，就能得出所有可能情况</p>\n<p>javascript 实现<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createExpress</span>(<span class=\"params\">nums</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> noBraket = [], oneBraket = [], twoBraket = [];</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">let</span> swapIndex = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">24</span>; i++) &#123;</div><div class=\"line\">    swap(swapIndex);</div><div class=\"line\">    swapIndex == nums.length - <span class=\"number\">1</span> ? swapIndex = <span class=\"number\">0</span> : swapIndex++;</div><div class=\"line\">    <span class=\"comment\">// nums 即为一个排列</span></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span>(<span class=\"params\">i</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(i &lt; nums.length - <span class=\"number\">1</span>) &#123;</div><div class=\"line\">      [nums[i], nums[i + <span class=\"number\">1</span>]] = [nums[i + <span class=\"number\">1</span>], nums[i]];</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      [nums[i], nums[<span class=\"number\">0</span>]] = [nums[<span class=\"number\">0</span>], nums[i]];</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"添加括号\"><a href=\"#添加括号\" class=\"headerlink\" title=\"添加括号\"></a>添加括号</h2><p>式子列出之后，需要给表达式添加括号，实际上有括号的可能情况只有两种: 只有一个括号和有两个括号。而每种情况都只有 5 种情况。</p>\n<ol>\n<li>一个括号<ul>\n<li>(1 2) 3 4</li>\n<li>(1 2 3) 4</li>\n<li>1 (2 3) 4</li>\n<li>1 (2 3 4)</li>\n<li>1 2 (3 4)</li>\n</ul>\n</li>\n<li>两个括号<ul>\n<li>(1 2) (3 4)</li>\n<li>((1 2) 3) 4</li>\n<li>(1 (2 3)) 4</li>\n<li>1 ((2 3) 4)</li>\n<li>1 (2 (3 4))</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"TODO\"><a href=\"#TODO\" class=\"headerlink\" title=\"TODO\"></a>TODO</h2><p>解决了以上问题之后，基本能算出所有的可能情况了，剩下的问题在于如何去除重复，和判断重复情况。</p>\n<p>比如 <code>(1 + 2 + 3) * 5</code> 和 <code>5 * (1 + 2 + 3)</code> 应该判断为同一种情况。</p>\n<h2 id=\"所有代码\"><a href=\"#所有代码\" class=\"headerlink\" title=\"所有代码\"></a>所有代码</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> nums = process.argv.slice(<span class=\"number\">2</span>, <span class=\"number\">6</span>);</div><div class=\"line\"></div><div class=\"line\">createExpress(nums);</div><div class=\"line\"><span class=\"comment\">// translate('(3+(3+4)*5');</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createExpress</span>(<span class=\"params\">nums</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> noBraket = [], oneBraket = [], twoBraket = [];</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">let</span> swapIndex = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">24</span>; i++) &#123;</div><div class=\"line\">    swap(swapIndex);</div><div class=\"line\">    swapIndex == nums.length - <span class=\"number\">1</span> ? swapIndex = <span class=\"number\">0</span> : swapIndex++;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 表达式</span></div><div class=\"line\">    <span class=\"keyword\">let</span> operTypes = [<span class=\"string\">'+'</span>, <span class=\"string\">'-'</span>, <span class=\"string\">'*'</span>, <span class=\"string\">'/'</span>];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; operTypes.length; j++) &#123;</div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k = <span class=\"number\">0</span>; k &lt; operTypes.length; k++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> l = <span class=\"number\">0</span>; l &lt; operTypes.length; l++) &#123;</div><div class=\"line\">          <span class=\"keyword\">let</span> express = <span class=\"string\">`<span class=\"subst\">$&#123;nums[<span class=\"number\">0</span>]&#125;</span><span class=\"subst\">$&#123;operTypes[j]&#125;</span><span class=\"subst\">$&#123;nums[<span class=\"number\">1</span>]&#125;</span><span class=\"subst\">$&#123;operTypes[k]&#125;</span><span class=\"subst\">$&#123;nums[<span class=\"number\">2</span>]&#125;</span><span class=\"subst\">$&#123;operTypes[l]&#125;</span><span class=\"subst\">$&#123;nums[<span class=\"number\">3</span>]&#125;</span>`</span>;</div><div class=\"line\">          <span class=\"comment\">// console.log(express)</span></div><div class=\"line\">          noBraket.push(express);</div><div class=\"line\"></div><div class=\"line\">          <span class=\"comment\">// 当不是全部都是同样优先级时才加括号</span></div><div class=\"line\">          <span class=\"keyword\">if</span>(!isSamePriority(operTypes[j], operTypes[k], operTypes[l])) &#123;</div><div class=\"line\">            <span class=\"comment\">// 加一个括号</span></div><div class=\"line\">            oneBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">0</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">4</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            oneBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">2</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">6</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            oneBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">4</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">8</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            oneBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">0</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">6</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            oneBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">2</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">8</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// 加两个括号</span></div><div class=\"line\">            twoBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">0</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">4</span>: <span class=\"string\">')'</span>,</div><div class=\"line\">              <span class=\"number\">6</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">10</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            twoBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">0</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">1</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">5</span>: <span class=\"string\">')'</span>,</div><div class=\"line\">              <span class=\"number\">8</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            twoBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">2</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">3</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">7</span>: <span class=\"string\">')'</span>,</div><div class=\"line\">              <span class=\"number\">10</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            twoBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">0</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">3</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">7</span>: <span class=\"string\">')'</span>,</div><div class=\"line\">              <span class=\"number\">8</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            twoBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">2</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">5</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">9</span>: <span class=\"string\">')'</span>,</div><div class=\"line\">              <span class=\"number\">10</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">let</span> expresses = noBraket.concat(oneBraket).concat(twoBraket);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; expresses.length; i++) &#123;</div><div class=\"line\">      <span class=\"comment\">// if(expresses[i] == '')</span></div><div class=\"line\">      <span class=\"comment\">// console.log(expresses[i], calculate(translate(expresses[i])))</span></div><div class=\"line\">      <span class=\"keyword\">if</span>(calculate(translate(expresses[i])) == <span class=\"number\">24</span>) &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(expresses[i]);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isSamePriority</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> opers = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>).join(<span class=\"string\">''</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span>((opers.match(<span class=\"regexp\">/[\\+\\-]/g</span>) &amp;&amp; opers.match(<span class=\"regexp\">/[\\+\\-]/g</span>).length == opers.length)</div><div class=\"line\">      || (opers.match(<span class=\"regexp\">/[\\*\\/]/g</span>) &amp;&amp; opers.match(<span class=\"regexp\">/[\\*\\/]/g</span>).length == opers.length)) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addBraket</span>(<span class=\"params\">express, param</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> chars = express.match(<span class=\"regexp\">/(\\d+)|[^\\d]/g</span>);</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> pos <span class=\"keyword\">in</span> param) &#123;</div><div class=\"line\">      chars.splice(+pos, <span class=\"number\">0</span>, param[pos]);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> chars.join(<span class=\"string\">''</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span>(<span class=\"params\">i</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(i &lt; nums.length - <span class=\"number\">1</span>) &#123;</div><div class=\"line\">      [nums[i], nums[i + <span class=\"number\">1</span>]] = [nums[i + <span class=\"number\">1</span>], nums[i]];</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      [nums[i], nums[<span class=\"number\">0</span>]] = [nums[<span class=\"number\">0</span>], nums[i]];</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 中缀表达式转前缀表达式</div><div class=\"line\"> * @param  &#123;string&#125; inExpress 中缀表达式</div><div class=\"line\"> * @return &#123;string&#125;           前缀表达式</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">translate</span>(<span class=\"params\">inExpress</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(inExpress == <span class=\"string\">''</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'表达式为空'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 输出前缀表达式</span></div><div class=\"line\">  <span class=\"keyword\">let</span> output = [];</div><div class=\"line\">  <span class=\"comment\">// 反转</span></div><div class=\"line\">  <span class=\"keyword\">let</span> chars = inExpress.match(<span class=\"regexp\">/(\\d+)|[^\\d]/g</span>).reverse();</div><div class=\"line\">  <span class=\"comment\">// 存放运算符的栈</span></div><div class=\"line\">  <span class=\"keyword\">let</span> stack = [];</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> ele <span class=\"keyword\">of</span> chars) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"regexp\">/\\d+/</span>.test(ele)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果是数字，直接输出</span></div><div class=\"line\">      output.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"regexp\">/[\\+\\-]/</span>.test(ele)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 栈顶元素</span></div><div class=\"line\">      <span class=\"keyword\">let</span> topEle = stack[stack.length - <span class=\"number\">1</span>];</div><div class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"regexp\">/[\\*\\/]/</span>.test(topEle)) &#123;</div><div class=\"line\">        <span class=\"comment\">// 如果栈顶元素优先级比加减高，依次将优先级高的运算符弹出</span></div><div class=\"line\">        <span class=\"keyword\">while</span>(stack.length &gt; <span class=\"number\">0</span> &amp;&amp; <span class=\"regexp\">/[\\*\\/]/</span>.test(topEle)) &#123;</div><div class=\"line\">          output.push(stack.pop());</div><div class=\"line\">          topEle = stack[stack.length - <span class=\"number\">1</span>];</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      stack.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"regexp\">/[\\*\\/\\)]/</span>.test(ele)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果是乘除或右括号，入栈</span></div><div class=\"line\">      stack.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// 如果是左括号，依次弹出至右括号</span></div><div class=\"line\">      <span class=\"keyword\">let</span> topEle = stack.pop();</div><div class=\"line\">      <span class=\"keyword\">while</span>(topEle !== <span class=\"string\">')'</span>) &#123;</div><div class=\"line\">        output.push(topEle);</div><div class=\"line\">        topEle = stack.pop();</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 将栈剩余的元素依次弹出</span></div><div class=\"line\">  <span class=\"keyword\">while</span>(stack.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    output.push(stack.pop());</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> output.reverse().join(<span class=\"string\">','</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 计算前缀表达式</div><div class=\"line\"> * @param  &#123;string&#125; preExpress 前缀表达式</div><div class=\"line\"> * @return &#123;number&#125;            结果</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">calculate</span>(<span class=\"params\">preExpress</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> chars = preExpress.split(<span class=\"string\">','</span>);</div><div class=\"line\">  <span class=\"keyword\">let</span> nums = [];</div><div class=\"line\">  <span class=\"keyword\">while</span>(chars.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> ele = chars.pop();</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"regexp\">/\\d+/</span>.test(ele)) &#123;</div><div class=\"line\">      nums.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> left = +nums.pop();</div><div class=\"line\">      <span class=\"keyword\">let</span> right = +nums.pop();</div><div class=\"line\">      <span class=\"keyword\">switch</span> (ele) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'+'</span>:</div><div class=\"line\">          nums.push(left + right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'-'</span>:</div><div class=\"line\">          nums.push(left - right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'*'</span>:</div><div class=\"line\">          nums.push(left * right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'/'</span>:</div><div class=\"line\">          nums.push(left / right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"<p>从北戴河回来的时候，和水哥在火车上玩 24 点，玩着玩着就聊到了求 24 点的实现（可怕的程序猿</p>\n<p>先考虑简单实现，即只有加减乘除四则运算。很直接的思路就是列出所有可能的表达式，依次求和，最后找出结果等于 24 的情况。</p>\n<p>这里涉及到两个关键点，一个是通过数字求出所有表达式，另一个是根据式子计算结果。</p>\n<p>求所有表达式可以理解为求四个数字的排列，然后插入运算符即可；根据式子计算结果我们可以利用前缀表达式做到。</p>","more":"<h2 id=\"前缀表达式\"><a href=\"#前缀表达式\" class=\"headerlink\" title=\"前缀表达式\"></a>前缀表达式</h2><p>我们平常使用的式子比如 <code>3*(5+9)-4</code>，称为中缀表达式，运算符夹在数字的中间，是人类易于理解的表达式。而计算机很难识别这种表达式，一是括号改变了式子的运行顺序，另外各种运算符之间存在优先级大小关系。</p>\n<p>相比而言，前缀表达式是计算机容易计算的，像上面这个例子，如果用前缀表达式来描述则是 <code>-*3+594</code>。可以看到前缀表达式中去掉了括号，运算符跑到了计算数字的左边。</p>\n<h3 id=\"中缀表达式转换为前缀表达式\"><a href=\"#中缀表达式转换为前缀表达式\" class=\"headerlink\" title=\"中缀表达式转换为前缀表达式\"></a>中缀表达式转换为前缀表达式</h3><p>中缀表达式转换为前缀表达式需要经过以下步骤：</p>\n<ol>\n<li>从右至左扫描中缀表达式，从右边第一个字符开始判断<ul>\n<li>如果当前字符是数字，则将数字直接输出。</li>\n<li>如果是运算符，栈顶也是运算符，则比较优先级：如果当前运算符的优先级大于等于栈顶运算符的优先级，运算符入栈，如果当前运算符的优先级小于栈顶运算符的优先级，将栈顶运算符弹出并输出，直到当前运算符的优先级大于等于栈顶运算符的优先级。</li>\n<li>如果是运算符，栈顶为括号或栈为空，入栈。</li>\n<li>如果是右括号，则入栈。</li>\n<li>如果是左括号，将所有的运算符全部出栈并输出，直到栈顶为右括号，最后将左右的两括号一起删除。</li>\n</ul>\n</li>\n<li>重复上述操作直至扫描结束，将栈内剩余运算符全部出栈并输出，最后逆序输出字符串。</li>\n</ol>\n<p>以 <code>3*(5+9)-4</code> 为例，过程如下：</p>\n<ol>\n<li><p>字符为 4</p>\n<blockquote>\n<p>如果当前字符是数字，则将数字直接输出。</p>\n</blockquote>\n<ul>\n<li>输出序列：4</li>\n<li>栈：[]</li>\n</ul>\n</li>\n<li><p>字符为 -</p>\n<blockquote>\n<p>如果是运算符，栈顶为括号或栈为空，入栈。</p>\n</blockquote>\n<ul>\n<li>输出序列：4</li>\n<li>栈：[-]</li>\n</ul>\n</li>\n<li><p>字符为 )</p>\n<blockquote>\n<p>如果是右括号，则入栈。</p>\n</blockquote>\n<ul>\n<li>输出序列：4</li>\n<li>栈：[-, )]</li>\n</ul>\n</li>\n<li><p>字符为 9</p>\n<ul>\n<li>输出序列：49</li>\n<li>栈：[-, )]</li>\n</ul>\n</li>\n<li><p>字符为 +</p>\n<blockquote>\n<p>如果是运算符，栈顶为括号或栈为空，入栈。</p>\n</blockquote>\n<ul>\n<li>输出序列：49</li>\n<li>栈：[-, ), +]</li>\n</ul>\n</li>\n<li><p>字符为 5</p>\n<ul>\n<li>输出序列：495</li>\n<li>栈：[-, ), +]</li>\n</ul>\n</li>\n<li><p>字符为 (</p>\n<blockquote>\n<p>如果是左括号，将所有的运算符全部出栈并输出，直到栈顶为右括号，最后将左右的两括号一起删除。</p>\n</blockquote>\n<p>输出序列：495+<br>栈：[-]</p>\n</li>\n<li><p>字符为 *</p>\n<blockquote>\n<p>如果当前运算符的优先级大于等于栈顶运算符的优先级，运算符入栈</p>\n</blockquote>\n<ul>\n<li>输出序列：495+</li>\n<li>栈：[-, *]</li>\n</ul>\n</li>\n<li><p>字符为 3</p>\n<ul>\n<li>输出序列：495+3</li>\n<li>栈：[-, *]</li>\n</ul>\n</li>\n<li><p>结束</p>\n<blockquote>\n<p>将栈内剩余运算符全部出栈并输出，最后逆序输出字符串。</p>\n</blockquote>\n<ul>\n<li>输出序列：<code>495+3*-</code></li>\n<li>逆序：<code>-*3+594</code></li>\n</ul>\n</li>\n</ol>\n<p>所以最后结果为 <code>-*3+594</code>。</p>\n<p>javascript实现如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 中缀表达式转前缀表达式</div><div class=\"line\"> * @param  &#123;string&#125; inExpress 中缀表达式</div><div class=\"line\"> * @return &#123;string&#125;           前缀表达式</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">translate</span>(<span class=\"params\">inExpress</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(inExpress == <span class=\"string\">''</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'表达式为空'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 输出前缀表达式</span></div><div class=\"line\">  <span class=\"keyword\">let</span> output = [];</div><div class=\"line\">  <span class=\"comment\">// 反转</span></div><div class=\"line\">  <span class=\"keyword\">let</span> chars = inExpress.match(<span class=\"regexp\">/(\\d+)|[^\\d]/g</span>).reverse();</div><div class=\"line\">  <span class=\"comment\">// 存放运算符的栈</span></div><div class=\"line\">  <span class=\"keyword\">let</span> stack = [];</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> ele <span class=\"keyword\">of</span> chars) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"regexp\">/\\d+/</span>.test(ele)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果是数字，直接输出</span></div><div class=\"line\">      output.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"regexp\">/[\\+\\-]/</span>.test(ele)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 栈顶元素</span></div><div class=\"line\">      <span class=\"keyword\">let</span> topEle = stack[stack.length - <span class=\"number\">1</span>];</div><div class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"regexp\">/[\\*\\/]/</span>.test(topEle)) &#123;</div><div class=\"line\">        <span class=\"comment\">// 如果栈顶元素优先级比加减高，依次将优先级高的运算符弹出</span></div><div class=\"line\">        <span class=\"keyword\">while</span>(stack.length &gt; <span class=\"number\">0</span> &amp;&amp; <span class=\"regexp\">/[\\*\\/]/</span>.test(topEle)) &#123;</div><div class=\"line\">          output.push(stack.pop());</div><div class=\"line\">          topEle = stack[stack.length - <span class=\"number\">1</span>];</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      stack.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"regexp\">/[\\*\\/\\)]/</span>.test(ele)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果是乘除或右括号，入栈</span></div><div class=\"line\">      stack.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// 如果是左括号，依次弹出至右括号</span></div><div class=\"line\">      <span class=\"keyword\">let</span> topEle = stack.pop();</div><div class=\"line\">      <span class=\"keyword\">while</span>(topEle !== <span class=\"string\">')'</span>) &#123;</div><div class=\"line\">        output.push(topEle);</div><div class=\"line\">        topEle = stack.pop();</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 将栈剩余的元素依次弹出</span></div><div class=\"line\">  <span class=\"keyword\">while</span>(stack.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    output.push(stack.pop());</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> output.reverse().join(<span class=\"string\">','</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"计算前缀表达式\"><a href=\"#计算前缀表达式\" class=\"headerlink\" title=\"计算前缀表达式\"></a>计算前缀表达式</h3><p>前缀表达式的计算也使用到了栈，规则如下：</p>\n<ol>\n<li>从右至左扫描表达式<ul>\n<li>如果当前字符是数字，入栈</li>\n<li>如果当前字符是运算符，栈弹出两个元素，进行运算，并将结果入栈</li>\n</ul>\n</li>\n<li>重复上述过程，直到扫描结束</li>\n</ol>\n<p>继续以 <code>-*3+594</code> 为例，计算如下：</p>\n<ol>\n<li>栈:[4]</li>\n<li>栈:[4, 9]</li>\n<li>栈:[4, 9, 5]</li>\n<li>计算 <code>5 + 9</code>，得到结果 14 压入栈中。栈:[4, 14]</li>\n<li>栈:[4, 14, 3]</li>\n<li>计算 <code>3 * 14</code>，得到结果 42 压入栈中。栈:[4, 42]</li>\n<li>计算 <code>42 - 4</code>，得到结果 38 压入栈中。栈:[38]</li>\n</ol>\n<p>最后结果即为 48。</p>\n<p>javascript 实现：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 计算前缀表达式</div><div class=\"line\"> * @param  &#123;string&#125; preExpress 前缀表达式</div><div class=\"line\"> * @return &#123;number&#125;            结果</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">calculate</span>(<span class=\"params\">preExpress</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> chars = preExpress.split(<span class=\"string\">','</span>);</div><div class=\"line\">  <span class=\"keyword\">let</span> nums = [];</div><div class=\"line\">  <span class=\"keyword\">while</span>(chars.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> ele = chars.pop();</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"regexp\">/\\d+/</span>.test(ele)) &#123;</div><div class=\"line\">      nums.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> left = +nums.pop();</div><div class=\"line\">      <span class=\"keyword\">let</span> right = +nums.pop();</div><div class=\"line\">      <span class=\"keyword\">switch</span> (ele) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'+'</span>:</div><div class=\"line\">          nums.push(left + right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'-'</span>:</div><div class=\"line\">          nums.push(left - right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'*'</span>:</div><div class=\"line\">          nums.push(left * right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'/'</span>:</div><div class=\"line\">          nums.push(left / right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"排列\"><a href=\"#排列\" class=\"headerlink\" title=\"排列\"></a>排列</h2><p>对于 <code>1, 2, 3, 4</code>，四个数字，我们知道一共有 <code>4! = 24</code> 种排列。</p>\n<p>而事实上，这二十四种排列是从第一个数字开始，依次与后面的数字交换而来的。</p>\n<ul>\n<li>1, 2 交换: <code>2, 1, 3, 4</code></li>\n<li>1, 3 交换：<code>2, 3, 1, 4</code></li>\n<li>1, 4 交换：<code>2, 3, 4, 1</code></li>\n<li>1, 2 交换：<code>1, 3, 4, 2</code></li>\n<li>1, 3 交换：<code>3, 1, 4, 2</code></li>\n<li>…依次类推</li>\n</ul>\n<p>所以只要在 <code>n!</code> 时间内，就能得出所有可能情况</p>\n<p>javascript 实现<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createExpress</span>(<span class=\"params\">nums</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> noBraket = [], oneBraket = [], twoBraket = [];</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">let</span> swapIndex = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">24</span>; i++) &#123;</div><div class=\"line\">    swap(swapIndex);</div><div class=\"line\">    swapIndex == nums.length - <span class=\"number\">1</span> ? swapIndex = <span class=\"number\">0</span> : swapIndex++;</div><div class=\"line\">    <span class=\"comment\">// nums 即为一个排列</span></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span>(<span class=\"params\">i</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(i &lt; nums.length - <span class=\"number\">1</span>) &#123;</div><div class=\"line\">      [nums[i], nums[i + <span class=\"number\">1</span>]] = [nums[i + <span class=\"number\">1</span>], nums[i]];</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      [nums[i], nums[<span class=\"number\">0</span>]] = [nums[<span class=\"number\">0</span>], nums[i]];</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"添加括号\"><a href=\"#添加括号\" class=\"headerlink\" title=\"添加括号\"></a>添加括号</h2><p>式子列出之后，需要给表达式添加括号，实际上有括号的可能情况只有两种: 只有一个括号和有两个括号。而每种情况都只有 5 种情况。</p>\n<ol>\n<li>一个括号<ul>\n<li>(1 2) 3 4</li>\n<li>(1 2 3) 4</li>\n<li>1 (2 3) 4</li>\n<li>1 (2 3 4)</li>\n<li>1 2 (3 4)</li>\n</ul>\n</li>\n<li>两个括号<ul>\n<li>(1 2) (3 4)</li>\n<li>((1 2) 3) 4</li>\n<li>(1 (2 3)) 4</li>\n<li>1 ((2 3) 4)</li>\n<li>1 (2 (3 4))</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"TODO\"><a href=\"#TODO\" class=\"headerlink\" title=\"TODO\"></a>TODO</h2><p>解决了以上问题之后，基本能算出所有的可能情况了，剩下的问题在于如何去除重复，和判断重复情况。</p>\n<p>比如 <code>(1 + 2 + 3) * 5</code> 和 <code>5 * (1 + 2 + 3)</code> 应该判断为同一种情况。</p>\n<h2 id=\"所有代码\"><a href=\"#所有代码\" class=\"headerlink\" title=\"所有代码\"></a>所有代码</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> nums = process.argv.slice(<span class=\"number\">2</span>, <span class=\"number\">6</span>);</div><div class=\"line\"></div><div class=\"line\">createExpress(nums);</div><div class=\"line\"><span class=\"comment\">// translate('(3+(3+4)*5');</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createExpress</span>(<span class=\"params\">nums</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> noBraket = [], oneBraket = [], twoBraket = [];</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">let</span> swapIndex = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">24</span>; i++) &#123;</div><div class=\"line\">    swap(swapIndex);</div><div class=\"line\">    swapIndex == nums.length - <span class=\"number\">1</span> ? swapIndex = <span class=\"number\">0</span> : swapIndex++;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 表达式</span></div><div class=\"line\">    <span class=\"keyword\">let</span> operTypes = [<span class=\"string\">'+'</span>, <span class=\"string\">'-'</span>, <span class=\"string\">'*'</span>, <span class=\"string\">'/'</span>];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; operTypes.length; j++) &#123;</div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k = <span class=\"number\">0</span>; k &lt; operTypes.length; k++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> l = <span class=\"number\">0</span>; l &lt; operTypes.length; l++) &#123;</div><div class=\"line\">          <span class=\"keyword\">let</span> express = <span class=\"string\">`<span class=\"subst\">$&#123;nums[<span class=\"number\">0</span>]&#125;</span><span class=\"subst\">$&#123;operTypes[j]&#125;</span><span class=\"subst\">$&#123;nums[<span class=\"number\">1</span>]&#125;</span><span class=\"subst\">$&#123;operTypes[k]&#125;</span><span class=\"subst\">$&#123;nums[<span class=\"number\">2</span>]&#125;</span><span class=\"subst\">$&#123;operTypes[l]&#125;</span><span class=\"subst\">$&#123;nums[<span class=\"number\">3</span>]&#125;</span>`</span>;</div><div class=\"line\">          <span class=\"comment\">// console.log(express)</span></div><div class=\"line\">          noBraket.push(express);</div><div class=\"line\"></div><div class=\"line\">          <span class=\"comment\">// 当不是全部都是同样优先级时才加括号</span></div><div class=\"line\">          <span class=\"keyword\">if</span>(!isSamePriority(operTypes[j], operTypes[k], operTypes[l])) &#123;</div><div class=\"line\">            <span class=\"comment\">// 加一个括号</span></div><div class=\"line\">            oneBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">0</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">4</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            oneBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">2</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">6</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            oneBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">4</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">8</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            oneBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">0</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">6</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            oneBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">2</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">8</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// 加两个括号</span></div><div class=\"line\">            twoBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">0</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">4</span>: <span class=\"string\">')'</span>,</div><div class=\"line\">              <span class=\"number\">6</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">10</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            twoBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">0</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">1</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">5</span>: <span class=\"string\">')'</span>,</div><div class=\"line\">              <span class=\"number\">8</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            twoBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">2</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">3</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">7</span>: <span class=\"string\">')'</span>,</div><div class=\"line\">              <span class=\"number\">10</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            twoBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">0</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">3</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">7</span>: <span class=\"string\">')'</span>,</div><div class=\"line\">              <span class=\"number\">8</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            twoBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">2</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">5</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">9</span>: <span class=\"string\">')'</span>,</div><div class=\"line\">              <span class=\"number\">10</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">let</span> expresses = noBraket.concat(oneBraket).concat(twoBraket);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; expresses.length; i++) &#123;</div><div class=\"line\">      <span class=\"comment\">// if(expresses[i] == '')</span></div><div class=\"line\">      <span class=\"comment\">// console.log(expresses[i], calculate(translate(expresses[i])))</span></div><div class=\"line\">      <span class=\"keyword\">if</span>(calculate(translate(expresses[i])) == <span class=\"number\">24</span>) &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(expresses[i]);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isSamePriority</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> opers = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>).join(<span class=\"string\">''</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span>((opers.match(<span class=\"regexp\">/[\\+\\-]/g</span>) &amp;&amp; opers.match(<span class=\"regexp\">/[\\+\\-]/g</span>).length == opers.length)</div><div class=\"line\">      || (opers.match(<span class=\"regexp\">/[\\*\\/]/g</span>) &amp;&amp; opers.match(<span class=\"regexp\">/[\\*\\/]/g</span>).length == opers.length)) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addBraket</span>(<span class=\"params\">express, param</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> chars = express.match(<span class=\"regexp\">/(\\d+)|[^\\d]/g</span>);</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> pos <span class=\"keyword\">in</span> param) &#123;</div><div class=\"line\">      chars.splice(+pos, <span class=\"number\">0</span>, param[pos]);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> chars.join(<span class=\"string\">''</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span>(<span class=\"params\">i</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(i &lt; nums.length - <span class=\"number\">1</span>) &#123;</div><div class=\"line\">      [nums[i], nums[i + <span class=\"number\">1</span>]] = [nums[i + <span class=\"number\">1</span>], nums[i]];</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      [nums[i], nums[<span class=\"number\">0</span>]] = [nums[<span class=\"number\">0</span>], nums[i]];</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 中缀表达式转前缀表达式</div><div class=\"line\"> * @param  &#123;string&#125; inExpress 中缀表达式</div><div class=\"line\"> * @return &#123;string&#125;           前缀表达式</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">translate</span>(<span class=\"params\">inExpress</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(inExpress == <span class=\"string\">''</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'表达式为空'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 输出前缀表达式</span></div><div class=\"line\">  <span class=\"keyword\">let</span> output = [];</div><div class=\"line\">  <span class=\"comment\">// 反转</span></div><div class=\"line\">  <span class=\"keyword\">let</span> chars = inExpress.match(<span class=\"regexp\">/(\\d+)|[^\\d]/g</span>).reverse();</div><div class=\"line\">  <span class=\"comment\">// 存放运算符的栈</span></div><div class=\"line\">  <span class=\"keyword\">let</span> stack = [];</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> ele <span class=\"keyword\">of</span> chars) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"regexp\">/\\d+/</span>.test(ele)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果是数字，直接输出</span></div><div class=\"line\">      output.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"regexp\">/[\\+\\-]/</span>.test(ele)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 栈顶元素</span></div><div class=\"line\">      <span class=\"keyword\">let</span> topEle = stack[stack.length - <span class=\"number\">1</span>];</div><div class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"regexp\">/[\\*\\/]/</span>.test(topEle)) &#123;</div><div class=\"line\">        <span class=\"comment\">// 如果栈顶元素优先级比加减高，依次将优先级高的运算符弹出</span></div><div class=\"line\">        <span class=\"keyword\">while</span>(stack.length &gt; <span class=\"number\">0</span> &amp;&amp; <span class=\"regexp\">/[\\*\\/]/</span>.test(topEle)) &#123;</div><div class=\"line\">          output.push(stack.pop());</div><div class=\"line\">          topEle = stack[stack.length - <span class=\"number\">1</span>];</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      stack.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"regexp\">/[\\*\\/\\)]/</span>.test(ele)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果是乘除或右括号，入栈</span></div><div class=\"line\">      stack.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// 如果是左括号，依次弹出至右括号</span></div><div class=\"line\">      <span class=\"keyword\">let</span> topEle = stack.pop();</div><div class=\"line\">      <span class=\"keyword\">while</span>(topEle !== <span class=\"string\">')'</span>) &#123;</div><div class=\"line\">        output.push(topEle);</div><div class=\"line\">        topEle = stack.pop();</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 将栈剩余的元素依次弹出</span></div><div class=\"line\">  <span class=\"keyword\">while</span>(stack.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    output.push(stack.pop());</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> output.reverse().join(<span class=\"string\">','</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 计算前缀表达式</div><div class=\"line\"> * @param  &#123;string&#125; preExpress 前缀表达式</div><div class=\"line\"> * @return &#123;number&#125;            结果</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">calculate</span>(<span class=\"params\">preExpress</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> chars = preExpress.split(<span class=\"string\">','</span>);</div><div class=\"line\">  <span class=\"keyword\">let</span> nums = [];</div><div class=\"line\">  <span class=\"keyword\">while</span>(chars.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> ele = chars.pop();</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"regexp\">/\\d+/</span>.test(ele)) &#123;</div><div class=\"line\">      nums.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> left = +nums.pop();</div><div class=\"line\">      <span class=\"keyword\">let</span> right = +nums.pop();</div><div class=\"line\">      <span class=\"keyword\">switch</span> (ele) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'+'</span>:</div><div class=\"line\">          nums.push(left + right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'-'</span>:</div><div class=\"line\">          nums.push(left - right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'*'</span>:</div><div class=\"line\">          nums.push(left * right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'/'</span>:</div><div class=\"line\">          nums.push(left / right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"使用 node-canvas 绘制验证码","date":"2016-11-17T13:59:14.000Z","_content":"\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/captcha-by-node-canvas/01.png)\n\n最近要给 node 项目加上验证码，找到了 node-canvas 这个库，简单地用了一下，发现还是蛮好用的。\n\ngit 地址：[node-canvas](https://github.com/Automattic/node-canvas)\n\n<!-- more -->\n\n顾名思义，node-canvas 允许你在 node 端使用 canvas。在验证码这个使用场景里，我们可以先生成验证码，然后在 canvas 上绘制，最后将图片返回给前端。\n\n## step 1 安装\n\n在安装 node-canvas 之前，还需要安装一些依赖。不同的系统需要安装的不同，以 linux 和 mac 为例：\n\n- linux:  `sudo yum install cairo cairo-devel cairomm-devel libjpeg-turbo-devel pango pango-devel pangomm pangomm-devel giflib-devel`\n- mac: `brew install pkg-config cairo pango libpng jpeg giflib`\n\n其他参考 [node-canvas#installation](https://github.com/Automattic/node-canvas#installation)\n\n安装完依赖后，执行 `npm install canvas` 即可。\n\n## step 2 画图\n\n通过获取 canvas，可以得到 context 对象，然后就可以像在前端一样绘制图形了\n\n```javascript\nconst Canvas = require('canvas');\nconst canvas = new Canvas(100, 30),\n    ctx = canvas.getContext('2d');\n```\n\n实际上我用到的 api 和前端的 canvas 是一样的，绘制过程就不多解释，可以参考 canvas 的相关教程。\n\n下面是绘制一个 `a + b = ?` 的验证码\n\n```javascript\nctx.font = '24px \"Microsoft YaHei\"';\n\n// 绘制文本\nlet drawText = (text, x) => {\n  ctx.save();\n  // 旋转角度\n  const angle = Math.random() / 10;\n  // y 坐标\n  const y = 22;\n  ctx.rotate(angle);\n  ctx.fillText(text, x, y);\n  ctx.restore();\n}\n\n// 随机画线\nlet drawLine = () => {\n  const num = Math.floor(Math.random() * 2 + 3);\n  // 随机画几条彩色线条\n  for (let i = 0; i < num; i++) {\n    const color = '#' + (Math.random() * 0xffffff << 0).toString(16);\n    const y1 = Math.random() * height;\n    const y2 = Math.random() * height;\n  // 画线\n    ctx.strokeStyle = color;\n    ctx.beginPath();\n    ctx.lineTo(0, y1);\n    ctx.lineTo(width, y2);\n    ctx.stroke();\n  }\n}\n\n// 数字的文本随机从小写汉字、大写汉字、数字里选择\nconst numArr = [\n  '〇一二三四五六七八九',\n  '0123456789',\n  '零壹贰叁肆伍陆柒捌玖'  \n];\n// 第一个数字\nconst fir = Math.floor(Math.random() * 10);\n// 第二个数字\nconst sec = Math.floor(Math.random() * 10);\n// 随机选取运算\nconst operArr = ['加', '减', '乘'];\nconst oper = Math.floor(Math.random() * operArr.length);\n\ndrawLine();\ndrawText(numArr[Math.floor(Math.random() * numArr.length)][fir], 10);\ndrawText(operArr[oper], 40);\ndrawText(numArr[Math.floor(Math.random() * numArr.length)][sec], 70);\ndrawText('=', 100);\ndrawText('?', 130);\n\n// 验证码值的计算\nlet captcha;\nswitch(oper) {\n  case 0: \n    captcha = fir + sec;\n    break;\n  case 1:\n    captcha = fir - sec;\n    break;\n  case 2:\n    captcha = fir * sec;\n    break;\n}\n\n// 存入 session\nreq.session.captcha = captcha;\n```\n\n效果如下：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/captcha-by-node-canvas/01.png)\n\n## step 3 返回图片\n\n调用 `canvas.toDataURL()`，可以返回图片的 base64 格式数据。\n\n```javascript\nres.send({\n  status: 200,\n  data: canvas.toDataURL()\n})\n```\n\n前端将该数据加到 img 的 src 属性中即可。\n\n## 中文乱码\n\n在将项目部署到 linux 后，发现输出显示的图片中的中文都变成了方框。\n\n 我参考了 [redhat 6 下 node-canvas中文方框解决办法](https://my.oschina.net/u/129529/blog/266843) 这篇文章，但是没有全部运行，而是安装了 `yum groupinstall \"Chinese Support\"`，`yum groupinstall Fonts` 这两个。\n\n另外参考 [用node-canvas绘制中文的时候乱码怎么解决？](https://cnodejs.org/topic/53f98ad8bbdaa79d518c0836) 问题里的 5 楼，使用了微软雅黑。\n\n还有 [issue#461](https://github.com/Automattic/node-canvas/issues/461)，在字体两侧加上引号。\n\n我按这三个做了，然后 **重启项目** 就好了~","source":"_posts/captcha-by-node-canvas.md","raw":"---\ntitle: 使用 node-canvas 绘制验证码\ndate: 2016-11-17 21:59:14\ntags: [nodejs]\n---\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/captcha-by-node-canvas/01.png)\n\n最近要给 node 项目加上验证码，找到了 node-canvas 这个库，简单地用了一下，发现还是蛮好用的。\n\ngit 地址：[node-canvas](https://github.com/Automattic/node-canvas)\n\n<!-- more -->\n\n顾名思义，node-canvas 允许你在 node 端使用 canvas。在验证码这个使用场景里，我们可以先生成验证码，然后在 canvas 上绘制，最后将图片返回给前端。\n\n## step 1 安装\n\n在安装 node-canvas 之前，还需要安装一些依赖。不同的系统需要安装的不同，以 linux 和 mac 为例：\n\n- linux:  `sudo yum install cairo cairo-devel cairomm-devel libjpeg-turbo-devel pango pango-devel pangomm pangomm-devel giflib-devel`\n- mac: `brew install pkg-config cairo pango libpng jpeg giflib`\n\n其他参考 [node-canvas#installation](https://github.com/Automattic/node-canvas#installation)\n\n安装完依赖后，执行 `npm install canvas` 即可。\n\n## step 2 画图\n\n通过获取 canvas，可以得到 context 对象，然后就可以像在前端一样绘制图形了\n\n```javascript\nconst Canvas = require('canvas');\nconst canvas = new Canvas(100, 30),\n    ctx = canvas.getContext('2d');\n```\n\n实际上我用到的 api 和前端的 canvas 是一样的，绘制过程就不多解释，可以参考 canvas 的相关教程。\n\n下面是绘制一个 `a + b = ?` 的验证码\n\n```javascript\nctx.font = '24px \"Microsoft YaHei\"';\n\n// 绘制文本\nlet drawText = (text, x) => {\n  ctx.save();\n  // 旋转角度\n  const angle = Math.random() / 10;\n  // y 坐标\n  const y = 22;\n  ctx.rotate(angle);\n  ctx.fillText(text, x, y);\n  ctx.restore();\n}\n\n// 随机画线\nlet drawLine = () => {\n  const num = Math.floor(Math.random() * 2 + 3);\n  // 随机画几条彩色线条\n  for (let i = 0; i < num; i++) {\n    const color = '#' + (Math.random() * 0xffffff << 0).toString(16);\n    const y1 = Math.random() * height;\n    const y2 = Math.random() * height;\n  // 画线\n    ctx.strokeStyle = color;\n    ctx.beginPath();\n    ctx.lineTo(0, y1);\n    ctx.lineTo(width, y2);\n    ctx.stroke();\n  }\n}\n\n// 数字的文本随机从小写汉字、大写汉字、数字里选择\nconst numArr = [\n  '〇一二三四五六七八九',\n  '0123456789',\n  '零壹贰叁肆伍陆柒捌玖'  \n];\n// 第一个数字\nconst fir = Math.floor(Math.random() * 10);\n// 第二个数字\nconst sec = Math.floor(Math.random() * 10);\n// 随机选取运算\nconst operArr = ['加', '减', '乘'];\nconst oper = Math.floor(Math.random() * operArr.length);\n\ndrawLine();\ndrawText(numArr[Math.floor(Math.random() * numArr.length)][fir], 10);\ndrawText(operArr[oper], 40);\ndrawText(numArr[Math.floor(Math.random() * numArr.length)][sec], 70);\ndrawText('=', 100);\ndrawText('?', 130);\n\n// 验证码值的计算\nlet captcha;\nswitch(oper) {\n  case 0: \n    captcha = fir + sec;\n    break;\n  case 1:\n    captcha = fir - sec;\n    break;\n  case 2:\n    captcha = fir * sec;\n    break;\n}\n\n// 存入 session\nreq.session.captcha = captcha;\n```\n\n效果如下：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/captcha-by-node-canvas/01.png)\n\n## step 3 返回图片\n\n调用 `canvas.toDataURL()`，可以返回图片的 base64 格式数据。\n\n```javascript\nres.send({\n  status: 200,\n  data: canvas.toDataURL()\n})\n```\n\n前端将该数据加到 img 的 src 属性中即可。\n\n## 中文乱码\n\n在将项目部署到 linux 后，发现输出显示的图片中的中文都变成了方框。\n\n 我参考了 [redhat 6 下 node-canvas中文方框解决办法](https://my.oschina.net/u/129529/blog/266843) 这篇文章，但是没有全部运行，而是安装了 `yum groupinstall \"Chinese Support\"`，`yum groupinstall Fonts` 这两个。\n\n另外参考 [用node-canvas绘制中文的时候乱码怎么解决？](https://cnodejs.org/topic/53f98ad8bbdaa79d518c0836) 问题里的 5 楼，使用了微软雅黑。\n\n还有 [issue#461](https://github.com/Automattic/node-canvas/issues/461)，在字体两侧加上引号。\n\n我按这三个做了，然后 **重启项目** 就好了~","slug":"captcha-by-node-canvas","published":1,"updated":"2017-03-17T14:48:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcvb000mn927qekvwmql","content":"<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/captcha-by-node-canvas/01.png\" alt=\"\"></p>\n<p>最近要给 node 项目加上验证码，找到了 node-canvas 这个库，简单地用了一下，发现还是蛮好用的。</p>\n<p>git 地址：<a href=\"https://github.com/Automattic/node-canvas\" target=\"_blank\" rel=\"external\">node-canvas</a></p>\n<a id=\"more\"></a>\n<p>顾名思义，node-canvas 允许你在 node 端使用 canvas。在验证码这个使用场景里，我们可以先生成验证码，然后在 canvas 上绘制，最后将图片返回给前端。</p>\n<h2 id=\"step-1-安装\"><a href=\"#step-1-安装\" class=\"headerlink\" title=\"step 1 安装\"></a>step 1 安装</h2><p>在安装 node-canvas 之前，还需要安装一些依赖。不同的系统需要安装的不同，以 linux 和 mac 为例：</p>\n<ul>\n<li>linux:  <code>sudo yum install cairo cairo-devel cairomm-devel libjpeg-turbo-devel pango pango-devel pangomm pangomm-devel giflib-devel</code></li>\n<li>mac: <code>brew install pkg-config cairo pango libpng jpeg giflib</code></li>\n</ul>\n<p>其他参考 <a href=\"https://github.com/Automattic/node-canvas#installation\" target=\"_blank\" rel=\"external\">node-canvas#installation</a></p>\n<p>安装完依赖后，执行 <code>npm install canvas</code> 即可。</p>\n<h2 id=\"step-2-画图\"><a href=\"#step-2-画图\" class=\"headerlink\" title=\"step 2 画图\"></a>step 2 画图</h2><p>通过获取 canvas，可以得到 context 对象，然后就可以像在前端一样绘制图形了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> Canvas = <span class=\"built_in\">require</span>(<span class=\"string\">'canvas'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> canvas = <span class=\"keyword\">new</span> Canvas(<span class=\"number\">100</span>, <span class=\"number\">30</span>),</div><div class=\"line\">    ctx = canvas.getContext(<span class=\"string\">'2d'</span>);</div></pre></td></tr></table></figure>\n<p>实际上我用到的 api 和前端的 canvas 是一样的，绘制过程就不多解释，可以参考 canvas 的相关教程。</p>\n<p>下面是绘制一个 <code>a + b = ?</code> 的验证码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\">ctx.font = <span class=\"string\">'24px \"Microsoft YaHei\"'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 绘制文本</span></div><div class=\"line\"><span class=\"keyword\">let</span> drawText = <span class=\"function\">(<span class=\"params\">text, x</span>) =&gt;</span> &#123;</div><div class=\"line\">  ctx.save();</div><div class=\"line\">  <span class=\"comment\">// 旋转角度</span></div><div class=\"line\">  <span class=\"keyword\">const</span> angle = <span class=\"built_in\">Math</span>.random() / <span class=\"number\">10</span>;</div><div class=\"line\">  <span class=\"comment\">// y 坐标</span></div><div class=\"line\">  <span class=\"keyword\">const</span> y = <span class=\"number\">22</span>;</div><div class=\"line\">  ctx.rotate(angle);</div><div class=\"line\">  ctx.fillText(text, x, y);</div><div class=\"line\">  ctx.restore();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 随机画线</span></div><div class=\"line\"><span class=\"keyword\">let</span> drawLine = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> num = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">2</span> + <span class=\"number\">3</span>);</div><div class=\"line\">  <span class=\"comment\">// 随机画几条彩色线条</span></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> color = <span class=\"string\">'#'</span> + (<span class=\"built_in\">Math</span>.random() * <span class=\"number\">0xffffff</span> &lt;&lt; <span class=\"number\">0</span>).toString(<span class=\"number\">16</span>);</div><div class=\"line\">    <span class=\"keyword\">const</span> y1 = <span class=\"built_in\">Math</span>.random() * height;</div><div class=\"line\">    <span class=\"keyword\">const</span> y2 = <span class=\"built_in\">Math</span>.random() * height;</div><div class=\"line\">  <span class=\"comment\">// 画线</span></div><div class=\"line\">    ctx.strokeStyle = color;</div><div class=\"line\">    ctx.beginPath();</div><div class=\"line\">    ctx.lineTo(<span class=\"number\">0</span>, y1);</div><div class=\"line\">    ctx.lineTo(width, y2);</div><div class=\"line\">    ctx.stroke();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 数字的文本随机从小写汉字、大写汉字、数字里选择</span></div><div class=\"line\"><span class=\"keyword\">const</span> numArr = [</div><div class=\"line\">  <span class=\"string\">'〇一二三四五六七八九'</span>,</div><div class=\"line\">  <span class=\"string\">'0123456789'</span>,</div><div class=\"line\">  <span class=\"string\">'零壹贰叁肆伍陆柒捌玖'</span>  </div><div class=\"line\">];</div><div class=\"line\"><span class=\"comment\">// 第一个数字</span></div><div class=\"line\"><span class=\"keyword\">const</span> fir = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">10</span>);</div><div class=\"line\"><span class=\"comment\">// 第二个数字</span></div><div class=\"line\"><span class=\"keyword\">const</span> sec = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">10</span>);</div><div class=\"line\"><span class=\"comment\">// 随机选取运算</span></div><div class=\"line\"><span class=\"keyword\">const</span> operArr = [<span class=\"string\">'加'</span>, <span class=\"string\">'减'</span>, <span class=\"string\">'乘'</span>];</div><div class=\"line\"><span class=\"keyword\">const</span> oper = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * operArr.length);</div><div class=\"line\"></div><div class=\"line\">drawLine();</div><div class=\"line\">drawText(numArr[<span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * numArr.length)][fir], <span class=\"number\">10</span>);</div><div class=\"line\">drawText(operArr[oper], <span class=\"number\">40</span>);</div><div class=\"line\">drawText(numArr[<span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * numArr.length)][sec], <span class=\"number\">70</span>);</div><div class=\"line\">drawText(<span class=\"string\">'='</span>, <span class=\"number\">100</span>);</div><div class=\"line\">drawText(<span class=\"string\">'?'</span>, <span class=\"number\">130</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 验证码值的计算</span></div><div class=\"line\"><span class=\"keyword\">let</span> captcha;</div><div class=\"line\"><span class=\"keyword\">switch</span>(oper) &#123;</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">0</span>: </div><div class=\"line\">    captcha = fir + sec;</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</div><div class=\"line\">    captcha = fir - sec;</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</div><div class=\"line\">    captcha = fir * sec;</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 存入 session</span></div><div class=\"line\">req.session.captcha = captcha;</div></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/captcha-by-node-canvas/01.png\" alt=\"\"></p>\n<h2 id=\"step-3-返回图片\"><a href=\"#step-3-返回图片\" class=\"headerlink\" title=\"step 3 返回图片\"></a>step 3 返回图片</h2><p>调用 <code>canvas.toDataURL()</code>，可以返回图片的 base64 格式数据。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">res.send(&#123;</div><div class=\"line\">  <span class=\"attr\">status</span>: <span class=\"number\">200</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: canvas.toDataURL()</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>前端将该数据加到 img 的 src 属性中即可。</p>\n<h2 id=\"中文乱码\"><a href=\"#中文乱码\" class=\"headerlink\" title=\"中文乱码\"></a>中文乱码</h2><p>在将项目部署到 linux 后，发现输出显示的图片中的中文都变成了方框。</p>\n<p> 我参考了 <a href=\"https://my.oschina.net/u/129529/blog/266843\" target=\"_blank\" rel=\"external\">redhat 6 下 node-canvas中文方框解决办法</a> 这篇文章，但是没有全部运行，而是安装了 <code>yum groupinstall &quot;Chinese Support&quot;</code>，<code>yum groupinstall Fonts</code> 这两个。</p>\n<p>另外参考 <a href=\"https://cnodejs.org/topic/53f98ad8bbdaa79d518c0836\" target=\"_blank\" rel=\"external\">用node-canvas绘制中文的时候乱码怎么解决？</a> 问题里的 5 楼，使用了微软雅黑。</p>\n<p>还有 <a href=\"https://github.com/Automattic/node-canvas/issues/461\" target=\"_blank\" rel=\"external\">issue#461</a>，在字体两侧加上引号。</p>\n<p>我按这三个做了，然后 <strong>重启项目</strong> 就好了~</p>\n","excerpt":"<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/captcha-by-node-canvas/01.png\" alt=\"\"></p>\n<p>最近要给 node 项目加上验证码，找到了 node-canvas 这个库，简单地用了一下，发现还是蛮好用的。</p>\n<p>git 地址：<a href=\"https://github.com/Automattic/node-canvas\">node-canvas</a></p>","more":"<p>顾名思义，node-canvas 允许你在 node 端使用 canvas。在验证码这个使用场景里，我们可以先生成验证码，然后在 canvas 上绘制，最后将图片返回给前端。</p>\n<h2 id=\"step-1-安装\"><a href=\"#step-1-安装\" class=\"headerlink\" title=\"step 1 安装\"></a>step 1 安装</h2><p>在安装 node-canvas 之前，还需要安装一些依赖。不同的系统需要安装的不同，以 linux 和 mac 为例：</p>\n<ul>\n<li>linux:  <code>sudo yum install cairo cairo-devel cairomm-devel libjpeg-turbo-devel pango pango-devel pangomm pangomm-devel giflib-devel</code></li>\n<li>mac: <code>brew install pkg-config cairo pango libpng jpeg giflib</code></li>\n</ul>\n<p>其他参考 <a href=\"https://github.com/Automattic/node-canvas#installation\">node-canvas#installation</a></p>\n<p>安装完依赖后，执行 <code>npm install canvas</code> 即可。</p>\n<h2 id=\"step-2-画图\"><a href=\"#step-2-画图\" class=\"headerlink\" title=\"step 2 画图\"></a>step 2 画图</h2><p>通过获取 canvas，可以得到 context 对象，然后就可以像在前端一样绘制图形了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> Canvas = <span class=\"built_in\">require</span>(<span class=\"string\">'canvas'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> canvas = <span class=\"keyword\">new</span> Canvas(<span class=\"number\">100</span>, <span class=\"number\">30</span>),</div><div class=\"line\">    ctx = canvas.getContext(<span class=\"string\">'2d'</span>);</div></pre></td></tr></table></figure>\n<p>实际上我用到的 api 和前端的 canvas 是一样的，绘制过程就不多解释，可以参考 canvas 的相关教程。</p>\n<p>下面是绘制一个 <code>a + b = ?</code> 的验证码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\">ctx.font = <span class=\"string\">'24px \"Microsoft YaHei\"'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 绘制文本</span></div><div class=\"line\"><span class=\"keyword\">let</span> drawText = <span class=\"function\">(<span class=\"params\">text, x</span>) =&gt;</span> &#123;</div><div class=\"line\">  ctx.save();</div><div class=\"line\">  <span class=\"comment\">// 旋转角度</span></div><div class=\"line\">  <span class=\"keyword\">const</span> angle = <span class=\"built_in\">Math</span>.random() / <span class=\"number\">10</span>;</div><div class=\"line\">  <span class=\"comment\">// y 坐标</span></div><div class=\"line\">  <span class=\"keyword\">const</span> y = <span class=\"number\">22</span>;</div><div class=\"line\">  ctx.rotate(angle);</div><div class=\"line\">  ctx.fillText(text, x, y);</div><div class=\"line\">  ctx.restore();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 随机画线</span></div><div class=\"line\"><span class=\"keyword\">let</span> drawLine = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> num = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">2</span> + <span class=\"number\">3</span>);</div><div class=\"line\">  <span class=\"comment\">// 随机画几条彩色线条</span></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> color = <span class=\"string\">'#'</span> + (<span class=\"built_in\">Math</span>.random() * <span class=\"number\">0xffffff</span> &lt;&lt; <span class=\"number\">0</span>).toString(<span class=\"number\">16</span>);</div><div class=\"line\">    <span class=\"keyword\">const</span> y1 = <span class=\"built_in\">Math</span>.random() * height;</div><div class=\"line\">    <span class=\"keyword\">const</span> y2 = <span class=\"built_in\">Math</span>.random() * height;</div><div class=\"line\">  <span class=\"comment\">// 画线</span></div><div class=\"line\">    ctx.strokeStyle = color;</div><div class=\"line\">    ctx.beginPath();</div><div class=\"line\">    ctx.lineTo(<span class=\"number\">0</span>, y1);</div><div class=\"line\">    ctx.lineTo(width, y2);</div><div class=\"line\">    ctx.stroke();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 数字的文本随机从小写汉字、大写汉字、数字里选择</span></div><div class=\"line\"><span class=\"keyword\">const</span> numArr = [</div><div class=\"line\">  <span class=\"string\">'〇一二三四五六七八九'</span>,</div><div class=\"line\">  <span class=\"string\">'0123456789'</span>,</div><div class=\"line\">  <span class=\"string\">'零壹贰叁肆伍陆柒捌玖'</span>  </div><div class=\"line\">];</div><div class=\"line\"><span class=\"comment\">// 第一个数字</span></div><div class=\"line\"><span class=\"keyword\">const</span> fir = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">10</span>);</div><div class=\"line\"><span class=\"comment\">// 第二个数字</span></div><div class=\"line\"><span class=\"keyword\">const</span> sec = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">10</span>);</div><div class=\"line\"><span class=\"comment\">// 随机选取运算</span></div><div class=\"line\"><span class=\"keyword\">const</span> operArr = [<span class=\"string\">'加'</span>, <span class=\"string\">'减'</span>, <span class=\"string\">'乘'</span>];</div><div class=\"line\"><span class=\"keyword\">const</span> oper = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * operArr.length);</div><div class=\"line\"></div><div class=\"line\">drawLine();</div><div class=\"line\">drawText(numArr[<span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * numArr.length)][fir], <span class=\"number\">10</span>);</div><div class=\"line\">drawText(operArr[oper], <span class=\"number\">40</span>);</div><div class=\"line\">drawText(numArr[<span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * numArr.length)][sec], <span class=\"number\">70</span>);</div><div class=\"line\">drawText(<span class=\"string\">'='</span>, <span class=\"number\">100</span>);</div><div class=\"line\">drawText(<span class=\"string\">'?'</span>, <span class=\"number\">130</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 验证码值的计算</span></div><div class=\"line\"><span class=\"keyword\">let</span> captcha;</div><div class=\"line\"><span class=\"keyword\">switch</span>(oper) &#123;</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">0</span>: </div><div class=\"line\">    captcha = fir + sec;</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</div><div class=\"line\">    captcha = fir - sec;</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</div><div class=\"line\">    captcha = fir * sec;</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 存入 session</span></div><div class=\"line\">req.session.captcha = captcha;</div></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/captcha-by-node-canvas/01.png\" alt=\"\"></p>\n<h2 id=\"step-3-返回图片\"><a href=\"#step-3-返回图片\" class=\"headerlink\" title=\"step 3 返回图片\"></a>step 3 返回图片</h2><p>调用 <code>canvas.toDataURL()</code>，可以返回图片的 base64 格式数据。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">res.send(&#123;</div><div class=\"line\">  <span class=\"attr\">status</span>: <span class=\"number\">200</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: canvas.toDataURL()</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>前端将该数据加到 img 的 src 属性中即可。</p>\n<h2 id=\"中文乱码\"><a href=\"#中文乱码\" class=\"headerlink\" title=\"中文乱码\"></a>中文乱码</h2><p>在将项目部署到 linux 后，发现输出显示的图片中的中文都变成了方框。</p>\n<p> 我参考了 <a href=\"https://my.oschina.net/u/129529/blog/266843\">redhat 6 下 node-canvas中文方框解决办法</a> 这篇文章，但是没有全部运行，而是安装了 <code>yum groupinstall &quot;Chinese Support&quot;</code>，<code>yum groupinstall Fonts</code> 这两个。</p>\n<p>另外参考 <a href=\"https://cnodejs.org/topic/53f98ad8bbdaa79d518c0836\">用node-canvas绘制中文的时候乱码怎么解决？</a> 问题里的 5 楼，使用了微软雅黑。</p>\n<p>还有 <a href=\"https://github.com/Automattic/node-canvas/issues/461\">issue#461</a>，在字体两侧加上引号。</p>\n<p>我按这三个做了，然后 <strong>重启项目</strong> 就好了~</p>"},{"title":"中心极限定理","date":"2017-01-23T14:28:45.000Z","_content":"\n中心极限定理非常简单，但非常强大。\n\n<!--more-->\n\n假设这里有一枚古怪的骰子，它有 30% 的概率掷到 1，20% 的概率掷到 3，10% 的概率掷到 4，40% 的概率掷到6，且永远不会掷到 2 和 5。下面是它古怪的概率分布图。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/central-limit-theorem/0.png)\n\n下面我随机掷 10 次骰子，并计算出这 10 次结果的平均数。把这个过程称为一次试验，重复进行 100000 次后，记录各种平均数出现的次数，得到这样的结果：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/central-limit-theorem/1.png)\n\n可能现在还不太明显，继续增加每次试验掷骰子的次数 n，从 10 增加到 25，得到结果如下：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/central-limit-theorem/2.png)\n\n跟正态分布图很像！实际上，n 越大，这个图像越接近 **正态分布**，这也是中心极限定理给出的：\n\n> 如果你从总体中随机抽取多个样本，那么每一样本的平均数趋于正态分布。\n\n**这真是一件神奇的事情，骰子的概率分布图跟正态分布八竿子打不到一起，但是最终得到了一个正态分布图。**\n\n## 中心极限定理\n\n不仅如此，中心极限定理还给出了样本和总体具有的紧密联系。\n\n1. 样本平均数的平均数等于总体的平均数。\n2. 样本平均数的方差 $\\sigma\\_{\\overline{X}}^2$ 等于 总体方差 $\\sigma^2$ 除以 n，即 $\\sigma\\_{\\overline{X}}^2 = \\frac{\\sigma^2}{n}$\n\n听起来有点绕口，结合上面例子，我们在 100000 次试验中得到了 100000 组样本，每组样本的样本数是 25，那么，这些样本的平均数趋于正态分布。\n\n样本均值也就是指上面得到的 100000 个平均数；样本均值的平均数即这 100000 个平均数的平均数；样本均值的方差即这 100000 个平均数的方差。\n\n我们可以验证一下中心极限定理给出的等式：\n\n在上面的例子里面，总体的期望值\n\n$$\n\\mu = 0.3 \\times 1 + 0.2 \\times 3 + 0.1 \\times 4 + 0.4 \\times 6 = 3.5\n$$\n\n总体的方差\n$$\n\\sigma^2 = 0.3 \\times (1 - 3.5)^2 + 0.2 \\times (3 - 3.5)^2 + 0.1 \\times (4 - 3.5)^2 + 0.4 \\times (6 - 3.5)^2 = 4.45\n$$\n\n以 $n = 25$，为例，此时的 $\\overline{X} = 3.7$，$\\sigma\\_{\\overline{X}}^2 = 0.176$（做试验的时候就能算出来）。\n\n而根据公式，$\\frac{\\sigma^2}{n} = \\frac{4.45}{25} = 0.175$，和 0.176 已经非常接近了。\n\n所以，使用中心极限定理，可以根据样本估计总体的情况，也可以在已知总体的情况对样本做估计。\n\n## 例子\n\n举个实际的例子：\n\n男性在户外活动时平均需要喝 2 升水，标准差 0.7 升，你先在要为 50 个男性策划一个户外活动，并准备携带 110 升水，请问水不够的概率是多少？\n\n水不够也就是说 50 个男性饮水量超过了 110 升水，所以实际上问题等同于 50 个男性平均饮水量超过 $110 / 50 = 2.2$ 升水的概率是多少。\n\n而 50 正是从总体中抽出的样本数 n，根据中心极限定理：\n\n1. 样本均值的均值 $\\overline{X} = \\mu = 2$\n2. 当 n = 50 时，样本均值方差 $\\sigma\\_{\\overline{X}}^2 = \\frac{\\sigma^2}{n}$，那么样本均值标准差 $\\sigma\\_{\\overline{X}} = \\frac{\\sigma}{\\sqrt{n}} = \\frac{0.7}{\\sqrt{50}} = 0.099$\n\n*为了方便讨论，把 0.099 约成 0.1。*\n\n那么，样本均值即是满足 $\\mu = 2$，${\\sigma = 0.1}$ 的正态分布。\n\n回到问题上来，也就是求在这个正态分布中，大于 2.2 的概率是多少？\n\n2.2 超过了均值(2) 2 个标准差(0.1)，根据经验法则，这个概率也就是 $1 - (0.5 + 0.95 / 2) = 0.025$。\n","source":"_posts/central-limit-theorem.md","raw":"---\ntitle: 中心极限定理\ndate: 2017-01-23 22:28:45\ntags: [统计学]\n---\n\n中心极限定理非常简单，但非常强大。\n\n<!--more-->\n\n假设这里有一枚古怪的骰子，它有 30% 的概率掷到 1，20% 的概率掷到 3，10% 的概率掷到 4，40% 的概率掷到6，且永远不会掷到 2 和 5。下面是它古怪的概率分布图。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/central-limit-theorem/0.png)\n\n下面我随机掷 10 次骰子，并计算出这 10 次结果的平均数。把这个过程称为一次试验，重复进行 100000 次后，记录各种平均数出现的次数，得到这样的结果：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/central-limit-theorem/1.png)\n\n可能现在还不太明显，继续增加每次试验掷骰子的次数 n，从 10 增加到 25，得到结果如下：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/central-limit-theorem/2.png)\n\n跟正态分布图很像！实际上，n 越大，这个图像越接近 **正态分布**，这也是中心极限定理给出的：\n\n> 如果你从总体中随机抽取多个样本，那么每一样本的平均数趋于正态分布。\n\n**这真是一件神奇的事情，骰子的概率分布图跟正态分布八竿子打不到一起，但是最终得到了一个正态分布图。**\n\n## 中心极限定理\n\n不仅如此，中心极限定理还给出了样本和总体具有的紧密联系。\n\n1. 样本平均数的平均数等于总体的平均数。\n2. 样本平均数的方差 $\\sigma\\_{\\overline{X}}^2$ 等于 总体方差 $\\sigma^2$ 除以 n，即 $\\sigma\\_{\\overline{X}}^2 = \\frac{\\sigma^2}{n}$\n\n听起来有点绕口，结合上面例子，我们在 100000 次试验中得到了 100000 组样本，每组样本的样本数是 25，那么，这些样本的平均数趋于正态分布。\n\n样本均值也就是指上面得到的 100000 个平均数；样本均值的平均数即这 100000 个平均数的平均数；样本均值的方差即这 100000 个平均数的方差。\n\n我们可以验证一下中心极限定理给出的等式：\n\n在上面的例子里面，总体的期望值\n\n$$\n\\mu = 0.3 \\times 1 + 0.2 \\times 3 + 0.1 \\times 4 + 0.4 \\times 6 = 3.5\n$$\n\n总体的方差\n$$\n\\sigma^2 = 0.3 \\times (1 - 3.5)^2 + 0.2 \\times (3 - 3.5)^2 + 0.1 \\times (4 - 3.5)^2 + 0.4 \\times (6 - 3.5)^2 = 4.45\n$$\n\n以 $n = 25$，为例，此时的 $\\overline{X} = 3.7$，$\\sigma\\_{\\overline{X}}^2 = 0.176$（做试验的时候就能算出来）。\n\n而根据公式，$\\frac{\\sigma^2}{n} = \\frac{4.45}{25} = 0.175$，和 0.176 已经非常接近了。\n\n所以，使用中心极限定理，可以根据样本估计总体的情况，也可以在已知总体的情况对样本做估计。\n\n## 例子\n\n举个实际的例子：\n\n男性在户外活动时平均需要喝 2 升水，标准差 0.7 升，你先在要为 50 个男性策划一个户外活动，并准备携带 110 升水，请问水不够的概率是多少？\n\n水不够也就是说 50 个男性饮水量超过了 110 升水，所以实际上问题等同于 50 个男性平均饮水量超过 $110 / 50 = 2.2$ 升水的概率是多少。\n\n而 50 正是从总体中抽出的样本数 n，根据中心极限定理：\n\n1. 样本均值的均值 $\\overline{X} = \\mu = 2$\n2. 当 n = 50 时，样本均值方差 $\\sigma\\_{\\overline{X}}^2 = \\frac{\\sigma^2}{n}$，那么样本均值标准差 $\\sigma\\_{\\overline{X}} = \\frac{\\sigma}{\\sqrt{n}} = \\frac{0.7}{\\sqrt{50}} = 0.099$\n\n*为了方便讨论，把 0.099 约成 0.1。*\n\n那么，样本均值即是满足 $\\mu = 2$，${\\sigma = 0.1}$ 的正态分布。\n\n回到问题上来，也就是求在这个正态分布中，大于 2.2 的概率是多少？\n\n2.2 超过了均值(2) 2 个标准差(0.1)，根据经验法则，这个概率也就是 $1 - (0.5 + 0.95 / 2) = 0.025$。\n","slug":"central-limit-theorem","published":1,"updated":"2017-01-23T16:33:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcvd000on927jig79d6m","content":"<p>中心极限定理非常简单，但非常强大。</p>\n<a id=\"more\"></a>\n<p>假设这里有一枚古怪的骰子，它有 30% 的概率掷到 1，20% 的概率掷到 3，10% 的概率掷到 4，40% 的概率掷到6，且永远不会掷到 2 和 5。下面是它古怪的概率分布图。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/central-limit-theorem/0.png\" alt=\"\"></p>\n<p>下面我随机掷 10 次骰子，并计算出这 10 次结果的平均数。把这个过程称为一次试验，重复进行 100000 次后，记录各种平均数出现的次数，得到这样的结果：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/central-limit-theorem/1.png\" alt=\"\"></p>\n<p>可能现在还不太明显，继续增加每次试验掷骰子的次数 n，从 10 增加到 25，得到结果如下：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/central-limit-theorem/2.png\" alt=\"\"></p>\n<p>跟正态分布图很像！实际上，n 越大，这个图像越接近 <strong>正态分布</strong>，这也是中心极限定理给出的：</p>\n<blockquote>\n<p>如果你从总体中随机抽取多个样本，那么每一样本的平均数趋于正态分布。</p>\n</blockquote>\n<p><strong>这真是一件神奇的事情，骰子的概率分布图跟正态分布八竿子打不到一起，但是最终得到了一个正态分布图。</strong></p>\n<h2 id=\"中心极限定理\"><a href=\"#中心极限定理\" class=\"headerlink\" title=\"中心极限定理\"></a>中心极限定理</h2><p>不仅如此，中心极限定理还给出了样本和总体具有的紧密联系。</p>\n<ol>\n<li>样本平均数的平均数等于总体的平均数。</li>\n<li>样本平均数的方差 $\\sigma_{\\overline{X}}^2$ 等于 总体方差 $\\sigma^2$ 除以 n，即 $\\sigma_{\\overline{X}}^2 = \\frac{\\sigma^2}{n}$</li>\n</ol>\n<p>听起来有点绕口，结合上面例子，我们在 100000 次试验中得到了 100000 组样本，每组样本的样本数是 25，那么，这些样本的平均数趋于正态分布。</p>\n<p>样本均值也就是指上面得到的 100000 个平均数；样本均值的平均数即这 100000 个平均数的平均数；样本均值的方差即这 100000 个平均数的方差。</p>\n<p>我们可以验证一下中心极限定理给出的等式：</p>\n<p>在上面的例子里面，总体的期望值</p>\n<p>$$<br>\\mu = 0.3 \\times 1 + 0.2 \\times 3 + 0.1 \\times 4 + 0.4 \\times 6 = 3.5<br>$$</p>\n<p>总体的方差<br>$$<br>\\sigma^2 = 0.3 \\times (1 - 3.5)^2 + 0.2 \\times (3 - 3.5)^2 + 0.1 \\times (4 - 3.5)^2 + 0.4 \\times (6 - 3.5)^2 = 4.45<br>$$</p>\n<p>以 $n = 25$，为例，此时的 $\\overline{X} = 3.7$，$\\sigma_{\\overline{X}}^2 = 0.176$（做试验的时候就能算出来）。</p>\n<p>而根据公式，$\\frac{\\sigma^2}{n} = \\frac{4.45}{25} = 0.175$，和 0.176 已经非常接近了。</p>\n<p>所以，使用中心极限定理，可以根据样本估计总体的情况，也可以在已知总体的情况对样本做估计。</p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>举个实际的例子：</p>\n<p>男性在户外活动时平均需要喝 2 升水，标准差 0.7 升，你先在要为 50 个男性策划一个户外活动，并准备携带 110 升水，请问水不够的概率是多少？</p>\n<p>水不够也就是说 50 个男性饮水量超过了 110 升水，所以实际上问题等同于 50 个男性平均饮水量超过 $110 / 50 = 2.2$ 升水的概率是多少。</p>\n<p>而 50 正是从总体中抽出的样本数 n，根据中心极限定理：</p>\n<ol>\n<li>样本均值的均值 $\\overline{X} = \\mu = 2$</li>\n<li>当 n = 50 时，样本均值方差 $\\sigma_{\\overline{X}}^2 = \\frac{\\sigma^2}{n}$，那么样本均值标准差 $\\sigma_{\\overline{X}} = \\frac{\\sigma}{\\sqrt{n}} = \\frac{0.7}{\\sqrt{50}} = 0.099$</li>\n</ol>\n<p><em>为了方便讨论，把 0.099 约成 0.1。</em></p>\n<p>那么，样本均值即是满足 $\\mu = 2$，${\\sigma = 0.1}$ 的正态分布。</p>\n<p>回到问题上来，也就是求在这个正态分布中，大于 2.2 的概率是多少？</p>\n<p>2.2 超过了均值(2) 2 个标准差(0.1)，根据经验法则，这个概率也就是 $1 - (0.5 + 0.95 / 2) = 0.025$。</p>\n","excerpt":"<p>中心极限定理非常简单，但非常强大。</p>","more":"<p>假设这里有一枚古怪的骰子，它有 30% 的概率掷到 1，20% 的概率掷到 3，10% 的概率掷到 4，40% 的概率掷到6，且永远不会掷到 2 和 5。下面是它古怪的概率分布图。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/central-limit-theorem/0.png\" alt=\"\"></p>\n<p>下面我随机掷 10 次骰子，并计算出这 10 次结果的平均数。把这个过程称为一次试验，重复进行 100000 次后，记录各种平均数出现的次数，得到这样的结果：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/central-limit-theorem/1.png\" alt=\"\"></p>\n<p>可能现在还不太明显，继续增加每次试验掷骰子的次数 n，从 10 增加到 25，得到结果如下：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/central-limit-theorem/2.png\" alt=\"\"></p>\n<p>跟正态分布图很像！实际上，n 越大，这个图像越接近 <strong>正态分布</strong>，这也是中心极限定理给出的：</p>\n<blockquote>\n<p>如果你从总体中随机抽取多个样本，那么每一样本的平均数趋于正态分布。</p>\n</blockquote>\n<p><strong>这真是一件神奇的事情，骰子的概率分布图跟正态分布八竿子打不到一起，但是最终得到了一个正态分布图。</strong></p>\n<h2 id=\"中心极限定理\"><a href=\"#中心极限定理\" class=\"headerlink\" title=\"中心极限定理\"></a>中心极限定理</h2><p>不仅如此，中心极限定理还给出了样本和总体具有的紧密联系。</p>\n<ol>\n<li>样本平均数的平均数等于总体的平均数。</li>\n<li>样本平均数的方差 $\\sigma_{\\overline{X}}^2$ 等于 总体方差 $\\sigma^2$ 除以 n，即 $\\sigma_{\\overline{X}}^2 = \\frac{\\sigma^2}{n}$</li>\n</ol>\n<p>听起来有点绕口，结合上面例子，我们在 100000 次试验中得到了 100000 组样本，每组样本的样本数是 25，那么，这些样本的平均数趋于正态分布。</p>\n<p>样本均值也就是指上面得到的 100000 个平均数；样本均值的平均数即这 100000 个平均数的平均数；样本均值的方差即这 100000 个平均数的方差。</p>\n<p>我们可以验证一下中心极限定理给出的等式：</p>\n<p>在上面的例子里面，总体的期望值</p>\n<p>$$<br>\\mu = 0.3 \\times 1 + 0.2 \\times 3 + 0.1 \\times 4 + 0.4 \\times 6 = 3.5<br>$$</p>\n<p>总体的方差<br>$$<br>\\sigma^2 = 0.3 \\times (1 - 3.5)^2 + 0.2 \\times (3 - 3.5)^2 + 0.1 \\times (4 - 3.5)^2 + 0.4 \\times (6 - 3.5)^2 = 4.45<br>$$</p>\n<p>以 $n = 25$，为例，此时的 $\\overline{X} = 3.7$，$\\sigma_{\\overline{X}}^2 = 0.176$（做试验的时候就能算出来）。</p>\n<p>而根据公式，$\\frac{\\sigma^2}{n} = \\frac{4.45}{25} = 0.175$，和 0.176 已经非常接近了。</p>\n<p>所以，使用中心极限定理，可以根据样本估计总体的情况，也可以在已知总体的情况对样本做估计。</p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>举个实际的例子：</p>\n<p>男性在户外活动时平均需要喝 2 升水，标准差 0.7 升，你先在要为 50 个男性策划一个户外活动，并准备携带 110 升水，请问水不够的概率是多少？</p>\n<p>水不够也就是说 50 个男性饮水量超过了 110 升水，所以实际上问题等同于 50 个男性平均饮水量超过 $110 / 50 = 2.2$ 升水的概率是多少。</p>\n<p>而 50 正是从总体中抽出的样本数 n，根据中心极限定理：</p>\n<ol>\n<li>样本均值的均值 $\\overline{X} = \\mu = 2$</li>\n<li>当 n = 50 时，样本均值方差 $\\sigma_{\\overline{X}}^2 = \\frac{\\sigma^2}{n}$，那么样本均值标准差 $\\sigma_{\\overline{X}} = \\frac{\\sigma}{\\sqrt{n}} = \\frac{0.7}{\\sqrt{50}} = 0.099$</li>\n</ol>\n<p><em>为了方便讨论，把 0.099 约成 0.1。</em></p>\n<p>那么，样本均值即是满足 $\\mu = 2$，${\\sigma = 0.1}$ 的正态分布。</p>\n<p>回到问题上来，也就是求在这个正态分布中，大于 2.2 的概率是多少？</p>\n<p>2.2 超过了均值(2) 2 个标准差(0.1)，根据经验法则，这个概率也就是 $1 - (0.5 + 0.95 / 2) = 0.025$。</p>"},{"title":"时钟运算","date":"2016-11-10T15:00:00.000Z","_content":"\n时钟运算是密码技术里面很常见的运算，在了解 Diffie-Hellman 密钥交换、RSA 之前，最好对时钟运算有一定的了解。\n\n<!-- more -->\n\n所谓时钟运算，实际上就是 **除法求余数的运算**。当时针指向 11 的时候，再过两小时，时针不会指向 13，而是回到了 1，因为钟面上最多只到 12。在这里，我们记为：\n\n$$13mod\\,12=1$$\n\n在数论中，当整数 a，b 除以 m 所得余数相等的时候，则称 a，b 对于模 m 同余，记作：\n\n$$a≡b(mod\\,m)$$\n\n读作 **a 同余于 b 模 m**，或 **a 与 b 对模 m 同余**。\n\n也就是在上面的例子中，我们也可以写作：$13≡1(mod\\,12)$，因为 1 模 12 的结果也是 1。\n\n以上就是时钟运算，其实可能我们小学的时候就已经学过了，不过在这里我们将讨论一下几个基本运算中的变换。\n\n## 乘法\n\n$$(a \\* b)\\,mod\\,n = ((a\\,mod\\,n) \\* (b\\,mod\\,n))\\,mod\\,n$$\n\n## 乘方\n\n乘方其实就是特殊的乘法\n\n$$a^b\\,mod\\,n = (a\\,mod\\,n)^b mod\\,n$$\n\n提到这两个运算的原因是我们可以通过上面这个等式快速计算诸如 $7^4 mod\\,12 = ?$\n\n显然，$7^4\\,mod\\,12 = 49^2\\,mod\\,12 = (49\\,mod\\,12)^2\\,mod\\,12 = 1\\,mod\\,12 = 1$，我们不必去计算 $7^4$ 是多少。\n\n## 对数\n\n乘方的逆运算称为对数，如果有一个式子 $7^? = 49$，我们一眼就能看出 ? 等于 2，但如果让你求 $7^?\\,mod\\,13 = 11$ 里的 ? 等于多少，我们得从 2 开始一个一个去算。\n\n在时钟运算里面，这称为 **离散对数**。当数字很大的时候，求离散对数非常困难，也非常耗时。能快速求出离散对数的算法到现在为止还没有被发现。Diffie-Hellman 密钥交换协议和 ElGamal 公钥算法中就运用到了离散对数。\n\n## 数论倒数\n\n考虑存在两个数 a，b，有 $a \\* b\\,mod\\,m = 1$，如果没有 mod 符号，当 $a \\* b = 1$ 的时候，我们说 a 和 b 是互为倒数的关系，而在时钟运算里面，则称 a 和 b 互为关于模 m 的数论倒数。即\n\n$$a * b ≡ 1 (mod\\,m)$$\n\n我们知道，除 0 以外的数都有倒数，那么在时钟运算里面是否也是如此呢？\n\n首先，0 乘任何数再模任何数都是 0，所以 0 是没有关于模 12 的数论倒数的。\n\n- $1 \\* 1 mod 12 = 1$，1 存在\n- 2 不存在\n- 3 不存在\n- 4 不存在\n- $5 \\* 5 mod 12 = 1$，5 存在\n- 6 不存在\n- $7 \\* 7 mod 12 = 1$，7 存在\n- 8 不存在\n- 9 不存在\n- 10 不存在\n- $11 \\* 1 mod 12 = 1$，11 存在\n\n看来，并不是所有数字都有关于模 12 的数论倒数的，那么有什么规律？我们可能注意到，好像他们都是质数？其实并不是（1 就不是质数），而是当 a 和 12 **最大公约数为 1** 的时候，a 才存在关于模 12 的数论倒数。也就是 **a 和 12 互质**。\n\n根据 欧拉定理（TODO）可以证明，如果两个正整数 a 和 n 互质，那么一定可以找到整数 b，使得 $a * b ≡ 1 (mod\\,n)$。","source":"_posts/clock-operation.md","raw":"---\ntitle: 时钟运算\ndate: 2016-11-10 23:00:00\ntags: [密码技术]\n---\n\n时钟运算是密码技术里面很常见的运算，在了解 Diffie-Hellman 密钥交换、RSA 之前，最好对时钟运算有一定的了解。\n\n<!-- more -->\n\n所谓时钟运算，实际上就是 **除法求余数的运算**。当时针指向 11 的时候，再过两小时，时针不会指向 13，而是回到了 1，因为钟面上最多只到 12。在这里，我们记为：\n\n$$13mod\\,12=1$$\n\n在数论中，当整数 a，b 除以 m 所得余数相等的时候，则称 a，b 对于模 m 同余，记作：\n\n$$a≡b(mod\\,m)$$\n\n读作 **a 同余于 b 模 m**，或 **a 与 b 对模 m 同余**。\n\n也就是在上面的例子中，我们也可以写作：$13≡1(mod\\,12)$，因为 1 模 12 的结果也是 1。\n\n以上就是时钟运算，其实可能我们小学的时候就已经学过了，不过在这里我们将讨论一下几个基本运算中的变换。\n\n## 乘法\n\n$$(a \\* b)\\,mod\\,n = ((a\\,mod\\,n) \\* (b\\,mod\\,n))\\,mod\\,n$$\n\n## 乘方\n\n乘方其实就是特殊的乘法\n\n$$a^b\\,mod\\,n = (a\\,mod\\,n)^b mod\\,n$$\n\n提到这两个运算的原因是我们可以通过上面这个等式快速计算诸如 $7^4 mod\\,12 = ?$\n\n显然，$7^4\\,mod\\,12 = 49^2\\,mod\\,12 = (49\\,mod\\,12)^2\\,mod\\,12 = 1\\,mod\\,12 = 1$，我们不必去计算 $7^4$ 是多少。\n\n## 对数\n\n乘方的逆运算称为对数，如果有一个式子 $7^? = 49$，我们一眼就能看出 ? 等于 2，但如果让你求 $7^?\\,mod\\,13 = 11$ 里的 ? 等于多少，我们得从 2 开始一个一个去算。\n\n在时钟运算里面，这称为 **离散对数**。当数字很大的时候，求离散对数非常困难，也非常耗时。能快速求出离散对数的算法到现在为止还没有被发现。Diffie-Hellman 密钥交换协议和 ElGamal 公钥算法中就运用到了离散对数。\n\n## 数论倒数\n\n考虑存在两个数 a，b，有 $a \\* b\\,mod\\,m = 1$，如果没有 mod 符号，当 $a \\* b = 1$ 的时候，我们说 a 和 b 是互为倒数的关系，而在时钟运算里面，则称 a 和 b 互为关于模 m 的数论倒数。即\n\n$$a * b ≡ 1 (mod\\,m)$$\n\n我们知道，除 0 以外的数都有倒数，那么在时钟运算里面是否也是如此呢？\n\n首先，0 乘任何数再模任何数都是 0，所以 0 是没有关于模 12 的数论倒数的。\n\n- $1 \\* 1 mod 12 = 1$，1 存在\n- 2 不存在\n- 3 不存在\n- 4 不存在\n- $5 \\* 5 mod 12 = 1$，5 存在\n- 6 不存在\n- $7 \\* 7 mod 12 = 1$，7 存在\n- 8 不存在\n- 9 不存在\n- 10 不存在\n- $11 \\* 1 mod 12 = 1$，11 存在\n\n看来，并不是所有数字都有关于模 12 的数论倒数的，那么有什么规律？我们可能注意到，好像他们都是质数？其实并不是（1 就不是质数），而是当 a 和 12 **最大公约数为 1** 的时候，a 才存在关于模 12 的数论倒数。也就是 **a 和 12 互质**。\n\n根据 欧拉定理（TODO）可以证明，如果两个正整数 a 和 n 互质，那么一定可以找到整数 b，使得 $a * b ≡ 1 (mod\\,n)$。","slug":"clock-operation","published":1,"updated":"2017-01-23T13:52:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcvf000qn927r614pjth","content":"<p>时钟运算是密码技术里面很常见的运算，在了解 Diffie-Hellman 密钥交换、RSA 之前，最好对时钟运算有一定的了解。</p>\n<a id=\"more\"></a>\n<p>所谓时钟运算，实际上就是 <strong>除法求余数的运算</strong>。当时针指向 11 的时候，再过两小时，时针不会指向 13，而是回到了 1，因为钟面上最多只到 12。在这里，我们记为：</p>\n<p>$$13mod\\,12=1$$</p>\n<p>在数论中，当整数 a，b 除以 m 所得余数相等的时候，则称 a，b 对于模 m 同余，记作：</p>\n<p>$$a≡b(mod\\,m)$$</p>\n<p>读作 <strong>a 同余于 b 模 m</strong>，或 <strong>a 与 b 对模 m 同余</strong>。</p>\n<p>也就是在上面的例子中，我们也可以写作：$13≡1(mod\\,12)$，因为 1 模 12 的结果也是 1。</p>\n<p>以上就是时钟运算，其实可能我们小学的时候就已经学过了，不过在这里我们将讨论一下几个基本运算中的变换。</p>\n<h2 id=\"乘法\"><a href=\"#乘法\" class=\"headerlink\" title=\"乘法\"></a>乘法</h2><p>$$(a * b)\\,mod\\,n = ((a\\,mod\\,n) * (b\\,mod\\,n))\\,mod\\,n$$</p>\n<h2 id=\"乘方\"><a href=\"#乘方\" class=\"headerlink\" title=\"乘方\"></a>乘方</h2><p>乘方其实就是特殊的乘法</p>\n<p>$$a^b\\,mod\\,n = (a\\,mod\\,n)^b mod\\,n$$</p>\n<p>提到这两个运算的原因是我们可以通过上面这个等式快速计算诸如 $7^4 mod\\,12 = ?$</p>\n<p>显然，$7^4\\,mod\\,12 = 49^2\\,mod\\,12 = (49\\,mod\\,12)^2\\,mod\\,12 = 1\\,mod\\,12 = 1$，我们不必去计算 $7^4$ 是多少。</p>\n<h2 id=\"对数\"><a href=\"#对数\" class=\"headerlink\" title=\"对数\"></a>对数</h2><p>乘方的逆运算称为对数，如果有一个式子 $7^? = 49$，我们一眼就能看出 ? 等于 2，但如果让你求 $7^?\\,mod\\,13 = 11$ 里的 ? 等于多少，我们得从 2 开始一个一个去算。</p>\n<p>在时钟运算里面，这称为 <strong>离散对数</strong>。当数字很大的时候，求离散对数非常困难，也非常耗时。能快速求出离散对数的算法到现在为止还没有被发现。Diffie-Hellman 密钥交换协议和 ElGamal 公钥算法中就运用到了离散对数。</p>\n<h2 id=\"数论倒数\"><a href=\"#数论倒数\" class=\"headerlink\" title=\"数论倒数\"></a>数论倒数</h2><p>考虑存在两个数 a，b，有 $a * b\\,mod\\,m = 1$，如果没有 mod 符号，当 $a * b = 1$ 的时候，我们说 a 和 b 是互为倒数的关系，而在时钟运算里面，则称 a 和 b 互为关于模 m 的数论倒数。即</p>\n<p>$$a * b ≡ 1 (mod\\,m)$$</p>\n<p>我们知道，除 0 以外的数都有倒数，那么在时钟运算里面是否也是如此呢？</p>\n<p>首先，0 乘任何数再模任何数都是 0，所以 0 是没有关于模 12 的数论倒数的。</p>\n<ul>\n<li>$1 * 1 mod 12 = 1$，1 存在</li>\n<li>2 不存在</li>\n<li>3 不存在</li>\n<li>4 不存在</li>\n<li>$5 * 5 mod 12 = 1$，5 存在</li>\n<li>6 不存在</li>\n<li>$7 * 7 mod 12 = 1$，7 存在</li>\n<li>8 不存在</li>\n<li>9 不存在</li>\n<li>10 不存在</li>\n<li>$11 * 1 mod 12 = 1$，11 存在</li>\n</ul>\n<p>看来，并不是所有数字都有关于模 12 的数论倒数的，那么有什么规律？我们可能注意到，好像他们都是质数？其实并不是（1 就不是质数），而是当 a 和 12 <strong>最大公约数为 1</strong> 的时候，a 才存在关于模 12 的数论倒数。也就是 <strong>a 和 12 互质</strong>。</p>\n<p>根据 欧拉定理（TODO）可以证明，如果两个正整数 a 和 n 互质，那么一定可以找到整数 b，使得 $a * b ≡ 1 (mod\\,n)$。</p>\n","excerpt":"<p>时钟运算是密码技术里面很常见的运算，在了解 Diffie-Hellman 密钥交换、RSA 之前，最好对时钟运算有一定的了解。</p>","more":"<p>所谓时钟运算，实际上就是 <strong>除法求余数的运算</strong>。当时针指向 11 的时候，再过两小时，时针不会指向 13，而是回到了 1，因为钟面上最多只到 12。在这里，我们记为：</p>\n<p>$$13mod\\,12=1$$</p>\n<p>在数论中，当整数 a，b 除以 m 所得余数相等的时候，则称 a，b 对于模 m 同余，记作：</p>\n<p>$$a≡b(mod\\,m)$$</p>\n<p>读作 <strong>a 同余于 b 模 m</strong>，或 <strong>a 与 b 对模 m 同余</strong>。</p>\n<p>也就是在上面的例子中，我们也可以写作：$13≡1(mod\\,12)$，因为 1 模 12 的结果也是 1。</p>\n<p>以上就是时钟运算，其实可能我们小学的时候就已经学过了，不过在这里我们将讨论一下几个基本运算中的变换。</p>\n<h2 id=\"乘法\"><a href=\"#乘法\" class=\"headerlink\" title=\"乘法\"></a>乘法</h2><p>$$(a * b)\\,mod\\,n = ((a\\,mod\\,n) * (b\\,mod\\,n))\\,mod\\,n$$</p>\n<h2 id=\"乘方\"><a href=\"#乘方\" class=\"headerlink\" title=\"乘方\"></a>乘方</h2><p>乘方其实就是特殊的乘法</p>\n<p>$$a^b\\,mod\\,n = (a\\,mod\\,n)^b mod\\,n$$</p>\n<p>提到这两个运算的原因是我们可以通过上面这个等式快速计算诸如 $7^4 mod\\,12 = ?$</p>\n<p>显然，$7^4\\,mod\\,12 = 49^2\\,mod\\,12 = (49\\,mod\\,12)^2\\,mod\\,12 = 1\\,mod\\,12 = 1$，我们不必去计算 $7^4$ 是多少。</p>\n<h2 id=\"对数\"><a href=\"#对数\" class=\"headerlink\" title=\"对数\"></a>对数</h2><p>乘方的逆运算称为对数，如果有一个式子 $7^? = 49$，我们一眼就能看出 ? 等于 2，但如果让你求 $7^?\\,mod\\,13 = 11$ 里的 ? 等于多少，我们得从 2 开始一个一个去算。</p>\n<p>在时钟运算里面，这称为 <strong>离散对数</strong>。当数字很大的时候，求离散对数非常困难，也非常耗时。能快速求出离散对数的算法到现在为止还没有被发现。Diffie-Hellman 密钥交换协议和 ElGamal 公钥算法中就运用到了离散对数。</p>\n<h2 id=\"数论倒数\"><a href=\"#数论倒数\" class=\"headerlink\" title=\"数论倒数\"></a>数论倒数</h2><p>考虑存在两个数 a，b，有 $a * b\\,mod\\,m = 1$，如果没有 mod 符号，当 $a * b = 1$ 的时候，我们说 a 和 b 是互为倒数的关系，而在时钟运算里面，则称 a 和 b 互为关于模 m 的数论倒数。即</p>\n<p>$$a * b ≡ 1 (mod\\,m)$$</p>\n<p>我们知道，除 0 以外的数都有倒数，那么在时钟运算里面是否也是如此呢？</p>\n<p>首先，0 乘任何数再模任何数都是 0，所以 0 是没有关于模 12 的数论倒数的。</p>\n<ul>\n<li>$1 * 1 mod 12 = 1$，1 存在</li>\n<li>2 不存在</li>\n<li>3 不存在</li>\n<li>4 不存在</li>\n<li>$5 * 5 mod 12 = 1$，5 存在</li>\n<li>6 不存在</li>\n<li>$7 * 7 mod 12 = 1$，7 存在</li>\n<li>8 不存在</li>\n<li>9 不存在</li>\n<li>10 不存在</li>\n<li>$11 * 1 mod 12 = 1$，11 存在</li>\n</ul>\n<p>看来，并不是所有数字都有关于模 12 的数论倒数的，那么有什么规律？我们可能注意到，好像他们都是质数？其实并不是（1 就不是质数），而是当 a 和 12 <strong>最大公约数为 1</strong> 的时候，a 才存在关于模 12 的数论倒数。也就是 <strong>a 和 12 互质</strong>。</p>\n<p>根据 欧拉定理（TODO）可以证明，如果两个正整数 a 和 n 互质，那么一定可以找到整数 b，使得 $a * b ≡ 1 (mod\\,n)$。</p>"},{"title":"决定系数 $R^2$","date":"2017-02-20T14:22:11.000Z","_content":"\n前一篇求出了散点的平均误差表达式，并求出了平均误差最小的直线方程，其实还有一种对直线拟合程度更有意义的估计：考虑 y 的波动程度有多少百分比能被 x 的波动程度所描述。\n\n<!-- more -->\n\n衡量 y 的波动程度可以用各点离 y 的均值的距离平方之和来表示，即\n\n$$\nSE\\_{\\overline{y}} = (y\\_1 - \\overline{y})^2 + (y\\_2 - \\overline{y})^2 + ... + (y\\_n - \\overline{y})^2\n$$\n\n要考虑其中能被回归线描述的部分，可以先看没有被回归线描述的部分，这个部分即回归线的平方误差，即上一篇所求 $SE_{line}$\n\n那么 y 的波动程度能被 x 的波动程度所描述的百分比即\n\n$$\n1 - \\frac{SE\\_{line}}{SE\\_{\\overline{y}}}\n$$\n\n这个值也就是决定系数 $R^2$，$R^2$ 越大，则说明直线的拟合程度越好。\n","source":"_posts/coefficient-of-determination.md","raw":"---\ntitle: 决定系数 $R^2$\ndate: 2017-02-20 22:22:11\ntags: [统计学]\n---\n\n前一篇求出了散点的平均误差表达式，并求出了平均误差最小的直线方程，其实还有一种对直线拟合程度更有意义的估计：考虑 y 的波动程度有多少百分比能被 x 的波动程度所描述。\n\n<!-- more -->\n\n衡量 y 的波动程度可以用各点离 y 的均值的距离平方之和来表示，即\n\n$$\nSE\\_{\\overline{y}} = (y\\_1 - \\overline{y})^2 + (y\\_2 - \\overline{y})^2 + ... + (y\\_n - \\overline{y})^2\n$$\n\n要考虑其中能被回归线描述的部分，可以先看没有被回归线描述的部分，这个部分即回归线的平方误差，即上一篇所求 $SE_{line}$\n\n那么 y 的波动程度能被 x 的波动程度所描述的百分比即\n\n$$\n1 - \\frac{SE\\_{line}}{SE\\_{\\overline{y}}}\n$$\n\n这个值也就是决定系数 $R^2$，$R^2$ 越大，则说明直线的拟合程度越好。\n","slug":"coefficient-of-determination","published":1,"updated":"2017-02-20T15:15:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcvh000sn927bsoh14p0","content":"<p>前一篇求出了散点的平均误差表达式，并求出了平均误差最小的直线方程，其实还有一种对直线拟合程度更有意义的估计：考虑 y 的波动程度有多少百分比能被 x 的波动程度所描述。</p>\n<a id=\"more\"></a>\n<p>衡量 y 的波动程度可以用各点离 y 的均值的距离平方之和来表示，即</p>\n<p>$$<br>SE_{\\overline{y}} = (y_1 - \\overline{y})^2 + (y_2 - \\overline{y})^2 + … + (y_n - \\overline{y})^2<br>$$</p>\n<p>要考虑其中能被回归线描述的部分，可以先看没有被回归线描述的部分，这个部分即回归线的平方误差，即上一篇所求 $SE_{line}$</p>\n<p>那么 y 的波动程度能被 x 的波动程度所描述的百分比即</p>\n<p>$$<br>1 - \\frac{SE_{line}}{SE_{\\overline{y}}}<br>$$</p>\n<p>这个值也就是决定系数 $R^2$，$R^2$ 越大，则说明直线的拟合程度越好。</p>\n","excerpt":"<p>前一篇求出了散点的平均误差表达式，并求出了平均误差最小的直线方程，其实还有一种对直线拟合程度更有意义的估计：考虑 y 的波动程度有多少百分比能被 x 的波动程度所描述。</p>","more":"<p>衡量 y 的波动程度可以用各点离 y 的均值的距离平方之和来表示，即</p>\n<p>$$<br>SE_{\\overline{y}} = (y_1 - \\overline{y})^2 + (y_2 - \\overline{y})^2 + … + (y_n - \\overline{y})^2<br>$$</p>\n<p>要考虑其中能被回归线描述的部分，可以先看没有被回归线描述的部分，这个部分即回归线的平方误差，即上一篇所求 $SE_{line}$</p>\n<p>那么 y 的波动程度能被 x 的波动程度所描述的百分比即</p>\n<p>$$<br>1 - \\frac{SE_{line}}{SE_{\\overline{y}}}<br>$$</p>\n<p>这个值也就是决定系数 $R^2$，$R^2$ 越大，则说明直线的拟合程度越好。</p>"},{"title":"求导四则运算和常见求导公式的推导","date":"2017-02-25T10:10:50.000Z","_content":"\n求导四则运算和常见求导公式的推导过程。\n\n<!-- more -->\n\n## 求导四则运算\n\n### 乘法\n\n设有函数 u、v\n\n$$\n\\begin{align}\n(uv)' &= \\lim\\_{\\Delta x \\to 0} \\cfrac{\\Delta (uv)}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\cfrac{u(x + \\Delta x) \\cdot v(x + \\Delta x) - u(x) \\cdot v(x)}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\cfrac{u(x + \\Delta x) \\cdot v(x + \\Delta x) - u(x) \\cdot v(x + \\Delta x) + u(x) \\cdot v(x + \\Delta x) - u(x) \\cdot v(x)}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\cfrac{v(x + \\Delta x) \\cdot [u(x + \\Delta x) - u(x)] + u(x) \\cdot [v(x + \\Delta x) - v(x)]}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\cfrac{v(x + \\Delta x) \\cdot \\Delta u + u(x) \\cdot \\Delta v}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\cfrac{v(x) \\cdot \\Delta u + u(x) \\cdot \\Delta v}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\left( v\\cfrac{\\Delta u}{\\Delta x} + u\\cfrac{\\Delta v}{\\Delta x} \\right) \\\\\\\n&= u'v + uv' \\\\\\\n\\end{align}\n$$\n\n### 除法\n\n#### 使用导数的定义\n\n$$\n\\begin{align}\n\\Delta \\cfrac{u}{v} &= \\lim\\_{\\Delta x \\to 0} \\left( \\cfrac{u + \\Delta u}{v + \\Delta v} - \\cfrac{u}{v} \\right) \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\cfrac{(u + \\Delta u) \\cdot v - u \\cdot (v + \\Delta v)}{(v + \\Delta v) \\cdot v} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\cfrac{uv + \\Delta u \\cdot v - uv - u \\cdot \\Delta v}{(v + \\Delta v)v} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\cfrac{\\Delta u \\cdot v - u \\cdot \\Delta v}{(v + \\Delta v) \\cdot v}\n\\end{align}\n$$\n\n所以\n\n$$\n\\begin{align}\n(\\cfrac{u}{v})' &= \\lim\\_{\\Delta x \\to 0} \\cfrac{\\Delta \\cfrac{u}{v}}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\cfrac{\\cfrac{\\Delta u}{\\Delta x} \\cdot v - u \\cfrac{\\Delta v}{\\Delta x}}{(v + \\Delta v) \\cdot v} \\\\\\\n&= \\cfrac{u'v - uv'}{v^2}\n\\end{align}\n$$\n\n#### 使用链式法则\n\n由 $(x^a)' = ax^{a - 1}$ 得\n\n$$\n(\\frac{1}{v})' = (v^{-1})' = -1 \\cdot v^{-2}\n$$\n\n由此\n\n$$\n\\begin{align}\n(\\frac{u}{v})' &= (uv^{-1})' \\\\\\\n&= u'v^{-1} + u(v^{-1})' \\\\\\\n&= u'v^{-1} + u(-1 \\cdot v^{-2}) \\\\\\\n&= \\cfrac{u'v - uv'}{v^2}\n\\end{align}\n$$\n\n## 常见求导公式\n\n### 1) $\\sin x$\n\n$$\n\\begin{align}\n\\cfrac{d}{dx}\\sin x &= \\lim\\_{\\Delta x \\to 0} \\cfrac{\\sin (x + \\Delta x) - \\sin x}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\cfrac{\\sin x\\cos \\Delta x + \\cos x\\sin \\Delta x - \\sin x}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\left( \\sin x \\cfrac{\\cos \\Delta x - 1}{\\Delta x} + \\cos x\\cfrac{\\sin \\Delta x}{\\Delta x} \\right) \\\\\\\n\\end{align}\n$$\n\n而 $\\cfrac{\\cos \\Delta x - 1}{\\Delta x}$ 实际上就是 $\\cos x$ 在 x = 0 处的导数，即：\n\n$$\n\\begin{align}\n\\lim\\_{\\Delta x \\to 0} \\cfrac{\\cos \\Delta x - 1}{\\Delta x} &= \\lim\\_{\\Delta x \\to 0} \\cfrac{\\cos (0 + \\Delta x) - \\cos 0}{\\Delta x} \\\\\\\n&= \\left. \\cfrac{d}{dx}\\cos x \\right |\\_{x = 0} \\\\\\\n&= 0\n\\end{align}\n$$\n\n$\\cfrac{\\sin \\Delta x}{\\Delta x}$ 实际上就是 $\\sin x$ 在 x = 0 处的导数，即：\n\n$$\n\\begin{align}\n\\lim\\_{\\Delta x \\to 0} \\cfrac{\\sin \\Delta x}{\\Delta x} &= \\lim\\_{\\Delta x \\to 0} \\cfrac{\\sin (0 + \\Delta x) - \\sin 0}{\\Delta x} \\\\\\\n&= \\left. \\cfrac{d}{dx}\\sin x \\right |\\_{x = 0} \\\\\\\n&= 1\n\\end{align}\n$$\n\n所以\n\n$$\n\\begin{align}\n\\cfrac{d}{dx}\\sin x &= \\lim\\_{\\Delta x \\to 0} \\left( \\sin x \\cfrac{\\cos \\Delta x - 1}{\\Delta x} + \\cos x\\cfrac{\\sin \\Delta x}{\\Delta x} \\right) \\\\\\\n&= \\sin x \\cdot 0 + \\cos x \\cdot 1 \\\\\\\n&= \\cos x\n\\end{align}\n$$\n\n### 2) $\\cos x$\n\n$$\n\\begin{align}\n\\cfrac{d}{dx}\\cos x &= \\lim\\_{\\Delta x \\to 0} \\cfrac{\\cos (x + \\Delta x) - \\cos x}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\cfrac{\\cos x \\cos \\Delta x - \\sin x \\sin \\Delta x - \\cos x}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\left( \\cos x \\cfrac{\\cos \\Delta x - 1}{\\Delta x} - \\sin x \\cfrac{\\sin \\Delta x}{\\Delta x} \\right) \\\\\\\n&= \\cos x \\cdot 0 - \\sin x \\cdot 1 \\\\\\\n&= -\\sin x\n\\end{align}\n$$\n\n所以，对于 $\\cos x$ 和 $\\sin x$ 而言，**只要知道了一个点 (x = 0) 处的导数，我们就知道了整个函数的导数。**\n\n### 3) $\\tan x$\n\n$$\n\\begin{align}\n\\cfrac{d}{dx} \\tan x &= \\cfrac{d}{dx} \\cfrac{\\sin x}{\\cos x} \\\\\\\n&= \\cfrac{d}{dx} \\cfrac{\\sin' x\\cos x + \\sin x\\cos' x}{\\cos^2 x} \\\\\\\n&= \\cfrac{\\cos^2 x + \\sin^2 x}{\\cos^2 x} \\\\\\\n&= \\cfrac{1}{\\cos^2 x}\n\\end{align}\n$$\n\n### 4) $\\sec x$\n\n$$\n\\begin{align}\n\\cfrac{d}{dx} \\sec x &= \\cfrac{d}{dx} (\\cos x)^{-1} \\\\\\\n&= -1 \\cdot (\\cos x)^{-2} (-\\sin x) \\\\\\\n&= \\cfrac{\\sin x}{\\cos^2 x} \\\\\\\n&= \\cfrac{1}{\\cos x} \\cfrac{\\sin x}{\\cos x} \\\\\\\n&= \\sec x \\tan x\n\\end{align}\n$$\n\n### 5) $x^n$\n\n#### 当 n 为正整数时\n\n$$\n\\begin{align}\n(x^n)' &= \\lim\\_{\\Delta x \\to 0} \\cfrac{(x + \\Delta x)^n - x^n}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\cfrac{x^n  + nx^{n - 1}\\Delta x + O((\\Delta x)^2) - x^n}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\cfrac{nx^{n - 1}\\Delta x + O((\\Delta x)^2)}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\left( nx^{n - 1} + O(\\Delta x) \\right) \\\\\\\n&= nx^{n - 1}\n\\end{align}\n$$\n\n#### 当 n 为负整数时\n\n先考虑当 n 为正整数时，试求 $\\cfrac{1}{x^n}$ 的导数\n\n$$\n\\begin{align}\n(\\cfrac{1}{x^n})' &= \\cfrac{-nx^{n - 1}}{x^{2n}} \\\\\\\n&= -nx^{n - 1 - 2n} \\\\\\\n&= -nx^{-n - 1}\n\\end{align}\n$$\n\n即 $(x^{-n})' = -nx^{-n - 1}$，由此说明当 n 为负整数时，$(x^n)' = nx^{n - 1}$ 同样适用。\n\n#### 其他情况\n\n下一节讨论\n","source":"_posts/common-derivation-formula.md","raw":"---\ntitle: 求导四则运算和常见求导公式的推导\ndate: 2017-02-25 18:10:50\ntags: [单变量微积分]\n---\n\n求导四则运算和常见求导公式的推导过程。\n\n<!-- more -->\n\n## 求导四则运算\n\n### 乘法\n\n设有函数 u、v\n\n$$\n\\begin{align}\n(uv)' &= \\lim\\_{\\Delta x \\to 0} \\cfrac{\\Delta (uv)}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\cfrac{u(x + \\Delta x) \\cdot v(x + \\Delta x) - u(x) \\cdot v(x)}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\cfrac{u(x + \\Delta x) \\cdot v(x + \\Delta x) - u(x) \\cdot v(x + \\Delta x) + u(x) \\cdot v(x + \\Delta x) - u(x) \\cdot v(x)}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\cfrac{v(x + \\Delta x) \\cdot [u(x + \\Delta x) - u(x)] + u(x) \\cdot [v(x + \\Delta x) - v(x)]}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\cfrac{v(x + \\Delta x) \\cdot \\Delta u + u(x) \\cdot \\Delta v}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\cfrac{v(x) \\cdot \\Delta u + u(x) \\cdot \\Delta v}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\left( v\\cfrac{\\Delta u}{\\Delta x} + u\\cfrac{\\Delta v}{\\Delta x} \\right) \\\\\\\n&= u'v + uv' \\\\\\\n\\end{align}\n$$\n\n### 除法\n\n#### 使用导数的定义\n\n$$\n\\begin{align}\n\\Delta \\cfrac{u}{v} &= \\lim\\_{\\Delta x \\to 0} \\left( \\cfrac{u + \\Delta u}{v + \\Delta v} - \\cfrac{u}{v} \\right) \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\cfrac{(u + \\Delta u) \\cdot v - u \\cdot (v + \\Delta v)}{(v + \\Delta v) \\cdot v} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\cfrac{uv + \\Delta u \\cdot v - uv - u \\cdot \\Delta v}{(v + \\Delta v)v} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\cfrac{\\Delta u \\cdot v - u \\cdot \\Delta v}{(v + \\Delta v) \\cdot v}\n\\end{align}\n$$\n\n所以\n\n$$\n\\begin{align}\n(\\cfrac{u}{v})' &= \\lim\\_{\\Delta x \\to 0} \\cfrac{\\Delta \\cfrac{u}{v}}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\cfrac{\\cfrac{\\Delta u}{\\Delta x} \\cdot v - u \\cfrac{\\Delta v}{\\Delta x}}{(v + \\Delta v) \\cdot v} \\\\\\\n&= \\cfrac{u'v - uv'}{v^2}\n\\end{align}\n$$\n\n#### 使用链式法则\n\n由 $(x^a)' = ax^{a - 1}$ 得\n\n$$\n(\\frac{1}{v})' = (v^{-1})' = -1 \\cdot v^{-2}\n$$\n\n由此\n\n$$\n\\begin{align}\n(\\frac{u}{v})' &= (uv^{-1})' \\\\\\\n&= u'v^{-1} + u(v^{-1})' \\\\\\\n&= u'v^{-1} + u(-1 \\cdot v^{-2}) \\\\\\\n&= \\cfrac{u'v - uv'}{v^2}\n\\end{align}\n$$\n\n## 常见求导公式\n\n### 1) $\\sin x$\n\n$$\n\\begin{align}\n\\cfrac{d}{dx}\\sin x &= \\lim\\_{\\Delta x \\to 0} \\cfrac{\\sin (x + \\Delta x) - \\sin x}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\cfrac{\\sin x\\cos \\Delta x + \\cos x\\sin \\Delta x - \\sin x}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\left( \\sin x \\cfrac{\\cos \\Delta x - 1}{\\Delta x} + \\cos x\\cfrac{\\sin \\Delta x}{\\Delta x} \\right) \\\\\\\n\\end{align}\n$$\n\n而 $\\cfrac{\\cos \\Delta x - 1}{\\Delta x}$ 实际上就是 $\\cos x$ 在 x = 0 处的导数，即：\n\n$$\n\\begin{align}\n\\lim\\_{\\Delta x \\to 0} \\cfrac{\\cos \\Delta x - 1}{\\Delta x} &= \\lim\\_{\\Delta x \\to 0} \\cfrac{\\cos (0 + \\Delta x) - \\cos 0}{\\Delta x} \\\\\\\n&= \\left. \\cfrac{d}{dx}\\cos x \\right |\\_{x = 0} \\\\\\\n&= 0\n\\end{align}\n$$\n\n$\\cfrac{\\sin \\Delta x}{\\Delta x}$ 实际上就是 $\\sin x$ 在 x = 0 处的导数，即：\n\n$$\n\\begin{align}\n\\lim\\_{\\Delta x \\to 0} \\cfrac{\\sin \\Delta x}{\\Delta x} &= \\lim\\_{\\Delta x \\to 0} \\cfrac{\\sin (0 + \\Delta x) - \\sin 0}{\\Delta x} \\\\\\\n&= \\left. \\cfrac{d}{dx}\\sin x \\right |\\_{x = 0} \\\\\\\n&= 1\n\\end{align}\n$$\n\n所以\n\n$$\n\\begin{align}\n\\cfrac{d}{dx}\\sin x &= \\lim\\_{\\Delta x \\to 0} \\left( \\sin x \\cfrac{\\cos \\Delta x - 1}{\\Delta x} + \\cos x\\cfrac{\\sin \\Delta x}{\\Delta x} \\right) \\\\\\\n&= \\sin x \\cdot 0 + \\cos x \\cdot 1 \\\\\\\n&= \\cos x\n\\end{align}\n$$\n\n### 2) $\\cos x$\n\n$$\n\\begin{align}\n\\cfrac{d}{dx}\\cos x &= \\lim\\_{\\Delta x \\to 0} \\cfrac{\\cos (x + \\Delta x) - \\cos x}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\cfrac{\\cos x \\cos \\Delta x - \\sin x \\sin \\Delta x - \\cos x}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\left( \\cos x \\cfrac{\\cos \\Delta x - 1}{\\Delta x} - \\sin x \\cfrac{\\sin \\Delta x}{\\Delta x} \\right) \\\\\\\n&= \\cos x \\cdot 0 - \\sin x \\cdot 1 \\\\\\\n&= -\\sin x\n\\end{align}\n$$\n\n所以，对于 $\\cos x$ 和 $\\sin x$ 而言，**只要知道了一个点 (x = 0) 处的导数，我们就知道了整个函数的导数。**\n\n### 3) $\\tan x$\n\n$$\n\\begin{align}\n\\cfrac{d}{dx} \\tan x &= \\cfrac{d}{dx} \\cfrac{\\sin x}{\\cos x} \\\\\\\n&= \\cfrac{d}{dx} \\cfrac{\\sin' x\\cos x + \\sin x\\cos' x}{\\cos^2 x} \\\\\\\n&= \\cfrac{\\cos^2 x + \\sin^2 x}{\\cos^2 x} \\\\\\\n&= \\cfrac{1}{\\cos^2 x}\n\\end{align}\n$$\n\n### 4) $\\sec x$\n\n$$\n\\begin{align}\n\\cfrac{d}{dx} \\sec x &= \\cfrac{d}{dx} (\\cos x)^{-1} \\\\\\\n&= -1 \\cdot (\\cos x)^{-2} (-\\sin x) \\\\\\\n&= \\cfrac{\\sin x}{\\cos^2 x} \\\\\\\n&= \\cfrac{1}{\\cos x} \\cfrac{\\sin x}{\\cos x} \\\\\\\n&= \\sec x \\tan x\n\\end{align}\n$$\n\n### 5) $x^n$\n\n#### 当 n 为正整数时\n\n$$\n\\begin{align}\n(x^n)' &= \\lim\\_{\\Delta x \\to 0} \\cfrac{(x + \\Delta x)^n - x^n}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\cfrac{x^n  + nx^{n - 1}\\Delta x + O((\\Delta x)^2) - x^n}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\cfrac{nx^{n - 1}\\Delta x + O((\\Delta x)^2)}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\left( nx^{n - 1} + O(\\Delta x) \\right) \\\\\\\n&= nx^{n - 1}\n\\end{align}\n$$\n\n#### 当 n 为负整数时\n\n先考虑当 n 为正整数时，试求 $\\cfrac{1}{x^n}$ 的导数\n\n$$\n\\begin{align}\n(\\cfrac{1}{x^n})' &= \\cfrac{-nx^{n - 1}}{x^{2n}} \\\\\\\n&= -nx^{n - 1 - 2n} \\\\\\\n&= -nx^{-n - 1}\n\\end{align}\n$$\n\n即 $(x^{-n})' = -nx^{-n - 1}$，由此说明当 n 为负整数时，$(x^n)' = nx^{n - 1}$ 同样适用。\n\n#### 其他情况\n\n下一节讨论\n","slug":"common-derivation-formula","published":1,"updated":"2017-02-26T03:26:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcvk000vn9276xm80dji","content":"<p>求导四则运算和常见求导公式的推导过程。</p>\n<a id=\"more\"></a>\n<h2 id=\"求导四则运算\"><a href=\"#求导四则运算\" class=\"headerlink\" title=\"求导四则运算\"></a>求导四则运算</h2><h3 id=\"乘法\"><a href=\"#乘法\" class=\"headerlink\" title=\"乘法\"></a>乘法</h3><p>设有函数 u、v</p>\n<p>$$<br>\\begin{align}<br>(uv)’ &amp;= \\lim_{\\Delta x \\to 0} \\cfrac{\\Delta (uv)}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\cfrac{u(x + \\Delta x) \\cdot v(x + \\Delta x) - u(x) \\cdot v(x)}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\cfrac{u(x + \\Delta x) \\cdot v(x + \\Delta x) - u(x) \\cdot v(x + \\Delta x) + u(x) \\cdot v(x + \\Delta x) - u(x) \\cdot v(x)}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\cfrac{v(x + \\Delta x) \\cdot [u(x + \\Delta x) - u(x)] + u(x) \\cdot [v(x + \\Delta x) - v(x)]}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\cfrac{v(x + \\Delta x) \\cdot \\Delta u + u(x) \\cdot \\Delta v}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\cfrac{v(x) \\cdot \\Delta u + u(x) \\cdot \\Delta v}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\left( v\\cfrac{\\Delta u}{\\Delta x} + u\\cfrac{\\Delta v}{\\Delta x} \\right) \\\\<br>&amp;= u’v + uv’ \\\\<br>\\end{align}<br>$$</p>\n<h3 id=\"除法\"><a href=\"#除法\" class=\"headerlink\" title=\"除法\"></a>除法</h3><h4 id=\"使用导数的定义\"><a href=\"#使用导数的定义\" class=\"headerlink\" title=\"使用导数的定义\"></a>使用导数的定义</h4><p>$$<br>\\begin{align}<br>\\Delta \\cfrac{u}{v} &amp;= \\lim_{\\Delta x \\to 0} \\left( \\cfrac{u + \\Delta u}{v + \\Delta v} - \\cfrac{u}{v} \\right) \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\cfrac{(u + \\Delta u) \\cdot v - u \\cdot (v + \\Delta v)}{(v + \\Delta v) \\cdot v} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\cfrac{uv + \\Delta u \\cdot v - uv - u \\cdot \\Delta v}{(v + \\Delta v)v} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\cfrac{\\Delta u \\cdot v - u \\cdot \\Delta v}{(v + \\Delta v) \\cdot v}<br>\\end{align}<br>$$</p>\n<p>所以</p>\n<p>$$<br>\\begin{align}<br>(\\cfrac{u}{v})’ &amp;= \\lim_{\\Delta x \\to 0} \\cfrac{\\Delta \\cfrac{u}{v}}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\cfrac{\\cfrac{\\Delta u}{\\Delta x} \\cdot v - u \\cfrac{\\Delta v}{\\Delta x}}{(v + \\Delta v) \\cdot v} \\\\<br>&amp;= \\cfrac{u’v - uv’}{v^2}<br>\\end{align}<br>$$</p>\n<h4 id=\"使用链式法则\"><a href=\"#使用链式法则\" class=\"headerlink\" title=\"使用链式法则\"></a>使用链式法则</h4><p>由 $(x^a)’ = ax^{a - 1}$ 得</p>\n<p>$$<br>(\\frac{1}{v})’ = (v^{-1})’ = -1 \\cdot v^{-2}<br>$$</p>\n<p>由此</p>\n<p>$$<br>\\begin{align}<br>(\\frac{u}{v})’ &amp;= (uv^{-1})’ \\\\<br>&amp;= u’v^{-1} + u(v^{-1})’ \\\\<br>&amp;= u’v^{-1} + u(-1 \\cdot v^{-2}) \\\\<br>&amp;= \\cfrac{u’v - uv’}{v^2}<br>\\end{align}<br>$$</p>\n<h2 id=\"常见求导公式\"><a href=\"#常见求导公式\" class=\"headerlink\" title=\"常见求导公式\"></a>常见求导公式</h2><h3 id=\"1-sin-x\"><a href=\"#1-sin-x\" class=\"headerlink\" title=\"1) $\\sin x$\"></a>1) $\\sin x$</h3><p>$$<br>\\begin{align}<br>\\cfrac{d}{dx}\\sin x &amp;= \\lim_{\\Delta x \\to 0} \\cfrac{\\sin (x + \\Delta x) - \\sin x}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\cfrac{\\sin x\\cos \\Delta x + \\cos x\\sin \\Delta x - \\sin x}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\left( \\sin x \\cfrac{\\cos \\Delta x - 1}{\\Delta x} + \\cos x\\cfrac{\\sin \\Delta x}{\\Delta x} \\right) \\\\<br>\\end{align}<br>$$</p>\n<p>而 $\\cfrac{\\cos \\Delta x - 1}{\\Delta x}$ 实际上就是 $\\cos x$ 在 x = 0 处的导数，即：</p>\n<p>$$<br>\\begin{align}<br>\\lim_{\\Delta x \\to 0} \\cfrac{\\cos \\Delta x - 1}{\\Delta x} &amp;= \\lim_{\\Delta x \\to 0} \\cfrac{\\cos (0 + \\Delta x) - \\cos 0}{\\Delta x} \\\\<br>&amp;= \\left. \\cfrac{d}{dx}\\cos x \\right |_{x = 0} \\\\<br>&amp;= 0<br>\\end{align}<br>$$</p>\n<p>$\\cfrac{\\sin \\Delta x}{\\Delta x}$ 实际上就是 $\\sin x$ 在 x = 0 处的导数，即：</p>\n<p>$$<br>\\begin{align}<br>\\lim_{\\Delta x \\to 0} \\cfrac{\\sin \\Delta x}{\\Delta x} &amp;= \\lim_{\\Delta x \\to 0} \\cfrac{\\sin (0 + \\Delta x) - \\sin 0}{\\Delta x} \\\\<br>&amp;= \\left. \\cfrac{d}{dx}\\sin x \\right |_{x = 0} \\\\<br>&amp;= 1<br>\\end{align}<br>$$</p>\n<p>所以</p>\n<p>$$<br>\\begin{align}<br>\\cfrac{d}{dx}\\sin x &amp;= \\lim_{\\Delta x \\to 0} \\left( \\sin x \\cfrac{\\cos \\Delta x - 1}{\\Delta x} + \\cos x\\cfrac{\\sin \\Delta x}{\\Delta x} \\right) \\\\<br>&amp;= \\sin x \\cdot 0 + \\cos x \\cdot 1 \\\\<br>&amp;= \\cos x<br>\\end{align}<br>$$</p>\n<h3 id=\"2-cos-x\"><a href=\"#2-cos-x\" class=\"headerlink\" title=\"2) $\\cos x$\"></a>2) $\\cos x$</h3><p>$$<br>\\begin{align}<br>\\cfrac{d}{dx}\\cos x &amp;= \\lim_{\\Delta x \\to 0} \\cfrac{\\cos (x + \\Delta x) - \\cos x}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\cfrac{\\cos x \\cos \\Delta x - \\sin x \\sin \\Delta x - \\cos x}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\left( \\cos x \\cfrac{\\cos \\Delta x - 1}{\\Delta x} - \\sin x \\cfrac{\\sin \\Delta x}{\\Delta x} \\right) \\\\<br>&amp;= \\cos x \\cdot 0 - \\sin x \\cdot 1 \\\\<br>&amp;= -\\sin x<br>\\end{align}<br>$$</p>\n<p>所以，对于 $\\cos x$ 和 $\\sin x$ 而言，<strong>只要知道了一个点 (x = 0) 处的导数，我们就知道了整个函数的导数。</strong></p>\n<h3 id=\"3-tan-x\"><a href=\"#3-tan-x\" class=\"headerlink\" title=\"3) $\\tan x$\"></a>3) $\\tan x$</h3><p>$$<br>\\begin{align}<br>\\cfrac{d}{dx} \\tan x &amp;= \\cfrac{d}{dx} \\cfrac{\\sin x}{\\cos x} \\\\<br>&amp;= \\cfrac{d}{dx} \\cfrac{\\sin’ x\\cos x + \\sin x\\cos’ x}{\\cos^2 x} \\\\<br>&amp;= \\cfrac{\\cos^2 x + \\sin^2 x}{\\cos^2 x} \\\\<br>&amp;= \\cfrac{1}{\\cos^2 x}<br>\\end{align}<br>$$</p>\n<h3 id=\"4-sec-x\"><a href=\"#4-sec-x\" class=\"headerlink\" title=\"4) $\\sec x$\"></a>4) $\\sec x$</h3><p>$$<br>\\begin{align}<br>\\cfrac{d}{dx} \\sec x &amp;= \\cfrac{d}{dx} (\\cos x)^{-1} \\\\<br>&amp;= -1 \\cdot (\\cos x)^{-2} (-\\sin x) \\\\<br>&amp;= \\cfrac{\\sin x}{\\cos^2 x} \\\\<br>&amp;= \\cfrac{1}{\\cos x} \\cfrac{\\sin x}{\\cos x} \\\\<br>&amp;= \\sec x \\tan x<br>\\end{align}<br>$$</p>\n<h3 id=\"5-x-n\"><a href=\"#5-x-n\" class=\"headerlink\" title=\"5) $x^n$\"></a>5) $x^n$</h3><h4 id=\"当-n-为正整数时\"><a href=\"#当-n-为正整数时\" class=\"headerlink\" title=\"当 n 为正整数时\"></a>当 n 为正整数时</h4><p>$$<br>\\begin{align}<br>(x^n)’ &amp;= \\lim_{\\Delta x \\to 0} \\cfrac{(x + \\Delta x)^n - x^n}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\cfrac{x^n  + nx^{n - 1}\\Delta x + O((\\Delta x)^2) - x^n}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\cfrac{nx^{n - 1}\\Delta x + O((\\Delta x)^2)}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\left( nx^{n - 1} + O(\\Delta x) \\right) \\\\<br>&amp;= nx^{n - 1}<br>\\end{align}<br>$$</p>\n<h4 id=\"当-n-为负整数时\"><a href=\"#当-n-为负整数时\" class=\"headerlink\" title=\"当 n 为负整数时\"></a>当 n 为负整数时</h4><p>先考虑当 n 为正整数时，试求 $\\cfrac{1}{x^n}$ 的导数</p>\n<p>$$<br>\\begin{align}<br>(\\cfrac{1}{x^n})’ &amp;= \\cfrac{-nx^{n - 1}}{x^{2n}} \\\\<br>&amp;= -nx^{n - 1 - 2n} \\\\<br>&amp;= -nx^{-n - 1}<br>\\end{align}<br>$$</p>\n<p>即 $(x^{-n})’ = -nx^{-n - 1}$，由此说明当 n 为负整数时，$(x^n)’ = nx^{n - 1}$ 同样适用。</p>\n<h4 id=\"其他情况\"><a href=\"#其他情况\" class=\"headerlink\" title=\"其他情况\"></a>其他情况</h4><p>下一节讨论</p>\n","excerpt":"<p>求导四则运算和常见求导公式的推导过程。</p>","more":"<h2 id=\"求导四则运算\"><a href=\"#求导四则运算\" class=\"headerlink\" title=\"求导四则运算\"></a>求导四则运算</h2><h3 id=\"乘法\"><a href=\"#乘法\" class=\"headerlink\" title=\"乘法\"></a>乘法</h3><p>设有函数 u、v</p>\n<p>$$<br>\\begin{align}<br>(uv)’ &amp;= \\lim_{\\Delta x \\to 0} \\cfrac{\\Delta (uv)}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\cfrac{u(x + \\Delta x) \\cdot v(x + \\Delta x) - u(x) \\cdot v(x)}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\cfrac{u(x + \\Delta x) \\cdot v(x + \\Delta x) - u(x) \\cdot v(x + \\Delta x) + u(x) \\cdot v(x + \\Delta x) - u(x) \\cdot v(x)}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\cfrac{v(x + \\Delta x) \\cdot [u(x + \\Delta x) - u(x)] + u(x) \\cdot [v(x + \\Delta x) - v(x)]}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\cfrac{v(x + \\Delta x) \\cdot \\Delta u + u(x) \\cdot \\Delta v}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\cfrac{v(x) \\cdot \\Delta u + u(x) \\cdot \\Delta v}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\left( v\\cfrac{\\Delta u}{\\Delta x} + u\\cfrac{\\Delta v}{\\Delta x} \\right) \\\\<br>&amp;= u’v + uv’ \\\\<br>\\end{align}<br>$$</p>\n<h3 id=\"除法\"><a href=\"#除法\" class=\"headerlink\" title=\"除法\"></a>除法</h3><h4 id=\"使用导数的定义\"><a href=\"#使用导数的定义\" class=\"headerlink\" title=\"使用导数的定义\"></a>使用导数的定义</h4><p>$$<br>\\begin{align}<br>\\Delta \\cfrac{u}{v} &amp;= \\lim_{\\Delta x \\to 0} \\left( \\cfrac{u + \\Delta u}{v + \\Delta v} - \\cfrac{u}{v} \\right) \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\cfrac{(u + \\Delta u) \\cdot v - u \\cdot (v + \\Delta v)}{(v + \\Delta v) \\cdot v} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\cfrac{uv + \\Delta u \\cdot v - uv - u \\cdot \\Delta v}{(v + \\Delta v)v} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\cfrac{\\Delta u \\cdot v - u \\cdot \\Delta v}{(v + \\Delta v) \\cdot v}<br>\\end{align}<br>$$</p>\n<p>所以</p>\n<p>$$<br>\\begin{align}<br>(\\cfrac{u}{v})’ &amp;= \\lim_{\\Delta x \\to 0} \\cfrac{\\Delta \\cfrac{u}{v}}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\cfrac{\\cfrac{\\Delta u}{\\Delta x} \\cdot v - u \\cfrac{\\Delta v}{\\Delta x}}{(v + \\Delta v) \\cdot v} \\\\<br>&amp;= \\cfrac{u’v - uv’}{v^2}<br>\\end{align}<br>$$</p>\n<h4 id=\"使用链式法则\"><a href=\"#使用链式法则\" class=\"headerlink\" title=\"使用链式法则\"></a>使用链式法则</h4><p>由 $(x^a)’ = ax^{a - 1}$ 得</p>\n<p>$$<br>(\\frac{1}{v})’ = (v^{-1})’ = -1 \\cdot v^{-2}<br>$$</p>\n<p>由此</p>\n<p>$$<br>\\begin{align}<br>(\\frac{u}{v})’ &amp;= (uv^{-1})’ \\\\<br>&amp;= u’v^{-1} + u(v^{-1})’ \\\\<br>&amp;= u’v^{-1} + u(-1 \\cdot v^{-2}) \\\\<br>&amp;= \\cfrac{u’v - uv’}{v^2}<br>\\end{align}<br>$$</p>\n<h2 id=\"常见求导公式\"><a href=\"#常见求导公式\" class=\"headerlink\" title=\"常见求导公式\"></a>常见求导公式</h2><h3 id=\"1-sin-x\"><a href=\"#1-sin-x\" class=\"headerlink\" title=\"1) $\\sin x$\"></a>1) $\\sin x$</h3><p>$$<br>\\begin{align}<br>\\cfrac{d}{dx}\\sin x &amp;= \\lim_{\\Delta x \\to 0} \\cfrac{\\sin (x + \\Delta x) - \\sin x}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\cfrac{\\sin x\\cos \\Delta x + \\cos x\\sin \\Delta x - \\sin x}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\left( \\sin x \\cfrac{\\cos \\Delta x - 1}{\\Delta x} + \\cos x\\cfrac{\\sin \\Delta x}{\\Delta x} \\right) \\\\<br>\\end{align}<br>$$</p>\n<p>而 $\\cfrac{\\cos \\Delta x - 1}{\\Delta x}$ 实际上就是 $\\cos x$ 在 x = 0 处的导数，即：</p>\n<p>$$<br>\\begin{align}<br>\\lim_{\\Delta x \\to 0} \\cfrac{\\cos \\Delta x - 1}{\\Delta x} &amp;= \\lim_{\\Delta x \\to 0} \\cfrac{\\cos (0 + \\Delta x) - \\cos 0}{\\Delta x} \\\\<br>&amp;= \\left. \\cfrac{d}{dx}\\cos x \\right |_{x = 0} \\\\<br>&amp;= 0<br>\\end{align}<br>$$</p>\n<p>$\\cfrac{\\sin \\Delta x}{\\Delta x}$ 实际上就是 $\\sin x$ 在 x = 0 处的导数，即：</p>\n<p>$$<br>\\begin{align}<br>\\lim_{\\Delta x \\to 0} \\cfrac{\\sin \\Delta x}{\\Delta x} &amp;= \\lim_{\\Delta x \\to 0} \\cfrac{\\sin (0 + \\Delta x) - \\sin 0}{\\Delta x} \\\\<br>&amp;= \\left. \\cfrac{d}{dx}\\sin x \\right |_{x = 0} \\\\<br>&amp;= 1<br>\\end{align}<br>$$</p>\n<p>所以</p>\n<p>$$<br>\\begin{align}<br>\\cfrac{d}{dx}\\sin x &amp;= \\lim_{\\Delta x \\to 0} \\left( \\sin x \\cfrac{\\cos \\Delta x - 1}{\\Delta x} + \\cos x\\cfrac{\\sin \\Delta x}{\\Delta x} \\right) \\\\<br>&amp;= \\sin x \\cdot 0 + \\cos x \\cdot 1 \\\\<br>&amp;= \\cos x<br>\\end{align}<br>$$</p>\n<h3 id=\"2-cos-x\"><a href=\"#2-cos-x\" class=\"headerlink\" title=\"2) $\\cos x$\"></a>2) $\\cos x$</h3><p>$$<br>\\begin{align}<br>\\cfrac{d}{dx}\\cos x &amp;= \\lim_{\\Delta x \\to 0} \\cfrac{\\cos (x + \\Delta x) - \\cos x}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\cfrac{\\cos x \\cos \\Delta x - \\sin x \\sin \\Delta x - \\cos x}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\left( \\cos x \\cfrac{\\cos \\Delta x - 1}{\\Delta x} - \\sin x \\cfrac{\\sin \\Delta x}{\\Delta x} \\right) \\\\<br>&amp;= \\cos x \\cdot 0 - \\sin x \\cdot 1 \\\\<br>&amp;= -\\sin x<br>\\end{align}<br>$$</p>\n<p>所以，对于 $\\cos x$ 和 $\\sin x$ 而言，<strong>只要知道了一个点 (x = 0) 处的导数，我们就知道了整个函数的导数。</strong></p>\n<h3 id=\"3-tan-x\"><a href=\"#3-tan-x\" class=\"headerlink\" title=\"3) $\\tan x$\"></a>3) $\\tan x$</h3><p>$$<br>\\begin{align}<br>\\cfrac{d}{dx} \\tan x &amp;= \\cfrac{d}{dx} \\cfrac{\\sin x}{\\cos x} \\\\<br>&amp;= \\cfrac{d}{dx} \\cfrac{\\sin’ x\\cos x + \\sin x\\cos’ x}{\\cos^2 x} \\\\<br>&amp;= \\cfrac{\\cos^2 x + \\sin^2 x}{\\cos^2 x} \\\\<br>&amp;= \\cfrac{1}{\\cos^2 x}<br>\\end{align}<br>$$</p>\n<h3 id=\"4-sec-x\"><a href=\"#4-sec-x\" class=\"headerlink\" title=\"4) $\\sec x$\"></a>4) $\\sec x$</h3><p>$$<br>\\begin{align}<br>\\cfrac{d}{dx} \\sec x &amp;= \\cfrac{d}{dx} (\\cos x)^{-1} \\\\<br>&amp;= -1 \\cdot (\\cos x)^{-2} (-\\sin x) \\\\<br>&amp;= \\cfrac{\\sin x}{\\cos^2 x} \\\\<br>&amp;= \\cfrac{1}{\\cos x} \\cfrac{\\sin x}{\\cos x} \\\\<br>&amp;= \\sec x \\tan x<br>\\end{align}<br>$$</p>\n<h3 id=\"5-x-n\"><a href=\"#5-x-n\" class=\"headerlink\" title=\"5) $x^n$\"></a>5) $x^n$</h3><h4 id=\"当-n-为正整数时\"><a href=\"#当-n-为正整数时\" class=\"headerlink\" title=\"当 n 为正整数时\"></a>当 n 为正整数时</h4><p>$$<br>\\begin{align}<br>(x^n)’ &amp;= \\lim_{\\Delta x \\to 0} \\cfrac{(x + \\Delta x)^n - x^n}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\cfrac{x^n  + nx^{n - 1}\\Delta x + O((\\Delta x)^2) - x^n}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\cfrac{nx^{n - 1}\\Delta x + O((\\Delta x)^2)}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\left( nx^{n - 1} + O(\\Delta x) \\right) \\\\<br>&amp;= nx^{n - 1}<br>\\end{align}<br>$$</p>\n<h4 id=\"当-n-为负整数时\"><a href=\"#当-n-为负整数时\" class=\"headerlink\" title=\"当 n 为负整数时\"></a>当 n 为负整数时</h4><p>先考虑当 n 为正整数时，试求 $\\cfrac{1}{x^n}$ 的导数</p>\n<p>$$<br>\\begin{align}<br>(\\cfrac{1}{x^n})’ &amp;= \\cfrac{-nx^{n - 1}}{x^{2n}} \\\\<br>&amp;= -nx^{n - 1 - 2n} \\\\<br>&amp;= -nx^{-n - 1}<br>\\end{align}<br>$$</p>\n<p>即 $(x^{-n})’ = -nx^{-n - 1}$，由此说明当 n 为负整数时，$(x^n)’ = nx^{n - 1}$ 同样适用。</p>\n<h4 id=\"其他情况\"><a href=\"#其他情况\" class=\"headerlink\" title=\"其他情况\"></a>其他情况</h4><p>下一节讨论</p>"},{"title":"置信区间","date":"2017-01-27T04:36:45.000Z","_content":"\n> 置信区间是指由样本统计量所构造的总体参数的估计区间。\n\n<!-- more -->\n\n先看一个很常见的场景。\n\n某地区将要进行选举活动，有 A、B 两个候选人，现随机抽查 250 个人，其中 142 个人支持 A，其他人支持 B。\n\n这是一个很简单的伯努利分布，假设选 A 的概率是 $p$，选 B 的概率是 $1 - p$，期望为 $\\mu$，方差为 $\\sigma$。如果能统计整个地区的所有人，那么这些值都能得到，但是统计整个地区显然是不切实际的，不过题目中给出了随机抽查的 250 个人，这 250 个人也就是样本，我们可以计算样本的几个统计值。\n\n设选 A 为 1，选 B 为 0；\n\n那么期望 $\\overline{X}$、方差 $s^2$ 可以得到：\n\n$\\overline{X} = \\frac{0 \\times 142 + 1 \\times (250 - 142)}{250} = 0.432$\n$s^2 = \\frac{142 \\times (0 - \\overline{X})^2 + (250 - 142) \\times (1 - \\overline{X}^2)}{250 - 1} = 0.246$\n$s = \\sqrt{s^2} = 0.496$\n\n那么，我们可以说选 A 的概率就是 0.432 吗？当然是不行的，因为 0.432 只是样本的期望值，和总体的期望值 $\\mu$ 是有差别的，我们需要估计总体期望值的大概范围。\n\n而根据中心极限定理，总体期望等于样本均值的均值，而样本均值的分布是正态分布，且\n\n$\n\\mu\\_{\\overline{X}} = \\mu\n$\n$\n\\sigma\\_{\\overline{X}} = \\frac{\\sigma}{\\sqrt{n}}\n$\n\n\n然而我们也没有总体的标准差 $\\sigma$，但我们可以通过样本的标准差来估计总体的标准差，即\n\n$$\n\\sigma \\approx s = 0.496\n$$\n\n所以\n\n$$\n\\sigma_{\\overline{X}} = \\frac{\\sigma}{\\sqrt{n}} \\approx \\frac{s}{\\sqrt{n}} = \\frac{0.496}{\\sqrt{250}} = 0.031\n$$\n\n也就是说，样本均值的抽样分布是符合 $\\sigma = 0.031$ 的正态分布，当然有一定的误差，因为总体的标准差是估计的。\n\n而根据正态分布的经验法则，在 $(\\mu − 3\\sigma, \\mu + 3\\sigma), (\\mu − 3\\sigma, \\mu + 3\\sigma)$ 发生的概率为 99.7%，也就是说，**我们有 99.7% 的理由相信，我们的样本均值是落在 $\\mu$ 的三个标准差以内的。** 换句话说，$\\mu$ 有 99.7% 的可能性处在样本均值的三个标准差以内。\n\n那么也就是说： 有 99.7% 的可能性，选 A 的概率在 0.496 - 3 \\* 0.031 到 0.496 + 3 \\* 0.031 之间，即 0.403 到 0.589。\n\n置信区间即 $0.496 \\pm 0.093$。\n\n另外需要注意的是，在本例中，样本空间大小为 250，如果样本数量很小，不超过 30 个时，就不能将样本均值的抽样分布看作标准的正态分布，而被称为 t 分布，t 分布的标准差要比正态分布的更大一些，针对 t 分布的概率表格，可以去查对应的 t 表格。\n","source":"_posts/confidence-interval.md","raw":"---\ntitle: 置信区间\ndate: 2017-01-27 12:36:45\ntags: [统计学]\n---\n\n> 置信区间是指由样本统计量所构造的总体参数的估计区间。\n\n<!-- more -->\n\n先看一个很常见的场景。\n\n某地区将要进行选举活动，有 A、B 两个候选人，现随机抽查 250 个人，其中 142 个人支持 A，其他人支持 B。\n\n这是一个很简单的伯努利分布，假设选 A 的概率是 $p$，选 B 的概率是 $1 - p$，期望为 $\\mu$，方差为 $\\sigma$。如果能统计整个地区的所有人，那么这些值都能得到，但是统计整个地区显然是不切实际的，不过题目中给出了随机抽查的 250 个人，这 250 个人也就是样本，我们可以计算样本的几个统计值。\n\n设选 A 为 1，选 B 为 0；\n\n那么期望 $\\overline{X}$、方差 $s^2$ 可以得到：\n\n$\\overline{X} = \\frac{0 \\times 142 + 1 \\times (250 - 142)}{250} = 0.432$\n$s^2 = \\frac{142 \\times (0 - \\overline{X})^2 + (250 - 142) \\times (1 - \\overline{X}^2)}{250 - 1} = 0.246$\n$s = \\sqrt{s^2} = 0.496$\n\n那么，我们可以说选 A 的概率就是 0.432 吗？当然是不行的，因为 0.432 只是样本的期望值，和总体的期望值 $\\mu$ 是有差别的，我们需要估计总体期望值的大概范围。\n\n而根据中心极限定理，总体期望等于样本均值的均值，而样本均值的分布是正态分布，且\n\n$\n\\mu\\_{\\overline{X}} = \\mu\n$\n$\n\\sigma\\_{\\overline{X}} = \\frac{\\sigma}{\\sqrt{n}}\n$\n\n\n然而我们也没有总体的标准差 $\\sigma$，但我们可以通过样本的标准差来估计总体的标准差，即\n\n$$\n\\sigma \\approx s = 0.496\n$$\n\n所以\n\n$$\n\\sigma_{\\overline{X}} = \\frac{\\sigma}{\\sqrt{n}} \\approx \\frac{s}{\\sqrt{n}} = \\frac{0.496}{\\sqrt{250}} = 0.031\n$$\n\n也就是说，样本均值的抽样分布是符合 $\\sigma = 0.031$ 的正态分布，当然有一定的误差，因为总体的标准差是估计的。\n\n而根据正态分布的经验法则，在 $(\\mu − 3\\sigma, \\mu + 3\\sigma), (\\mu − 3\\sigma, \\mu + 3\\sigma)$ 发生的概率为 99.7%，也就是说，**我们有 99.7% 的理由相信，我们的样本均值是落在 $\\mu$ 的三个标准差以内的。** 换句话说，$\\mu$ 有 99.7% 的可能性处在样本均值的三个标准差以内。\n\n那么也就是说： 有 99.7% 的可能性，选 A 的概率在 0.496 - 3 \\* 0.031 到 0.496 + 3 \\* 0.031 之间，即 0.403 到 0.589。\n\n置信区间即 $0.496 \\pm 0.093$。\n\n另外需要注意的是，在本例中，样本空间大小为 250，如果样本数量很小，不超过 30 个时，就不能将样本均值的抽样分布看作标准的正态分布，而被称为 t 分布，t 分布的标准差要比正态分布的更大一些，针对 t 分布的概率表格，可以去查对应的 t 表格。\n","slug":"confidence-interval","published":1,"updated":"2017-02-09T07:58:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcvm000wn927n7w5e10j","content":"<blockquote>\n<p>置信区间是指由样本统计量所构造的总体参数的估计区间。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>先看一个很常见的场景。</p>\n<p>某地区将要进行选举活动，有 A、B 两个候选人，现随机抽查 250 个人，其中 142 个人支持 A，其他人支持 B。</p>\n<p>这是一个很简单的伯努利分布，假设选 A 的概率是 $p$，选 B 的概率是 $1 - p$，期望为 $\\mu$，方差为 $\\sigma$。如果能统计整个地区的所有人，那么这些值都能得到，但是统计整个地区显然是不切实际的，不过题目中给出了随机抽查的 250 个人，这 250 个人也就是样本，我们可以计算样本的几个统计值。</p>\n<p>设选 A 为 1，选 B 为 0；</p>\n<p>那么期望 $\\overline{X}$、方差 $s^2$ 可以得到：</p>\n<p>$\\overline{X} = \\frac{0 \\times 142 + 1 \\times (250 - 142)}{250} = 0.432$<br>$s^2 = \\frac{142 \\times (0 - \\overline{X})^2 + (250 - 142) \\times (1 - \\overline{X}^2)}{250 - 1} = 0.246$<br>$s = \\sqrt{s^2} = 0.496$</p>\n<p>那么，我们可以说选 A 的概率就是 0.432 吗？当然是不行的，因为 0.432 只是样本的期望值，和总体的期望值 $\\mu$ 是有差别的，我们需要估计总体期望值的大概范围。</p>\n<p>而根据中心极限定理，总体期望等于样本均值的均值，而样本均值的分布是正态分布，且</p>\n<p>$<br>\\mu_{\\overline{X}} = \\mu<br>$<br>$<br>\\sigma_{\\overline{X}} = \\frac{\\sigma}{\\sqrt{n}}<br>$</p>\n<p>然而我们也没有总体的标准差 $\\sigma$，但我们可以通过样本的标准差来估计总体的标准差，即</p>\n<p>$$<br>\\sigma \\approx s = 0.496<br>$$</p>\n<p>所以</p>\n<p>$$<br>\\sigma_{\\overline{X}} = \\frac{\\sigma}{\\sqrt{n}} \\approx \\frac{s}{\\sqrt{n}} = \\frac{0.496}{\\sqrt{250}} = 0.031<br>$$</p>\n<p>也就是说，样本均值的抽样分布是符合 $\\sigma = 0.031$ 的正态分布，当然有一定的误差，因为总体的标准差是估计的。</p>\n<p>而根据正态分布的经验法则，在 $(\\mu − 3\\sigma, \\mu + 3\\sigma), (\\mu − 3\\sigma, \\mu + 3\\sigma)$ 发生的概率为 99.7%，也就是说，<strong>我们有 99.7% 的理由相信，我们的样本均值是落在 $\\mu$ 的三个标准差以内的。</strong> 换句话说，$\\mu$ 有 99.7% 的可能性处在样本均值的三个标准差以内。</p>\n<p>那么也就是说： 有 99.7% 的可能性，选 A 的概率在 0.496 - 3 * 0.031 到 0.496 + 3 * 0.031 之间，即 0.403 到 0.589。</p>\n<p>置信区间即 $0.496 \\pm 0.093$。</p>\n<p>另外需要注意的是，在本例中，样本空间大小为 250，如果样本数量很小，不超过 30 个时，就不能将样本均值的抽样分布看作标准的正态分布，而被称为 t 分布，t 分布的标准差要比正态分布的更大一些，针对 t 分布的概率表格，可以去查对应的 t 表格。</p>\n","excerpt":"<blockquote>\n<p>置信区间是指由样本统计量所构造的总体参数的估计区间。</p>\n</blockquote>","more":"<p>先看一个很常见的场景。</p>\n<p>某地区将要进行选举活动，有 A、B 两个候选人，现随机抽查 250 个人，其中 142 个人支持 A，其他人支持 B。</p>\n<p>这是一个很简单的伯努利分布，假设选 A 的概率是 $p$，选 B 的概率是 $1 - p$，期望为 $\\mu$，方差为 $\\sigma$。如果能统计整个地区的所有人，那么这些值都能得到，但是统计整个地区显然是不切实际的，不过题目中给出了随机抽查的 250 个人，这 250 个人也就是样本，我们可以计算样本的几个统计值。</p>\n<p>设选 A 为 1，选 B 为 0；</p>\n<p>那么期望 $\\overline{X}$、方差 $s^2$ 可以得到：</p>\n<p>$\\overline{X} = \\frac{0 \\times 142 + 1 \\times (250 - 142)}{250} = 0.432$<br>$s^2 = \\frac{142 \\times (0 - \\overline{X})^2 + (250 - 142) \\times (1 - \\overline{X}^2)}{250 - 1} = 0.246$<br>$s = \\sqrt{s^2} = 0.496$</p>\n<p>那么，我们可以说选 A 的概率就是 0.432 吗？当然是不行的，因为 0.432 只是样本的期望值，和总体的期望值 $\\mu$ 是有差别的，我们需要估计总体期望值的大概范围。</p>\n<p>而根据中心极限定理，总体期望等于样本均值的均值，而样本均值的分布是正态分布，且</p>\n<p>$<br>\\mu_{\\overline{X}} = \\mu<br>$<br>$<br>\\sigma_{\\overline{X}} = \\frac{\\sigma}{\\sqrt{n}}<br>$</p>\n<p>然而我们也没有总体的标准差 $\\sigma$，但我们可以通过样本的标准差来估计总体的标准差，即</p>\n<p>$$<br>\\sigma \\approx s = 0.496<br>$$</p>\n<p>所以</p>\n<p>$$<br>\\sigma_{\\overline{X}} = \\frac{\\sigma}{\\sqrt{n}} \\approx \\frac{s}{\\sqrt{n}} = \\frac{0.496}{\\sqrt{250}} = 0.031<br>$$</p>\n<p>也就是说，样本均值的抽样分布是符合 $\\sigma = 0.031$ 的正态分布，当然有一定的误差，因为总体的标准差是估计的。</p>\n<p>而根据正态分布的经验法则，在 $(\\mu − 3\\sigma, \\mu + 3\\sigma), (\\mu − 3\\sigma, \\mu + 3\\sigma)$ 发生的概率为 99.7%，也就是说，<strong>我们有 99.7% 的理由相信，我们的样本均值是落在 $\\mu$ 的三个标准差以内的。</strong> 换句话说，$\\mu$ 有 99.7% 的可能性处在样本均值的三个标准差以内。</p>\n<p>那么也就是说： 有 99.7% 的可能性，选 A 的概率在 0.496 - 3 * 0.031 到 0.496 + 3 * 0.031 之间，即 0.403 到 0.589。</p>\n<p>置信区间即 $0.496 \\pm 0.093$。</p>\n<p>另外需要注意的是，在本例中，样本空间大小为 250，如果样本数量很小，不超过 30 个时，就不能将样本均值的抽样分布看作标准的正态分布，而被称为 t 分布，t 分布的标准差要比正态分布的更大一些，针对 t 分布的概率表格，可以去查对应的 t 表格。</p>"},{"title":"函数柯里化","date":"2016-07-04T04:00:28.000Z","_content":"\n> 在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。   —— 维基百科\n\n<!-- more -->\n\n## 什么是柯里化\n\n先举个栗子：\n\n这里有个简单的求和方法 `add`\n\n```javascript\nfunction add(a, b) {\n  return a + b;\n}\n```\n\n调用它：\n\n```javascript\nadd(1, 2);  // 3\nadd(3, 3);  // 6\n```\n\n接下来我们使用柯里化的思想。\n\n> 柯里化声称 “如果你固定某些参数，你将得到接受余下参数的一个函数”。\n\n也就是说，如果满足柯里化思想，应该是这样的：\n```javascript\nfunction add(a, b) {\n  return a + b;\n}\n\nvar curryingAdd = currying(add, 5);\n\ncurryingAdd(1); // 6\ncurryingAdd(2); // 7\n```\n\n本来应该接收两个参数的 `add`，通过 `currying` 加工之后，可以用来接收余下的参数。\n\n上面的例子里面，其实就是把 `add` 接收的参数固定了一个，也就是 5，我们可以想到 `curryingAdd` 的一种简单实现。\n\n```javascript\nvar curryingAdd = function(a) {\n  return function(b) {\n    return a + b;\n  }\n}\n\ncurryingAdd(5)(1);  // 6\n```\n\n原理即是通过闭包保存了第一个变量。\n\n## currying 方法\n\n那么将普通函数转变为柯里化函数的 `currying` 是如何实现的呢，通过 `curringAdd`，可以想到使用闭包来实现。\n\n```javascript\nfunction currying(func) {\n  // 闭包保存固定参数\n  var firstArgs = Array.prototype.slice.call(arguments, 1);\n\n  return function() {\n    // 将固定参数和新参数一起传入原函数\n    var args = firstArgs.concat(Array.prototype.slice.call(arguments));\n    return func.apply(null, args);\n  }\n}\n\nfunction add(a, b) {\n  return a + b;\n}\n\ncurrying(add, 5)(1);  // 6\n```\n\n这种实现有一定的局限性，`curring` 方法的返回函数只能被执行一次，也就是我们不能这样调用：`currying(add)(1)(2)`\n\n要满足灵活的调用，需要判断接收的参数个数：\n\n```javascript\nfunction currying(func) {\n  // 闭包保存固定参数\n  var firstArgs = Array.prototype.slice.call(arguments, 1);\n\n  // 原函数接收的参数个数\n  var l = func.length;\n\n  return function inner() {\n    // 将固定参数和新参数一起传入原函数\n    firstArgs = firstArgs.concat(Array.prototype.slice.call(arguments));\n    if(firstArgs.length < l) {\n      return inner;\n    }\n    return func.apply(null, firstArgs);\n  }\n}\n\nfunction add(a, b) {\n  return a + b;\n}\n\ncurrying(add, 1)(5);  // 6\ncurrying(add)(1)(5);  // 6\ncurrying(add)(1, 5);  // 6\n```\n\n不过，我们还得考虑到原函数不用接收参数的情况，比如下面的 `sum`：\n```javascript\nfunction sum() {\n  var s = 0;\n  for (var i = 0, len = arguments.length; i < len; i++) {\n    s += arguments[i];\n  }\n  return s;\n}\n```\n\n`sum` 可以接收任意个参数并返回它们的和，我们通过调整 `currying` 的判断条件来覆盖这种情况。\n\n```javascript\nfunction currying(func) {\n  // 闭包保存固定参数\n  var firstArgs = Array.prototype.slice.call(arguments, 1);\n\n  // 原函数接收的参数个数\n  var l = func.length;\n\n  return function inner() {\n    // 将固定参数和新参数一起传入原函数\n    var newArgs = Array.prototype.slice.call(arguments);\n    firstArgs = firstArgs.concat(newArgs);\n\n    if((l == 0 && newArgs.length == 0) || (l > 0 && firstArgs.length == l)) {\n      // 调用完成\n      return func.apply(null, firstArgs);\n    }\n\n    return inner;\n  }\n}\n\ncurrying(sum, 1)(5)();  // 6\ncurrying(sum)(1)(5)(6)(7)();  // 19\ncurrying(sum)(1)(5)(6, 7)();  // 19\n\ncurrying(add, 1)(5);  // 6\ncurrying(add)(1)(5);  // 6\ncurrying(add)(1, 5);  // 6\n```\n","source":"_posts/currying.md","raw":"---\ntitle: 函数柯里化\ndate: 2016-07-04 12:00:28\ntags: [javascript]\n---\n\n> 在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。   —— 维基百科\n\n<!-- more -->\n\n## 什么是柯里化\n\n先举个栗子：\n\n这里有个简单的求和方法 `add`\n\n```javascript\nfunction add(a, b) {\n  return a + b;\n}\n```\n\n调用它：\n\n```javascript\nadd(1, 2);  // 3\nadd(3, 3);  // 6\n```\n\n接下来我们使用柯里化的思想。\n\n> 柯里化声称 “如果你固定某些参数，你将得到接受余下参数的一个函数”。\n\n也就是说，如果满足柯里化思想，应该是这样的：\n```javascript\nfunction add(a, b) {\n  return a + b;\n}\n\nvar curryingAdd = currying(add, 5);\n\ncurryingAdd(1); // 6\ncurryingAdd(2); // 7\n```\n\n本来应该接收两个参数的 `add`，通过 `currying` 加工之后，可以用来接收余下的参数。\n\n上面的例子里面，其实就是把 `add` 接收的参数固定了一个，也就是 5，我们可以想到 `curryingAdd` 的一种简单实现。\n\n```javascript\nvar curryingAdd = function(a) {\n  return function(b) {\n    return a + b;\n  }\n}\n\ncurryingAdd(5)(1);  // 6\n```\n\n原理即是通过闭包保存了第一个变量。\n\n## currying 方法\n\n那么将普通函数转变为柯里化函数的 `currying` 是如何实现的呢，通过 `curringAdd`，可以想到使用闭包来实现。\n\n```javascript\nfunction currying(func) {\n  // 闭包保存固定参数\n  var firstArgs = Array.prototype.slice.call(arguments, 1);\n\n  return function() {\n    // 将固定参数和新参数一起传入原函数\n    var args = firstArgs.concat(Array.prototype.slice.call(arguments));\n    return func.apply(null, args);\n  }\n}\n\nfunction add(a, b) {\n  return a + b;\n}\n\ncurrying(add, 5)(1);  // 6\n```\n\n这种实现有一定的局限性，`curring` 方法的返回函数只能被执行一次，也就是我们不能这样调用：`currying(add)(1)(2)`\n\n要满足灵活的调用，需要判断接收的参数个数：\n\n```javascript\nfunction currying(func) {\n  // 闭包保存固定参数\n  var firstArgs = Array.prototype.slice.call(arguments, 1);\n\n  // 原函数接收的参数个数\n  var l = func.length;\n\n  return function inner() {\n    // 将固定参数和新参数一起传入原函数\n    firstArgs = firstArgs.concat(Array.prototype.slice.call(arguments));\n    if(firstArgs.length < l) {\n      return inner;\n    }\n    return func.apply(null, firstArgs);\n  }\n}\n\nfunction add(a, b) {\n  return a + b;\n}\n\ncurrying(add, 1)(5);  // 6\ncurrying(add)(1)(5);  // 6\ncurrying(add)(1, 5);  // 6\n```\n\n不过，我们还得考虑到原函数不用接收参数的情况，比如下面的 `sum`：\n```javascript\nfunction sum() {\n  var s = 0;\n  for (var i = 0, len = arguments.length; i < len; i++) {\n    s += arguments[i];\n  }\n  return s;\n}\n```\n\n`sum` 可以接收任意个参数并返回它们的和，我们通过调整 `currying` 的判断条件来覆盖这种情况。\n\n```javascript\nfunction currying(func) {\n  // 闭包保存固定参数\n  var firstArgs = Array.prototype.slice.call(arguments, 1);\n\n  // 原函数接收的参数个数\n  var l = func.length;\n\n  return function inner() {\n    // 将固定参数和新参数一起传入原函数\n    var newArgs = Array.prototype.slice.call(arguments);\n    firstArgs = firstArgs.concat(newArgs);\n\n    if((l == 0 && newArgs.length == 0) || (l > 0 && firstArgs.length == l)) {\n      // 调用完成\n      return func.apply(null, firstArgs);\n    }\n\n    return inner;\n  }\n}\n\ncurrying(sum, 1)(5)();  // 6\ncurrying(sum)(1)(5)(6)(7)();  // 19\ncurrying(sum)(1)(5)(6, 7)();  // 19\n\ncurrying(add, 1)(5);  // 6\ncurrying(add)(1)(5);  // 6\ncurrying(add)(1, 5);  // 6\n```\n","slug":"currying","published":1,"updated":"2017-03-17T13:39:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcvo000yn927mqeubzhr","content":"<blockquote>\n<p>在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。   —— 维基百科</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"什么是柯里化\"><a href=\"#什么是柯里化\" class=\"headerlink\" title=\"什么是柯里化\"></a>什么是柯里化</h2><p>先举个栗子：</p>\n<p>这里有个简单的求和方法 <code>add</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用它：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">add(<span class=\"number\">1</span>, <span class=\"number\">2</span>);  <span class=\"comment\">// 3</span></div><div class=\"line\">add(<span class=\"number\">3</span>, <span class=\"number\">3</span>);  <span class=\"comment\">// 6</span></div></pre></td></tr></table></figure>\n<p>接下来我们使用柯里化的思想。</p>\n<blockquote>\n<p>柯里化声称 “如果你固定某些参数，你将得到接受余下参数的一个函数”。</p>\n</blockquote>\n<p>也就是说，如果满足柯里化思想，应该是这样的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> curryingAdd = currying(add, <span class=\"number\">5</span>);</div><div class=\"line\"></div><div class=\"line\">curryingAdd(<span class=\"number\">1</span>); <span class=\"comment\">// 6</span></div><div class=\"line\">curryingAdd(<span class=\"number\">2</span>); <span class=\"comment\">// 7</span></div></pre></td></tr></table></figure></p>\n<p>本来应该接收两个参数的 <code>add</code>，通过 <code>currying</code> 加工之后，可以用来接收余下的参数。</p>\n<p>上面的例子里面，其实就是把 <code>add</code> 接收的参数固定了一个，也就是 5，我们可以想到 <code>curryingAdd</code> 的一种简单实现。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> curryingAdd = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">curryingAdd(<span class=\"number\">5</span>)(<span class=\"number\">1</span>);  <span class=\"comment\">// 6</span></div></pre></td></tr></table></figure>\n<p>原理即是通过闭包保存了第一个变量。</p>\n<h2 id=\"currying-方法\"><a href=\"#currying-方法\" class=\"headerlink\" title=\"currying 方法\"></a>currying 方法</h2><p>那么将普通函数转变为柯里化函数的 <code>currying</code> 是如何实现的呢，通过 <code>curringAdd</code>，可以想到使用闭包来实现。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">currying</span>(<span class=\"params\">func</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 闭包保存固定参数</span></div><div class=\"line\">  <span class=\"keyword\">var</span> firstArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 将固定参数和新参数一起传入原函数</span></div><div class=\"line\">    <span class=\"keyword\">var</span> args = firstArgs.concat(<span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>));</div><div class=\"line\">    <span class=\"keyword\">return</span> func.apply(<span class=\"literal\">null</span>, args);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">currying(add, <span class=\"number\">5</span>)(<span class=\"number\">1</span>);  <span class=\"comment\">// 6</span></div></pre></td></tr></table></figure>\n<p>这种实现有一定的局限性，<code>curring</code> 方法的返回函数只能被执行一次，也就是我们不能这样调用：<code>currying(add)(1)(2)</code></p>\n<p>要满足灵活的调用，需要判断接收的参数个数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">currying</span>(<span class=\"params\">func</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 闭包保存固定参数</span></div><div class=\"line\">  <span class=\"keyword\">var</span> firstArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 原函数接收的参数个数</span></div><div class=\"line\">  <span class=\"keyword\">var</span> l = func.length;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inner</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 将固定参数和新参数一起传入原函数</span></div><div class=\"line\">    firstArgs = firstArgs.concat(<span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>));</div><div class=\"line\">    <span class=\"keyword\">if</span>(firstArgs.length &lt; l) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> inner;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> func.apply(<span class=\"literal\">null</span>, firstArgs);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">currying(add, <span class=\"number\">1</span>)(<span class=\"number\">5</span>);  <span class=\"comment\">// 6</span></div><div class=\"line\">currying(add)(<span class=\"number\">1</span>)(<span class=\"number\">5</span>);  <span class=\"comment\">// 6</span></div><div class=\"line\">currying(add)(<span class=\"number\">1</span>, <span class=\"number\">5</span>);  <span class=\"comment\">// 6</span></div></pre></td></tr></table></figure>\n<p>不过，我们还得考虑到原函数不用接收参数的情况，比如下面的 <code>sum</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> s = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = <span class=\"built_in\">arguments</span>.length; i &lt; len; i++) &#123;</div><div class=\"line\">    s += <span class=\"built_in\">arguments</span>[i];</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> s;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>sum</code> 可以接收任意个参数并返回它们的和，我们通过调整 <code>currying</code> 的判断条件来覆盖这种情况。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">currying</span>(<span class=\"params\">func</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 闭包保存固定参数</span></div><div class=\"line\">  <span class=\"keyword\">var</span> firstArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 原函数接收的参数个数</span></div><div class=\"line\">  <span class=\"keyword\">var</span> l = func.length;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inner</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 将固定参数和新参数一起传入原函数</span></div><div class=\"line\">    <span class=\"keyword\">var</span> newArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);</div><div class=\"line\">    firstArgs = firstArgs.concat(newArgs);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>((l == <span class=\"number\">0</span> &amp;&amp; newArgs.length == <span class=\"number\">0</span>) || (l &gt; <span class=\"number\">0</span> &amp;&amp; firstArgs.length == l)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 调用完成</span></div><div class=\"line\">      <span class=\"keyword\">return</span> func.apply(<span class=\"literal\">null</span>, firstArgs);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> inner;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">currying(sum, <span class=\"number\">1</span>)(<span class=\"number\">5</span>)();  <span class=\"comment\">// 6</span></div><div class=\"line\">currying(sum)(<span class=\"number\">1</span>)(<span class=\"number\">5</span>)(<span class=\"number\">6</span>)(<span class=\"number\">7</span>)();  <span class=\"comment\">// 19</span></div><div class=\"line\">currying(sum)(<span class=\"number\">1</span>)(<span class=\"number\">5</span>)(<span class=\"number\">6</span>, <span class=\"number\">7</span>)();  <span class=\"comment\">// 19</span></div><div class=\"line\"></div><div class=\"line\">currying(add, <span class=\"number\">1</span>)(<span class=\"number\">5</span>);  <span class=\"comment\">// 6</span></div><div class=\"line\">currying(add)(<span class=\"number\">1</span>)(<span class=\"number\">5</span>);  <span class=\"comment\">// 6</span></div><div class=\"line\">currying(add)(<span class=\"number\">1</span>, <span class=\"number\">5</span>);  <span class=\"comment\">// 6</span></div></pre></td></tr></table></figure>\n","excerpt":"<blockquote>\n<p>在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。   —— 维基百科</p>\n</blockquote>","more":"<h2 id=\"什么是柯里化\"><a href=\"#什么是柯里化\" class=\"headerlink\" title=\"什么是柯里化\"></a>什么是柯里化</h2><p>先举个栗子：</p>\n<p>这里有个简单的求和方法 <code>add</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用它：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">add(<span class=\"number\">1</span>, <span class=\"number\">2</span>);  <span class=\"comment\">// 3</span></div><div class=\"line\">add(<span class=\"number\">3</span>, <span class=\"number\">3</span>);  <span class=\"comment\">// 6</span></div></pre></td></tr></table></figure>\n<p>接下来我们使用柯里化的思想。</p>\n<blockquote>\n<p>柯里化声称 “如果你固定某些参数，你将得到接受余下参数的一个函数”。</p>\n</blockquote>\n<p>也就是说，如果满足柯里化思想，应该是这样的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> curryingAdd = currying(add, <span class=\"number\">5</span>);</div><div class=\"line\"></div><div class=\"line\">curryingAdd(<span class=\"number\">1</span>); <span class=\"comment\">// 6</span></div><div class=\"line\">curryingAdd(<span class=\"number\">2</span>); <span class=\"comment\">// 7</span></div></pre></td></tr></table></figure></p>\n<p>本来应该接收两个参数的 <code>add</code>，通过 <code>currying</code> 加工之后，可以用来接收余下的参数。</p>\n<p>上面的例子里面，其实就是把 <code>add</code> 接收的参数固定了一个，也就是 5，我们可以想到 <code>curryingAdd</code> 的一种简单实现。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> curryingAdd = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">curryingAdd(<span class=\"number\">5</span>)(<span class=\"number\">1</span>);  <span class=\"comment\">// 6</span></div></pre></td></tr></table></figure>\n<p>原理即是通过闭包保存了第一个变量。</p>\n<h2 id=\"currying-方法\"><a href=\"#currying-方法\" class=\"headerlink\" title=\"currying 方法\"></a>currying 方法</h2><p>那么将普通函数转变为柯里化函数的 <code>currying</code> 是如何实现的呢，通过 <code>curringAdd</code>，可以想到使用闭包来实现。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">currying</span>(<span class=\"params\">func</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 闭包保存固定参数</span></div><div class=\"line\">  <span class=\"keyword\">var</span> firstArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 将固定参数和新参数一起传入原函数</span></div><div class=\"line\">    <span class=\"keyword\">var</span> args = firstArgs.concat(<span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>));</div><div class=\"line\">    <span class=\"keyword\">return</span> func.apply(<span class=\"literal\">null</span>, args);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">currying(add, <span class=\"number\">5</span>)(<span class=\"number\">1</span>);  <span class=\"comment\">// 6</span></div></pre></td></tr></table></figure>\n<p>这种实现有一定的局限性，<code>curring</code> 方法的返回函数只能被执行一次，也就是我们不能这样调用：<code>currying(add)(1)(2)</code></p>\n<p>要满足灵活的调用，需要判断接收的参数个数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">currying</span>(<span class=\"params\">func</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 闭包保存固定参数</span></div><div class=\"line\">  <span class=\"keyword\">var</span> firstArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 原函数接收的参数个数</span></div><div class=\"line\">  <span class=\"keyword\">var</span> l = func.length;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inner</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 将固定参数和新参数一起传入原函数</span></div><div class=\"line\">    firstArgs = firstArgs.concat(<span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>));</div><div class=\"line\">    <span class=\"keyword\">if</span>(firstArgs.length &lt; l) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> inner;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> func.apply(<span class=\"literal\">null</span>, firstArgs);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">currying(add, <span class=\"number\">1</span>)(<span class=\"number\">5</span>);  <span class=\"comment\">// 6</span></div><div class=\"line\">currying(add)(<span class=\"number\">1</span>)(<span class=\"number\">5</span>);  <span class=\"comment\">// 6</span></div><div class=\"line\">currying(add)(<span class=\"number\">1</span>, <span class=\"number\">5</span>);  <span class=\"comment\">// 6</span></div></pre></td></tr></table></figure>\n<p>不过，我们还得考虑到原函数不用接收参数的情况，比如下面的 <code>sum</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> s = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = <span class=\"built_in\">arguments</span>.length; i &lt; len; i++) &#123;</div><div class=\"line\">    s += <span class=\"built_in\">arguments</span>[i];</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> s;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>sum</code> 可以接收任意个参数并返回它们的和，我们通过调整 <code>currying</code> 的判断条件来覆盖这种情况。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">currying</span>(<span class=\"params\">func</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 闭包保存固定参数</span></div><div class=\"line\">  <span class=\"keyword\">var</span> firstArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 原函数接收的参数个数</span></div><div class=\"line\">  <span class=\"keyword\">var</span> l = func.length;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inner</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 将固定参数和新参数一起传入原函数</span></div><div class=\"line\">    <span class=\"keyword\">var</span> newArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);</div><div class=\"line\">    firstArgs = firstArgs.concat(newArgs);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>((l == <span class=\"number\">0</span> &amp;&amp; newArgs.length == <span class=\"number\">0</span>) || (l &gt; <span class=\"number\">0</span> &amp;&amp; firstArgs.length == l)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 调用完成</span></div><div class=\"line\">      <span class=\"keyword\">return</span> func.apply(<span class=\"literal\">null</span>, firstArgs);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> inner;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">currying(sum, <span class=\"number\">1</span>)(<span class=\"number\">5</span>)();  <span class=\"comment\">// 6</span></div><div class=\"line\">currying(sum)(<span class=\"number\">1</span>)(<span class=\"number\">5</span>)(<span class=\"number\">6</span>)(<span class=\"number\">7</span>)();  <span class=\"comment\">// 19</span></div><div class=\"line\">currying(sum)(<span class=\"number\">1</span>)(<span class=\"number\">5</span>)(<span class=\"number\">6</span>, <span class=\"number\">7</span>)();  <span class=\"comment\">// 19</span></div><div class=\"line\"></div><div class=\"line\">currying(add, <span class=\"number\">1</span>)(<span class=\"number\">5</span>);  <span class=\"comment\">// 6</span></div><div class=\"line\">currying(add)(<span class=\"number\">1</span>)(<span class=\"number\">5</span>);  <span class=\"comment\">// 6</span></div><div class=\"line\">currying(add)(<span class=\"number\">1</span>, <span class=\"number\">5</span>);  <span class=\"comment\">// 6</span></div></pre></td></tr></table></figure>"},{"title":"数据抓取の经验","date":"2016-08-12T13:32:34.000Z","_content":"\n## 业务需求\n\n这里讨论的是给了用户名和密码，需要获取登陆之后页面内的某些数据。\n那么问题来了，\n**Q1. 用户名和密码都有了，直接登录不就完了吗！**\nA: 用机器去抓，省时又省力，关键是很酷。\n**Q2. 用户名和密码都有了，难道不是 so easy 吗！**\nA: 一般情况下都挺简单，但也有部分网站相当难抓，比如 [腾讯爸爸](http://tui.qq.com/)。\n**Q3. 用户名和密码都有了，登陆一次，以后携带 cookie 不就可以了吗！**\nA: cookie 很容易过期，让程序自己去拿 cookie，这样每次都是最新的 cookie，不是更酷吗？\n\n理想情况下，**构建请求参数 ---> 请求登陆接口 ---> 返回 SESSIONID ---> 携带 SESSIONID 请求目标接口**，就能拿到数据了，但是很可惜，一般的网站都不是理想情况，要成功干好这件事，需要非常非常地耐心和非常非常地仔细。\n<!--more-->\n## 第〇步 清空浏览器 Cookie\n\n这是最重要的一步，一定要清，不然哭一整天。另外在抓取过程中，只要重来，就清一次。因为如果不清 Cookie，浏览器会将上次保留的 Cookie 发送出去，干扰我们找真实的请求。\n下图是Chrome 清空 cookie 的地方：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/01.png)\n\n什么？你不是用 chrome？那你别往下看了\n\n## 第一步 从需要抓取的接口找起\n\n要抓取的数据肯定是来源于一个接口的，只是响应体内容可能有差异，比如是 JSON 格式返回的，或者是藏在 HTML 返回的，都有可能。首先要找到这个目标接口，然后重点关注它的请求头。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/02.png)\n\nCookie 是服务器判断用户有没有登陆的凭证，对应于服务器上的 Session，所以一般情况下，只要能拿到这个字段就大功告成了。请求的 cookie 都在请求体的 cookie 中，对应的响应的 cookie 都在响应体的 set-cookie 中。\n不同的后台语言对应不同的 Session 名字，常见的有： JSESSIONID (Java EE),、PHPSESSID (PHP)、 ASPSESSIONID (Microsoft ASP).。如上图可以大致推断这个网站是使用 JavaEE 开发的。\n\n## 第二步 从后往前推\n\n找到抓取数据所在的接口以后，一步一步往上找，点击请求，打开右侧的 Cookies 选项卡，可以看到这次请求的 Cookies 交互情况。**如果 Response Cookies 出现了目标请求中的 JSESSIONID**，没错！离成功近了一步，你需要拿小本子把这个请求记下来了。\n而这个请求在请求时很可能也需要一些 Cookies，所以以此类推，继续往上找。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/03.png)\n\n## 第三步 找到登陆请求\n\n要登录的网站必定是有个登录的请求的，登录请求一般有这么几种参数：\n1) 用户名、明文密码\n2) 用户名、加密密码\n3) 用户名、加密密码、加密其他参数\n（当然一般登陆还需要验证码，使用一些能够破解验证码的服务即可）\n\n碰到第一种，恭喜，今天可以提前下班了。登录的参数已经都有了，剩下的，一是请求登录接口可能需要 cookies，这个 cookies 如果包含 sessionid，sessionid 一定可以从登录之前的接口拿到，那么往前找就对了。二是请求登录接口之后一定会**直接或间接**返回**能够代表用户凭证的东西**，拿着这个东西，继续寻找能够**拿到目标接口需要的 sessionid** 即可。\n\n碰到第二种，还行，仔细的话还是能正常加班的。加密的过程一定是在 javascript 中完成的，打开源码，好好啃一下，这里有两个经验，一是可以先找一下这个按钮有没有 click 事件，如果有，八成在这个事件里写好了加密过程，如果没有，说明是表单提交。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/04.png)\n\n另外实在没有办法，就在源码里搜一下 cookie 等相关的字段，更容易命中一点。\n\n碰到第三种，去洗把脸准备准备加班了。其实不管是加密密码，还是加密其他参数，都是在 js 里面完成的，难度可能其实差不多，但是这体现了后台的重视程度。。。所以可能会更复杂一点，像腾讯里面使用了统一的登陆方式，所以也使用了统一的加密方法，加密的地方还蛮多的，看源码找了半天才找出来，这里就不展开了，有兴趣可以交流一下。\n\n## 一点人生经验\n\n抓取的方法其实在上面三步里说的差不多了，说白了就是仿照请求的过程，在不同的请求中寻找前后台交互的流程，下面是中间的一些经验：\n\n### 1) cookie 的作用域\n\n每个 cookie 都有自己的域，这可能在刚抓取的时候很容易被忽视，网页在登陆前后的跳转中，很可能会经历不同的域名，比如从 site.com/aaa 跳到 site.com/bbb，这两次返回的 cookie 域可能就会不同，重要的是这两个响应可能都返回 SESSIONID，但是两个是**不同**的，一定要分清接下来的请求携带的是哪一个。举个栗子：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/05.png)\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/06.png)\n\n同样是 JSESSIONID，不能搞混哦。\n\n### 2) 302 跳转\n你可能会碰到 302 重定向，可怕的是有的信息就藏在 302 请求中：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/07.png)\n\n这里就有个坑了，之前没有注意，我请求这个 url 的时候，想拿这个 cookie，写好代码之后，发现确实拿到 cookie 了，但是后面请求目标接口总是不成功，最后把响应头拿出来一看，发现！\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/08.png)\n\n尼玛！cookie 的作用域不同啊！（上面是 /ad/，而我的是 /hccas/）\n然后把响应状态打出来一看！\n200！\n擦擦擦擦，一下午就被这个干掉了，其实这是因为 request.js（我使用的是nodejs）对 302 请求作了自动重定向造成了，也就是碰到 302 就跟着跳了，但我们并不想它跳，这时需要设置一个参数：\n\n```\nfollowRedirect: false\n```\n\n然后就成功拿到了！\n","source":"_posts/data-capture.md","raw":"---\ntitle: 数据抓取の经验\ndate: 2016-08-12 21:32:34\ntags: [总结]\n---\n\n## 业务需求\n\n这里讨论的是给了用户名和密码，需要获取登陆之后页面内的某些数据。\n那么问题来了，\n**Q1. 用户名和密码都有了，直接登录不就完了吗！**\nA: 用机器去抓，省时又省力，关键是很酷。\n**Q2. 用户名和密码都有了，难道不是 so easy 吗！**\nA: 一般情况下都挺简单，但也有部分网站相当难抓，比如 [腾讯爸爸](http://tui.qq.com/)。\n**Q3. 用户名和密码都有了，登陆一次，以后携带 cookie 不就可以了吗！**\nA: cookie 很容易过期，让程序自己去拿 cookie，这样每次都是最新的 cookie，不是更酷吗？\n\n理想情况下，**构建请求参数 ---> 请求登陆接口 ---> 返回 SESSIONID ---> 携带 SESSIONID 请求目标接口**，就能拿到数据了，但是很可惜，一般的网站都不是理想情况，要成功干好这件事，需要非常非常地耐心和非常非常地仔细。\n<!--more-->\n## 第〇步 清空浏览器 Cookie\n\n这是最重要的一步，一定要清，不然哭一整天。另外在抓取过程中，只要重来，就清一次。因为如果不清 Cookie，浏览器会将上次保留的 Cookie 发送出去，干扰我们找真实的请求。\n下图是Chrome 清空 cookie 的地方：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/01.png)\n\n什么？你不是用 chrome？那你别往下看了\n\n## 第一步 从需要抓取的接口找起\n\n要抓取的数据肯定是来源于一个接口的，只是响应体内容可能有差异，比如是 JSON 格式返回的，或者是藏在 HTML 返回的，都有可能。首先要找到这个目标接口，然后重点关注它的请求头。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/02.png)\n\nCookie 是服务器判断用户有没有登陆的凭证，对应于服务器上的 Session，所以一般情况下，只要能拿到这个字段就大功告成了。请求的 cookie 都在请求体的 cookie 中，对应的响应的 cookie 都在响应体的 set-cookie 中。\n不同的后台语言对应不同的 Session 名字，常见的有： JSESSIONID (Java EE),、PHPSESSID (PHP)、 ASPSESSIONID (Microsoft ASP).。如上图可以大致推断这个网站是使用 JavaEE 开发的。\n\n## 第二步 从后往前推\n\n找到抓取数据所在的接口以后，一步一步往上找，点击请求，打开右侧的 Cookies 选项卡，可以看到这次请求的 Cookies 交互情况。**如果 Response Cookies 出现了目标请求中的 JSESSIONID**，没错！离成功近了一步，你需要拿小本子把这个请求记下来了。\n而这个请求在请求时很可能也需要一些 Cookies，所以以此类推，继续往上找。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/03.png)\n\n## 第三步 找到登陆请求\n\n要登录的网站必定是有个登录的请求的，登录请求一般有这么几种参数：\n1) 用户名、明文密码\n2) 用户名、加密密码\n3) 用户名、加密密码、加密其他参数\n（当然一般登陆还需要验证码，使用一些能够破解验证码的服务即可）\n\n碰到第一种，恭喜，今天可以提前下班了。登录的参数已经都有了，剩下的，一是请求登录接口可能需要 cookies，这个 cookies 如果包含 sessionid，sessionid 一定可以从登录之前的接口拿到，那么往前找就对了。二是请求登录接口之后一定会**直接或间接**返回**能够代表用户凭证的东西**，拿着这个东西，继续寻找能够**拿到目标接口需要的 sessionid** 即可。\n\n碰到第二种，还行，仔细的话还是能正常加班的。加密的过程一定是在 javascript 中完成的，打开源码，好好啃一下，这里有两个经验，一是可以先找一下这个按钮有没有 click 事件，如果有，八成在这个事件里写好了加密过程，如果没有，说明是表单提交。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/04.png)\n\n另外实在没有办法，就在源码里搜一下 cookie 等相关的字段，更容易命中一点。\n\n碰到第三种，去洗把脸准备准备加班了。其实不管是加密密码，还是加密其他参数，都是在 js 里面完成的，难度可能其实差不多，但是这体现了后台的重视程度。。。所以可能会更复杂一点，像腾讯里面使用了统一的登陆方式，所以也使用了统一的加密方法，加密的地方还蛮多的，看源码找了半天才找出来，这里就不展开了，有兴趣可以交流一下。\n\n## 一点人生经验\n\n抓取的方法其实在上面三步里说的差不多了，说白了就是仿照请求的过程，在不同的请求中寻找前后台交互的流程，下面是中间的一些经验：\n\n### 1) cookie 的作用域\n\n每个 cookie 都有自己的域，这可能在刚抓取的时候很容易被忽视，网页在登陆前后的跳转中，很可能会经历不同的域名，比如从 site.com/aaa 跳到 site.com/bbb，这两次返回的 cookie 域可能就会不同，重要的是这两个响应可能都返回 SESSIONID，但是两个是**不同**的，一定要分清接下来的请求携带的是哪一个。举个栗子：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/05.png)\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/06.png)\n\n同样是 JSESSIONID，不能搞混哦。\n\n### 2) 302 跳转\n你可能会碰到 302 重定向，可怕的是有的信息就藏在 302 请求中：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/07.png)\n\n这里就有个坑了，之前没有注意，我请求这个 url 的时候，想拿这个 cookie，写好代码之后，发现确实拿到 cookie 了，但是后面请求目标接口总是不成功，最后把响应头拿出来一看，发现！\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/08.png)\n\n尼玛！cookie 的作用域不同啊！（上面是 /ad/，而我的是 /hccas/）\n然后把响应状态打出来一看！\n200！\n擦擦擦擦，一下午就被这个干掉了，其实这是因为 request.js（我使用的是nodejs）对 302 请求作了自动重定向造成了，也就是碰到 302 就跟着跳了，但我们并不想它跳，这时需要设置一个参数：\n\n```\nfollowRedirect: false\n```\n\n然后就成功拿到了！\n","slug":"data-capture","published":1,"updated":"2017-03-17T13:40:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcvp0010n9274iv0kky7","content":"<h2 id=\"业务需求\"><a href=\"#业务需求\" class=\"headerlink\" title=\"业务需求\"></a>业务需求</h2><p>这里讨论的是给了用户名和密码，需要获取登陆之后页面内的某些数据。<br>那么问题来了，<br><strong>Q1. 用户名和密码都有了，直接登录不就完了吗！</strong><br>A: 用机器去抓，省时又省力，关键是很酷。<br><strong>Q2. 用户名和密码都有了，难道不是 so easy 吗！</strong><br>A: 一般情况下都挺简单，但也有部分网站相当难抓，比如 <a href=\"http://tui.qq.com/\" target=\"_blank\" rel=\"external\">腾讯爸爸</a>。<br><strong>Q3. 用户名和密码都有了，登陆一次，以后携带 cookie 不就可以了吗！</strong><br>A: cookie 很容易过期，让程序自己去拿 cookie，这样每次都是最新的 cookie，不是更酷吗？</p>\n<p>理想情况下，<strong>构建请求参数 —&gt; 请求登陆接口 —&gt; 返回 SESSIONID —&gt; 携带 SESSIONID 请求目标接口</strong>，就能拿到数据了，但是很可惜，一般的网站都不是理想情况，要成功干好这件事，需要非常非常地耐心和非常非常地仔细。<br><a id=\"more\"></a></p>\n<h2 id=\"第〇步-清空浏览器-Cookie\"><a href=\"#第〇步-清空浏览器-Cookie\" class=\"headerlink\" title=\"第〇步 清空浏览器 Cookie\"></a>第〇步 清空浏览器 Cookie</h2><p>这是最重要的一步，一定要清，不然哭一整天。另外在抓取过程中，只要重来，就清一次。因为如果不清 Cookie，浏览器会将上次保留的 Cookie 发送出去，干扰我们找真实的请求。<br>下图是Chrome 清空 cookie 的地方：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/01.png\" alt=\"\"></p>\n<p>什么？你不是用 chrome？那你别往下看了</p>\n<h2 id=\"第一步-从需要抓取的接口找起\"><a href=\"#第一步-从需要抓取的接口找起\" class=\"headerlink\" title=\"第一步 从需要抓取的接口找起\"></a>第一步 从需要抓取的接口找起</h2><p>要抓取的数据肯定是来源于一个接口的，只是响应体内容可能有差异，比如是 JSON 格式返回的，或者是藏在 HTML 返回的，都有可能。首先要找到这个目标接口，然后重点关注它的请求头。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/02.png\" alt=\"\"></p>\n<p>Cookie 是服务器判断用户有没有登陆的凭证，对应于服务器上的 Session，所以一般情况下，只要能拿到这个字段就大功告成了。请求的 cookie 都在请求体的 cookie 中，对应的响应的 cookie 都在响应体的 set-cookie 中。<br>不同的后台语言对应不同的 Session 名字，常见的有： JSESSIONID (Java EE),、PHPSESSID (PHP)、 ASPSESSIONID (Microsoft ASP).。如上图可以大致推断这个网站是使用 JavaEE 开发的。</p>\n<h2 id=\"第二步-从后往前推\"><a href=\"#第二步-从后往前推\" class=\"headerlink\" title=\"第二步 从后往前推\"></a>第二步 从后往前推</h2><p>找到抓取数据所在的接口以后，一步一步往上找，点击请求，打开右侧的 Cookies 选项卡，可以看到这次请求的 Cookies 交互情况。<strong>如果 Response Cookies 出现了目标请求中的 JSESSIONID</strong>，没错！离成功近了一步，你需要拿小本子把这个请求记下来了。<br>而这个请求在请求时很可能也需要一些 Cookies，所以以此类推，继续往上找。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/03.png\" alt=\"\"></p>\n<h2 id=\"第三步-找到登陆请求\"><a href=\"#第三步-找到登陆请求\" class=\"headerlink\" title=\"第三步 找到登陆请求\"></a>第三步 找到登陆请求</h2><p>要登录的网站必定是有个登录的请求的，登录请求一般有这么几种参数：<br>1) 用户名、明文密码<br>2) 用户名、加密密码<br>3) 用户名、加密密码、加密其他参数<br>（当然一般登陆还需要验证码，使用一些能够破解验证码的服务即可）</p>\n<p>碰到第一种，恭喜，今天可以提前下班了。登录的参数已经都有了，剩下的，一是请求登录接口可能需要 cookies，这个 cookies 如果包含 sessionid，sessionid 一定可以从登录之前的接口拿到，那么往前找就对了。二是请求登录接口之后一定会<strong>直接或间接</strong>返回<strong>能够代表用户凭证的东西</strong>，拿着这个东西，继续寻找能够<strong>拿到目标接口需要的 sessionid</strong> 即可。</p>\n<p>碰到第二种，还行，仔细的话还是能正常加班的。加密的过程一定是在 javascript 中完成的，打开源码，好好啃一下，这里有两个经验，一是可以先找一下这个按钮有没有 click 事件，如果有，八成在这个事件里写好了加密过程，如果没有，说明是表单提交。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/04.png\" alt=\"\"></p>\n<p>另外实在没有办法，就在源码里搜一下 cookie 等相关的字段，更容易命中一点。</p>\n<p>碰到第三种，去洗把脸准备准备加班了。其实不管是加密密码，还是加密其他参数，都是在 js 里面完成的，难度可能其实差不多，但是这体现了后台的重视程度。。。所以可能会更复杂一点，像腾讯里面使用了统一的登陆方式，所以也使用了统一的加密方法，加密的地方还蛮多的，看源码找了半天才找出来，这里就不展开了，有兴趣可以交流一下。</p>\n<h2 id=\"一点人生经验\"><a href=\"#一点人生经验\" class=\"headerlink\" title=\"一点人生经验\"></a>一点人生经验</h2><p>抓取的方法其实在上面三步里说的差不多了，说白了就是仿照请求的过程，在不同的请求中寻找前后台交互的流程，下面是中间的一些经验：</p>\n<h3 id=\"1-cookie-的作用域\"><a href=\"#1-cookie-的作用域\" class=\"headerlink\" title=\"1) cookie 的作用域\"></a>1) cookie 的作用域</h3><p>每个 cookie 都有自己的域，这可能在刚抓取的时候很容易被忽视，网页在登陆前后的跳转中，很可能会经历不同的域名，比如从 site.com/aaa 跳到 site.com/bbb，这两次返回的 cookie 域可能就会不同，重要的是这两个响应可能都返回 SESSIONID，但是两个是<strong>不同</strong>的，一定要分清接下来的请求携带的是哪一个。举个栗子：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/05.png\" alt=\"\"></p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/06.png\" alt=\"\"></p>\n<p>同样是 JSESSIONID，不能搞混哦。</p>\n<h3 id=\"2-302-跳转\"><a href=\"#2-302-跳转\" class=\"headerlink\" title=\"2) 302 跳转\"></a>2) 302 跳转</h3><p>你可能会碰到 302 重定向，可怕的是有的信息就藏在 302 请求中：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/07.png\" alt=\"\"></p>\n<p>这里就有个坑了，之前没有注意，我请求这个 url 的时候，想拿这个 cookie，写好代码之后，发现确实拿到 cookie 了，但是后面请求目标接口总是不成功，最后把响应头拿出来一看，发现！</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/08.png\" alt=\"\"></p>\n<p>尼玛！cookie 的作用域不同啊！（上面是 /ad/，而我的是 /hccas/）<br>然后把响应状态打出来一看！<br>200！<br>擦擦擦擦，一下午就被这个干掉了，其实这是因为 request.js（我使用的是nodejs）对 302 请求作了自动重定向造成了，也就是碰到 302 就跟着跳了，但我们并不想它跳，这时需要设置一个参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">followRedirect: false</div></pre></td></tr></table></figure>\n<p>然后就成功拿到了！</p>\n","excerpt":"<h2 id=\"业务需求\"><a href=\"#业务需求\" class=\"headerlink\" title=\"业务需求\"></a>业务需求</h2><p>这里讨论的是给了用户名和密码，需要获取登陆之后页面内的某些数据。<br>那么问题来了，<br><strong>Q1. 用户名和密码都有了，直接登录不就完了吗！</strong><br>A: 用机器去抓，省时又省力，关键是很酷。<br><strong>Q2. 用户名和密码都有了，难道不是 so easy 吗！</strong><br>A: 一般情况下都挺简单，但也有部分网站相当难抓，比如 <a href=\"http://tui.qq.com/\">腾讯爸爸</a>。<br><strong>Q3. 用户名和密码都有了，登陆一次，以后携带 cookie 不就可以了吗！</strong><br>A: cookie 很容易过期，让程序自己去拿 cookie，这样每次都是最新的 cookie，不是更酷吗？</p>\n<p>理想情况下，<strong>构建请求参数 —&gt; 请求登陆接口 —&gt; 返回 SESSIONID —&gt; 携带 SESSIONID 请求目标接口</strong>，就能拿到数据了，但是很可惜，一般的网站都不是理想情况，要成功干好这件事，需要非常非常地耐心和非常非常地仔细。<br>","more":"</p>\n<h2 id=\"第〇步-清空浏览器-Cookie\"><a href=\"#第〇步-清空浏览器-Cookie\" class=\"headerlink\" title=\"第〇步 清空浏览器 Cookie\"></a>第〇步 清空浏览器 Cookie</h2><p>这是最重要的一步，一定要清，不然哭一整天。另外在抓取过程中，只要重来，就清一次。因为如果不清 Cookie，浏览器会将上次保留的 Cookie 发送出去，干扰我们找真实的请求。<br>下图是Chrome 清空 cookie 的地方：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/01.png\" alt=\"\"></p>\n<p>什么？你不是用 chrome？那你别往下看了</p>\n<h2 id=\"第一步-从需要抓取的接口找起\"><a href=\"#第一步-从需要抓取的接口找起\" class=\"headerlink\" title=\"第一步 从需要抓取的接口找起\"></a>第一步 从需要抓取的接口找起</h2><p>要抓取的数据肯定是来源于一个接口的，只是响应体内容可能有差异，比如是 JSON 格式返回的，或者是藏在 HTML 返回的，都有可能。首先要找到这个目标接口，然后重点关注它的请求头。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/02.png\" alt=\"\"></p>\n<p>Cookie 是服务器判断用户有没有登陆的凭证，对应于服务器上的 Session，所以一般情况下，只要能拿到这个字段就大功告成了。请求的 cookie 都在请求体的 cookie 中，对应的响应的 cookie 都在响应体的 set-cookie 中。<br>不同的后台语言对应不同的 Session 名字，常见的有： JSESSIONID (Java EE),、PHPSESSID (PHP)、 ASPSESSIONID (Microsoft ASP).。如上图可以大致推断这个网站是使用 JavaEE 开发的。</p>\n<h2 id=\"第二步-从后往前推\"><a href=\"#第二步-从后往前推\" class=\"headerlink\" title=\"第二步 从后往前推\"></a>第二步 从后往前推</h2><p>找到抓取数据所在的接口以后，一步一步往上找，点击请求，打开右侧的 Cookies 选项卡，可以看到这次请求的 Cookies 交互情况。<strong>如果 Response Cookies 出现了目标请求中的 JSESSIONID</strong>，没错！离成功近了一步，你需要拿小本子把这个请求记下来了。<br>而这个请求在请求时很可能也需要一些 Cookies，所以以此类推，继续往上找。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/03.png\" alt=\"\"></p>\n<h2 id=\"第三步-找到登陆请求\"><a href=\"#第三步-找到登陆请求\" class=\"headerlink\" title=\"第三步 找到登陆请求\"></a>第三步 找到登陆请求</h2><p>要登录的网站必定是有个登录的请求的，登录请求一般有这么几种参数：<br>1) 用户名、明文密码<br>2) 用户名、加密密码<br>3) 用户名、加密密码、加密其他参数<br>（当然一般登陆还需要验证码，使用一些能够破解验证码的服务即可）</p>\n<p>碰到第一种，恭喜，今天可以提前下班了。登录的参数已经都有了，剩下的，一是请求登录接口可能需要 cookies，这个 cookies 如果包含 sessionid，sessionid 一定可以从登录之前的接口拿到，那么往前找就对了。二是请求登录接口之后一定会<strong>直接或间接</strong>返回<strong>能够代表用户凭证的东西</strong>，拿着这个东西，继续寻找能够<strong>拿到目标接口需要的 sessionid</strong> 即可。</p>\n<p>碰到第二种，还行，仔细的话还是能正常加班的。加密的过程一定是在 javascript 中完成的，打开源码，好好啃一下，这里有两个经验，一是可以先找一下这个按钮有没有 click 事件，如果有，八成在这个事件里写好了加密过程，如果没有，说明是表单提交。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/04.png\" alt=\"\"></p>\n<p>另外实在没有办法，就在源码里搜一下 cookie 等相关的字段，更容易命中一点。</p>\n<p>碰到第三种，去洗把脸准备准备加班了。其实不管是加密密码，还是加密其他参数，都是在 js 里面完成的，难度可能其实差不多，但是这体现了后台的重视程度。。。所以可能会更复杂一点，像腾讯里面使用了统一的登陆方式，所以也使用了统一的加密方法，加密的地方还蛮多的，看源码找了半天才找出来，这里就不展开了，有兴趣可以交流一下。</p>\n<h2 id=\"一点人生经验\"><a href=\"#一点人生经验\" class=\"headerlink\" title=\"一点人生经验\"></a>一点人生经验</h2><p>抓取的方法其实在上面三步里说的差不多了，说白了就是仿照请求的过程，在不同的请求中寻找前后台交互的流程，下面是中间的一些经验：</p>\n<h3 id=\"1-cookie-的作用域\"><a href=\"#1-cookie-的作用域\" class=\"headerlink\" title=\"1) cookie 的作用域\"></a>1) cookie 的作用域</h3><p>每个 cookie 都有自己的域，这可能在刚抓取的时候很容易被忽视，网页在登陆前后的跳转中，很可能会经历不同的域名，比如从 site.com/aaa 跳到 site.com/bbb，这两次返回的 cookie 域可能就会不同，重要的是这两个响应可能都返回 SESSIONID，但是两个是<strong>不同</strong>的，一定要分清接下来的请求携带的是哪一个。举个栗子：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/05.png\" alt=\"\"></p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/06.png\" alt=\"\"></p>\n<p>同样是 JSESSIONID，不能搞混哦。</p>\n<h3 id=\"2-302-跳转\"><a href=\"#2-302-跳转\" class=\"headerlink\" title=\"2) 302 跳转\"></a>2) 302 跳转</h3><p>你可能会碰到 302 重定向，可怕的是有的信息就藏在 302 请求中：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/07.png\" alt=\"\"></p>\n<p>这里就有个坑了，之前没有注意，我请求这个 url 的时候，想拿这个 cookie，写好代码之后，发现确实拿到 cookie 了，但是后面请求目标接口总是不成功，最后把响应头拿出来一看，发现！</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/08.png\" alt=\"\"></p>\n<p>尼玛！cookie 的作用域不同啊！（上面是 /ad/，而我的是 /hccas/）<br>然后把响应状态打出来一看！<br>200！<br>擦擦擦擦，一下午就被这个干掉了，其实这是因为 request.js（我使用的是nodejs）对 302 请求作了自动重定向造成了，也就是碰到 302 就跟着跳了，但我们并不想它跳，这时需要设置一个参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">followRedirect: false</div></pre></td></tr></table></figure>\n<p>然后就成功拿到了！</p>"},{"title":"基本数据结构（一）","date":"2016-07-24T05:39:57.000Z","_content":"\n通过 Javascript 实现各种基本数据结构。包括栈、队列、链表、集合等\n\n<!-- more -->\n\n## 栈\n\n栈算是相对来说最简单的数据结构了，遵循后进先出原则，可以通过维护一个数组来实现一个栈类。\n\n### API\n- push(ele1, [ele2, ...]) 添加一个或多个元素到栈顶\n- pop() 弹出栈顶元素\n- peek() 返回栈顶元素，但不弹出它\n- isEmpty() 如果栈为空，则返回 true，否则返回 false\n- clear() 清空栈\n- size() 返回栈中元素个数\n\n### 实现\n```javascript\nclass Stack {\n  constructor() {\n    this.arr = [];\n  }\n\n  /**\n   * 出栈\n   * @return 栈顶元素\n   */\n  pop() {\n    if(this.isEmpty()) {\n      throw new Error('stack underflow error');\n    }\n    return this.arr.pop();\n  }\n\n  /**\n   * 入栈\n   * @params  新元素\n   */\n  push() {\n    const args = Array.from(arguments);\n    if(args.length == 0) {\n      throw new Error('缺少参数');\n    }\n    for(let ele of args) {\n      this.arr.push(ele);\n    }\n  }\n\n  /**\n   * 返回栈顶元素但不出栈\n   * @return 栈顶元素\n   */\n  peek() {\n    if(this.isEmpty) {\n      throw new Error('该栈为空栈');\n    }\n    return this.arr[this.arr.length - 1];\n  }\n\n  /**\n   * 是否为空栈\n   * @return boolean 是否为空栈\n   */\n  isEmpty() {\n    return this.size() == 0;\n  }\n\n  /**\n   * 栈的大小\n   * @return number 栈的大小\n   */\n  size() {\n    return this.arr.length;\n  }\n\n  /**\n   * 清空栈\n   */\n  clear() {\n    this.arr = [];\n  }\n\n  /**\n   * 打印栈中元素\n   * @return string 栈中所有元素\n   */\n  print() {\n    console.log(this.arr.toString());\n  }\n}\n```\n\n### 应用\n\n#### 十进制转其他进制\n\n我们可以使用栈来解决进制转换的问题，从十进制转指定的进制实际上是让十进制数除以进制的基数，再将得到的结果继续作被除数，一直到商为 0 为止。将每次的余数压栈，最后让栈依次弹出，连接成的字符串即为转换后的数。\n\n```javascript\nfunction baseConverter(decNumber, base) {\n  const stack = new Stack();\n  const digits = '0123456789ABCDEF';\n  let result = '';\n\n  while(decNumber > 0) {\n    let rem = Math.floor(decNumber % base);\n    stack.push(digits[rem]);\n    decNumber = Math.floor(decNumber / base);\n  }\n\n  while(!stack.isEmpty()) {\n    result += stack.pop();\n  }\n\n  return result;\n}\n\nconsole.log(baseConverter(100345, 2)); // 11000011111111001\nconsole.log(baseConverter(100345, 8));  // 303771\nconsole.log(baseConverter(100345, 16)); // 187F9\n```\n\n## 队列\n\n队列和栈很类似，但遵循先进先出原则。\n\n### API\n- enqueue(ele1, [ele2, ...]) 向队尾添加一个或多个元素\n- dequeue() 移除队首元素，并返回\n- front() 返回队首元素，但不移除它\n- isEmpty() 队列为空时，返回 true，否则返回 false\n- size() 返回队列中元素个数\n- clear() 清空队列\n- print() 打印队列\n\n### 实现\n```javascript\nclass Queue {\n  constructor() {\n    this.arr = [];\n  }\n\n  enqueue() {\n    const args = Array.from(arguments);\n    if(args.length == 0) {\n      throw new Error('缺少参数');\n    }\n    for(let ele of args) {\n      this.arr.push(ele);\n    }\n  }\n\n  dequeue() {\n    if(this.isEmpty()) {\n      throw new Error('queue is empty');\n    }\n    return this.arr.shift();\n  }\n\n  front() {\n    if(this.isEmpty()) {\n      throw new Error('queue is empty');\n    }\n    return this.arr[0];\n  }\n\n  isEmpty() {\n    return this.size() == 0;\n  }\n\n  size() {\n    return this.arr.length;\n  }\n\n  clear() {\n    this.arr = [];\n  }\n\n  print() {\n    console.log(this.arr.toString());\n  }\n}\n```\n\n### 应用\n\n#### 优先队列\n\n优先队列中的每个元素都有一个优先级，优先级的数字越小，优先级越高。为了使优先级越高的元素越先出队列，添加该元素的时候，会根据它的优先级将它插入到合适的位置。\n\n```javascript\nclass PriorityQueue extends Queue{\n  constructor(...args) {\n    super(...args);\n  }\n\n  enqueue(element, priority) {\n    const ele = {\n      element: element,\n      priority: priority\n    };\n\n    if(this.isEmpty()) {\n      this.arr.push(ele);\n      return;\n    }\n\n    let added = false;\n    for(let i in this.arr) {\n      if(priority < this.arr[i].priority) {\n        this.arr.splice(i, 0, ele);\n        added = true;\n        break;\n      }\n    }\n\n    if(!added) {\n      this.arr.push(ele);\n    }\n  }\n\n  print() {\n    console.log(this.arr.map((item) => {\n      return item.element;\n    }).join(','));\n  }\n}\n\nlet priorityQueue = new PriorityQueue();\npriorityQueue.enqueue('john', 2);\npriorityQueue.enqueue('jack', 1);\npriorityQueue.enqueue('mark', 3);\npriorityQueue.enqueue('camila', 1); \npriorityQueue.print();  // jack,camila,john,mark\n```\n\n#### 循环队列——击鼓传花\n\n假设有一圈小孩围着坐，将一朵花交给队首的小孩，小孩依次将花传给下一个小孩，当传到队尾的时候，再将花传给队首的小孩，也就是队列首尾相连，形成了一个循环队列。\n\n在“击鼓传花”游戏中，给定一个数字，当传递次数达到这个次数时，淘汰掉此时拿花的小孩，再进行下一轮，直到只有一个小孩（胜者）。\n\n```javascript\nfunction hotPotato(nameList, num) {\n  const queue = new Queue();\n\n  // 小孩入列\n  for (let name of nameList) {\n    queue.enqueue(name);\n  }\n\n  while(queue.size() > 1) {\n    for(let i = 0; i < num; i++) {\n      // 将队首的小孩放到队尾\n      queue.enqueue(queue.dequeue());\n    }\n    // 淘汰\n    console.log(queue.dequeue() + ' 被淘汰了。');\n  }\n\n  return queue.dequeue();\n}\n\nlet nameList = ['John', 'Jack', 'Camila', 'Ingrid', 'Carl'];\nlet winner = hotPotato(nameList, 7);\n/**\n * Camila 被淘汰了。\n * Jack 被淘汰了。\n * Carl 被淘汰了。\n * Ingrid 被淘汰了。\n * winner: John\n */\nconsole.log('winner: ' + winner);\n```\n\n## 链表\n\n链表存储有序的元素集合，但不同于数组，链表中的元素在内存中不是连续放置的，每个元素由一个存储元素本身的结点和一个指向下一个元素的引用组成。\n\n### API\n- append(element) 在尾部添加一个新元素\n- insert(position, element) 在指定位置插入一个新元素\n- remove(element) 从链表中移除一个元素\n- indexOf(element) 返回元素在链表中的索引，如果没有返回 -1\n- removeAt(position) 从特定位置移除一个元素\n- isEmpty() 返回链表是否为空\n- size() 链表中元素的个数\n- toString() 输出所有元素的值\n\n### 实现\n```javascript\n/* 结点类 */\nclass Node {\n  constructor(element, next = null) {\n    this.element = element;\n    this.next = next;\n  }\n}\n\n/* 链表类 */\nclass LinkedList {\n  constructor() {\n    // 链表头\n    this.head = null;\n    // 链表长度\n    this.length = 0;\n  }\n\n  append(element) {\n    const node = new Node(element);\n\n    if(this.head == null) {\n      this.head = node;\n    } else {\n      let current = this.head;\n      while(current.next != null) {\n        current = current.next;\n      }\n      current.next = node;      \n    }\n\n    this.length++;\n  }\n\n  insert(position, element) {\n    if(position < 0 || position >= this.size()) {\n      throw new Error('illegal position');\n    }\n    const node = new Node(element);\n    let current = this.head, previous = null;\n    if(position == 0) {\n      node.next = this.head;\n      this.head = node;\n    } else {\n      let index = 0;\n      while(index < position) {\n        previous = current;\n        current = current.next;\n        index++;\n      }\n      node.next = current;\n      previous.next = node;\n    }\n    this.length++;\n  }\n\n  removeAt(position) {\n    if(this.isEmpty()) {\n      throw new Error('list is empty');\n    }\n    if(position < 0 || position >= this.size()) {\n      throw new Error('illegal position');\n    }\n    let current = this.head, previous = null;\n    if(position == 0) {\n      this.head = current.next;\n    } else {\n      let index = 0;\n      while(index < position) {\n        previous = current;\n        current = current.next;\n        index++;\n      }\n\n      previous.next = current.next;\n    }\n    this.length--;\n    return current.element;\n  }\n\n  remove(element) {\n    const index = this.indexOf(element);\n    this.removeAt(index);\n  }\n\n  indexOf(element) {\n    let current = this.head;\n    let index = -1;\n    while(current) {\n      index++;\n      if(current.element == element) {\n        return index;\n      }\n      current = current.next;\n    }\n    return -1;\n  }\n\n  isEmpty() {\n    return this.size() == 0;\n  }\n\n  size() {\n    return this.length;\n  }\n\n  toString() {\n    let result = '';\n    let current = this.head;\n    while(current) {\n      result += current.element;\n      current = current.next;\n    }\n    return result;\n  }\n}\n```\n\n## 集合\n\n集合由一组无序且唯一的项组成。\n\n### API\n- add(value) 向集合添加一个元素\n- remove(value) 从集合内移除一个元素 \n- has(value) 元素是否在集合中\n- clear() 清空集合\n- size() 返回集合所包含的元素数量\n- values() 返回包含集合中所有值的数组\n\n### 实现\n```javascript\nclass Set {\n  constructor() {\n    this.items = {};\n  }\n\n  has(value) {\n    return value in this.items;\n  }\n\n  add(value) {\n    if(!this.has(value)) {\n      this.items[value] = value;\n      return true;\n    }\n    return false;\n  }\n\n  remove(value) {\n    if(this.has(value)) {\n      delete this.items[value];\n      return true;\n    }\n    return false;\n  }\n\n  clear() {\n    this.items = {};\n  }\n\n  size() {\n    return Object.keys(this.items).length;\n  }\n\n  values() {\n    return Object.keys(this.items);\n  }\n}\n```\n\n### 集合操作\n```javascript\nclass Set {\n  constructor() {\n    this.items = {};\n  }\n\n  //...\n\n  /**\n   * 并集\n   */\n  union(otherSet) {\n    const union = new Set();\n\n    for(let item in this.items) {\n      union.add(item);\n    }\n\n    let values = otherSet.values();\n    for(let value of values) {\n      console.log(value);\n      union.add(value);\n    }\n\n    return union;\n  }\n\n  /**\n   * 交集\n   */\n  intersection(otherSet) {\n    const intersection = new Set();\n    for(let item in this.items) {\n      if(otherSet.has(item)) {\n        intersection.add(item);\n      }\n    }\n\n    return intersection;\n  }\n\n  /**\n   * 差集\n   */\n  difference(otherSet) {\n    const difference = new Set();\n\n    for(let item in this.items) {\n      if(!otherSet.has(item)) {\n        difference.add(item);\n      }\n    }\n\n    return difference;\n  }\n\n  /**\n   * 当前集合是否为给定集合的子集\n   */\n  subset(otherSet) {\n    if(this.size() > otherSet.size()) {\n      return false;\n    }\n    for(let item in this.items) {\n      if(!otherSet.has(item)) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n```","source":"_posts/data-structures.md","raw":"---\ntitle: 基本数据结构（一）\ndate: 2016-07-24 13:39:57\ntags: [数据结构]\n---\n\n通过 Javascript 实现各种基本数据结构。包括栈、队列、链表、集合等\n\n<!-- more -->\n\n## 栈\n\n栈算是相对来说最简单的数据结构了，遵循后进先出原则，可以通过维护一个数组来实现一个栈类。\n\n### API\n- push(ele1, [ele2, ...]) 添加一个或多个元素到栈顶\n- pop() 弹出栈顶元素\n- peek() 返回栈顶元素，但不弹出它\n- isEmpty() 如果栈为空，则返回 true，否则返回 false\n- clear() 清空栈\n- size() 返回栈中元素个数\n\n### 实现\n```javascript\nclass Stack {\n  constructor() {\n    this.arr = [];\n  }\n\n  /**\n   * 出栈\n   * @return 栈顶元素\n   */\n  pop() {\n    if(this.isEmpty()) {\n      throw new Error('stack underflow error');\n    }\n    return this.arr.pop();\n  }\n\n  /**\n   * 入栈\n   * @params  新元素\n   */\n  push() {\n    const args = Array.from(arguments);\n    if(args.length == 0) {\n      throw new Error('缺少参数');\n    }\n    for(let ele of args) {\n      this.arr.push(ele);\n    }\n  }\n\n  /**\n   * 返回栈顶元素但不出栈\n   * @return 栈顶元素\n   */\n  peek() {\n    if(this.isEmpty) {\n      throw new Error('该栈为空栈');\n    }\n    return this.arr[this.arr.length - 1];\n  }\n\n  /**\n   * 是否为空栈\n   * @return boolean 是否为空栈\n   */\n  isEmpty() {\n    return this.size() == 0;\n  }\n\n  /**\n   * 栈的大小\n   * @return number 栈的大小\n   */\n  size() {\n    return this.arr.length;\n  }\n\n  /**\n   * 清空栈\n   */\n  clear() {\n    this.arr = [];\n  }\n\n  /**\n   * 打印栈中元素\n   * @return string 栈中所有元素\n   */\n  print() {\n    console.log(this.arr.toString());\n  }\n}\n```\n\n### 应用\n\n#### 十进制转其他进制\n\n我们可以使用栈来解决进制转换的问题，从十进制转指定的进制实际上是让十进制数除以进制的基数，再将得到的结果继续作被除数，一直到商为 0 为止。将每次的余数压栈，最后让栈依次弹出，连接成的字符串即为转换后的数。\n\n```javascript\nfunction baseConverter(decNumber, base) {\n  const stack = new Stack();\n  const digits = '0123456789ABCDEF';\n  let result = '';\n\n  while(decNumber > 0) {\n    let rem = Math.floor(decNumber % base);\n    stack.push(digits[rem]);\n    decNumber = Math.floor(decNumber / base);\n  }\n\n  while(!stack.isEmpty()) {\n    result += stack.pop();\n  }\n\n  return result;\n}\n\nconsole.log(baseConverter(100345, 2)); // 11000011111111001\nconsole.log(baseConverter(100345, 8));  // 303771\nconsole.log(baseConverter(100345, 16)); // 187F9\n```\n\n## 队列\n\n队列和栈很类似，但遵循先进先出原则。\n\n### API\n- enqueue(ele1, [ele2, ...]) 向队尾添加一个或多个元素\n- dequeue() 移除队首元素，并返回\n- front() 返回队首元素，但不移除它\n- isEmpty() 队列为空时，返回 true，否则返回 false\n- size() 返回队列中元素个数\n- clear() 清空队列\n- print() 打印队列\n\n### 实现\n```javascript\nclass Queue {\n  constructor() {\n    this.arr = [];\n  }\n\n  enqueue() {\n    const args = Array.from(arguments);\n    if(args.length == 0) {\n      throw new Error('缺少参数');\n    }\n    for(let ele of args) {\n      this.arr.push(ele);\n    }\n  }\n\n  dequeue() {\n    if(this.isEmpty()) {\n      throw new Error('queue is empty');\n    }\n    return this.arr.shift();\n  }\n\n  front() {\n    if(this.isEmpty()) {\n      throw new Error('queue is empty');\n    }\n    return this.arr[0];\n  }\n\n  isEmpty() {\n    return this.size() == 0;\n  }\n\n  size() {\n    return this.arr.length;\n  }\n\n  clear() {\n    this.arr = [];\n  }\n\n  print() {\n    console.log(this.arr.toString());\n  }\n}\n```\n\n### 应用\n\n#### 优先队列\n\n优先队列中的每个元素都有一个优先级，优先级的数字越小，优先级越高。为了使优先级越高的元素越先出队列，添加该元素的时候，会根据它的优先级将它插入到合适的位置。\n\n```javascript\nclass PriorityQueue extends Queue{\n  constructor(...args) {\n    super(...args);\n  }\n\n  enqueue(element, priority) {\n    const ele = {\n      element: element,\n      priority: priority\n    };\n\n    if(this.isEmpty()) {\n      this.arr.push(ele);\n      return;\n    }\n\n    let added = false;\n    for(let i in this.arr) {\n      if(priority < this.arr[i].priority) {\n        this.arr.splice(i, 0, ele);\n        added = true;\n        break;\n      }\n    }\n\n    if(!added) {\n      this.arr.push(ele);\n    }\n  }\n\n  print() {\n    console.log(this.arr.map((item) => {\n      return item.element;\n    }).join(','));\n  }\n}\n\nlet priorityQueue = new PriorityQueue();\npriorityQueue.enqueue('john', 2);\npriorityQueue.enqueue('jack', 1);\npriorityQueue.enqueue('mark', 3);\npriorityQueue.enqueue('camila', 1); \npriorityQueue.print();  // jack,camila,john,mark\n```\n\n#### 循环队列——击鼓传花\n\n假设有一圈小孩围着坐，将一朵花交给队首的小孩，小孩依次将花传给下一个小孩，当传到队尾的时候，再将花传给队首的小孩，也就是队列首尾相连，形成了一个循环队列。\n\n在“击鼓传花”游戏中，给定一个数字，当传递次数达到这个次数时，淘汰掉此时拿花的小孩，再进行下一轮，直到只有一个小孩（胜者）。\n\n```javascript\nfunction hotPotato(nameList, num) {\n  const queue = new Queue();\n\n  // 小孩入列\n  for (let name of nameList) {\n    queue.enqueue(name);\n  }\n\n  while(queue.size() > 1) {\n    for(let i = 0; i < num; i++) {\n      // 将队首的小孩放到队尾\n      queue.enqueue(queue.dequeue());\n    }\n    // 淘汰\n    console.log(queue.dequeue() + ' 被淘汰了。');\n  }\n\n  return queue.dequeue();\n}\n\nlet nameList = ['John', 'Jack', 'Camila', 'Ingrid', 'Carl'];\nlet winner = hotPotato(nameList, 7);\n/**\n * Camila 被淘汰了。\n * Jack 被淘汰了。\n * Carl 被淘汰了。\n * Ingrid 被淘汰了。\n * winner: John\n */\nconsole.log('winner: ' + winner);\n```\n\n## 链表\n\n链表存储有序的元素集合，但不同于数组，链表中的元素在内存中不是连续放置的，每个元素由一个存储元素本身的结点和一个指向下一个元素的引用组成。\n\n### API\n- append(element) 在尾部添加一个新元素\n- insert(position, element) 在指定位置插入一个新元素\n- remove(element) 从链表中移除一个元素\n- indexOf(element) 返回元素在链表中的索引，如果没有返回 -1\n- removeAt(position) 从特定位置移除一个元素\n- isEmpty() 返回链表是否为空\n- size() 链表中元素的个数\n- toString() 输出所有元素的值\n\n### 实现\n```javascript\n/* 结点类 */\nclass Node {\n  constructor(element, next = null) {\n    this.element = element;\n    this.next = next;\n  }\n}\n\n/* 链表类 */\nclass LinkedList {\n  constructor() {\n    // 链表头\n    this.head = null;\n    // 链表长度\n    this.length = 0;\n  }\n\n  append(element) {\n    const node = new Node(element);\n\n    if(this.head == null) {\n      this.head = node;\n    } else {\n      let current = this.head;\n      while(current.next != null) {\n        current = current.next;\n      }\n      current.next = node;      \n    }\n\n    this.length++;\n  }\n\n  insert(position, element) {\n    if(position < 0 || position >= this.size()) {\n      throw new Error('illegal position');\n    }\n    const node = new Node(element);\n    let current = this.head, previous = null;\n    if(position == 0) {\n      node.next = this.head;\n      this.head = node;\n    } else {\n      let index = 0;\n      while(index < position) {\n        previous = current;\n        current = current.next;\n        index++;\n      }\n      node.next = current;\n      previous.next = node;\n    }\n    this.length++;\n  }\n\n  removeAt(position) {\n    if(this.isEmpty()) {\n      throw new Error('list is empty');\n    }\n    if(position < 0 || position >= this.size()) {\n      throw new Error('illegal position');\n    }\n    let current = this.head, previous = null;\n    if(position == 0) {\n      this.head = current.next;\n    } else {\n      let index = 0;\n      while(index < position) {\n        previous = current;\n        current = current.next;\n        index++;\n      }\n\n      previous.next = current.next;\n    }\n    this.length--;\n    return current.element;\n  }\n\n  remove(element) {\n    const index = this.indexOf(element);\n    this.removeAt(index);\n  }\n\n  indexOf(element) {\n    let current = this.head;\n    let index = -1;\n    while(current) {\n      index++;\n      if(current.element == element) {\n        return index;\n      }\n      current = current.next;\n    }\n    return -1;\n  }\n\n  isEmpty() {\n    return this.size() == 0;\n  }\n\n  size() {\n    return this.length;\n  }\n\n  toString() {\n    let result = '';\n    let current = this.head;\n    while(current) {\n      result += current.element;\n      current = current.next;\n    }\n    return result;\n  }\n}\n```\n\n## 集合\n\n集合由一组无序且唯一的项组成。\n\n### API\n- add(value) 向集合添加一个元素\n- remove(value) 从集合内移除一个元素 \n- has(value) 元素是否在集合中\n- clear() 清空集合\n- size() 返回集合所包含的元素数量\n- values() 返回包含集合中所有值的数组\n\n### 实现\n```javascript\nclass Set {\n  constructor() {\n    this.items = {};\n  }\n\n  has(value) {\n    return value in this.items;\n  }\n\n  add(value) {\n    if(!this.has(value)) {\n      this.items[value] = value;\n      return true;\n    }\n    return false;\n  }\n\n  remove(value) {\n    if(this.has(value)) {\n      delete this.items[value];\n      return true;\n    }\n    return false;\n  }\n\n  clear() {\n    this.items = {};\n  }\n\n  size() {\n    return Object.keys(this.items).length;\n  }\n\n  values() {\n    return Object.keys(this.items);\n  }\n}\n```\n\n### 集合操作\n```javascript\nclass Set {\n  constructor() {\n    this.items = {};\n  }\n\n  //...\n\n  /**\n   * 并集\n   */\n  union(otherSet) {\n    const union = new Set();\n\n    for(let item in this.items) {\n      union.add(item);\n    }\n\n    let values = otherSet.values();\n    for(let value of values) {\n      console.log(value);\n      union.add(value);\n    }\n\n    return union;\n  }\n\n  /**\n   * 交集\n   */\n  intersection(otherSet) {\n    const intersection = new Set();\n    for(let item in this.items) {\n      if(otherSet.has(item)) {\n        intersection.add(item);\n      }\n    }\n\n    return intersection;\n  }\n\n  /**\n   * 差集\n   */\n  difference(otherSet) {\n    const difference = new Set();\n\n    for(let item in this.items) {\n      if(!otherSet.has(item)) {\n        difference.add(item);\n      }\n    }\n\n    return difference;\n  }\n\n  /**\n   * 当前集合是否为给定集合的子集\n   */\n  subset(otherSet) {\n    if(this.size() > otherSet.size()) {\n      return false;\n    }\n    for(let item in this.items) {\n      if(!otherSet.has(item)) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n```","slug":"data-structures","published":1,"updated":"2017-03-17T13:40:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcvr0013n927xb3fsd11","content":"<p>通过 Javascript 实现各种基本数据结构。包括栈、队列、链表、集合等</p>\n<a id=\"more\"></a>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><p>栈算是相对来说最简单的数据结构了，遵循后进先出原则，可以通过维护一个数组来实现一个栈类。</p>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>push(ele1, [ele2, …]) 添加一个或多个元素到栈顶</li>\n<li>pop() 弹出栈顶元素</li>\n<li>peek() 返回栈顶元素，但不弹出它</li>\n<li>isEmpty() 如果栈为空，则返回 true，否则返回 false</li>\n<li>clear() 清空栈</li>\n<li>size() 返回栈中元素个数</li>\n</ul>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr = [];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</span></div><div class=\"line\">   * 出栈</div><div class=\"line\">   * @return 栈顶元素</div><div class=\"line\">   */</div><div class=\"line\">  pop() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.isEmpty()) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'stack underflow error'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr.pop();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</span></div><div class=\"line\">   * 入栈</div><div class=\"line\">   * @params  新元素</div><div class=\"line\">   */</div><div class=\"line\">  push() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> args = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span>(args.length == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'缺少参数'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> ele <span class=\"keyword\">of</span> args) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.arr.push(ele);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</span></div><div class=\"line\">   * 返回栈顶元素但不出栈</div><div class=\"line\">   * @return 栈顶元素</div><div class=\"line\">   */</div><div class=\"line\">  peek() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.isEmpty) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'该栈为空栈'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr[<span class=\"keyword\">this</span>.arr.length - <span class=\"number\">1</span>];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</span></div><div class=\"line\">   * 是否为空栈</div><div class=\"line\">   * @return boolean 是否为空栈</div><div class=\"line\">   */</div><div class=\"line\">  isEmpty() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.size() == <span class=\"number\">0</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</span></div><div class=\"line\">   * 栈的大小</div><div class=\"line\">   * @return number 栈的大小</div><div class=\"line\">   */</div><div class=\"line\">  size() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr.length;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</span></div><div class=\"line\">   * 清空栈</div><div class=\"line\">   */</div><div class=\"line\">  clear() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr = [];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</span></div><div class=\"line\">   * 打印栈中元素</div><div class=\"line\">   * @return string 栈中所有元素</div><div class=\"line\">   */</div><div class=\"line\">  print() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.arr.toString());</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><h4 id=\"十进制转其他进制\"><a href=\"#十进制转其他进制\" class=\"headerlink\" title=\"十进制转其他进制\"></a>十进制转其他进制</h4><p>我们可以使用栈来解决进制转换的问题，从十进制转指定的进制实际上是让十进制数除以进制的基数，再将得到的结果继续作被除数，一直到商为 0 为止。将每次的余数压栈，最后让栈依次弹出，连接成的字符串即为转换后的数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseConverter</span>(<span class=\"params\">decNumber, base</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> stack = <span class=\"keyword\">new</span> Stack();</div><div class=\"line\">  <span class=\"keyword\">const</span> digits = <span class=\"string\">'0123456789ABCDEF'</span>;</div><div class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"string\">''</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">while</span>(decNumber &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> rem = <span class=\"built_in\">Math</span>.floor(decNumber % base);</div><div class=\"line\">    stack.push(digits[rem]);</div><div class=\"line\">    decNumber = <span class=\"built_in\">Math</span>.floor(decNumber / base);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">while</span>(!stack.isEmpty()) &#123;</div><div class=\"line\">    result += stack.pop();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(baseConverter(<span class=\"number\">100345</span>, <span class=\"number\">2</span>)); <span class=\"comment\">// 11000011111111001</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(baseConverter(<span class=\"number\">100345</span>, <span class=\"number\">8</span>));  <span class=\"comment\">// 303771</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(baseConverter(<span class=\"number\">100345</span>, <span class=\"number\">16</span>)); <span class=\"comment\">// 187F9</span></div></pre></td></tr></table></figure>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><p>队列和栈很类似，但遵循先进先出原则。</p>\n<h3 id=\"API-1\"><a href=\"#API-1\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>enqueue(ele1, [ele2, …]) 向队尾添加一个或多个元素</li>\n<li>dequeue() 移除队首元素，并返回</li>\n<li>front() 返回队首元素，但不移除它</li>\n<li>isEmpty() 队列为空时，返回 true，否则返回 false</li>\n<li>size() 返回队列中元素个数</li>\n<li>clear() 清空队列</li>\n<li>print() 打印队列</li>\n</ul>\n<h3 id=\"实现-1\"><a href=\"#实现-1\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Queue</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr = [];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  enqueue() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> args = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span>(args.length == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'缺少参数'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> ele <span class=\"keyword\">of</span> args) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.arr.push(ele);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  dequeue() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.isEmpty()) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'queue is empty'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr.shift();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  front() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.isEmpty()) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'queue is empty'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr[<span class=\"number\">0</span>];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  isEmpty() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.size() == <span class=\"number\">0</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  size() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr.length;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  clear() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr = [];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  print() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.arr.toString());</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"应用-1\"><a href=\"#应用-1\" class=\"headerlink\" title=\"应用\"></a>应用</h3><h4 id=\"优先队列\"><a href=\"#优先队列\" class=\"headerlink\" title=\"优先队列\"></a>优先队列</h4><p>优先队列中的每个元素都有一个优先级，优先级的数字越小，优先级越高。为了使优先级越高的元素越先出队列，添加该元素的时候，会根据它的优先级将它插入到合适的位置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PriorityQueue</span> <span class=\"keyword\">extends</span> <span class=\"title\">Queue</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(...args) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(...args);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  enqueue(element, priority) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> ele = &#123;</div><div class=\"line\">      <span class=\"attr\">element</span>: element,</div><div class=\"line\">      <span class=\"attr\">priority</span>: priority</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.isEmpty()) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.arr.push(ele);</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">let</span> added = <span class=\"literal\">false</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.arr) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(priority &lt; <span class=\"keyword\">this</span>.arr[i].priority) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.arr.splice(i, <span class=\"number\">0</span>, ele);</div><div class=\"line\">        added = <span class=\"literal\">true</span>;</div><div class=\"line\">        <span class=\"keyword\">break</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(!added) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.arr.push(ele);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  print() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.arr.map(<span class=\"function\">(<span class=\"params\">item</span>) =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> item.element;</div><div class=\"line\">    &#125;).join(<span class=\"string\">','</span>));</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> priorityQueue = <span class=\"keyword\">new</span> PriorityQueue();</div><div class=\"line\">priorityQueue.enqueue(<span class=\"string\">'john'</span>, <span class=\"number\">2</span>);</div><div class=\"line\">priorityQueue.enqueue(<span class=\"string\">'jack'</span>, <span class=\"number\">1</span>);</div><div class=\"line\">priorityQueue.enqueue(<span class=\"string\">'mark'</span>, <span class=\"number\">3</span>);</div><div class=\"line\">priorityQueue.enqueue(<span class=\"string\">'camila'</span>, <span class=\"number\">1</span>); </div><div class=\"line\">priorityQueue.print();  <span class=\"comment\">// jack,camila,john,mark</span></div></pre></td></tr></table></figure>\n<h4 id=\"循环队列——击鼓传花\"><a href=\"#循环队列——击鼓传花\" class=\"headerlink\" title=\"循环队列——击鼓传花\"></a>循环队列——击鼓传花</h4><p>假设有一圈小孩围着坐，将一朵花交给队首的小孩，小孩依次将花传给下一个小孩，当传到队尾的时候，再将花传给队首的小孩，也就是队列首尾相连，形成了一个循环队列。</p>\n<p>在“击鼓传花”游戏中，给定一个数字，当传递次数达到这个次数时，淘汰掉此时拿花的小孩，再进行下一轮，直到只有一个小孩（胜者）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hotPotato</span>(<span class=\"params\">nameList, num</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> queue = <span class=\"keyword\">new</span> Queue();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 小孩入列</span></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">of</span> nameList) &#123;</div><div class=\"line\">    queue.enqueue(name);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">while</span>(queue.size() &gt; <span class=\"number\">1</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</div><div class=\"line\">      <span class=\"comment\">// 将队首的小孩放到队尾</span></div><div class=\"line\">      queue.enqueue(queue.dequeue());</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 淘汰</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(queue.dequeue() + <span class=\"string\">' 被淘汰了。'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> queue.dequeue();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> nameList = [<span class=\"string\">'John'</span>, <span class=\"string\">'Jack'</span>, <span class=\"string\">'Camila'</span>, <span class=\"string\">'Ingrid'</span>, <span class=\"string\">'Carl'</span>];</div><div class=\"line\"><span class=\"keyword\">let</span> winner = hotPotato(nameList, <span class=\"number\">7</span>);</div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Camila 被淘汰了。</div><div class=\"line\"> * Jack 被淘汰了。</div><div class=\"line\"> * Carl 被淘汰了。</div><div class=\"line\"> * Ingrid 被淘汰了。</div><div class=\"line\"> * winner: John</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'winner: '</span> + winner);</div></pre></td></tr></table></figure>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><p>链表存储有序的元素集合，但不同于数组，链表中的元素在内存中不是连续放置的，每个元素由一个存储元素本身的结点和一个指向下一个元素的引用组成。</p>\n<h3 id=\"API-2\"><a href=\"#API-2\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>append(element) 在尾部添加一个新元素</li>\n<li>insert(position, element) 在指定位置插入一个新元素</li>\n<li>remove(element) 从链表中移除一个元素</li>\n<li>indexOf(element) 返回元素在链表中的索引，如果没有返回 -1</li>\n<li>removeAt(position) 从特定位置移除一个元素</li>\n<li>isEmpty() 返回链表是否为空</li>\n<li>size() 链表中元素的个数</li>\n<li>toString() 输出所有元素的值</li>\n</ul>\n<h3 id=\"实现-2\"><a href=\"#实现-2\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* 结点类 */</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(element, next = null) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.element = element;</div><div class=\"line\">    <span class=\"keyword\">this</span>.next = next;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 链表类 */</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkedList</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"comment\">// 链表头</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.head = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"comment\">// 链表长度</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.length = <span class=\"number\">0</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  append(element) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> Node(element);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.head == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.head = node;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> current = <span class=\"keyword\">this</span>.head;</div><div class=\"line\">      <span class=\"keyword\">while</span>(current.next != <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        current = current.next;</div><div class=\"line\">      &#125;</div><div class=\"line\">      current.next = node;      </div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">this</span>.length++;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  insert(position, element) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(position &lt; <span class=\"number\">0</span> || position &gt;= <span class=\"keyword\">this</span>.size()) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'illegal position'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> Node(element);</div><div class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"keyword\">this</span>.head, previous = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span>(position == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      node.next = <span class=\"keyword\">this</span>.head;</div><div class=\"line\">      <span class=\"keyword\">this</span>.head = node;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> index = <span class=\"number\">0</span>;</div><div class=\"line\">      <span class=\"keyword\">while</span>(index &lt; position) &#123;</div><div class=\"line\">        previous = current;</div><div class=\"line\">        current = current.next;</div><div class=\"line\">        index++;</div><div class=\"line\">      &#125;</div><div class=\"line\">      node.next = current;</div><div class=\"line\">      previous.next = node;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.length++;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  removeAt(position) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.isEmpty()) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'list is empty'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span>(position &lt; <span class=\"number\">0</span> || position &gt;= <span class=\"keyword\">this</span>.size()) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'illegal position'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"keyword\">this</span>.head, previous = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span>(position == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.head = current.next;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> index = <span class=\"number\">0</span>;</div><div class=\"line\">      <span class=\"keyword\">while</span>(index &lt; position) &#123;</div><div class=\"line\">        previous = current;</div><div class=\"line\">        current = current.next;</div><div class=\"line\">        index++;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      previous.next = current.next;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.length--;</div><div class=\"line\">    <span class=\"keyword\">return</span> current.element;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  remove(element) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> index = <span class=\"keyword\">this</span>.indexOf(element);</div><div class=\"line\">    <span class=\"keyword\">this</span>.removeAt(index);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  indexOf(element) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"keyword\">this</span>.head;</div><div class=\"line\">    <span class=\"keyword\">let</span> index = <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span>(current) &#123;</div><div class=\"line\">      index++;</div><div class=\"line\">      <span class=\"keyword\">if</span>(current.element == element) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">      &#125;</div><div class=\"line\">      current = current.next;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  isEmpty() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.size() == <span class=\"number\">0</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  size() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.length;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"string\">''</span>;</div><div class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"keyword\">this</span>.head;</div><div class=\"line\">    <span class=\"keyword\">while</span>(current) &#123;</div><div class=\"line\">      result += current.element;</div><div class=\"line\">      current = current.next;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h2><p>集合由一组无序且唯一的项组成。</p>\n<h3 id=\"API-3\"><a href=\"#API-3\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>add(value) 向集合添加一个元素</li>\n<li>remove(value) 从集合内移除一个元素 </li>\n<li>has(value) 元素是否在集合中</li>\n<li>clear() 清空集合</li>\n<li>size() 返回集合所包含的元素数量</li>\n<li>values() 返回包含集合中所有值的数组</li>\n</ul>\n<h3 id=\"实现-3\"><a href=\"#实现-3\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Set</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.items = &#123;&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  has(value) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> value <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.items;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  add(value) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>.has(value)) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.items[value] = value;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  remove(value) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.has(value)) &#123;</div><div class=\"line\">      <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>.items[value];</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  clear() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.items = &#123;&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  size() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(<span class=\"keyword\">this</span>.items).length;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  values() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(<span class=\"keyword\">this</span>.items);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"集合操作\"><a href=\"#集合操作\" class=\"headerlink\" title=\"集合操作\"></a>集合操作</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Set</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.items = &#123;&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</span></div><div class=\"line\">   * 并集</div><div class=\"line\">   */</div><div class=\"line\">  union(otherSet) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> union = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> item <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.items) &#123;</div><div class=\"line\">      union.add(item);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">let</span> values = otherSet.values();</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> value <span class=\"keyword\">of</span> values) &#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(value);</div><div class=\"line\">      union.add(value);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> union;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</span></div><div class=\"line\">   * 交集</div><div class=\"line\">   */</div><div class=\"line\">  intersection(otherSet) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> intersection = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> item <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.items) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(otherSet.has(item)) &#123;</div><div class=\"line\">        intersection.add(item);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> intersection;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</span></div><div class=\"line\">   * 差集</div><div class=\"line\">   */</div><div class=\"line\">  difference(otherSet) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> difference = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> item <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.items) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(!otherSet.has(item)) &#123;</div><div class=\"line\">        difference.add(item);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> difference;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</span></div><div class=\"line\">   * 当前集合是否为给定集合的子集</div><div class=\"line\">   */</div><div class=\"line\">  subset(otherSet) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.size() &gt; otherSet.size()) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> item <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.items) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(!otherSet.has(item)) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","excerpt":"<p>通过 Javascript 实现各种基本数据结构。包括栈、队列、链表、集合等</p>","more":"<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><p>栈算是相对来说最简单的数据结构了，遵循后进先出原则，可以通过维护一个数组来实现一个栈类。</p>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>push(ele1, [ele2, …]) 添加一个或多个元素到栈顶</li>\n<li>pop() 弹出栈顶元素</li>\n<li>peek() 返回栈顶元素，但不弹出它</li>\n<li>isEmpty() 如果栈为空，则返回 true，否则返回 false</li>\n<li>clear() 清空栈</li>\n<li>size() 返回栈中元素个数</li>\n</ul>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr = [];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">   * 出栈</div><div class=\"line\">   * @return 栈顶元素</div><div class=\"line\">   */</span></div><div class=\"line\">  pop() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.isEmpty()) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'stack underflow error'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr.pop();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">   * 入栈</div><div class=\"line\">   * @params  新元素</div><div class=\"line\">   */</span></div><div class=\"line\">  push() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> args = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span>(args.length == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'缺少参数'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> ele <span class=\"keyword\">of</span> args) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.arr.push(ele);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">   * 返回栈顶元素但不出栈</div><div class=\"line\">   * @return 栈顶元素</div><div class=\"line\">   */</span></div><div class=\"line\">  peek() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.isEmpty) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'该栈为空栈'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr[<span class=\"keyword\">this</span>.arr.length - <span class=\"number\">1</span>];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">   * 是否为空栈</div><div class=\"line\">   * @return boolean 是否为空栈</div><div class=\"line\">   */</span></div><div class=\"line\">  isEmpty() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.size() == <span class=\"number\">0</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">   * 栈的大小</div><div class=\"line\">   * @return number 栈的大小</div><div class=\"line\">   */</span></div><div class=\"line\">  size() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr.length;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">   * 清空栈</div><div class=\"line\">   */</span></div><div class=\"line\">  clear() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr = [];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">   * 打印栈中元素</div><div class=\"line\">   * @return string 栈中所有元素</div><div class=\"line\">   */</span></div><div class=\"line\">  print() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.arr.toString());</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><h4 id=\"十进制转其他进制\"><a href=\"#十进制转其他进制\" class=\"headerlink\" title=\"十进制转其他进制\"></a>十进制转其他进制</h4><p>我们可以使用栈来解决进制转换的问题，从十进制转指定的进制实际上是让十进制数除以进制的基数，再将得到的结果继续作被除数，一直到商为 0 为止。将每次的余数压栈，最后让栈依次弹出，连接成的字符串即为转换后的数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseConverter</span>(<span class=\"params\">decNumber, base</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> stack = <span class=\"keyword\">new</span> Stack();</div><div class=\"line\">  <span class=\"keyword\">const</span> digits = <span class=\"string\">'0123456789ABCDEF'</span>;</div><div class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"string\">''</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">while</span>(decNumber &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> rem = <span class=\"built_in\">Math</span>.floor(decNumber % base);</div><div class=\"line\">    stack.push(digits[rem]);</div><div class=\"line\">    decNumber = <span class=\"built_in\">Math</span>.floor(decNumber / base);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">while</span>(!stack.isEmpty()) &#123;</div><div class=\"line\">    result += stack.pop();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(baseConverter(<span class=\"number\">100345</span>, <span class=\"number\">2</span>)); <span class=\"comment\">// 11000011111111001</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(baseConverter(<span class=\"number\">100345</span>, <span class=\"number\">8</span>));  <span class=\"comment\">// 303771</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(baseConverter(<span class=\"number\">100345</span>, <span class=\"number\">16</span>)); <span class=\"comment\">// 187F9</span></div></pre></td></tr></table></figure>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><p>队列和栈很类似，但遵循先进先出原则。</p>\n<h3 id=\"API-1\"><a href=\"#API-1\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>enqueue(ele1, [ele2, …]) 向队尾添加一个或多个元素</li>\n<li>dequeue() 移除队首元素，并返回</li>\n<li>front() 返回队首元素，但不移除它</li>\n<li>isEmpty() 队列为空时，返回 true，否则返回 false</li>\n<li>size() 返回队列中元素个数</li>\n<li>clear() 清空队列</li>\n<li>print() 打印队列</li>\n</ul>\n<h3 id=\"实现-1\"><a href=\"#实现-1\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Queue</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr = [];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  enqueue() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> args = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span>(args.length == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'缺少参数'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> ele <span class=\"keyword\">of</span> args) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.arr.push(ele);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  dequeue() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.isEmpty()) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'queue is empty'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr.shift();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  front() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.isEmpty()) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'queue is empty'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr[<span class=\"number\">0</span>];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  isEmpty() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.size() == <span class=\"number\">0</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  size() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr.length;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  clear() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr = [];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  print() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.arr.toString());</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"应用-1\"><a href=\"#应用-1\" class=\"headerlink\" title=\"应用\"></a>应用</h3><h4 id=\"优先队列\"><a href=\"#优先队列\" class=\"headerlink\" title=\"优先队列\"></a>优先队列</h4><p>优先队列中的每个元素都有一个优先级，优先级的数字越小，优先级越高。为了使优先级越高的元素越先出队列，添加该元素的时候，会根据它的优先级将它插入到合适的位置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PriorityQueue</span> <span class=\"keyword\">extends</span> <span class=\"title\">Queue</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(...args) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(...args);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  enqueue(element, priority) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> ele = &#123;</div><div class=\"line\">      <span class=\"attr\">element</span>: element,</div><div class=\"line\">      <span class=\"attr\">priority</span>: priority</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.isEmpty()) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.arr.push(ele);</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">let</span> added = <span class=\"literal\">false</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.arr) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(priority &lt; <span class=\"keyword\">this</span>.arr[i].priority) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.arr.splice(i, <span class=\"number\">0</span>, ele);</div><div class=\"line\">        added = <span class=\"literal\">true</span>;</div><div class=\"line\">        <span class=\"keyword\">break</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(!added) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.arr.push(ele);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  print() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.arr.map(<span class=\"function\">(<span class=\"params\">item</span>) =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> item.element;</div><div class=\"line\">    &#125;).join(<span class=\"string\">','</span>));</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> priorityQueue = <span class=\"keyword\">new</span> PriorityQueue();</div><div class=\"line\">priorityQueue.enqueue(<span class=\"string\">'john'</span>, <span class=\"number\">2</span>);</div><div class=\"line\">priorityQueue.enqueue(<span class=\"string\">'jack'</span>, <span class=\"number\">1</span>);</div><div class=\"line\">priorityQueue.enqueue(<span class=\"string\">'mark'</span>, <span class=\"number\">3</span>);</div><div class=\"line\">priorityQueue.enqueue(<span class=\"string\">'camila'</span>, <span class=\"number\">1</span>); </div><div class=\"line\">priorityQueue.print();  <span class=\"comment\">// jack,camila,john,mark</span></div></pre></td></tr></table></figure>\n<h4 id=\"循环队列——击鼓传花\"><a href=\"#循环队列——击鼓传花\" class=\"headerlink\" title=\"循环队列——击鼓传花\"></a>循环队列——击鼓传花</h4><p>假设有一圈小孩围着坐，将一朵花交给队首的小孩，小孩依次将花传给下一个小孩，当传到队尾的时候，再将花传给队首的小孩，也就是队列首尾相连，形成了一个循环队列。</p>\n<p>在“击鼓传花”游戏中，给定一个数字，当传递次数达到这个次数时，淘汰掉此时拿花的小孩，再进行下一轮，直到只有一个小孩（胜者）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hotPotato</span>(<span class=\"params\">nameList, num</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> queue = <span class=\"keyword\">new</span> Queue();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 小孩入列</span></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">of</span> nameList) &#123;</div><div class=\"line\">    queue.enqueue(name);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">while</span>(queue.size() &gt; <span class=\"number\">1</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</div><div class=\"line\">      <span class=\"comment\">// 将队首的小孩放到队尾</span></div><div class=\"line\">      queue.enqueue(queue.dequeue());</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 淘汰</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(queue.dequeue() + <span class=\"string\">' 被淘汰了。'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> queue.dequeue();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> nameList = [<span class=\"string\">'John'</span>, <span class=\"string\">'Jack'</span>, <span class=\"string\">'Camila'</span>, <span class=\"string\">'Ingrid'</span>, <span class=\"string\">'Carl'</span>];</div><div class=\"line\"><span class=\"keyword\">let</span> winner = hotPotato(nameList, <span class=\"number\">7</span>);</div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Camila 被淘汰了。</div><div class=\"line\"> * Jack 被淘汰了。</div><div class=\"line\"> * Carl 被淘汰了。</div><div class=\"line\"> * Ingrid 被淘汰了。</div><div class=\"line\"> * winner: John</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'winner: '</span> + winner);</div></pre></td></tr></table></figure>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><p>链表存储有序的元素集合，但不同于数组，链表中的元素在内存中不是连续放置的，每个元素由一个存储元素本身的结点和一个指向下一个元素的引用组成。</p>\n<h3 id=\"API-2\"><a href=\"#API-2\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>append(element) 在尾部添加一个新元素</li>\n<li>insert(position, element) 在指定位置插入一个新元素</li>\n<li>remove(element) 从链表中移除一个元素</li>\n<li>indexOf(element) 返回元素在链表中的索引，如果没有返回 -1</li>\n<li>removeAt(position) 从特定位置移除一个元素</li>\n<li>isEmpty() 返回链表是否为空</li>\n<li>size() 链表中元素的个数</li>\n<li>toString() 输出所有元素的值</li>\n</ul>\n<h3 id=\"实现-2\"><a href=\"#实现-2\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* 结点类 */</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(element, next = null) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.element = element;</div><div class=\"line\">    <span class=\"keyword\">this</span>.next = next;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 链表类 */</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkedList</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"comment\">// 链表头</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.head = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"comment\">// 链表长度</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.length = <span class=\"number\">0</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  append(element) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> Node(element);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.head == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.head = node;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> current = <span class=\"keyword\">this</span>.head;</div><div class=\"line\">      <span class=\"keyword\">while</span>(current.next != <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        current = current.next;</div><div class=\"line\">      &#125;</div><div class=\"line\">      current.next = node;      </div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">this</span>.length++;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  insert(position, element) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(position &lt; <span class=\"number\">0</span> || position &gt;= <span class=\"keyword\">this</span>.size()) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'illegal position'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> Node(element);</div><div class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"keyword\">this</span>.head, previous = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span>(position == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      node.next = <span class=\"keyword\">this</span>.head;</div><div class=\"line\">      <span class=\"keyword\">this</span>.head = node;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> index = <span class=\"number\">0</span>;</div><div class=\"line\">      <span class=\"keyword\">while</span>(index &lt; position) &#123;</div><div class=\"line\">        previous = current;</div><div class=\"line\">        current = current.next;</div><div class=\"line\">        index++;</div><div class=\"line\">      &#125;</div><div class=\"line\">      node.next = current;</div><div class=\"line\">      previous.next = node;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.length++;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  removeAt(position) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.isEmpty()) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'list is empty'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span>(position &lt; <span class=\"number\">0</span> || position &gt;= <span class=\"keyword\">this</span>.size()) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'illegal position'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"keyword\">this</span>.head, previous = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span>(position == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.head = current.next;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> index = <span class=\"number\">0</span>;</div><div class=\"line\">      <span class=\"keyword\">while</span>(index &lt; position) &#123;</div><div class=\"line\">        previous = current;</div><div class=\"line\">        current = current.next;</div><div class=\"line\">        index++;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      previous.next = current.next;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.length--;</div><div class=\"line\">    <span class=\"keyword\">return</span> current.element;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  remove(element) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> index = <span class=\"keyword\">this</span>.indexOf(element);</div><div class=\"line\">    <span class=\"keyword\">this</span>.removeAt(index);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  indexOf(element) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"keyword\">this</span>.head;</div><div class=\"line\">    <span class=\"keyword\">let</span> index = <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span>(current) &#123;</div><div class=\"line\">      index++;</div><div class=\"line\">      <span class=\"keyword\">if</span>(current.element == element) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">      &#125;</div><div class=\"line\">      current = current.next;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  isEmpty() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.size() == <span class=\"number\">0</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  size() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.length;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"string\">''</span>;</div><div class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"keyword\">this</span>.head;</div><div class=\"line\">    <span class=\"keyword\">while</span>(current) &#123;</div><div class=\"line\">      result += current.element;</div><div class=\"line\">      current = current.next;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h2><p>集合由一组无序且唯一的项组成。</p>\n<h3 id=\"API-3\"><a href=\"#API-3\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>add(value) 向集合添加一个元素</li>\n<li>remove(value) 从集合内移除一个元素 </li>\n<li>has(value) 元素是否在集合中</li>\n<li>clear() 清空集合</li>\n<li>size() 返回集合所包含的元素数量</li>\n<li>values() 返回包含集合中所有值的数组</li>\n</ul>\n<h3 id=\"实现-3\"><a href=\"#实现-3\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Set</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.items = &#123;&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  has(value) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> value <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.items;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  add(value) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>.has(value)) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.items[value] = value;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  remove(value) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.has(value)) &#123;</div><div class=\"line\">      <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>.items[value];</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  clear() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.items = &#123;&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  size() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(<span class=\"keyword\">this</span>.items).length;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  values() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(<span class=\"keyword\">this</span>.items);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"集合操作\"><a href=\"#集合操作\" class=\"headerlink\" title=\"集合操作\"></a>集合操作</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Set</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.items = &#123;&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">   * 并集</div><div class=\"line\">   */</span></div><div class=\"line\">  union(otherSet) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> union = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> item <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.items) &#123;</div><div class=\"line\">      union.add(item);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">let</span> values = otherSet.values();</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> value <span class=\"keyword\">of</span> values) &#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(value);</div><div class=\"line\">      union.add(value);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> union;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">   * 交集</div><div class=\"line\">   */</span></div><div class=\"line\">  intersection(otherSet) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> intersection = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> item <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.items) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(otherSet.has(item)) &#123;</div><div class=\"line\">        intersection.add(item);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> intersection;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">   * 差集</div><div class=\"line\">   */</span></div><div class=\"line\">  difference(otherSet) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> difference = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> item <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.items) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(!otherSet.has(item)) &#123;</div><div class=\"line\">        difference.add(item);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> difference;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">   * 当前集合是否为给定集合的子集</div><div class=\"line\">   */</span></div><div class=\"line\">  subset(otherSet) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.size() &gt; otherSet.size()) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> item <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.items) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(!otherSet.has(item)) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"基本数据结构（二）","date":"2016-07-26T15:39:57.000Z","_content":"\n通过 Javascript 实现各种基本数据结构。包括字典、散列表、图等。\n\n<!-- more -->\n\n## 字典\n\n字典存储一个键值对，相当于封装了对对象的操作，比较简单，不展开说明。\n\n### API\n- keys() 以数组形式返回字典包含的所有键名\n- has(key) 返回字典是否包含键值\n- set(key, value) 存储一个键值对\n- remove(key) 根据键值删除对应的键值对\n- get(key) 返回指定键名对应的值\n- values() 以数组形式返回字典内所有值\n- size() 返回字典内键值对的数量\n\n### 实现\n\n```javascript\nclass Dictionary {\n  constructor() {\n    this.items = {};\n  }\n\n  keys() {\n    return Object.keys(this.items);\n  }\n\n  has(key) {\n    return key in this.items;\n  }\n\n  set(key, value) {\n    this.items[key] = value;\n  }\n\n  remove(key) {\n    if(this.has(key)) {\n      delete this.items[key];\n      return true;\n    }\n    return false;\n  }\n\n  get(key) {\n    return this.has(key) ? this.items[key] : undefined;\n  }\n\n  values() {\n    let result = [];\n    for(let key in this.items) {\n      if(this.has(key)) {\n        result.push(this.items[key]);\n      }\n    }\n    return result;\n  }\n\n  size() {\n    return this.keys().length;\n  }\n}\n```\n\n## 散列表\n\n散列表是普通数组的推广，它是实现字典操作的一种有效数据结构。\n\n### API\n- put(key, value) 向散列表添加一个项\n- remove(key) 根据键值从散列表中移除值\n- get(key) 返回根据键值检索到的特定的值\n\n### 散列函数\n\n将数据插入到散列表的时候，需要通过散列函数来计算出这个数据存放的位置，这样每次取数据的时候，只需要再次通过散列函数计算便能知道数据的位置了。\n\n一个表现良好的散列函数是由几个方面构成的：插入和检索元素的时间（即性能），还包括较低的冲突可能性。比如如下散列函数：\n\n```javascript\nfunction djb2HashCode(key) {\n  let hash = 5381;\n  for(let i = 0; i < key.length; i++) {\n    hash = hash * 33 + key.charCodeAt(i);\n  }\n  return hash % 1013;\n}\n```\n\n当 key 为 `Gandalf` 时，该函数返回 `798`，代表该数据将存在数组下标为 798 的位置。\n\n显然，`put`、`remove` 和 `get` 方法都是围绕这个值来工作的。\n\n```javascript\nclass HashTable {\n  constructor() {\n    this.arr = [];\n  }\n\n  put(key, value) {\n    const position = djb2HashCode(key);\n    this.arr[position] = value;\n  }\n\n  remove(key) {\n    const position = djb2HashCode(key);\n    this.arr[position] = undefined;\n  }\n\n  get(key) {\n    const position = djb2HashCode(key);\n    return this.arr[position];\n  }\n}\n```\n\n### 解决冲突\n\n显然，这种方式存在一个致命的弱点：当两个 `key` 值计算出来的哈希值是相同的时候，两个元素将被插入同一个地方，后插入的元素将覆盖掉先插入的元素，这称为发生了冲突。\n\n处理冲突有几种方法：分离链接、线性探查和双散列法。\n\n#### 1. 分离链接\n\n分离链接在散列表的每个位置创建一个链表，存在相同位置的元素时，元素将被添加到链表的末尾。\n\n```javascript\nclass ValuePair {\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n  }\n\n  toString() {\n    return this.key + ',' + this.value;\n  }\n}\n\nclass HashTable {\n  constructor() {\n    this.arr = [];\n  }\n\n  put(key, value) {\n    const position = djb2HashCode(key);\n    let list = this.arr[position];\n    if(this.arr[position] == undefined) {\n      this.arr[position] = new LinkedList();\n    }\n    this.arr[position].append(new ValuePair(key, value));\n  }\n\n  remove(key) {\n    const position = djb2HashCode(key);\n    const list = this.arr[position];\n\n    if(list != undefined) {\n      let current = list.getHead();\n\n      while(current.next) {\n        if(current.element.key == key) {\n          list.remove(current.element);\n          if(list.isEmpty()) {\n            this.arr[position] = undefined;\n          }\n          return true;\n        }\n        current = current.next;\n      }\n\n      if(current.element.key == key) {\n        list.remove(current.element);\n        if(list.isEmpty()) {\n          this.arr[position] = undefined;\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n  get(key) {\n    const position = djb2HashCode(key);\n    const list = this.arr[position];\n\n    if(list != undefined) {\n      let current = list.getHead();\n      while(current.next) {\n        if(current.element.key == key) {\n          return current.element.value;\n        }\n        current = current.next;\n      }\n\n      if(current.element.key == key) {\n        return current.element.value;\n      }\n    }\n    return undefined;\n  }\n}\n```\n\n#### 2. 线性探查\n\n线性探查指当插入新元素时，如果索引为 `index` 的位置已经被占据了，就尝试 `index + 1` 的位置，如果 `index + 1` 的位置也被占据了，就尝试 `index + 2` 的位置，以此类推。\n\n```javascript\nclass HashTable {\n  constructor() {\n    this.arr = [];\n  }\n\n  put(key, value) {\n    const position = djb2HashCode(key);\n\n    if(this.arr[position] == undefined) {\n      this.arr[position] = new ValuePair(key, value);\n    } else {\n      let index = position + 1;\n      while(this.arr[index] != undefined) {\n        index++;\n      }\n      this.arr[index] = new ValuePair(key, value);\n    }\n  }\n\n  get(key) {\n    const position = djb2HashCode(key);\n\n    if(this.arr[position] != undefined) {\n      let index = position;\n      while(this.arr[index] != undefined) {\n        if(this.arr[index].key == key) {\n          return this.arr[index].value;\n        }\n        index++;\n      }\n    }\n\n    return undefined;\n  }\n\n  remove(key) {\n    const position = djb2HashCode(key);\n\n    if(this.arr[position] != undefined) {\n      let index = position;\n      while(this.arr[index] != undefined) {\n        if(this.arr[index].key == key) {\n          this.arr[index] = undefined;\n          // 重新调整散列表\n          for(let i = index; i < this.arr.length; i++) {\n            this.arr[i] = this.arr[i + 1];\n          }\n          this.arr.length--;\n          return true;\n        }\n        index++;\n      }\n    }\n\n    return false;\n  }\n}\n```\n\n使用线性探查需要注意的是：\n- 在一些语言中，需要定义数组的大小，当为占据的数据寻找下一个可用位置的时候，数组的可用位置可能会被用完，这就需要根据一些策略改变散列表的大小。但是 Javascript 里面不用担心这个问题，因为数组长度会根据需要自动改变大小。\n- 删除一个\n数据的时候，需要重新调整这个位置以及之后的数据，因为删除会使这个位置为空，造成之后查询这个位置时被认为没有这个数据。\n\n## 图\n\n### 基本概念\n- 相邻顶点：由一条边连接在一起的顶点\n- 度：一个顶点的度是其相邻顶点的数量\n- 路径：路径是顶点 v1, v2, ..., vk 的一个连续序列，其中 vi 和 v(i+1) 是相邻的\n- 简单路径：简单路径是不包含重复顶点的路径\n\n### 图的表示\n\n一个图 G=(V, E) 由以下元素组成：\n\n- V: 一组顶点\n- E: 一组边，连接 V 中的顶点\n\n![图](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/01.png)\n\n#### 邻接矩阵\n\n在矩阵中，索引为 i 的结点和索引为 j 的结点相邻，则 `arr[i][j] === 1`，否则 `arr[i][j] !== 1`。\n\n![邻接矩阵](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/02.png)\n\n在无向图中，矩阵是一个对称矩阵。\n\n#### 邻接表\n\n邻接表由图中每个顶点和每个顶点的相邻顶点列表组成。\n\n![邻接表](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/03.png)\n\n#### 关联矩阵\n\n关联矩阵中，矩阵的行表示顶点，列表示边。\n\n![关联矩阵](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/04.png)\n\n### 实现\n\n以邻接表描述图实现如下：\n\n```javascript\nclass Graph {\n  constructor() {\n    // 顶点集合\n    this.vertics = [];\n    // 邻接表\n    this.adjList = new Dictionary();\n  }\n\n  addVertex(v) {\n    this.vertics.push(v);\n    this.adjList.set(v, []);\n  }\n\n  addEdge(v, w) {\n    this.adjList.get(v).push(w);\n    this.adjList.get(w).push(v);\n  }\n\n  toString() {\n    let result = '';\n    for(let vertex of this.vertics) {\n      result += vertex + ' =>';\n      let neighbors = this.adjList.get(vertex);\n      for(let neighbor of neighbors) {\n        result += ' ' + neighbor;\n      }\n      result += '\\n';\n    }\n    return result;\n  }\n}\n```\n\n### 图的遍历\n\n图的遍历算法的思想是必须追踪每一个第一次访问的结点，并且追踪有哪些结点还没有被完全探索。对于图的两种遍历算法，都需要明确指定第一个被访问的结点。\n\n我们用三种颜色来标注顶点，用来表示它们的状态：\n\n- 白色：表示该顶点还没有被访问过\n- 灰色：表示该顶点被访问过，但没有被探索过\n- 黑色：表示该顶点被访问且已经被探索\n\n#### 广度优先搜索(Breadth-First Search, BFS)\n\n![广度优先搜索](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/05.png)\n\n广度优先搜素先宽后深访问顶点，从顶点 v 开始的 BFS 算法步骤如下：\n\n1. 创建一个队列 Q\n2. 将 v 标注为灰色，并将 v 入队列\n3. 如果 Q 非空，则运行以下步骤：\n   a) 队首 u 出队列\n   b) 将 u 标记为灰色\n   c) 将 u 所有白色相邻顶点入队列\n   d) 将 u 标注为黑色\n\n```javascript\nclass Graph {\n  //...\n\n  initColor() {\n    const colors = [];\n    for(let vertex of this.vertics) {\n      colors[vertex] = 'white';\n    }\n    return colors;\n  }\n\n  bfs(v, callback) {\n    const colors = this.initColor();\n    const queue = new Queue();\n\n    queue.enqueue(v);\n    colors[v] = 'gray';\n\n    while(!queue.isEmpty()) {\n      let curVertex = queue.dequeue();\n      let neighbors = this.adjList.get(curVertex);\n      // 遍历当前结点的相邻结点\n      for(let neighbor of neighbors) {\n        // 将未访问的结点插入队列并标记为未探索\n        if(colors[neighbor] == 'white') {\n          queue.enqueue(neighbor);\n          colors[neighbor] = 'gray';\n        }\n      }\n      // 当前结点已经探索完\n      colors[curVertex] = 'black';\n      callback && callback(curVertex);\n    }\n  }\n}\n```\n\n\n#### 深度优先搜索(Depth-First Search, DFS)\n\n![深度优先搜索](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/06.png)\n\n广度优先搜素先深后宽访问顶点，从顶点 v 开始的 DFS 算法步骤如下：\n\n1. 将 v 标注为灰色\n2. 对 v 的所有白色相邻顶点 w ：\n   a) 访问 w\n3. 将 v 标记为黑色\n\n```javascript\nclass Graph {\n  //...\n\n  initColor() {\n    const colors = [];\n    for(let vertex of this.vertics) {\n      colors[vertex] = 'white';\n    }\n    return colors;\n  }\n\n  dfs(v, callback) {\n    const colors = this.initColor();\n\n    var dfsVisit = (v) => {\n      // 访问当前结点\n      colors[v] = 'gray';\n\n      callback && callback(v);\n\n      let neighbors = this.adjList.get(v);\n      // 探索当前结点\n      for(let neighbor of neighbors) {\n        if(colors[neighbor] == 'white') {\n          dfsVisit(neighbor);\n        }\n      }\n      colors[v] = 'black';\n    }\n\n    dfsVisit(v);\n  }\n}\n```\n\n#### 结果\n\n```javascript\nvar graph = new Graph();\nvar vertics = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'];\nfor(let vertex of vertics) {\n  graph.addVertex(vertex);\n}\n\ngraph.addEdge('A', 'B');\ngraph.addEdge('A', 'C');\ngraph.addEdge('A', 'D');\ngraph.addEdge('C', 'D');\ngraph.addEdge('C', 'G');\ngraph.addEdge('D', 'G');\ngraph.addEdge('D', 'H');\ngraph.addEdge('B', 'E');\ngraph.addEdge('B', 'F');\ngraph.addEdge('E', 'I');\n\n/**\n * 广度优先\n * A\n * B\n * C\n * D\n * E\n * F\n * G\n * H\n * I\n */\ngraph.bfs('A', v => console.log(v))\n\n/**\n * 深度优先\n * A\n * B\n * E\n * I\n * F\n * C\n * D\n * H\n * G\n */\ngraph.dfs('A', v => console.log(v))\n```","source":"_posts/data-structures-2.md","raw":"---\ntitle: 基本数据结构（二）\ndate: 2016-07-26 23:39:57\ntags: [数据结构]\n---\n\n通过 Javascript 实现各种基本数据结构。包括字典、散列表、图等。\n\n<!-- more -->\n\n## 字典\n\n字典存储一个键值对，相当于封装了对对象的操作，比较简单，不展开说明。\n\n### API\n- keys() 以数组形式返回字典包含的所有键名\n- has(key) 返回字典是否包含键值\n- set(key, value) 存储一个键值对\n- remove(key) 根据键值删除对应的键值对\n- get(key) 返回指定键名对应的值\n- values() 以数组形式返回字典内所有值\n- size() 返回字典内键值对的数量\n\n### 实现\n\n```javascript\nclass Dictionary {\n  constructor() {\n    this.items = {};\n  }\n\n  keys() {\n    return Object.keys(this.items);\n  }\n\n  has(key) {\n    return key in this.items;\n  }\n\n  set(key, value) {\n    this.items[key] = value;\n  }\n\n  remove(key) {\n    if(this.has(key)) {\n      delete this.items[key];\n      return true;\n    }\n    return false;\n  }\n\n  get(key) {\n    return this.has(key) ? this.items[key] : undefined;\n  }\n\n  values() {\n    let result = [];\n    for(let key in this.items) {\n      if(this.has(key)) {\n        result.push(this.items[key]);\n      }\n    }\n    return result;\n  }\n\n  size() {\n    return this.keys().length;\n  }\n}\n```\n\n## 散列表\n\n散列表是普通数组的推广，它是实现字典操作的一种有效数据结构。\n\n### API\n- put(key, value) 向散列表添加一个项\n- remove(key) 根据键值从散列表中移除值\n- get(key) 返回根据键值检索到的特定的值\n\n### 散列函数\n\n将数据插入到散列表的时候，需要通过散列函数来计算出这个数据存放的位置，这样每次取数据的时候，只需要再次通过散列函数计算便能知道数据的位置了。\n\n一个表现良好的散列函数是由几个方面构成的：插入和检索元素的时间（即性能），还包括较低的冲突可能性。比如如下散列函数：\n\n```javascript\nfunction djb2HashCode(key) {\n  let hash = 5381;\n  for(let i = 0; i < key.length; i++) {\n    hash = hash * 33 + key.charCodeAt(i);\n  }\n  return hash % 1013;\n}\n```\n\n当 key 为 `Gandalf` 时，该函数返回 `798`，代表该数据将存在数组下标为 798 的位置。\n\n显然，`put`、`remove` 和 `get` 方法都是围绕这个值来工作的。\n\n```javascript\nclass HashTable {\n  constructor() {\n    this.arr = [];\n  }\n\n  put(key, value) {\n    const position = djb2HashCode(key);\n    this.arr[position] = value;\n  }\n\n  remove(key) {\n    const position = djb2HashCode(key);\n    this.arr[position] = undefined;\n  }\n\n  get(key) {\n    const position = djb2HashCode(key);\n    return this.arr[position];\n  }\n}\n```\n\n### 解决冲突\n\n显然，这种方式存在一个致命的弱点：当两个 `key` 值计算出来的哈希值是相同的时候，两个元素将被插入同一个地方，后插入的元素将覆盖掉先插入的元素，这称为发生了冲突。\n\n处理冲突有几种方法：分离链接、线性探查和双散列法。\n\n#### 1. 分离链接\n\n分离链接在散列表的每个位置创建一个链表，存在相同位置的元素时，元素将被添加到链表的末尾。\n\n```javascript\nclass ValuePair {\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n  }\n\n  toString() {\n    return this.key + ',' + this.value;\n  }\n}\n\nclass HashTable {\n  constructor() {\n    this.arr = [];\n  }\n\n  put(key, value) {\n    const position = djb2HashCode(key);\n    let list = this.arr[position];\n    if(this.arr[position] == undefined) {\n      this.arr[position] = new LinkedList();\n    }\n    this.arr[position].append(new ValuePair(key, value));\n  }\n\n  remove(key) {\n    const position = djb2HashCode(key);\n    const list = this.arr[position];\n\n    if(list != undefined) {\n      let current = list.getHead();\n\n      while(current.next) {\n        if(current.element.key == key) {\n          list.remove(current.element);\n          if(list.isEmpty()) {\n            this.arr[position] = undefined;\n          }\n          return true;\n        }\n        current = current.next;\n      }\n\n      if(current.element.key == key) {\n        list.remove(current.element);\n        if(list.isEmpty()) {\n          this.arr[position] = undefined;\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n  get(key) {\n    const position = djb2HashCode(key);\n    const list = this.arr[position];\n\n    if(list != undefined) {\n      let current = list.getHead();\n      while(current.next) {\n        if(current.element.key == key) {\n          return current.element.value;\n        }\n        current = current.next;\n      }\n\n      if(current.element.key == key) {\n        return current.element.value;\n      }\n    }\n    return undefined;\n  }\n}\n```\n\n#### 2. 线性探查\n\n线性探查指当插入新元素时，如果索引为 `index` 的位置已经被占据了，就尝试 `index + 1` 的位置，如果 `index + 1` 的位置也被占据了，就尝试 `index + 2` 的位置，以此类推。\n\n```javascript\nclass HashTable {\n  constructor() {\n    this.arr = [];\n  }\n\n  put(key, value) {\n    const position = djb2HashCode(key);\n\n    if(this.arr[position] == undefined) {\n      this.arr[position] = new ValuePair(key, value);\n    } else {\n      let index = position + 1;\n      while(this.arr[index] != undefined) {\n        index++;\n      }\n      this.arr[index] = new ValuePair(key, value);\n    }\n  }\n\n  get(key) {\n    const position = djb2HashCode(key);\n\n    if(this.arr[position] != undefined) {\n      let index = position;\n      while(this.arr[index] != undefined) {\n        if(this.arr[index].key == key) {\n          return this.arr[index].value;\n        }\n        index++;\n      }\n    }\n\n    return undefined;\n  }\n\n  remove(key) {\n    const position = djb2HashCode(key);\n\n    if(this.arr[position] != undefined) {\n      let index = position;\n      while(this.arr[index] != undefined) {\n        if(this.arr[index].key == key) {\n          this.arr[index] = undefined;\n          // 重新调整散列表\n          for(let i = index; i < this.arr.length; i++) {\n            this.arr[i] = this.arr[i + 1];\n          }\n          this.arr.length--;\n          return true;\n        }\n        index++;\n      }\n    }\n\n    return false;\n  }\n}\n```\n\n使用线性探查需要注意的是：\n- 在一些语言中，需要定义数组的大小，当为占据的数据寻找下一个可用位置的时候，数组的可用位置可能会被用完，这就需要根据一些策略改变散列表的大小。但是 Javascript 里面不用担心这个问题，因为数组长度会根据需要自动改变大小。\n- 删除一个\n数据的时候，需要重新调整这个位置以及之后的数据，因为删除会使这个位置为空，造成之后查询这个位置时被认为没有这个数据。\n\n## 图\n\n### 基本概念\n- 相邻顶点：由一条边连接在一起的顶点\n- 度：一个顶点的度是其相邻顶点的数量\n- 路径：路径是顶点 v1, v2, ..., vk 的一个连续序列，其中 vi 和 v(i+1) 是相邻的\n- 简单路径：简单路径是不包含重复顶点的路径\n\n### 图的表示\n\n一个图 G=(V, E) 由以下元素组成：\n\n- V: 一组顶点\n- E: 一组边，连接 V 中的顶点\n\n![图](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/01.png)\n\n#### 邻接矩阵\n\n在矩阵中，索引为 i 的结点和索引为 j 的结点相邻，则 `arr[i][j] === 1`，否则 `arr[i][j] !== 1`。\n\n![邻接矩阵](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/02.png)\n\n在无向图中，矩阵是一个对称矩阵。\n\n#### 邻接表\n\n邻接表由图中每个顶点和每个顶点的相邻顶点列表组成。\n\n![邻接表](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/03.png)\n\n#### 关联矩阵\n\n关联矩阵中，矩阵的行表示顶点，列表示边。\n\n![关联矩阵](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/04.png)\n\n### 实现\n\n以邻接表描述图实现如下：\n\n```javascript\nclass Graph {\n  constructor() {\n    // 顶点集合\n    this.vertics = [];\n    // 邻接表\n    this.adjList = new Dictionary();\n  }\n\n  addVertex(v) {\n    this.vertics.push(v);\n    this.adjList.set(v, []);\n  }\n\n  addEdge(v, w) {\n    this.adjList.get(v).push(w);\n    this.adjList.get(w).push(v);\n  }\n\n  toString() {\n    let result = '';\n    for(let vertex of this.vertics) {\n      result += vertex + ' =>';\n      let neighbors = this.adjList.get(vertex);\n      for(let neighbor of neighbors) {\n        result += ' ' + neighbor;\n      }\n      result += '\\n';\n    }\n    return result;\n  }\n}\n```\n\n### 图的遍历\n\n图的遍历算法的思想是必须追踪每一个第一次访问的结点，并且追踪有哪些结点还没有被完全探索。对于图的两种遍历算法，都需要明确指定第一个被访问的结点。\n\n我们用三种颜色来标注顶点，用来表示它们的状态：\n\n- 白色：表示该顶点还没有被访问过\n- 灰色：表示该顶点被访问过，但没有被探索过\n- 黑色：表示该顶点被访问且已经被探索\n\n#### 广度优先搜索(Breadth-First Search, BFS)\n\n![广度优先搜索](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/05.png)\n\n广度优先搜素先宽后深访问顶点，从顶点 v 开始的 BFS 算法步骤如下：\n\n1. 创建一个队列 Q\n2. 将 v 标注为灰色，并将 v 入队列\n3. 如果 Q 非空，则运行以下步骤：\n   a) 队首 u 出队列\n   b) 将 u 标记为灰色\n   c) 将 u 所有白色相邻顶点入队列\n   d) 将 u 标注为黑色\n\n```javascript\nclass Graph {\n  //...\n\n  initColor() {\n    const colors = [];\n    for(let vertex of this.vertics) {\n      colors[vertex] = 'white';\n    }\n    return colors;\n  }\n\n  bfs(v, callback) {\n    const colors = this.initColor();\n    const queue = new Queue();\n\n    queue.enqueue(v);\n    colors[v] = 'gray';\n\n    while(!queue.isEmpty()) {\n      let curVertex = queue.dequeue();\n      let neighbors = this.adjList.get(curVertex);\n      // 遍历当前结点的相邻结点\n      for(let neighbor of neighbors) {\n        // 将未访问的结点插入队列并标记为未探索\n        if(colors[neighbor] == 'white') {\n          queue.enqueue(neighbor);\n          colors[neighbor] = 'gray';\n        }\n      }\n      // 当前结点已经探索完\n      colors[curVertex] = 'black';\n      callback && callback(curVertex);\n    }\n  }\n}\n```\n\n\n#### 深度优先搜索(Depth-First Search, DFS)\n\n![深度优先搜索](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/06.png)\n\n广度优先搜素先深后宽访问顶点，从顶点 v 开始的 DFS 算法步骤如下：\n\n1. 将 v 标注为灰色\n2. 对 v 的所有白色相邻顶点 w ：\n   a) 访问 w\n3. 将 v 标记为黑色\n\n```javascript\nclass Graph {\n  //...\n\n  initColor() {\n    const colors = [];\n    for(let vertex of this.vertics) {\n      colors[vertex] = 'white';\n    }\n    return colors;\n  }\n\n  dfs(v, callback) {\n    const colors = this.initColor();\n\n    var dfsVisit = (v) => {\n      // 访问当前结点\n      colors[v] = 'gray';\n\n      callback && callback(v);\n\n      let neighbors = this.adjList.get(v);\n      // 探索当前结点\n      for(let neighbor of neighbors) {\n        if(colors[neighbor] == 'white') {\n          dfsVisit(neighbor);\n        }\n      }\n      colors[v] = 'black';\n    }\n\n    dfsVisit(v);\n  }\n}\n```\n\n#### 结果\n\n```javascript\nvar graph = new Graph();\nvar vertics = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'];\nfor(let vertex of vertics) {\n  graph.addVertex(vertex);\n}\n\ngraph.addEdge('A', 'B');\ngraph.addEdge('A', 'C');\ngraph.addEdge('A', 'D');\ngraph.addEdge('C', 'D');\ngraph.addEdge('C', 'G');\ngraph.addEdge('D', 'G');\ngraph.addEdge('D', 'H');\ngraph.addEdge('B', 'E');\ngraph.addEdge('B', 'F');\ngraph.addEdge('E', 'I');\n\n/**\n * 广度优先\n * A\n * B\n * C\n * D\n * E\n * F\n * G\n * H\n * I\n */\ngraph.bfs('A', v => console.log(v))\n\n/**\n * 深度优先\n * A\n * B\n * E\n * I\n * F\n * C\n * D\n * H\n * G\n */\ngraph.dfs('A', v => console.log(v))\n```","slug":"data-structures-2","published":1,"updated":"2017-03-17T13:40:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcvt0015n927f46l8fj7","content":"<p>通过 Javascript 实现各种基本数据结构。包括字典、散列表、图等。</p>\n<a id=\"more\"></a>\n<h2 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h2><p>字典存储一个键值对，相当于封装了对对象的操作，比较简单，不展开说明。</p>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>keys() 以数组形式返回字典包含的所有键名</li>\n<li>has(key) 返回字典是否包含键值</li>\n<li>set(key, value) 存储一个键值对</li>\n<li>remove(key) 根据键值删除对应的键值对</li>\n<li>get(key) 返回指定键名对应的值</li>\n<li>values() 以数组形式返回字典内所有值</li>\n<li>size() 返回字典内键值对的数量</li>\n</ul>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dictionary</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.items = &#123;&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  keys() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(<span class=\"keyword\">this</span>.items);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  has(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> key <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.items;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  set(key, value) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.items[key] = value;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  remove(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.has(key)) &#123;</div><div class=\"line\">      <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>.items[key];</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  get(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.has(key) ? <span class=\"keyword\">this</span>.items[key] : <span class=\"literal\">undefined</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  values() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> result = [];</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.items) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.has(key)) &#123;</div><div class=\"line\">        result.push(<span class=\"keyword\">this</span>.items[key]);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  size() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.keys().length;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h2><p>散列表是普通数组的推广，它是实现字典操作的一种有效数据结构。</p>\n<h3 id=\"API-1\"><a href=\"#API-1\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>put(key, value) 向散列表添加一个项</li>\n<li>remove(key) 根据键值从散列表中移除值</li>\n<li>get(key) 返回根据键值检索到的特定的值</li>\n</ul>\n<h3 id=\"散列函数\"><a href=\"#散列函数\" class=\"headerlink\" title=\"散列函数\"></a>散列函数</h3><p>将数据插入到散列表的时候，需要通过散列函数来计算出这个数据存放的位置，这样每次取数据的时候，只需要再次通过散列函数计算便能知道数据的位置了。</p>\n<p>一个表现良好的散列函数是由几个方面构成的：插入和检索元素的时间（即性能），还包括较低的冲突可能性。比如如下散列函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">djb2HashCode</span>(<span class=\"params\">key</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> hash = <span class=\"number\">5381</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; key.length; i++) &#123;</div><div class=\"line\">    hash = hash * <span class=\"number\">33</span> + key.charCodeAt(i);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> hash % <span class=\"number\">1013</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当 key 为 <code>Gandalf</code> 时，该函数返回 <code>798</code>，代表该数据将存在数组下标为 798 的位置。</p>\n<p>显然，<code>put</code>、<code>remove</code> 和 <code>get</code> 方法都是围绕这个值来工作的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTable</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr = [];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  put(key, value) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr[position] = value;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  remove(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr[position] = <span class=\"literal\">undefined</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  get(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr[position];</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"解决冲突\"><a href=\"#解决冲突\" class=\"headerlink\" title=\"解决冲突\"></a>解决冲突</h3><p>显然，这种方式存在一个致命的弱点：当两个 <code>key</code> 值计算出来的哈希值是相同的时候，两个元素将被插入同一个地方，后插入的元素将覆盖掉先插入的元素，这称为发生了冲突。</p>\n<p>处理冲突有几种方法：分离链接、线性探查和双散列法。</p>\n<h4 id=\"1-分离链接\"><a href=\"#1-分离链接\" class=\"headerlink\" title=\"1. 分离链接\"></a>1. 分离链接</h4><p>分离链接在散列表的每个位置创建一个链表，存在相同位置的元素时，元素将被添加到链表的末尾。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ValuePair</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(key, value) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.key = key;</div><div class=\"line\">    <span class=\"keyword\">this</span>.value = value;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.key + <span class=\"string\">','</span> + <span class=\"keyword\">this</span>.value;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTable</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr = [];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  put(key, value) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\">    <span class=\"keyword\">let</span> list = <span class=\"keyword\">this</span>.arr[position];</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.arr[position] == <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.arr[position] = <span class=\"keyword\">new</span> LinkedList();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr[position].append(<span class=\"keyword\">new</span> ValuePair(key, value));</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  remove(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\">    <span class=\"keyword\">const</span> list = <span class=\"keyword\">this</span>.arr[position];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(list != <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> current = list.getHead();</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">while</span>(current.next) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(current.element.key == key) &#123;</div><div class=\"line\">          list.remove(current.element);</div><div class=\"line\">          <span class=\"keyword\">if</span>(list.isEmpty()) &#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.arr[position] = <span class=\"literal\">undefined</span>;</div><div class=\"line\">          &#125;</div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        current = current.next;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span>(current.element.key == key) &#123;</div><div class=\"line\">        list.remove(current.element);</div><div class=\"line\">        <span class=\"keyword\">if</span>(list.isEmpty()) &#123;</div><div class=\"line\">          <span class=\"keyword\">this</span>.arr[position] = <span class=\"literal\">undefined</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  get(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\">    <span class=\"keyword\">const</span> list = <span class=\"keyword\">this</span>.arr[position];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(list != <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> current = list.getHead();</div><div class=\"line\">      <span class=\"keyword\">while</span>(current.next) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(current.element.key == key) &#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> current.element.value;</div><div class=\"line\">        &#125;</div><div class=\"line\">        current = current.next;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span>(current.element.key == key) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> current.element.value;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2-线性探查\"><a href=\"#2-线性探查\" class=\"headerlink\" title=\"2. 线性探查\"></a>2. 线性探查</h4><p>线性探查指当插入新元素时，如果索引为 <code>index</code> 的位置已经被占据了，就尝试 <code>index + 1</code> 的位置，如果 <code>index + 1</code> 的位置也被占据了，就尝试 <code>index + 2</code> 的位置，以此类推。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTable</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr = [];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  put(key, value) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.arr[position] == <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.arr[position] = <span class=\"keyword\">new</span> ValuePair(key, value);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> index = position + <span class=\"number\">1</span>;</div><div class=\"line\">      <span class=\"keyword\">while</span>(<span class=\"keyword\">this</span>.arr[index] != <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">        index++;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">this</span>.arr[index] = <span class=\"keyword\">new</span> ValuePair(key, value);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  get(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.arr[position] != <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> index = position;</div><div class=\"line\">      <span class=\"keyword\">while</span>(<span class=\"keyword\">this</span>.arr[index] != <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.arr[index].key == key) &#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr[index].value;</div><div class=\"line\">        &#125;</div><div class=\"line\">        index++;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  remove(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.arr[position] != <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> index = position;</div><div class=\"line\">      <span class=\"keyword\">while</span>(<span class=\"keyword\">this</span>.arr[index] != <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.arr[index].key == key) &#123;</div><div class=\"line\">          <span class=\"keyword\">this</span>.arr[index] = <span class=\"literal\">undefined</span>;</div><div class=\"line\">          <span class=\"comment\">// 重新调整散列表</span></div><div class=\"line\">          <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = index; i &lt; <span class=\"keyword\">this</span>.arr.length; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.arr[i] = <span class=\"keyword\">this</span>.arr[i + <span class=\"number\">1</span>];</div><div class=\"line\">          &#125;</div><div class=\"line\">          <span class=\"keyword\">this</span>.arr.length--;</div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        index++;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用线性探查需要注意的是：</p>\n<ul>\n<li>在一些语言中，需要定义数组的大小，当为占据的数据寻找下一个可用位置的时候，数组的可用位置可能会被用完，这就需要根据一些策略改变散列表的大小。但是 Javascript 里面不用担心这个问题，因为数组长度会根据需要自动改变大小。</li>\n<li>删除一个<br>数据的时候，需要重新调整这个位置以及之后的数据，因为删除会使这个位置为空，造成之后查询这个位置时被认为没有这个数据。</li>\n</ul>\n<h2 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul>\n<li>相邻顶点：由一条边连接在一起的顶点</li>\n<li>度：一个顶点的度是其相邻顶点的数量</li>\n<li>路径：路径是顶点 v1, v2, …, vk 的一个连续序列，其中 vi 和 v(i+1) 是相邻的</li>\n<li>简单路径：简单路径是不包含重复顶点的路径</li>\n</ul>\n<h3 id=\"图的表示\"><a href=\"#图的表示\" class=\"headerlink\" title=\"图的表示\"></a>图的表示</h3><p>一个图 G=(V, E) 由以下元素组成：</p>\n<ul>\n<li>V: 一组顶点</li>\n<li>E: 一组边，连接 V 中的顶点</li>\n</ul>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/01.png\" alt=\"图\"></p>\n<h4 id=\"邻接矩阵\"><a href=\"#邻接矩阵\" class=\"headerlink\" title=\"邻接矩阵\"></a>邻接矩阵</h4><p>在矩阵中，索引为 i 的结点和索引为 j 的结点相邻，则 <code>arr[i][j] === 1</code>，否则 <code>arr[i][j] !== 1</code>。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/02.png\" alt=\"邻接矩阵\"></p>\n<p>在无向图中，矩阵是一个对称矩阵。</p>\n<h4 id=\"邻接表\"><a href=\"#邻接表\" class=\"headerlink\" title=\"邻接表\"></a>邻接表</h4><p>邻接表由图中每个顶点和每个顶点的相邻顶点列表组成。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/03.png\" alt=\"邻接表\"></p>\n<h4 id=\"关联矩阵\"><a href=\"#关联矩阵\" class=\"headerlink\" title=\"关联矩阵\"></a>关联矩阵</h4><p>关联矩阵中，矩阵的行表示顶点，列表示边。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/04.png\" alt=\"关联矩阵\"></p>\n<h3 id=\"实现-1\"><a href=\"#实现-1\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>以邻接表描述图实现如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"comment\">// 顶点集合</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.vertics = [];</div><div class=\"line\">    <span class=\"comment\">// 邻接表</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.adjList = <span class=\"keyword\">new</span> Dictionary();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  addVertex(v) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.vertics.push(v);</div><div class=\"line\">    <span class=\"keyword\">this</span>.adjList.set(v, []);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  addEdge(v, w) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.adjList.get(v).push(w);</div><div class=\"line\">    <span class=\"keyword\">this</span>.adjList.get(w).push(v);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"string\">''</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> vertex <span class=\"keyword\">of</span> <span class=\"keyword\">this</span>.vertics) &#123;</div><div class=\"line\">      result += vertex + <span class=\"string\">' =&gt;'</span>;</div><div class=\"line\">      <span class=\"keyword\">let</span> neighbors = <span class=\"keyword\">this</span>.adjList.get(vertex);</div><div class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> neighbor <span class=\"keyword\">of</span> neighbors) &#123;</div><div class=\"line\">        result += <span class=\"string\">' '</span> + neighbor;</div><div class=\"line\">      &#125;</div><div class=\"line\">      result += <span class=\"string\">'\\n'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"图的遍历\"><a href=\"#图的遍历\" class=\"headerlink\" title=\"图的遍历\"></a>图的遍历</h3><p>图的遍历算法的思想是必须追踪每一个第一次访问的结点，并且追踪有哪些结点还没有被完全探索。对于图的两种遍历算法，都需要明确指定第一个被访问的结点。</p>\n<p>我们用三种颜色来标注顶点，用来表示它们的状态：</p>\n<ul>\n<li>白色：表示该顶点还没有被访问过</li>\n<li>灰色：表示该顶点被访问过，但没有被探索过</li>\n<li>黑色：表示该顶点被访问且已经被探索</li>\n</ul>\n<h4 id=\"广度优先搜索-Breadth-First-Search-BFS\"><a href=\"#广度优先搜索-Breadth-First-Search-BFS\" class=\"headerlink\" title=\"广度优先搜索(Breadth-First Search, BFS)\"></a>广度优先搜索(Breadth-First Search, BFS)</h4><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/05.png\" alt=\"广度优先搜索\"></p>\n<p>广度优先搜素先宽后深访问顶点，从顶点 v 开始的 BFS 算法步骤如下：</p>\n<ol>\n<li>创建一个队列 Q</li>\n<li>将 v 标注为灰色，并将 v 入队列</li>\n<li>如果 Q 非空，则运行以下步骤：<br>a) 队首 u 出队列<br>b) 将 u 标记为灰色<br>c) 将 u 所有白色相邻顶点入队列<br>d) 将 u 标注为黑色</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\"></div><div class=\"line\">  initColor() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> colors = [];</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> vertex <span class=\"keyword\">of</span> <span class=\"keyword\">this</span>.vertics) &#123;</div><div class=\"line\">      colors[vertex] = <span class=\"string\">'white'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> colors;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  bfs(v, callback) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> colors = <span class=\"keyword\">this</span>.initColor();</div><div class=\"line\">    <span class=\"keyword\">const</span> queue = <span class=\"keyword\">new</span> Queue();</div><div class=\"line\"></div><div class=\"line\">    queue.enqueue(v);</div><div class=\"line\">    colors[v] = <span class=\"string\">'gray'</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(!queue.isEmpty()) &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> curVertex = queue.dequeue();</div><div class=\"line\">      <span class=\"keyword\">let</span> neighbors = <span class=\"keyword\">this</span>.adjList.get(curVertex);</div><div class=\"line\">      <span class=\"comment\">// 遍历当前结点的相邻结点</span></div><div class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> neighbor <span class=\"keyword\">of</span> neighbors) &#123;</div><div class=\"line\">        <span class=\"comment\">// 将未访问的结点插入队列并标记为未探索</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(colors[neighbor] == <span class=\"string\">'white'</span>) &#123;</div><div class=\"line\">          queue.enqueue(neighbor);</div><div class=\"line\">          colors[neighbor] = <span class=\"string\">'gray'</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">// 当前结点已经探索完</span></div><div class=\"line\">      colors[curVertex] = <span class=\"string\">'black'</span>;</div><div class=\"line\">      callback &amp;&amp; callback(curVertex);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"深度优先搜索-Depth-First-Search-DFS\"><a href=\"#深度优先搜索-Depth-First-Search-DFS\" class=\"headerlink\" title=\"深度优先搜索(Depth-First Search, DFS)\"></a>深度优先搜索(Depth-First Search, DFS)</h4><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/06.png\" alt=\"深度优先搜索\"></p>\n<p>广度优先搜素先深后宽访问顶点，从顶点 v 开始的 DFS 算法步骤如下：</p>\n<ol>\n<li>将 v 标注为灰色</li>\n<li>对 v 的所有白色相邻顶点 w ：<br>a) 访问 w</li>\n<li>将 v 标记为黑色</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\"></div><div class=\"line\">  initColor() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> colors = [];</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> vertex <span class=\"keyword\">of</span> <span class=\"keyword\">this</span>.vertics) &#123;</div><div class=\"line\">      colors[vertex] = <span class=\"string\">'white'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> colors;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  dfs(v, callback) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> colors = <span class=\"keyword\">this</span>.initColor();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> dfsVisit = <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 访问当前结点</span></div><div class=\"line\">      colors[v] = <span class=\"string\">'gray'</span>;</div><div class=\"line\"></div><div class=\"line\">      callback &amp;&amp; callback(v);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">let</span> neighbors = <span class=\"keyword\">this</span>.adjList.get(v);</div><div class=\"line\">      <span class=\"comment\">// 探索当前结点</span></div><div class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> neighbor <span class=\"keyword\">of</span> neighbors) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(colors[neighbor] == <span class=\"string\">'white'</span>) &#123;</div><div class=\"line\">          dfsVisit(neighbor);</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      colors[v] = <span class=\"string\">'black'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    dfsVisit(v);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> graph = <span class=\"keyword\">new</span> Graph();</div><div class=\"line\"><span class=\"keyword\">var</span> vertics = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>, <span class=\"string\">'D'</span>, <span class=\"string\">'E'</span>, <span class=\"string\">'F'</span>, <span class=\"string\">'G'</span>, <span class=\"string\">'H'</span>, <span class=\"string\">'I'</span>];</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> vertex <span class=\"keyword\">of</span> vertics) &#123;</div><div class=\"line\">  graph.addVertex(vertex);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">graph.addEdge(<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'A'</span>, <span class=\"string\">'C'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'A'</span>, <span class=\"string\">'D'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'C'</span>, <span class=\"string\">'D'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'C'</span>, <span class=\"string\">'G'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'D'</span>, <span class=\"string\">'G'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'D'</span>, <span class=\"string\">'H'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'B'</span>, <span class=\"string\">'E'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'B'</span>, <span class=\"string\">'F'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'E'</span>, <span class=\"string\">'I'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 广度优先</div><div class=\"line\"> * A</div><div class=\"line\"> * B</div><div class=\"line\"> * C</div><div class=\"line\"> * D</div><div class=\"line\"> * E</div><div class=\"line\"> * F</div><div class=\"line\"> * G</div><div class=\"line\"> * H</div><div class=\"line\"> * I</div><div class=\"line\"> */</div><div class=\"line\">graph.bfs(<span class=\"string\">'A'</span>, v =&gt; <span class=\"built_in\">console</span>.log(v))</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 深度优先</div><div class=\"line\"> * A</div><div class=\"line\"> * B</div><div class=\"line\"> * E</div><div class=\"line\"> * I</div><div class=\"line\"> * F</div><div class=\"line\"> * C</div><div class=\"line\"> * D</div><div class=\"line\"> * H</div><div class=\"line\"> * G</div><div class=\"line\"> */</div><div class=\"line\">graph.dfs(<span class=\"string\">'A'</span>, v =&gt; <span class=\"built_in\">console</span>.log(v))</div></pre></td></tr></table></figure>","excerpt":"<p>通过 Javascript 实现各种基本数据结构。包括字典、散列表、图等。</p>","more":"<h2 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h2><p>字典存储一个键值对，相当于封装了对对象的操作，比较简单，不展开说明。</p>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>keys() 以数组形式返回字典包含的所有键名</li>\n<li>has(key) 返回字典是否包含键值</li>\n<li>set(key, value) 存储一个键值对</li>\n<li>remove(key) 根据键值删除对应的键值对</li>\n<li>get(key) 返回指定键名对应的值</li>\n<li>values() 以数组形式返回字典内所有值</li>\n<li>size() 返回字典内键值对的数量</li>\n</ul>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dictionary</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.items = &#123;&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  keys() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(<span class=\"keyword\">this</span>.items);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  has(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> key <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.items;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  set(key, value) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.items[key] = value;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  remove(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.has(key)) &#123;</div><div class=\"line\">      <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>.items[key];</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  get(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.has(key) ? <span class=\"keyword\">this</span>.items[key] : <span class=\"literal\">undefined</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  values() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> result = [];</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.items) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.has(key)) &#123;</div><div class=\"line\">        result.push(<span class=\"keyword\">this</span>.items[key]);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  size() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.keys().length;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h2><p>散列表是普通数组的推广，它是实现字典操作的一种有效数据结构。</p>\n<h3 id=\"API-1\"><a href=\"#API-1\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>put(key, value) 向散列表添加一个项</li>\n<li>remove(key) 根据键值从散列表中移除值</li>\n<li>get(key) 返回根据键值检索到的特定的值</li>\n</ul>\n<h3 id=\"散列函数\"><a href=\"#散列函数\" class=\"headerlink\" title=\"散列函数\"></a>散列函数</h3><p>将数据插入到散列表的时候，需要通过散列函数来计算出这个数据存放的位置，这样每次取数据的时候，只需要再次通过散列函数计算便能知道数据的位置了。</p>\n<p>一个表现良好的散列函数是由几个方面构成的：插入和检索元素的时间（即性能），还包括较低的冲突可能性。比如如下散列函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">djb2HashCode</span>(<span class=\"params\">key</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> hash = <span class=\"number\">5381</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; key.length; i++) &#123;</div><div class=\"line\">    hash = hash * <span class=\"number\">33</span> + key.charCodeAt(i);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> hash % <span class=\"number\">1013</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当 key 为 <code>Gandalf</code> 时，该函数返回 <code>798</code>，代表该数据将存在数组下标为 798 的位置。</p>\n<p>显然，<code>put</code>、<code>remove</code> 和 <code>get</code> 方法都是围绕这个值来工作的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTable</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr = [];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  put(key, value) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr[position] = value;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  remove(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr[position] = <span class=\"literal\">undefined</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  get(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr[position];</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"解决冲突\"><a href=\"#解决冲突\" class=\"headerlink\" title=\"解决冲突\"></a>解决冲突</h3><p>显然，这种方式存在一个致命的弱点：当两个 <code>key</code> 值计算出来的哈希值是相同的时候，两个元素将被插入同一个地方，后插入的元素将覆盖掉先插入的元素，这称为发生了冲突。</p>\n<p>处理冲突有几种方法：分离链接、线性探查和双散列法。</p>\n<h4 id=\"1-分离链接\"><a href=\"#1-分离链接\" class=\"headerlink\" title=\"1. 分离链接\"></a>1. 分离链接</h4><p>分离链接在散列表的每个位置创建一个链表，存在相同位置的元素时，元素将被添加到链表的末尾。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ValuePair</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(key, value) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.key = key;</div><div class=\"line\">    <span class=\"keyword\">this</span>.value = value;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.key + <span class=\"string\">','</span> + <span class=\"keyword\">this</span>.value;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTable</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr = [];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  put(key, value) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\">    <span class=\"keyword\">let</span> list = <span class=\"keyword\">this</span>.arr[position];</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.arr[position] == <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.arr[position] = <span class=\"keyword\">new</span> LinkedList();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr[position].append(<span class=\"keyword\">new</span> ValuePair(key, value));</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  remove(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\">    <span class=\"keyword\">const</span> list = <span class=\"keyword\">this</span>.arr[position];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(list != <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> current = list.getHead();</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">while</span>(current.next) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(current.element.key == key) &#123;</div><div class=\"line\">          list.remove(current.element);</div><div class=\"line\">          <span class=\"keyword\">if</span>(list.isEmpty()) &#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.arr[position] = <span class=\"literal\">undefined</span>;</div><div class=\"line\">          &#125;</div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        current = current.next;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span>(current.element.key == key) &#123;</div><div class=\"line\">        list.remove(current.element);</div><div class=\"line\">        <span class=\"keyword\">if</span>(list.isEmpty()) &#123;</div><div class=\"line\">          <span class=\"keyword\">this</span>.arr[position] = <span class=\"literal\">undefined</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  get(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\">    <span class=\"keyword\">const</span> list = <span class=\"keyword\">this</span>.arr[position];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(list != <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> current = list.getHead();</div><div class=\"line\">      <span class=\"keyword\">while</span>(current.next) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(current.element.key == key) &#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> current.element.value;</div><div class=\"line\">        &#125;</div><div class=\"line\">        current = current.next;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span>(current.element.key == key) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> current.element.value;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2-线性探查\"><a href=\"#2-线性探查\" class=\"headerlink\" title=\"2. 线性探查\"></a>2. 线性探查</h4><p>线性探查指当插入新元素时，如果索引为 <code>index</code> 的位置已经被占据了，就尝试 <code>index + 1</code> 的位置，如果 <code>index + 1</code> 的位置也被占据了，就尝试 <code>index + 2</code> 的位置，以此类推。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTable</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr = [];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  put(key, value) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.arr[position] == <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.arr[position] = <span class=\"keyword\">new</span> ValuePair(key, value);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> index = position + <span class=\"number\">1</span>;</div><div class=\"line\">      <span class=\"keyword\">while</span>(<span class=\"keyword\">this</span>.arr[index] != <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">        index++;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">this</span>.arr[index] = <span class=\"keyword\">new</span> ValuePair(key, value);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  get(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.arr[position] != <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> index = position;</div><div class=\"line\">      <span class=\"keyword\">while</span>(<span class=\"keyword\">this</span>.arr[index] != <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.arr[index].key == key) &#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr[index].value;</div><div class=\"line\">        &#125;</div><div class=\"line\">        index++;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  remove(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.arr[position] != <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> index = position;</div><div class=\"line\">      <span class=\"keyword\">while</span>(<span class=\"keyword\">this</span>.arr[index] != <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.arr[index].key == key) &#123;</div><div class=\"line\">          <span class=\"keyword\">this</span>.arr[index] = <span class=\"literal\">undefined</span>;</div><div class=\"line\">          <span class=\"comment\">// 重新调整散列表</span></div><div class=\"line\">          <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = index; i &lt; <span class=\"keyword\">this</span>.arr.length; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.arr[i] = <span class=\"keyword\">this</span>.arr[i + <span class=\"number\">1</span>];</div><div class=\"line\">          &#125;</div><div class=\"line\">          <span class=\"keyword\">this</span>.arr.length--;</div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        index++;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用线性探查需要注意的是：</p>\n<ul>\n<li>在一些语言中，需要定义数组的大小，当为占据的数据寻找下一个可用位置的时候，数组的可用位置可能会被用完，这就需要根据一些策略改变散列表的大小。但是 Javascript 里面不用担心这个问题，因为数组长度会根据需要自动改变大小。</li>\n<li>删除一个<br>数据的时候，需要重新调整这个位置以及之后的数据，因为删除会使这个位置为空，造成之后查询这个位置时被认为没有这个数据。</li>\n</ul>\n<h2 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul>\n<li>相邻顶点：由一条边连接在一起的顶点</li>\n<li>度：一个顶点的度是其相邻顶点的数量</li>\n<li>路径：路径是顶点 v1, v2, …, vk 的一个连续序列，其中 vi 和 v(i+1) 是相邻的</li>\n<li>简单路径：简单路径是不包含重复顶点的路径</li>\n</ul>\n<h3 id=\"图的表示\"><a href=\"#图的表示\" class=\"headerlink\" title=\"图的表示\"></a>图的表示</h3><p>一个图 G=(V, E) 由以下元素组成：</p>\n<ul>\n<li>V: 一组顶点</li>\n<li>E: 一组边，连接 V 中的顶点</li>\n</ul>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/01.png\" alt=\"图\"></p>\n<h4 id=\"邻接矩阵\"><a href=\"#邻接矩阵\" class=\"headerlink\" title=\"邻接矩阵\"></a>邻接矩阵</h4><p>在矩阵中，索引为 i 的结点和索引为 j 的结点相邻，则 <code>arr[i][j] === 1</code>，否则 <code>arr[i][j] !== 1</code>。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/02.png\" alt=\"邻接矩阵\"></p>\n<p>在无向图中，矩阵是一个对称矩阵。</p>\n<h4 id=\"邻接表\"><a href=\"#邻接表\" class=\"headerlink\" title=\"邻接表\"></a>邻接表</h4><p>邻接表由图中每个顶点和每个顶点的相邻顶点列表组成。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/03.png\" alt=\"邻接表\"></p>\n<h4 id=\"关联矩阵\"><a href=\"#关联矩阵\" class=\"headerlink\" title=\"关联矩阵\"></a>关联矩阵</h4><p>关联矩阵中，矩阵的行表示顶点，列表示边。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/04.png\" alt=\"关联矩阵\"></p>\n<h3 id=\"实现-1\"><a href=\"#实现-1\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>以邻接表描述图实现如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"comment\">// 顶点集合</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.vertics = [];</div><div class=\"line\">    <span class=\"comment\">// 邻接表</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.adjList = <span class=\"keyword\">new</span> Dictionary();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  addVertex(v) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.vertics.push(v);</div><div class=\"line\">    <span class=\"keyword\">this</span>.adjList.set(v, []);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  addEdge(v, w) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.adjList.get(v).push(w);</div><div class=\"line\">    <span class=\"keyword\">this</span>.adjList.get(w).push(v);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"string\">''</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> vertex <span class=\"keyword\">of</span> <span class=\"keyword\">this</span>.vertics) &#123;</div><div class=\"line\">      result += vertex + <span class=\"string\">' =&gt;'</span>;</div><div class=\"line\">      <span class=\"keyword\">let</span> neighbors = <span class=\"keyword\">this</span>.adjList.get(vertex);</div><div class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> neighbor <span class=\"keyword\">of</span> neighbors) &#123;</div><div class=\"line\">        result += <span class=\"string\">' '</span> + neighbor;</div><div class=\"line\">      &#125;</div><div class=\"line\">      result += <span class=\"string\">'\\n'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"图的遍历\"><a href=\"#图的遍历\" class=\"headerlink\" title=\"图的遍历\"></a>图的遍历</h3><p>图的遍历算法的思想是必须追踪每一个第一次访问的结点，并且追踪有哪些结点还没有被完全探索。对于图的两种遍历算法，都需要明确指定第一个被访问的结点。</p>\n<p>我们用三种颜色来标注顶点，用来表示它们的状态：</p>\n<ul>\n<li>白色：表示该顶点还没有被访问过</li>\n<li>灰色：表示该顶点被访问过，但没有被探索过</li>\n<li>黑色：表示该顶点被访问且已经被探索</li>\n</ul>\n<h4 id=\"广度优先搜索-Breadth-First-Search-BFS\"><a href=\"#广度优先搜索-Breadth-First-Search-BFS\" class=\"headerlink\" title=\"广度优先搜索(Breadth-First Search, BFS)\"></a>广度优先搜索(Breadth-First Search, BFS)</h4><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/05.png\" alt=\"广度优先搜索\"></p>\n<p>广度优先搜素先宽后深访问顶点，从顶点 v 开始的 BFS 算法步骤如下：</p>\n<ol>\n<li>创建一个队列 Q</li>\n<li>将 v 标注为灰色，并将 v 入队列</li>\n<li>如果 Q 非空，则运行以下步骤：<br>a) 队首 u 出队列<br>b) 将 u 标记为灰色<br>c) 将 u 所有白色相邻顶点入队列<br>d) 将 u 标注为黑色</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\"></div><div class=\"line\">  initColor() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> colors = [];</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> vertex <span class=\"keyword\">of</span> <span class=\"keyword\">this</span>.vertics) &#123;</div><div class=\"line\">      colors[vertex] = <span class=\"string\">'white'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> colors;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  bfs(v, callback) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> colors = <span class=\"keyword\">this</span>.initColor();</div><div class=\"line\">    <span class=\"keyword\">const</span> queue = <span class=\"keyword\">new</span> Queue();</div><div class=\"line\"></div><div class=\"line\">    queue.enqueue(v);</div><div class=\"line\">    colors[v] = <span class=\"string\">'gray'</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(!queue.isEmpty()) &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> curVertex = queue.dequeue();</div><div class=\"line\">      <span class=\"keyword\">let</span> neighbors = <span class=\"keyword\">this</span>.adjList.get(curVertex);</div><div class=\"line\">      <span class=\"comment\">// 遍历当前结点的相邻结点</span></div><div class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> neighbor <span class=\"keyword\">of</span> neighbors) &#123;</div><div class=\"line\">        <span class=\"comment\">// 将未访问的结点插入队列并标记为未探索</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(colors[neighbor] == <span class=\"string\">'white'</span>) &#123;</div><div class=\"line\">          queue.enqueue(neighbor);</div><div class=\"line\">          colors[neighbor] = <span class=\"string\">'gray'</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">// 当前结点已经探索完</span></div><div class=\"line\">      colors[curVertex] = <span class=\"string\">'black'</span>;</div><div class=\"line\">      callback &amp;&amp; callback(curVertex);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"深度优先搜索-Depth-First-Search-DFS\"><a href=\"#深度优先搜索-Depth-First-Search-DFS\" class=\"headerlink\" title=\"深度优先搜索(Depth-First Search, DFS)\"></a>深度优先搜索(Depth-First Search, DFS)</h4><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/06.png\" alt=\"深度优先搜索\"></p>\n<p>广度优先搜素先深后宽访问顶点，从顶点 v 开始的 DFS 算法步骤如下：</p>\n<ol>\n<li>将 v 标注为灰色</li>\n<li>对 v 的所有白色相邻顶点 w ：<br>a) 访问 w</li>\n<li>将 v 标记为黑色</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\"></div><div class=\"line\">  initColor() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> colors = [];</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> vertex <span class=\"keyword\">of</span> <span class=\"keyword\">this</span>.vertics) &#123;</div><div class=\"line\">      colors[vertex] = <span class=\"string\">'white'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> colors;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  dfs(v, callback) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> colors = <span class=\"keyword\">this</span>.initColor();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> dfsVisit = <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 访问当前结点</span></div><div class=\"line\">      colors[v] = <span class=\"string\">'gray'</span>;</div><div class=\"line\"></div><div class=\"line\">      callback &amp;&amp; callback(v);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">let</span> neighbors = <span class=\"keyword\">this</span>.adjList.get(v);</div><div class=\"line\">      <span class=\"comment\">// 探索当前结点</span></div><div class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> neighbor <span class=\"keyword\">of</span> neighbors) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(colors[neighbor] == <span class=\"string\">'white'</span>) &#123;</div><div class=\"line\">          dfsVisit(neighbor);</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      colors[v] = <span class=\"string\">'black'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    dfsVisit(v);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> graph = <span class=\"keyword\">new</span> Graph();</div><div class=\"line\"><span class=\"keyword\">var</span> vertics = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>, <span class=\"string\">'D'</span>, <span class=\"string\">'E'</span>, <span class=\"string\">'F'</span>, <span class=\"string\">'G'</span>, <span class=\"string\">'H'</span>, <span class=\"string\">'I'</span>];</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> vertex <span class=\"keyword\">of</span> vertics) &#123;</div><div class=\"line\">  graph.addVertex(vertex);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">graph.addEdge(<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'A'</span>, <span class=\"string\">'C'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'A'</span>, <span class=\"string\">'D'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'C'</span>, <span class=\"string\">'D'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'C'</span>, <span class=\"string\">'G'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'D'</span>, <span class=\"string\">'G'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'D'</span>, <span class=\"string\">'H'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'B'</span>, <span class=\"string\">'E'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'B'</span>, <span class=\"string\">'F'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'E'</span>, <span class=\"string\">'I'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 广度优先</div><div class=\"line\"> * A</div><div class=\"line\"> * B</div><div class=\"line\"> * C</div><div class=\"line\"> * D</div><div class=\"line\"> * E</div><div class=\"line\"> * F</div><div class=\"line\"> * G</div><div class=\"line\"> * H</div><div class=\"line\"> * I</div><div class=\"line\"> */</span></div><div class=\"line\">graph.bfs(<span class=\"string\">'A'</span>, v =&gt; <span class=\"built_in\">console</span>.log(v))</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 深度优先</div><div class=\"line\"> * A</div><div class=\"line\"> * B</div><div class=\"line\"> * E</div><div class=\"line\"> * I</div><div class=\"line\"> * F</div><div class=\"line\"> * C</div><div class=\"line\"> * D</div><div class=\"line\"> * H</div><div class=\"line\"> * G</div><div class=\"line\"> */</span></div><div class=\"line\">graph.dfs(<span class=\"string\">'A'</span>, v =&gt; <span class=\"built_in\">console</span>.log(v))</div></pre></td></tr></table></figure>"},{"title":"Diffie-Hellman 密钥交换","date":"2016-11-13T11:00:00.000Z","_content":"\n在对称密码中我们提到了，**密钥配送问题** 是对称密码中存在的一个问题。\n\n在上一篇里面我们已经介绍了可以解决这个问题的一个方式——使用公钥密码，这一篇我们讨论解决密钥配送问题的另一种方式：Diffie-Hellman 密钥交换\n\n<!-- more -->\n\n考虑这样一种情景，Alice 和 Bob 需要进行通信，为了保证消息的机密性，在通信之前，Alice 和 Bob 必须就某个密钥达成一致，但此时 Alice 和 Bob 之间的通信已经被 Eve 窃听了，任何在 Alice 和 Bob 之间的信息都会被 Eve 知道。那么 Alice 和 Bob 如何生成共享密钥呢？\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/diffie-hellman/01.png)\n\n## 单向函数\n\n为了解决这个问题，Diffie-Hellman 密钥交换使用了一种特殊的函数：单向函数，这种函数计算起来很简单，但是逆向计算非常困难。好比颜色的混合：将两种颜色混合得到混合颜色很容易，但通过混合颜色得到原先的两种颜色就非常困难了。\n\n## 例子：颜色混合\n\n不妨就把 Diffie-Hellman 密钥交换的思想用颜色混合来描述：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/diffie-hellman/02.png)\n\nAlice 和 Bob 的通信过程如下：\n\n1. Alice 和 Bob 首先就某一颜色达成一致（这里假设是黄色）\n2. Alice 和 Bob 各自生成一个私有颜色（不告诉对方）\n3. Alice 将自己的私有颜色与公开颜色混合，并将混合颜色发送给 Bob\n4. Bob 将自己的私有颜色与公开颜色混合，并将混合颜色发送给 Alice\n5. Alice 和 Bob 各自将自己的私有颜色与对方的混合颜色进行混合，得到的就是共享密钥\n\n所以实际上，共享密钥的颜色就是 Alice 的私有颜色 + Bob 的私有颜色 + 公开颜色，所以他们最终得到的结果是相同的。而 Eve 虽然全程窃听了 Alice 和 Bob 的通信，但她只能得到双方的混合颜色和公开颜色，而 **通过混合颜色得到原先的两种颜色非常困难**，所以 Eve 想得到共享密钥，只有拿到 Alice 或 Bob 任一的私有颜色才行。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/diffie-hellman/03.png)\n\n以上就是 Diffie-Hellman 密钥交换的思想，我们也能看到双方实际上并没有真正交换密钥，所以这种方法也称为 **Diffie-Hellman 密钥协商**。\n\n## 时钟运算\n\n上面是通过颜色举的例子，使用到了 **混合颜色容易，拆解颜色困难** 这个单向函数。而在数学上，这里用到的是 **时钟运算**。（参考 [时钟运算](/2016/11/13/clock-operation/) 一章）\n\n重新描述以上过程为：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/diffie-hellman/04.png)\n\nAlice 和 Bob 的通信过程如下：\n\n1. Alice 和 Bob 就两个数字 G 和 P 达成一致\n2. Alice 和 Bob 各自生成一个私有数字 A 和 B（不告诉对方）\n3. Alice 计算 $G^A\\,mod\\,P$ 的值，并将结果 Y 传给 Bob\n4. Bob 计算 $G^B\\,mod\\,P$ 的值，并将结果 X 传给 Alice\n5. Alice 计算 $X^A\\,mod\\,P$ 的值，此值即为共享密钥\n6. Bob 计算 $Y^B\\,mod\\,P$ 的值，此值即为共享密钥\n\n所以在上面得到共享密钥的过程中\n\n- Alice 实际上计算了 $(G^B\\,mod\\,P)^A\\,mod\\,P$\n- Bob 实际上计算了 $(G^A\\,mod\\,P)^B\\,mod\\,P$\n\n根据时钟运算，二者都等于 $G^{AB}\\,mod\\,P$，同样的，Eve 得到了 G，P，X 和 Y，但是没有 A 或 B，是很难求出共享密钥的，Alice 和 Bob 由此完成了共享密钥的协商。\n\n## 被困住的 Eve\n\n解释一下很难求出共享密钥中的很难的含义。\n\n也就是说，我们能够根据 $G^A\\,mod\\,P$ 计算出 A 吗？如果仅仅是根据 $G^A$ 的话，要计算出 A 并不难，然而 **根据 $G^A\\,mod\\,P$ 计算出 A 的有效算法到现在还没有出现**，当 P 特别大的时候，使用最快的计算机计算也要数以年计的时间。这个问题称为有限域的 **离散对数问题**。\n\n而有限域的离散对数问题的复杂度正是支撑 Diffie-Hellman 密钥交换算法的基础。\n\n## G 和 P 的选取\n\n在上面的过程中，Alice 和 Bob 首先就数字 G 和 P 达成了一致，但 G 和 P 并不是随便选取的。好比如果 G 是 2，P 是 2，那无论 A 和 B 取多少，X 和 Y 都是 0，导致共享密钥也是 0，那当然是不行的。\n\n这里 P 取一个很大的质数，而 G 是 P 的一个 **生成元**。\n\n## 生成元\n\n假设 P 取 13。对于不同 G 的不同次方，可以得到下面这张表\n\n| G/A  | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |      |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | :--- | ---- |\n| 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |      |\n| 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |      |\n| 2    | 2    | 4    | 8    | 3    | 6    | 12   | 11   | 9    | 5    | 10   | 7    | 1    | 生成元  |\n| 3    | 3    | 9    | 1    | 3    | 9    | 1    | 3    | 9    | 1    | 3    | 9    | 1    |      |\n| 4    | 4    | 3    | 12   | 9    | 10   | 1    | 4    | 3    | 12   | 9    | 10   | 1    |      |\n| 5    | 5    | 12   | 8    | 1    | 5    | 12   | 8    | 1    | 5    | 12   | 8    | 1    |      |\n| 6    | 6    | 10   | 8    | 9    | 2    | 12   | 7    | 3    | 5    | 4    | 11   | 1    | 生成元  |\n| 7    | 7    | 10   | 5    | 9    | 11   | 12   | 6    | 3    | 8    | 4    | 2    | 1    | 生成元  |\n| 8    | 8    | 12   | 5    | 1    | 8    | 12   | 5    | 1    | 8    | 12   | 5    | 1    |      |\n| 9    | 9    | 3    | 1    | 9    | 3    | 1    | 9    | 3    | 1    | 9    | 3    | 1    |      |\n| 10   | 10   | 9    | 12   | 3    | 4    | 1    | 10   | 9    | 12   | 3    | 4    | 1    |      |\n| 11   | 11   | 4    | 5    | 3    | 7    | 12   | 2    | 9    | 8    | 10   | 6    | 1    | 生成元  |\n| 12   | 12   | 1    | 12   | 1    | 12   | 1    | 12   | 1    | 12   | 1    | 12   | 1    |      |\n\n从上表中可以看出，当 G 等于 2 时，G 的 1 到 12 次方模 13 得到的结果全都不一样，也就是出现了 1 到 12 的全部整数，因此 2 称为 13 的生成元。同样的，6、7、11 也是 13 的生成元。\n\n*在数论中，又称为 2 为 模 13 的原根。*\n\n上表中还出现了一个有趣的现象，除了 G 等于 0，其他数字的 G 的 12 次方都等于 1。这正好是 **欧拉定理** 的一个体现。（参考 欧拉定理 一章 TODO）\n\n> 当 P 和 A 互质时，$A^{P - 1} ≡ 1 (mod\\,P)$\n\n于是当 G 为 P 的生成元时，Alice 就能够从 1 到 P - 2 中随机选取一个数字作为秘密数字。\n\n","source":"_posts/diffie-hellman-key-exchange.md","raw":"---\ntitle: Diffie-Hellman 密钥交换\ndate: 2016-11-13 19:00:00\ntags: [密码技术]\n---\n\n在对称密码中我们提到了，**密钥配送问题** 是对称密码中存在的一个问题。\n\n在上一篇里面我们已经介绍了可以解决这个问题的一个方式——使用公钥密码，这一篇我们讨论解决密钥配送问题的另一种方式：Diffie-Hellman 密钥交换\n\n<!-- more -->\n\n考虑这样一种情景，Alice 和 Bob 需要进行通信，为了保证消息的机密性，在通信之前，Alice 和 Bob 必须就某个密钥达成一致，但此时 Alice 和 Bob 之间的通信已经被 Eve 窃听了，任何在 Alice 和 Bob 之间的信息都会被 Eve 知道。那么 Alice 和 Bob 如何生成共享密钥呢？\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/diffie-hellman/01.png)\n\n## 单向函数\n\n为了解决这个问题，Diffie-Hellman 密钥交换使用了一种特殊的函数：单向函数，这种函数计算起来很简单，但是逆向计算非常困难。好比颜色的混合：将两种颜色混合得到混合颜色很容易，但通过混合颜色得到原先的两种颜色就非常困难了。\n\n## 例子：颜色混合\n\n不妨就把 Diffie-Hellman 密钥交换的思想用颜色混合来描述：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/diffie-hellman/02.png)\n\nAlice 和 Bob 的通信过程如下：\n\n1. Alice 和 Bob 首先就某一颜色达成一致（这里假设是黄色）\n2. Alice 和 Bob 各自生成一个私有颜色（不告诉对方）\n3. Alice 将自己的私有颜色与公开颜色混合，并将混合颜色发送给 Bob\n4. Bob 将自己的私有颜色与公开颜色混合，并将混合颜色发送给 Alice\n5. Alice 和 Bob 各自将自己的私有颜色与对方的混合颜色进行混合，得到的就是共享密钥\n\n所以实际上，共享密钥的颜色就是 Alice 的私有颜色 + Bob 的私有颜色 + 公开颜色，所以他们最终得到的结果是相同的。而 Eve 虽然全程窃听了 Alice 和 Bob 的通信，但她只能得到双方的混合颜色和公开颜色，而 **通过混合颜色得到原先的两种颜色非常困难**，所以 Eve 想得到共享密钥，只有拿到 Alice 或 Bob 任一的私有颜色才行。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/diffie-hellman/03.png)\n\n以上就是 Diffie-Hellman 密钥交换的思想，我们也能看到双方实际上并没有真正交换密钥，所以这种方法也称为 **Diffie-Hellman 密钥协商**。\n\n## 时钟运算\n\n上面是通过颜色举的例子，使用到了 **混合颜色容易，拆解颜色困难** 这个单向函数。而在数学上，这里用到的是 **时钟运算**。（参考 [时钟运算](/2016/11/13/clock-operation/) 一章）\n\n重新描述以上过程为：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/diffie-hellman/04.png)\n\nAlice 和 Bob 的通信过程如下：\n\n1. Alice 和 Bob 就两个数字 G 和 P 达成一致\n2. Alice 和 Bob 各自生成一个私有数字 A 和 B（不告诉对方）\n3. Alice 计算 $G^A\\,mod\\,P$ 的值，并将结果 Y 传给 Bob\n4. Bob 计算 $G^B\\,mod\\,P$ 的值，并将结果 X 传给 Alice\n5. Alice 计算 $X^A\\,mod\\,P$ 的值，此值即为共享密钥\n6. Bob 计算 $Y^B\\,mod\\,P$ 的值，此值即为共享密钥\n\n所以在上面得到共享密钥的过程中\n\n- Alice 实际上计算了 $(G^B\\,mod\\,P)^A\\,mod\\,P$\n- Bob 实际上计算了 $(G^A\\,mod\\,P)^B\\,mod\\,P$\n\n根据时钟运算，二者都等于 $G^{AB}\\,mod\\,P$，同样的，Eve 得到了 G，P，X 和 Y，但是没有 A 或 B，是很难求出共享密钥的，Alice 和 Bob 由此完成了共享密钥的协商。\n\n## 被困住的 Eve\n\n解释一下很难求出共享密钥中的很难的含义。\n\n也就是说，我们能够根据 $G^A\\,mod\\,P$ 计算出 A 吗？如果仅仅是根据 $G^A$ 的话，要计算出 A 并不难，然而 **根据 $G^A\\,mod\\,P$ 计算出 A 的有效算法到现在还没有出现**，当 P 特别大的时候，使用最快的计算机计算也要数以年计的时间。这个问题称为有限域的 **离散对数问题**。\n\n而有限域的离散对数问题的复杂度正是支撑 Diffie-Hellman 密钥交换算法的基础。\n\n## G 和 P 的选取\n\n在上面的过程中，Alice 和 Bob 首先就数字 G 和 P 达成了一致，但 G 和 P 并不是随便选取的。好比如果 G 是 2，P 是 2，那无论 A 和 B 取多少，X 和 Y 都是 0，导致共享密钥也是 0，那当然是不行的。\n\n这里 P 取一个很大的质数，而 G 是 P 的一个 **生成元**。\n\n## 生成元\n\n假设 P 取 13。对于不同 G 的不同次方，可以得到下面这张表\n\n| G/A  | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |      |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | :--- | ---- |\n| 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |      |\n| 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |      |\n| 2    | 2    | 4    | 8    | 3    | 6    | 12   | 11   | 9    | 5    | 10   | 7    | 1    | 生成元  |\n| 3    | 3    | 9    | 1    | 3    | 9    | 1    | 3    | 9    | 1    | 3    | 9    | 1    |      |\n| 4    | 4    | 3    | 12   | 9    | 10   | 1    | 4    | 3    | 12   | 9    | 10   | 1    |      |\n| 5    | 5    | 12   | 8    | 1    | 5    | 12   | 8    | 1    | 5    | 12   | 8    | 1    |      |\n| 6    | 6    | 10   | 8    | 9    | 2    | 12   | 7    | 3    | 5    | 4    | 11   | 1    | 生成元  |\n| 7    | 7    | 10   | 5    | 9    | 11   | 12   | 6    | 3    | 8    | 4    | 2    | 1    | 生成元  |\n| 8    | 8    | 12   | 5    | 1    | 8    | 12   | 5    | 1    | 8    | 12   | 5    | 1    |      |\n| 9    | 9    | 3    | 1    | 9    | 3    | 1    | 9    | 3    | 1    | 9    | 3    | 1    |      |\n| 10   | 10   | 9    | 12   | 3    | 4    | 1    | 10   | 9    | 12   | 3    | 4    | 1    |      |\n| 11   | 11   | 4    | 5    | 3    | 7    | 12   | 2    | 9    | 8    | 10   | 6    | 1    | 生成元  |\n| 12   | 12   | 1    | 12   | 1    | 12   | 1    | 12   | 1    | 12   | 1    | 12   | 1    |      |\n\n从上表中可以看出，当 G 等于 2 时，G 的 1 到 12 次方模 13 得到的结果全都不一样，也就是出现了 1 到 12 的全部整数，因此 2 称为 13 的生成元。同样的，6、7、11 也是 13 的生成元。\n\n*在数论中，又称为 2 为 模 13 的原根。*\n\n上表中还出现了一个有趣的现象，除了 G 等于 0，其他数字的 G 的 12 次方都等于 1。这正好是 **欧拉定理** 的一个体现。（参考 欧拉定理 一章 TODO）\n\n> 当 P 和 A 互质时，$A^{P - 1} ≡ 1 (mod\\,P)$\n\n于是当 G 为 P 的生成元时，Alice 就能够从 1 到 P - 2 中随机选取一个数字作为秘密数字。\n\n","slug":"diffie-hellman-key-exchange","published":1,"updated":"2017-01-23T13:52:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcvv0017n927i3ipa2h6","content":"<p>在对称密码中我们提到了，<strong>密钥配送问题</strong> 是对称密码中存在的一个问题。</p>\n<p>在上一篇里面我们已经介绍了可以解决这个问题的一个方式——使用公钥密码，这一篇我们讨论解决密钥配送问题的另一种方式：Diffie-Hellman 密钥交换</p>\n<a id=\"more\"></a>\n<p>考虑这样一种情景，Alice 和 Bob 需要进行通信，为了保证消息的机密性，在通信之前，Alice 和 Bob 必须就某个密钥达成一致，但此时 Alice 和 Bob 之间的通信已经被 Eve 窃听了，任何在 Alice 和 Bob 之间的信息都会被 Eve 知道。那么 Alice 和 Bob 如何生成共享密钥呢？</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/diffie-hellman/01.png\" alt=\"\"></p>\n<h2 id=\"单向函数\"><a href=\"#单向函数\" class=\"headerlink\" title=\"单向函数\"></a>单向函数</h2><p>为了解决这个问题，Diffie-Hellman 密钥交换使用了一种特殊的函数：单向函数，这种函数计算起来很简单，但是逆向计算非常困难。好比颜色的混合：将两种颜色混合得到混合颜色很容易，但通过混合颜色得到原先的两种颜色就非常困难了。</p>\n<h2 id=\"例子：颜色混合\"><a href=\"#例子：颜色混合\" class=\"headerlink\" title=\"例子：颜色混合\"></a>例子：颜色混合</h2><p>不妨就把 Diffie-Hellman 密钥交换的思想用颜色混合来描述：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/diffie-hellman/02.png\" alt=\"\"></p>\n<p>Alice 和 Bob 的通信过程如下：</p>\n<ol>\n<li>Alice 和 Bob 首先就某一颜色达成一致（这里假设是黄色）</li>\n<li>Alice 和 Bob 各自生成一个私有颜色（不告诉对方）</li>\n<li>Alice 将自己的私有颜色与公开颜色混合，并将混合颜色发送给 Bob</li>\n<li>Bob 将自己的私有颜色与公开颜色混合，并将混合颜色发送给 Alice</li>\n<li>Alice 和 Bob 各自将自己的私有颜色与对方的混合颜色进行混合，得到的就是共享密钥</li>\n</ol>\n<p>所以实际上，共享密钥的颜色就是 Alice 的私有颜色 + Bob 的私有颜色 + 公开颜色，所以他们最终得到的结果是相同的。而 Eve 虽然全程窃听了 Alice 和 Bob 的通信，但她只能得到双方的混合颜色和公开颜色，而 <strong>通过混合颜色得到原先的两种颜色非常困难</strong>，所以 Eve 想得到共享密钥，只有拿到 Alice 或 Bob 任一的私有颜色才行。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/diffie-hellman/03.png\" alt=\"\"></p>\n<p>以上就是 Diffie-Hellman 密钥交换的思想，我们也能看到双方实际上并没有真正交换密钥，所以这种方法也称为 <strong>Diffie-Hellman 密钥协商</strong>。</p>\n<h2 id=\"时钟运算\"><a href=\"#时钟运算\" class=\"headerlink\" title=\"时钟运算\"></a>时钟运算</h2><p>上面是通过颜色举的例子，使用到了 <strong>混合颜色容易，拆解颜色困难</strong> 这个单向函数。而在数学上，这里用到的是 <strong>时钟运算</strong>。（参考 <a href=\"/2016/11/13/clock-operation/\">时钟运算</a> 一章）</p>\n<p>重新描述以上过程为：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/diffie-hellman/04.png\" alt=\"\"></p>\n<p>Alice 和 Bob 的通信过程如下：</p>\n<ol>\n<li>Alice 和 Bob 就两个数字 G 和 P 达成一致</li>\n<li>Alice 和 Bob 各自生成一个私有数字 A 和 B（不告诉对方）</li>\n<li>Alice 计算 $G^A\\,mod\\,P$ 的值，并将结果 Y 传给 Bob</li>\n<li>Bob 计算 $G^B\\,mod\\,P$ 的值，并将结果 X 传给 Alice</li>\n<li>Alice 计算 $X^A\\,mod\\,P$ 的值，此值即为共享密钥</li>\n<li>Bob 计算 $Y^B\\,mod\\,P$ 的值，此值即为共享密钥</li>\n</ol>\n<p>所以在上面得到共享密钥的过程中</p>\n<ul>\n<li>Alice 实际上计算了 $(G^B\\,mod\\,P)^A\\,mod\\,P$</li>\n<li>Bob 实际上计算了 $(G^A\\,mod\\,P)^B\\,mod\\,P$</li>\n</ul>\n<p>根据时钟运算，二者都等于 $G^{AB}\\,mod\\,P$，同样的，Eve 得到了 G，P，X 和 Y，但是没有 A 或 B，是很难求出共享密钥的，Alice 和 Bob 由此完成了共享密钥的协商。</p>\n<h2 id=\"被困住的-Eve\"><a href=\"#被困住的-Eve\" class=\"headerlink\" title=\"被困住的 Eve\"></a>被困住的 Eve</h2><p>解释一下很难求出共享密钥中的很难的含义。</p>\n<p>也就是说，我们能够根据 $G^A\\,mod\\,P$ 计算出 A 吗？如果仅仅是根据 $G^A$ 的话，要计算出 A 并不难，然而 <strong>根据 $G^A\\,mod\\,P$ 计算出 A 的有效算法到现在还没有出现</strong>，当 P 特别大的时候，使用最快的计算机计算也要数以年计的时间。这个问题称为有限域的 <strong>离散对数问题</strong>。</p>\n<p>而有限域的离散对数问题的复杂度正是支撑 Diffie-Hellman 密钥交换算法的基础。</p>\n<h2 id=\"G-和-P-的选取\"><a href=\"#G-和-P-的选取\" class=\"headerlink\" title=\"G 和 P 的选取\"></a>G 和 P 的选取</h2><p>在上面的过程中，Alice 和 Bob 首先就数字 G 和 P 达成了一致，但 G 和 P 并不是随便选取的。好比如果 G 是 2，P 是 2，那无论 A 和 B 取多少，X 和 Y 都是 0，导致共享密钥也是 0，那当然是不行的。</p>\n<p>这里 P 取一个很大的质数，而 G 是 P 的一个 <strong>生成元</strong>。</p>\n<h2 id=\"生成元\"><a href=\"#生成元\" class=\"headerlink\" title=\"生成元\"></a>生成元</h2><p>假设 P 取 13。对于不同 G 的不同次方，可以得到下面这张表</p>\n<table>\n<thead>\n<tr>\n<th>G/A</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n<th>9</th>\n<th>10</th>\n<th>11</th>\n<th style=\"text-align:left\">12</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td style=\"text-align:left\">0</td>\n<td></td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td style=\"text-align:left\">1</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>2</td>\n<td>4</td>\n<td>8</td>\n<td>3</td>\n<td>6</td>\n<td>12</td>\n<td>11</td>\n<td>9</td>\n<td>5</td>\n<td>10</td>\n<td>7</td>\n<td style=\"text-align:left\">1</td>\n<td>生成元</td>\n</tr>\n<tr>\n<td>3</td>\n<td>3</td>\n<td>9</td>\n<td>1</td>\n<td>3</td>\n<td>9</td>\n<td>1</td>\n<td>3</td>\n<td>9</td>\n<td>1</td>\n<td>3</td>\n<td>9</td>\n<td style=\"text-align:left\">1</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>4</td>\n<td>3</td>\n<td>12</td>\n<td>9</td>\n<td>10</td>\n<td>1</td>\n<td>4</td>\n<td>3</td>\n<td>12</td>\n<td>9</td>\n<td>10</td>\n<td style=\"text-align:left\">1</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>5</td>\n<td>12</td>\n<td>8</td>\n<td>1</td>\n<td>5</td>\n<td>12</td>\n<td>8</td>\n<td>1</td>\n<td>5</td>\n<td>12</td>\n<td>8</td>\n<td style=\"text-align:left\">1</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>6</td>\n<td>10</td>\n<td>8</td>\n<td>9</td>\n<td>2</td>\n<td>12</td>\n<td>7</td>\n<td>3</td>\n<td>5</td>\n<td>4</td>\n<td>11</td>\n<td style=\"text-align:left\">1</td>\n<td>生成元</td>\n</tr>\n<tr>\n<td>7</td>\n<td>7</td>\n<td>10</td>\n<td>5</td>\n<td>9</td>\n<td>11</td>\n<td>12</td>\n<td>6</td>\n<td>3</td>\n<td>8</td>\n<td>4</td>\n<td>2</td>\n<td style=\"text-align:left\">1</td>\n<td>生成元</td>\n</tr>\n<tr>\n<td>8</td>\n<td>8</td>\n<td>12</td>\n<td>5</td>\n<td>1</td>\n<td>8</td>\n<td>12</td>\n<td>5</td>\n<td>1</td>\n<td>8</td>\n<td>12</td>\n<td>5</td>\n<td style=\"text-align:left\">1</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>9</td>\n<td>3</td>\n<td>1</td>\n<td>9</td>\n<td>3</td>\n<td>1</td>\n<td>9</td>\n<td>3</td>\n<td>1</td>\n<td>9</td>\n<td>3</td>\n<td style=\"text-align:left\">1</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>10</td>\n<td>9</td>\n<td>12</td>\n<td>3</td>\n<td>4</td>\n<td>1</td>\n<td>10</td>\n<td>9</td>\n<td>12</td>\n<td>3</td>\n<td>4</td>\n<td style=\"text-align:left\">1</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>11</td>\n<td>4</td>\n<td>5</td>\n<td>3</td>\n<td>7</td>\n<td>12</td>\n<td>2</td>\n<td>9</td>\n<td>8</td>\n<td>10</td>\n<td>6</td>\n<td style=\"text-align:left\">1</td>\n<td>生成元</td>\n</tr>\n<tr>\n<td>12</td>\n<td>12</td>\n<td>1</td>\n<td>12</td>\n<td>1</td>\n<td>12</td>\n<td>1</td>\n<td>12</td>\n<td>1</td>\n<td>12</td>\n<td>1</td>\n<td>12</td>\n<td style=\"text-align:left\">1</td>\n</tr>\n</tbody>\n</table>\n<p>从上表中可以看出，当 G 等于 2 时，G 的 1 到 12 次方模 13 得到的结果全都不一样，也就是出现了 1 到 12 的全部整数，因此 2 称为 13 的生成元。同样的，6、7、11 也是 13 的生成元。</p>\n<p><em>在数论中，又称为 2 为 模 13 的原根。</em></p>\n<p>上表中还出现了一个有趣的现象，除了 G 等于 0，其他数字的 G 的 12 次方都等于 1。这正好是 <strong>欧拉定理</strong> 的一个体现。（参考 欧拉定理 一章 TODO）</p>\n<blockquote>\n<p>当 P 和 A 互质时，$A^{P - 1} ≡ 1 (mod\\,P)$</p>\n</blockquote>\n<p>于是当 G 为 P 的生成元时，Alice 就能够从 1 到 P - 2 中随机选取一个数字作为秘密数字。</p>\n","excerpt":"<p>在对称密码中我们提到了，<strong>密钥配送问题</strong> 是对称密码中存在的一个问题。</p>\n<p>在上一篇里面我们已经介绍了可以解决这个问题的一个方式——使用公钥密码，这一篇我们讨论解决密钥配送问题的另一种方式：Diffie-Hellman 密钥交换</p>","more":"<p>考虑这样一种情景，Alice 和 Bob 需要进行通信，为了保证消息的机密性，在通信之前，Alice 和 Bob 必须就某个密钥达成一致，但此时 Alice 和 Bob 之间的通信已经被 Eve 窃听了，任何在 Alice 和 Bob 之间的信息都会被 Eve 知道。那么 Alice 和 Bob 如何生成共享密钥呢？</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/diffie-hellman/01.png\" alt=\"\"></p>\n<h2 id=\"单向函数\"><a href=\"#单向函数\" class=\"headerlink\" title=\"单向函数\"></a>单向函数</h2><p>为了解决这个问题，Diffie-Hellman 密钥交换使用了一种特殊的函数：单向函数，这种函数计算起来很简单，但是逆向计算非常困难。好比颜色的混合：将两种颜色混合得到混合颜色很容易，但通过混合颜色得到原先的两种颜色就非常困难了。</p>\n<h2 id=\"例子：颜色混合\"><a href=\"#例子：颜色混合\" class=\"headerlink\" title=\"例子：颜色混合\"></a>例子：颜色混合</h2><p>不妨就把 Diffie-Hellman 密钥交换的思想用颜色混合来描述：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/diffie-hellman/02.png\" alt=\"\"></p>\n<p>Alice 和 Bob 的通信过程如下：</p>\n<ol>\n<li>Alice 和 Bob 首先就某一颜色达成一致（这里假设是黄色）</li>\n<li>Alice 和 Bob 各自生成一个私有颜色（不告诉对方）</li>\n<li>Alice 将自己的私有颜色与公开颜色混合，并将混合颜色发送给 Bob</li>\n<li>Bob 将自己的私有颜色与公开颜色混合，并将混合颜色发送给 Alice</li>\n<li>Alice 和 Bob 各自将自己的私有颜色与对方的混合颜色进行混合，得到的就是共享密钥</li>\n</ol>\n<p>所以实际上，共享密钥的颜色就是 Alice 的私有颜色 + Bob 的私有颜色 + 公开颜色，所以他们最终得到的结果是相同的。而 Eve 虽然全程窃听了 Alice 和 Bob 的通信，但她只能得到双方的混合颜色和公开颜色，而 <strong>通过混合颜色得到原先的两种颜色非常困难</strong>，所以 Eve 想得到共享密钥，只有拿到 Alice 或 Bob 任一的私有颜色才行。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/diffie-hellman/03.png\" alt=\"\"></p>\n<p>以上就是 Diffie-Hellman 密钥交换的思想，我们也能看到双方实际上并没有真正交换密钥，所以这种方法也称为 <strong>Diffie-Hellman 密钥协商</strong>。</p>\n<h2 id=\"时钟运算\"><a href=\"#时钟运算\" class=\"headerlink\" title=\"时钟运算\"></a>时钟运算</h2><p>上面是通过颜色举的例子，使用到了 <strong>混合颜色容易，拆解颜色困难</strong> 这个单向函数。而在数学上，这里用到的是 <strong>时钟运算</strong>。（参考 <a href=\"/2016/11/13/clock-operation/\">时钟运算</a> 一章）</p>\n<p>重新描述以上过程为：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/diffie-hellman/04.png\" alt=\"\"></p>\n<p>Alice 和 Bob 的通信过程如下：</p>\n<ol>\n<li>Alice 和 Bob 就两个数字 G 和 P 达成一致</li>\n<li>Alice 和 Bob 各自生成一个私有数字 A 和 B（不告诉对方）</li>\n<li>Alice 计算 $G^A\\,mod\\,P$ 的值，并将结果 Y 传给 Bob</li>\n<li>Bob 计算 $G^B\\,mod\\,P$ 的值，并将结果 X 传给 Alice</li>\n<li>Alice 计算 $X^A\\,mod\\,P$ 的值，此值即为共享密钥</li>\n<li>Bob 计算 $Y^B\\,mod\\,P$ 的值，此值即为共享密钥</li>\n</ol>\n<p>所以在上面得到共享密钥的过程中</p>\n<ul>\n<li>Alice 实际上计算了 $(G^B\\,mod\\,P)^A\\,mod\\,P$</li>\n<li>Bob 实际上计算了 $(G^A\\,mod\\,P)^B\\,mod\\,P$</li>\n</ul>\n<p>根据时钟运算，二者都等于 $G^{AB}\\,mod\\,P$，同样的，Eve 得到了 G，P，X 和 Y，但是没有 A 或 B，是很难求出共享密钥的，Alice 和 Bob 由此完成了共享密钥的协商。</p>\n<h2 id=\"被困住的-Eve\"><a href=\"#被困住的-Eve\" class=\"headerlink\" title=\"被困住的 Eve\"></a>被困住的 Eve</h2><p>解释一下很难求出共享密钥中的很难的含义。</p>\n<p>也就是说，我们能够根据 $G^A\\,mod\\,P$ 计算出 A 吗？如果仅仅是根据 $G^A$ 的话，要计算出 A 并不难，然而 <strong>根据 $G^A\\,mod\\,P$ 计算出 A 的有效算法到现在还没有出现</strong>，当 P 特别大的时候，使用最快的计算机计算也要数以年计的时间。这个问题称为有限域的 <strong>离散对数问题</strong>。</p>\n<p>而有限域的离散对数问题的复杂度正是支撑 Diffie-Hellman 密钥交换算法的基础。</p>\n<h2 id=\"G-和-P-的选取\"><a href=\"#G-和-P-的选取\" class=\"headerlink\" title=\"G 和 P 的选取\"></a>G 和 P 的选取</h2><p>在上面的过程中，Alice 和 Bob 首先就数字 G 和 P 达成了一致，但 G 和 P 并不是随便选取的。好比如果 G 是 2，P 是 2，那无论 A 和 B 取多少，X 和 Y 都是 0，导致共享密钥也是 0，那当然是不行的。</p>\n<p>这里 P 取一个很大的质数，而 G 是 P 的一个 <strong>生成元</strong>。</p>\n<h2 id=\"生成元\"><a href=\"#生成元\" class=\"headerlink\" title=\"生成元\"></a>生成元</h2><p>假设 P 取 13。对于不同 G 的不同次方，可以得到下面这张表</p>\n<table>\n<thead>\n<tr>\n<th>G/A</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n<th>9</th>\n<th>10</th>\n<th>11</th>\n<th style=\"text-align:left\">12</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td style=\"text-align:left\">0</td>\n<td></td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td style=\"text-align:left\">1</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>2</td>\n<td>4</td>\n<td>8</td>\n<td>3</td>\n<td>6</td>\n<td>12</td>\n<td>11</td>\n<td>9</td>\n<td>5</td>\n<td>10</td>\n<td>7</td>\n<td style=\"text-align:left\">1</td>\n<td>生成元</td>\n</tr>\n<tr>\n<td>3</td>\n<td>3</td>\n<td>9</td>\n<td>1</td>\n<td>3</td>\n<td>9</td>\n<td>1</td>\n<td>3</td>\n<td>9</td>\n<td>1</td>\n<td>3</td>\n<td>9</td>\n<td style=\"text-align:left\">1</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>4</td>\n<td>3</td>\n<td>12</td>\n<td>9</td>\n<td>10</td>\n<td>1</td>\n<td>4</td>\n<td>3</td>\n<td>12</td>\n<td>9</td>\n<td>10</td>\n<td style=\"text-align:left\">1</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>5</td>\n<td>12</td>\n<td>8</td>\n<td>1</td>\n<td>5</td>\n<td>12</td>\n<td>8</td>\n<td>1</td>\n<td>5</td>\n<td>12</td>\n<td>8</td>\n<td style=\"text-align:left\">1</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>6</td>\n<td>10</td>\n<td>8</td>\n<td>9</td>\n<td>2</td>\n<td>12</td>\n<td>7</td>\n<td>3</td>\n<td>5</td>\n<td>4</td>\n<td>11</td>\n<td style=\"text-align:left\">1</td>\n<td>生成元</td>\n</tr>\n<tr>\n<td>7</td>\n<td>7</td>\n<td>10</td>\n<td>5</td>\n<td>9</td>\n<td>11</td>\n<td>12</td>\n<td>6</td>\n<td>3</td>\n<td>8</td>\n<td>4</td>\n<td>2</td>\n<td style=\"text-align:left\">1</td>\n<td>生成元</td>\n</tr>\n<tr>\n<td>8</td>\n<td>8</td>\n<td>12</td>\n<td>5</td>\n<td>1</td>\n<td>8</td>\n<td>12</td>\n<td>5</td>\n<td>1</td>\n<td>8</td>\n<td>12</td>\n<td>5</td>\n<td style=\"text-align:left\">1</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>9</td>\n<td>3</td>\n<td>1</td>\n<td>9</td>\n<td>3</td>\n<td>1</td>\n<td>9</td>\n<td>3</td>\n<td>1</td>\n<td>9</td>\n<td>3</td>\n<td style=\"text-align:left\">1</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>10</td>\n<td>9</td>\n<td>12</td>\n<td>3</td>\n<td>4</td>\n<td>1</td>\n<td>10</td>\n<td>9</td>\n<td>12</td>\n<td>3</td>\n<td>4</td>\n<td style=\"text-align:left\">1</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>11</td>\n<td>4</td>\n<td>5</td>\n<td>3</td>\n<td>7</td>\n<td>12</td>\n<td>2</td>\n<td>9</td>\n<td>8</td>\n<td>10</td>\n<td>6</td>\n<td style=\"text-align:left\">1</td>\n<td>生成元</td>\n</tr>\n<tr>\n<td>12</td>\n<td>12</td>\n<td>1</td>\n<td>12</td>\n<td>1</td>\n<td>12</td>\n<td>1</td>\n<td>12</td>\n<td>1</td>\n<td>12</td>\n<td>1</td>\n<td>12</td>\n<td style=\"text-align:left\">1</td>\n</tr>\n</tbody>\n</table>\n<p>从上表中可以看出，当 G 等于 2 时，G 的 1 到 12 次方模 13 得到的结果全都不一样，也就是出现了 1 到 12 的全部整数，因此 2 称为 13 的生成元。同样的，6、7、11 也是 13 的生成元。</p>\n<p><em>在数论中，又称为 2 为 模 13 的原根。</em></p>\n<p>上表中还出现了一个有趣的现象，除了 G 等于 0，其他数字的 G 的 12 次方都等于 1。这正好是 <strong>欧拉定理</strong> 的一个体现。（参考 欧拉定理 一章 TODO）</p>\n<blockquote>\n<p>当 P 和 A 互质时，$A^{P - 1} ≡ 1 (mod\\,P)$</p>\n</blockquote>\n<p>于是当 G 为 P 的生成元时，Alice 就能够从 1 到 P - 2 中随机选取一个数字作为秘密数字。</p>"},{"title":"指数与对数函数导数","date":"2017-02-25T15:03:50.000Z","_content":"\n使用 e 底法和对数微分法求解指数与对数函数导数。\n\n<!-- more -->\n\n## $a^x$\n\n试求 $a^x$ 的导数。\n\n$$\n\\begin{align}\n\\cfrac{d}{dx} a^x &= \\lim\\_{\\Delta x \\to 0} \\cfrac{a^{x + \\Delta x} - a^x}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} a^x \\cfrac{a^{\\Delta x} - 1}{\\Delta x}\n\\end{align}\n$$\n\n即 $\\cfrac{d}{dx} = a^x \\lim\\_{\\Delta x \\to 0} \\cfrac{a^{\\Delta x} - 1}{\\Delta x}$\n\n而 $\\lim\\_{\\Delta x \\to 0} \\cfrac{a^{\\Delta x} - 1}{\\Delta x}$ 实际上就是 $a^x$ 在 x = 0 处的导数，只要我们知道了在这个点处的导数，我们就能得到整个函数的导数，这和求 $\\sin$、$\\cos$ 的导数时如出一辙，但是很不幸的，我们并不知道这个点出的导数。\n\n### 引入神秘的 e\n\n设 $\\lim\\_{\\Delta x \\to 0} \\cfrac{a^{\\Delta x} - 1}{\\Delta x}$ 为关于 a 的函数 $M(a)$，不妨设存在一个数 e，使得 $M(e) = 1$\n\n那么，$\\cfrac{d}{d} e^x = e^x \\cdot M(e) = e^x$，且 $\\left. \\cfrac{d}{d} e^x \\right|\\_{x = 0} = 1$\n\n注意，虽然我们到现在还不知道 e 是什么数，但我们可以先利用 e 得到一些公式，随后再求解 e。\n\n## 自然对数\n\n以 e 为底数的对数叫做自然对数，记为 $\\ln$，且\n\n$$\n\\begin{align}\n\\ln (a + b) &= \\ln a + \\ln b \\\\\\\n\\ln a^n &= n\\ln a\n\\end{align}\n$$\n\n### $\\ln x$ 的导数\n\n$$\n\\begin{align}\nw &= \\ln x \\\\\\\ne^w &= x \\\\\\\ne^w \\cdot w' &= 1 \\\\\\\nw' &= \\frac{1}{e^w} \\\\\\\n&= \\frac{1}{x}\n\\end{align}\n$$\n\n即 $(\\ln x)' = \\cfrac{1}{x}$\n\n## 求解 $a^x$ 的导数\n\n### e底法\n\n将 $a^x$ 转换为以 e 为底的指数。\n\n因为 $a = e^{ln a}$，代入得\n\n$$\n\\begin{align}\n\\cfrac{d}{dx}a^x &= \\cfrac{d}{dx}(e^{\\ln a})^x \\\\\\\n&= \\cfrac{d}{dx} e^{x\\ln a} \\\\\\\n&= \\ln a \\cdot e^{x\\ln a} \\\\\\\n&= \\ln a \\cdot a^x\n\\end{align}\n$$\n\n> 而 $\\cfrac{d}{dx} a^x = a^x \\cdot M(a)$，所以，$M(a) = ln a$\n\n### 对数微分法\n\n对某些函数而言，求其对数的导数比求该函数本身的导数更简单。\n\n设有函数 u，现要求其导数 $\\cfrac{d}{dx} u$，那么\n\n$$\n\\begin{align}\n\\cfrac{d}{dx} \\ln u &= \\cfrac{d}{du} \\ln u \\cdot \\cfrac{d}{dx} u \\\\\\\n&= \\cfrac{u'}{u}\n\\end{align}\n$$\n\n对 $a^x$ 而言，设 $u = a^x$，由对数的性质，$\\ln u = \\ln a^x = x\\ln a$，那么 $(\\ln u)' = \\ln a$\n\n而 $\\cfrac{d}{dx} \\ln u = \\cfrac{u'}{u}$，所以即\n\n$$\n\\begin{align}\n\\cfrac{u'}{u} &= \\ln a \\\\\\\nu' &= u \\ln a \\\\\\\n&= a^x \\ln a\n\\end{align}\n$$\n\n## 几个栗子\n\n### 1) $x^a$\n\n之前已经讨论过求导 $x^a$，a 为有理数情况，实际上求导公式对无理数同样适用\n\n#### e 底法\n\n$$\n\\begin{align}\nx^a &= (e^{\\ln x})^a \\\\\\\n&= e^{a \\ln x} \\\\\\\n(e^{a \\ln x})' &= e^{a \\ln x} \\cdot \\frac{a}{x} \\\\\\\n&= x^a \\cdot \\frac{a}{x} \\\\\\\n&= ax^{a - 1}\n\\end{align}\n$$\n\n#### 对数微分法\n\n$$\n\\begin{align}\nu &= x^a \\\\\\\n\\ln u &= a \\ln x \\\\\\\n(\\ln u)' &= \\frac{a}{x} \\\\\\\n\\frac{u'}{u} &= \\frac{a}{x} \\\\\\\nu' &= u \\frac{a}{x} \\\\\\\n&= x^a \\frac{a}{x} \\\\\\\n&= ax^{a - 1}\n\\end{align}\n$$\n\n### 2) $x^x$\n\n求 $x^x$ 的导数\n\n$$\n\\begin{align}\nv &= x^x \\\\\\\n\\ln v &= x \\ln x \\\\\\\n\\cfrac{v'}{v} &= \\ln x + x \\cdot \\cfrac{1}{x} \\\\\\\n&= \\ln x + 1 \\\\\\\nv' &= v \\cdot (\\ln x + 1) \\\\\\\n&= x^x(\\ln x + 1)\n\\end{align}\n$$\n\n### 3) 例 3\n\n求 $\\lim\\_{n \\to \\infty} (1 + \\frac{1}{n})^n$\n\n对函数取对数，得 $\\ln (1 + \\frac{1}{n})^n = n \\ln(1 + \\frac{1}{n})$\n\n设 $\\Delta x = \\frac{1}{n}$，因为 $n \\to \\infty$，所以 $\\Delta x \\to 0$\n\n$$\n\\begin{align}\n\\lim\\_{n \\to \\infty} n \\ln(1 + \\frac{1}{n}) &= \\lim\\_{\\Delta x \\to 0} \\frac{1}{\\Delta x} \\ln (1 + \\Delta x) \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\cfrac{\\ln(1 + \\Delta x) - \\ln 1}{\\Delta x} \\\\\\\n\\end{align}\n$$\n\n即 $\\ln x$ 在 x = 1 处的导数，而 $\\left. (\\ln x)' \\right|\\_{x = 1} = \\left. \\frac{1}{x} \\right|\\_{x = 1} = 1$，即 $\\lim\\_{\\Delta x \\to 0} \\ln (1 + \\frac{1}{n})^n = 1$，而\n\n$$\n\\begin{align}\n\\lim\\_{n \\to \\infty} (1 + \\frac{1}{n})^n &= \\lim\\_{n \\to \\infty} e^{\\ln (1 + \\frac{1}{n})^n} \\\\\\\n&= e^{\\lim\\_{n \\to \\infty} \\ln (1 + \\frac{1}{n})^n} \\\\\\\n&= e\n\\end{align}\n$$\n\n这也就是说，神秘的 $e = \\lim\\_{n \\to \\infty}(1 + \\frac{1}{n})^n$\n","source":"_posts/exponentials-and-logarithms-derivative.md","raw":"---\ntitle: 指数与对数函数导数\ndate: 2017-02-25 23:03:50\ntags: [单变量微积分]\n---\n\n使用 e 底法和对数微分法求解指数与对数函数导数。\n\n<!-- more -->\n\n## $a^x$\n\n试求 $a^x$ 的导数。\n\n$$\n\\begin{align}\n\\cfrac{d}{dx} a^x &= \\lim\\_{\\Delta x \\to 0} \\cfrac{a^{x + \\Delta x} - a^x}{\\Delta x} \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} a^x \\cfrac{a^{\\Delta x} - 1}{\\Delta x}\n\\end{align}\n$$\n\n即 $\\cfrac{d}{dx} = a^x \\lim\\_{\\Delta x \\to 0} \\cfrac{a^{\\Delta x} - 1}{\\Delta x}$\n\n而 $\\lim\\_{\\Delta x \\to 0} \\cfrac{a^{\\Delta x} - 1}{\\Delta x}$ 实际上就是 $a^x$ 在 x = 0 处的导数，只要我们知道了在这个点处的导数，我们就能得到整个函数的导数，这和求 $\\sin$、$\\cos$ 的导数时如出一辙，但是很不幸的，我们并不知道这个点出的导数。\n\n### 引入神秘的 e\n\n设 $\\lim\\_{\\Delta x \\to 0} \\cfrac{a^{\\Delta x} - 1}{\\Delta x}$ 为关于 a 的函数 $M(a)$，不妨设存在一个数 e，使得 $M(e) = 1$\n\n那么，$\\cfrac{d}{d} e^x = e^x \\cdot M(e) = e^x$，且 $\\left. \\cfrac{d}{d} e^x \\right|\\_{x = 0} = 1$\n\n注意，虽然我们到现在还不知道 e 是什么数，但我们可以先利用 e 得到一些公式，随后再求解 e。\n\n## 自然对数\n\n以 e 为底数的对数叫做自然对数，记为 $\\ln$，且\n\n$$\n\\begin{align}\n\\ln (a + b) &= \\ln a + \\ln b \\\\\\\n\\ln a^n &= n\\ln a\n\\end{align}\n$$\n\n### $\\ln x$ 的导数\n\n$$\n\\begin{align}\nw &= \\ln x \\\\\\\ne^w &= x \\\\\\\ne^w \\cdot w' &= 1 \\\\\\\nw' &= \\frac{1}{e^w} \\\\\\\n&= \\frac{1}{x}\n\\end{align}\n$$\n\n即 $(\\ln x)' = \\cfrac{1}{x}$\n\n## 求解 $a^x$ 的导数\n\n### e底法\n\n将 $a^x$ 转换为以 e 为底的指数。\n\n因为 $a = e^{ln a}$，代入得\n\n$$\n\\begin{align}\n\\cfrac{d}{dx}a^x &= \\cfrac{d}{dx}(e^{\\ln a})^x \\\\\\\n&= \\cfrac{d}{dx} e^{x\\ln a} \\\\\\\n&= \\ln a \\cdot e^{x\\ln a} \\\\\\\n&= \\ln a \\cdot a^x\n\\end{align}\n$$\n\n> 而 $\\cfrac{d}{dx} a^x = a^x \\cdot M(a)$，所以，$M(a) = ln a$\n\n### 对数微分法\n\n对某些函数而言，求其对数的导数比求该函数本身的导数更简单。\n\n设有函数 u，现要求其导数 $\\cfrac{d}{dx} u$，那么\n\n$$\n\\begin{align}\n\\cfrac{d}{dx} \\ln u &= \\cfrac{d}{du} \\ln u \\cdot \\cfrac{d}{dx} u \\\\\\\n&= \\cfrac{u'}{u}\n\\end{align}\n$$\n\n对 $a^x$ 而言，设 $u = a^x$，由对数的性质，$\\ln u = \\ln a^x = x\\ln a$，那么 $(\\ln u)' = \\ln a$\n\n而 $\\cfrac{d}{dx} \\ln u = \\cfrac{u'}{u}$，所以即\n\n$$\n\\begin{align}\n\\cfrac{u'}{u} &= \\ln a \\\\\\\nu' &= u \\ln a \\\\\\\n&= a^x \\ln a\n\\end{align}\n$$\n\n## 几个栗子\n\n### 1) $x^a$\n\n之前已经讨论过求导 $x^a$，a 为有理数情况，实际上求导公式对无理数同样适用\n\n#### e 底法\n\n$$\n\\begin{align}\nx^a &= (e^{\\ln x})^a \\\\\\\n&= e^{a \\ln x} \\\\\\\n(e^{a \\ln x})' &= e^{a \\ln x} \\cdot \\frac{a}{x} \\\\\\\n&= x^a \\cdot \\frac{a}{x} \\\\\\\n&= ax^{a - 1}\n\\end{align}\n$$\n\n#### 对数微分法\n\n$$\n\\begin{align}\nu &= x^a \\\\\\\n\\ln u &= a \\ln x \\\\\\\n(\\ln u)' &= \\frac{a}{x} \\\\\\\n\\frac{u'}{u} &= \\frac{a}{x} \\\\\\\nu' &= u \\frac{a}{x} \\\\\\\n&= x^a \\frac{a}{x} \\\\\\\n&= ax^{a - 1}\n\\end{align}\n$$\n\n### 2) $x^x$\n\n求 $x^x$ 的导数\n\n$$\n\\begin{align}\nv &= x^x \\\\\\\n\\ln v &= x \\ln x \\\\\\\n\\cfrac{v'}{v} &= \\ln x + x \\cdot \\cfrac{1}{x} \\\\\\\n&= \\ln x + 1 \\\\\\\nv' &= v \\cdot (\\ln x + 1) \\\\\\\n&= x^x(\\ln x + 1)\n\\end{align}\n$$\n\n### 3) 例 3\n\n求 $\\lim\\_{n \\to \\infty} (1 + \\frac{1}{n})^n$\n\n对函数取对数，得 $\\ln (1 + \\frac{1}{n})^n = n \\ln(1 + \\frac{1}{n})$\n\n设 $\\Delta x = \\frac{1}{n}$，因为 $n \\to \\infty$，所以 $\\Delta x \\to 0$\n\n$$\n\\begin{align}\n\\lim\\_{n \\to \\infty} n \\ln(1 + \\frac{1}{n}) &= \\lim\\_{\\Delta x \\to 0} \\frac{1}{\\Delta x} \\ln (1 + \\Delta x) \\\\\\\n&= \\lim\\_{\\Delta x \\to 0} \\cfrac{\\ln(1 + \\Delta x) - \\ln 1}{\\Delta x} \\\\\\\n\\end{align}\n$$\n\n即 $\\ln x$ 在 x = 1 处的导数，而 $\\left. (\\ln x)' \\right|\\_{x = 1} = \\left. \\frac{1}{x} \\right|\\_{x = 1} = 1$，即 $\\lim\\_{\\Delta x \\to 0} \\ln (1 + \\frac{1}{n})^n = 1$，而\n\n$$\n\\begin{align}\n\\lim\\_{n \\to \\infty} (1 + \\frac{1}{n})^n &= \\lim\\_{n \\to \\infty} e^{\\ln (1 + \\frac{1}{n})^n} \\\\\\\n&= e^{\\lim\\_{n \\to \\infty} \\ln (1 + \\frac{1}{n})^n} \\\\\\\n&= e\n\\end{align}\n$$\n\n这也就是说，神秘的 $e = \\lim\\_{n \\to \\infty}(1 + \\frac{1}{n})^n$\n","slug":"exponentials-and-logarithms-derivative","published":1,"updated":"2017-02-26T04:12:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcvw0019n9278fqqsaa0","content":"<p>使用 e 底法和对数微分法求解指数与对数函数导数。</p>\n<a id=\"more\"></a>\n<h2 id=\"a-x\"><a href=\"#a-x\" class=\"headerlink\" title=\"$a^x$\"></a>$a^x$</h2><p>试求 $a^x$ 的导数。</p>\n<p>$$<br>\\begin{align}<br>\\cfrac{d}{dx} a^x &amp;= \\lim_{\\Delta x \\to 0} \\cfrac{a^{x + \\Delta x} - a^x}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} a^x \\cfrac{a^{\\Delta x} - 1}{\\Delta x}<br>\\end{align}<br>$$</p>\n<p>即 $\\cfrac{d}{dx} = a^x \\lim_{\\Delta x \\to 0} \\cfrac{a^{\\Delta x} - 1}{\\Delta x}$</p>\n<p>而 $\\lim_{\\Delta x \\to 0} \\cfrac{a^{\\Delta x} - 1}{\\Delta x}$ 实际上就是 $a^x$ 在 x = 0 处的导数，只要我们知道了在这个点处的导数，我们就能得到整个函数的导数，这和求 $\\sin$、$\\cos$ 的导数时如出一辙，但是很不幸的，我们并不知道这个点出的导数。</p>\n<h3 id=\"引入神秘的-e\"><a href=\"#引入神秘的-e\" class=\"headerlink\" title=\"引入神秘的 e\"></a>引入神秘的 e</h3><p>设 $\\lim_{\\Delta x \\to 0} \\cfrac{a^{\\Delta x} - 1}{\\Delta x}$ 为关于 a 的函数 $M(a)$，不妨设存在一个数 e，使得 $M(e) = 1$</p>\n<p>那么，$\\cfrac{d}{d} e^x = e^x \\cdot M(e) = e^x$，且 $\\left. \\cfrac{d}{d} e^x \\right|_{x = 0} = 1$</p>\n<p>注意，虽然我们到现在还不知道 e 是什么数，但我们可以先利用 e 得到一些公式，随后再求解 e。</p>\n<h2 id=\"自然对数\"><a href=\"#自然对数\" class=\"headerlink\" title=\"自然对数\"></a>自然对数</h2><p>以 e 为底数的对数叫做自然对数，记为 $\\ln$，且</p>\n<p>$$<br>\\begin{align}<br>\\ln (a + b) &amp;= \\ln a + \\ln b \\\\<br>\\ln a^n &amp;= n\\ln a<br>\\end{align}<br>$$</p>\n<h3 id=\"ln-x-的导数\"><a href=\"#ln-x-的导数\" class=\"headerlink\" title=\"$\\ln x$ 的导数\"></a>$\\ln x$ 的导数</h3><p>$$<br>\\begin{align}<br>w &amp;= \\ln x \\\\<br>e^w &amp;= x \\\\<br>e^w \\cdot w’ &amp;= 1 \\\\<br>w’ &amp;= \\frac{1}{e^w} \\\\<br>&amp;= \\frac{1}{x}<br>\\end{align}<br>$$</p>\n<p>即 $(\\ln x)’ = \\cfrac{1}{x}$</p>\n<h2 id=\"求解-a-x-的导数\"><a href=\"#求解-a-x-的导数\" class=\"headerlink\" title=\"求解 $a^x$ 的导数\"></a>求解 $a^x$ 的导数</h2><h3 id=\"e底法\"><a href=\"#e底法\" class=\"headerlink\" title=\"e底法\"></a>e底法</h3><p>将 $a^x$ 转换为以 e 为底的指数。</p>\n<p>因为 $a = e^{ln a}$，代入得</p>\n<p>$$<br>\\begin{align}<br>\\cfrac{d}{dx}a^x &amp;= \\cfrac{d}{dx}(e^{\\ln a})^x \\\\<br>&amp;= \\cfrac{d}{dx} e^{x\\ln a} \\\\<br>&amp;= \\ln a \\cdot e^{x\\ln a} \\\\<br>&amp;= \\ln a \\cdot a^x<br>\\end{align}<br>$$</p>\n<blockquote>\n<p>而 $\\cfrac{d}{dx} a^x = a^x \\cdot M(a)$，所以，$M(a) = ln a$</p>\n</blockquote>\n<h3 id=\"对数微分法\"><a href=\"#对数微分法\" class=\"headerlink\" title=\"对数微分法\"></a>对数微分法</h3><p>对某些函数而言，求其对数的导数比求该函数本身的导数更简单。</p>\n<p>设有函数 u，现要求其导数 $\\cfrac{d}{dx} u$，那么</p>\n<p>$$<br>\\begin{align}<br>\\cfrac{d}{dx} \\ln u &amp;= \\cfrac{d}{du} \\ln u \\cdot \\cfrac{d}{dx} u \\\\<br>&amp;= \\cfrac{u’}{u}<br>\\end{align}<br>$$</p>\n<p>对 $a^x$ 而言，设 $u = a^x$，由对数的性质，$\\ln u = \\ln a^x = x\\ln a$，那么 $(\\ln u)’ = \\ln a$</p>\n<p>而 $\\cfrac{d}{dx} \\ln u = \\cfrac{u’}{u}$，所以即</p>\n<p>$$<br>\\begin{align}<br>\\cfrac{u’}{u} &amp;= \\ln a \\\\<br>u’ &amp;= u \\ln a \\\\<br>&amp;= a^x \\ln a<br>\\end{align}<br>$$</p>\n<h2 id=\"几个栗子\"><a href=\"#几个栗子\" class=\"headerlink\" title=\"几个栗子\"></a>几个栗子</h2><h3 id=\"1-x-a\"><a href=\"#1-x-a\" class=\"headerlink\" title=\"1) $x^a$\"></a>1) $x^a$</h3><p>之前已经讨论过求导 $x^a$，a 为有理数情况，实际上求导公式对无理数同样适用</p>\n<h4 id=\"e-底法\"><a href=\"#e-底法\" class=\"headerlink\" title=\"e 底法\"></a>e 底法</h4><p>$$<br>\\begin{align}<br>x^a &amp;= (e^{\\ln x})^a \\\\<br>&amp;= e^{a \\ln x} \\\\<br>(e^{a \\ln x})’ &amp;= e^{a \\ln x} \\cdot \\frac{a}{x} \\\\<br>&amp;= x^a \\cdot \\frac{a}{x} \\\\<br>&amp;= ax^{a - 1}<br>\\end{align}<br>$$</p>\n<h4 id=\"对数微分法-1\"><a href=\"#对数微分法-1\" class=\"headerlink\" title=\"对数微分法\"></a>对数微分法</h4><p>$$<br>\\begin{align}<br>u &amp;= x^a \\\\<br>\\ln u &amp;= a \\ln x \\\\<br>(\\ln u)’ &amp;= \\frac{a}{x} \\\\<br>\\frac{u’}{u} &amp;= \\frac{a}{x} \\\\<br>u’ &amp;= u \\frac{a}{x} \\\\<br>&amp;= x^a \\frac{a}{x} \\\\<br>&amp;= ax^{a - 1}<br>\\end{align}<br>$$</p>\n<h3 id=\"2-x-x\"><a href=\"#2-x-x\" class=\"headerlink\" title=\"2) $x^x$\"></a>2) $x^x$</h3><p>求 $x^x$ 的导数</p>\n<p>$$<br>\\begin{align}<br>v &amp;= x^x \\\\<br>\\ln v &amp;= x \\ln x \\\\<br>\\cfrac{v’}{v} &amp;= \\ln x + x \\cdot \\cfrac{1}{x} \\\\<br>&amp;= \\ln x + 1 \\\\<br>v’ &amp;= v \\cdot (\\ln x + 1) \\\\<br>&amp;= x^x(\\ln x + 1)<br>\\end{align}<br>$$</p>\n<h3 id=\"3-例-3\"><a href=\"#3-例-3\" class=\"headerlink\" title=\"3) 例 3\"></a>3) 例 3</h3><p>求 $\\lim_{n \\to \\infty} (1 + \\frac{1}{n})^n$</p>\n<p>对函数取对数，得 $\\ln (1 + \\frac{1}{n})^n = n \\ln(1 + \\frac{1}{n})$</p>\n<p>设 $\\Delta x = \\frac{1}{n}$，因为 $n \\to \\infty$，所以 $\\Delta x \\to 0$</p>\n<p>$$<br>\\begin{align}<br>\\lim_{n \\to \\infty} n \\ln(1 + \\frac{1}{n}) &amp;= \\lim_{\\Delta x \\to 0} \\frac{1}{\\Delta x} \\ln (1 + \\Delta x) \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\cfrac{\\ln(1 + \\Delta x) - \\ln 1}{\\Delta x} \\\\<br>\\end{align}<br>$$</p>\n<p>即 $\\ln x$ 在 x = 1 处的导数，而 $\\left. (\\ln x)’ \\right|_{x = 1} = \\left. \\frac{1}{x} \\right|_{x = 1} = 1$，即 $\\lim_{\\Delta x \\to 0} \\ln (1 + \\frac{1}{n})^n = 1$，而</p>\n<p>$$<br>\\begin{align}<br>\\lim_{n \\to \\infty} (1 + \\frac{1}{n})^n &amp;= \\lim_{n \\to \\infty} e^{\\ln (1 + \\frac{1}{n})^n} \\\\<br>&amp;= e^{\\lim_{n \\to \\infty} \\ln (1 + \\frac{1}{n})^n} \\\\<br>&amp;= e<br>\\end{align}<br>$$</p>\n<p>这也就是说，神秘的 $e = \\lim_{n \\to \\infty}(1 + \\frac{1}{n})^n$</p>\n","excerpt":"<p>使用 e 底法和对数微分法求解指数与对数函数导数。</p>","more":"<h2 id=\"a-x\"><a href=\"#a-x\" class=\"headerlink\" title=\"$a^x$\"></a>$a^x$</h2><p>试求 $a^x$ 的导数。</p>\n<p>$$<br>\\begin{align}<br>\\cfrac{d}{dx} a^x &amp;= \\lim_{\\Delta x \\to 0} \\cfrac{a^{x + \\Delta x} - a^x}{\\Delta x} \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} a^x \\cfrac{a^{\\Delta x} - 1}{\\Delta x}<br>\\end{align}<br>$$</p>\n<p>即 $\\cfrac{d}{dx} = a^x \\lim_{\\Delta x \\to 0} \\cfrac{a^{\\Delta x} - 1}{\\Delta x}$</p>\n<p>而 $\\lim_{\\Delta x \\to 0} \\cfrac{a^{\\Delta x} - 1}{\\Delta x}$ 实际上就是 $a^x$ 在 x = 0 处的导数，只要我们知道了在这个点处的导数，我们就能得到整个函数的导数，这和求 $\\sin$、$\\cos$ 的导数时如出一辙，但是很不幸的，我们并不知道这个点出的导数。</p>\n<h3 id=\"引入神秘的-e\"><a href=\"#引入神秘的-e\" class=\"headerlink\" title=\"引入神秘的 e\"></a>引入神秘的 e</h3><p>设 $\\lim_{\\Delta x \\to 0} \\cfrac{a^{\\Delta x} - 1}{\\Delta x}$ 为关于 a 的函数 $M(a)$，不妨设存在一个数 e，使得 $M(e) = 1$</p>\n<p>那么，$\\cfrac{d}{d} e^x = e^x \\cdot M(e) = e^x$，且 $\\left. \\cfrac{d}{d} e^x \\right|_{x = 0} = 1$</p>\n<p>注意，虽然我们到现在还不知道 e 是什么数，但我们可以先利用 e 得到一些公式，随后再求解 e。</p>\n<h2 id=\"自然对数\"><a href=\"#自然对数\" class=\"headerlink\" title=\"自然对数\"></a>自然对数</h2><p>以 e 为底数的对数叫做自然对数，记为 $\\ln$，且</p>\n<p>$$<br>\\begin{align}<br>\\ln (a + b) &amp;= \\ln a + \\ln b \\\\<br>\\ln a^n &amp;= n\\ln a<br>\\end{align}<br>$$</p>\n<h3 id=\"ln-x-的导数\"><a href=\"#ln-x-的导数\" class=\"headerlink\" title=\"$\\ln x$ 的导数\"></a>$\\ln x$ 的导数</h3><p>$$<br>\\begin{align}<br>w &amp;= \\ln x \\\\<br>e^w &amp;= x \\\\<br>e^w \\cdot w’ &amp;= 1 \\\\<br>w’ &amp;= \\frac{1}{e^w} \\\\<br>&amp;= \\frac{1}{x}<br>\\end{align}<br>$$</p>\n<p>即 $(\\ln x)’ = \\cfrac{1}{x}$</p>\n<h2 id=\"求解-a-x-的导数\"><a href=\"#求解-a-x-的导数\" class=\"headerlink\" title=\"求解 $a^x$ 的导数\"></a>求解 $a^x$ 的导数</h2><h3 id=\"e底法\"><a href=\"#e底法\" class=\"headerlink\" title=\"e底法\"></a>e底法</h3><p>将 $a^x$ 转换为以 e 为底的指数。</p>\n<p>因为 $a = e^{ln a}$，代入得</p>\n<p>$$<br>\\begin{align}<br>\\cfrac{d}{dx}a^x &amp;= \\cfrac{d}{dx}(e^{\\ln a})^x \\\\<br>&amp;= \\cfrac{d}{dx} e^{x\\ln a} \\\\<br>&amp;= \\ln a \\cdot e^{x\\ln a} \\\\<br>&amp;= \\ln a \\cdot a^x<br>\\end{align}<br>$$</p>\n<blockquote>\n<p>而 $\\cfrac{d}{dx} a^x = a^x \\cdot M(a)$，所以，$M(a) = ln a$</p>\n</blockquote>\n<h3 id=\"对数微分法\"><a href=\"#对数微分法\" class=\"headerlink\" title=\"对数微分法\"></a>对数微分法</h3><p>对某些函数而言，求其对数的导数比求该函数本身的导数更简单。</p>\n<p>设有函数 u，现要求其导数 $\\cfrac{d}{dx} u$，那么</p>\n<p>$$<br>\\begin{align}<br>\\cfrac{d}{dx} \\ln u &amp;= \\cfrac{d}{du} \\ln u \\cdot \\cfrac{d}{dx} u \\\\<br>&amp;= \\cfrac{u’}{u}<br>\\end{align}<br>$$</p>\n<p>对 $a^x$ 而言，设 $u = a^x$，由对数的性质，$\\ln u = \\ln a^x = x\\ln a$，那么 $(\\ln u)’ = \\ln a$</p>\n<p>而 $\\cfrac{d}{dx} \\ln u = \\cfrac{u’}{u}$，所以即</p>\n<p>$$<br>\\begin{align}<br>\\cfrac{u’}{u} &amp;= \\ln a \\\\<br>u’ &amp;= u \\ln a \\\\<br>&amp;= a^x \\ln a<br>\\end{align}<br>$$</p>\n<h2 id=\"几个栗子\"><a href=\"#几个栗子\" class=\"headerlink\" title=\"几个栗子\"></a>几个栗子</h2><h3 id=\"1-x-a\"><a href=\"#1-x-a\" class=\"headerlink\" title=\"1) $x^a$\"></a>1) $x^a$</h3><p>之前已经讨论过求导 $x^a$，a 为有理数情况，实际上求导公式对无理数同样适用</p>\n<h4 id=\"e-底法\"><a href=\"#e-底法\" class=\"headerlink\" title=\"e 底法\"></a>e 底法</h4><p>$$<br>\\begin{align}<br>x^a &amp;= (e^{\\ln x})^a \\\\<br>&amp;= e^{a \\ln x} \\\\<br>(e^{a \\ln x})’ &amp;= e^{a \\ln x} \\cdot \\frac{a}{x} \\\\<br>&amp;= x^a \\cdot \\frac{a}{x} \\\\<br>&amp;= ax^{a - 1}<br>\\end{align}<br>$$</p>\n<h4 id=\"对数微分法-1\"><a href=\"#对数微分法-1\" class=\"headerlink\" title=\"对数微分法\"></a>对数微分法</h4><p>$$<br>\\begin{align}<br>u &amp;= x^a \\\\<br>\\ln u &amp;= a \\ln x \\\\<br>(\\ln u)’ &amp;= \\frac{a}{x} \\\\<br>\\frac{u’}{u} &amp;= \\frac{a}{x} \\\\<br>u’ &amp;= u \\frac{a}{x} \\\\<br>&amp;= x^a \\frac{a}{x} \\\\<br>&amp;= ax^{a - 1}<br>\\end{align}<br>$$</p>\n<h3 id=\"2-x-x\"><a href=\"#2-x-x\" class=\"headerlink\" title=\"2) $x^x$\"></a>2) $x^x$</h3><p>求 $x^x$ 的导数</p>\n<p>$$<br>\\begin{align}<br>v &amp;= x^x \\\\<br>\\ln v &amp;= x \\ln x \\\\<br>\\cfrac{v’}{v} &amp;= \\ln x + x \\cdot \\cfrac{1}{x} \\\\<br>&amp;= \\ln x + 1 \\\\<br>v’ &amp;= v \\cdot (\\ln x + 1) \\\\<br>&amp;= x^x(\\ln x + 1)<br>\\end{align}<br>$$</p>\n<h3 id=\"3-例-3\"><a href=\"#3-例-3\" class=\"headerlink\" title=\"3) 例 3\"></a>3) 例 3</h3><p>求 $\\lim_{n \\to \\infty} (1 + \\frac{1}{n})^n$</p>\n<p>对函数取对数，得 $\\ln (1 + \\frac{1}{n})^n = n \\ln(1 + \\frac{1}{n})$</p>\n<p>设 $\\Delta x = \\frac{1}{n}$，因为 $n \\to \\infty$，所以 $\\Delta x \\to 0$</p>\n<p>$$<br>\\begin{align}<br>\\lim_{n \\to \\infty} n \\ln(1 + \\frac{1}{n}) &amp;= \\lim_{\\Delta x \\to 0} \\frac{1}{\\Delta x} \\ln (1 + \\Delta x) \\\\<br>&amp;= \\lim_{\\Delta x \\to 0} \\cfrac{\\ln(1 + \\Delta x) - \\ln 1}{\\Delta x} \\\\<br>\\end{align}<br>$$</p>\n<p>即 $\\ln x$ 在 x = 1 处的导数，而 $\\left. (\\ln x)’ \\right|_{x = 1} = \\left. \\frac{1}{x} \\right|_{x = 1} = 1$，即 $\\lim_{\\Delta x \\to 0} \\ln (1 + \\frac{1}{n})^n = 1$，而</p>\n<p>$$<br>\\begin{align}<br>\\lim_{n \\to \\infty} (1 + \\frac{1}{n})^n &amp;= \\lim_{n \\to \\infty} e^{\\ln (1 + \\frac{1}{n})^n} \\\\<br>&amp;= e^{\\lim_{n \\to \\infty} \\ln (1 + \\frac{1}{n})^n} \\\\<br>&amp;= e<br>\\end{align}<br>$$</p>\n<p>这也就是说，神秘的 $e = \\lim_{n \\to \\infty}(1 + \\frac{1}{n})^n$</p>"},{"title":"Express 权限控制","date":"2016-10-25T02:28:57.000Z","_content":"\nExpress 是一个路由和中间件 Web 框架，其自身只具有最低程度的功能：Express 应用程序基本上是一系列中间件函数调用。\n\n所谓的控制权限实际上是将资源和路由对应起来，当进入特定路由时，对用户进行权限判定。\n\n<!-- more -->\n\n项目结构参考 [[译\\]Express应用结构的最佳实践](https://segmentfault.com/a/1190000004019233)\n\n## 路由\n\n首先路由的划分应该尽可能清晰：\n\n```\n├── controllers\n│   ├── fr\n│   │   └── index.js\n│   ├── report\n│   │   └── index.js\n│   ├── user\n│   │   └── index.js\n│   └── index.js\n└── app.js\n```\n\nindex.js 是路由的入口文件，用来引用子路由以及一些没有常规前缀的路由，如首页路由。\n\n### index.js\n\n```javascript\nconst express = require('express');\nconst auth = require('../middlewares/auth');\nconst user = require('./user');\nconst fr = require('./fr');\nconst report = require('./report');\nconst router = express.Router();\n\nrouter.use(auth);\nrouter.use('/user', user);\nrouter.use('/fr', fr);\nrouter.use('/report', report);\n\nmodule.exports = router;\n```\n\n当有请求进入匹配的路由时，Express 按路由定义的先后顺序加载中间件，这也就是说，当用户请求 `/user/get` 的时候，必定会加载 `/user` 这个路由（如果这两个路由都定义过）。所以，我们可以在根路由下设置中间件，在这个中间件里控制权限。**即上面代码中的 auth**\n\n## 权限控制\n\nauth 实际上就是一个中间件，只不过这个中间件是其他所有中间件的入口。\n\n### auth.js\n\n```javascript\n'use strict';\n\nconst express = require('express');\nconst router = express.Router();\nconst user = require('../models/user');\nconst url = require('url');\n\nconst whiteAPI = ['/health', '/user/login', '/user/logout'];\n\nmodule.exports = function(req, res, next) {\n\n  let session = req.session;\n\n  // 请求路由\n  let route = url.parse(req.url).pathname;\n\n  // 无须登录的接口\n  if(whiteAPI.indexOf(route) !== -1) {\n    next();\n    return;\n  }\n\n  let username = session.username;\n\n  // 判断是否登录\n  if(!username) {\n    // 未登录\n    res.send({\n      status: 401,\n      message: '未登录'\n    })\n    return;\n  }\n\n  // 检查权限\n  user.get(username).then(info => {\n    let permission = info.permission;\n    for(let p of permission) {\n      let reg = new RegExp(p);\n      if(reg.test(route)) {\n        next();\n        return;\n      }\n    }\n    \n    // 没有权限\n    res.send({\n      status: 403,\n      message: '没有访问权限'\n    })\n  }).catch(err => {\n    res.send({\n      status: 500,\n      message: err.message\n    })\n  });\n}\n```\n\n如果没有权限或没有登录，直接返回错误状态，否则通过 `next()` 放行至下个路由。\n\n## 用户状态保存\n\n上面使用了 `session` 来保存用户信息，在express 中使用 session 可以引用 `express-session` 库。github 地址：[express-session](https://github.com/expressjs/session)\n\n### app.js\n\n```javascript\nvar session = require('express-session');\nvar RedisStore = require('connect-redis')(session);\nvar redis = require('redis');\nvar redisClient = redis.createClient({\n  host: 'your redis host',\n  port: 6379,\n  password: 'your redis password'\n});\n\n// 路由\nvar router = require('./controllers');\n\nvar app = express();\n\n// session\napp.use(session({\n  secret: 'your secret',\n  // rolling: 每次请求都重新设置session cookie，即假设你的cookie是10分钟过期，每次请求都会再设置10分钟\n  rolling: false,\n  saveUninitialized: false,\n  store: new RedisStore({\n    client: redisClient\n  }),\n  cookie: {\n    maxAge: 1 * 24 * 60 * 60 * 1000\n  }\n}));\n```\n\nexpress-session 默认是使用内存存储 session，所以一重启服务用户的状态就丢了，推荐使用 redis 或者 mongodb 来存储。上面例子使用了 redis。\n\n## 注意\n\n另外需要注意的是，如果前端是使用 ajax 进行请求，需要在 request 中带上 `withCredentials = true;`，并在服务端设置响应头 `Access-Control-Allow-Credentials: true`。\n\n```javascript\nres.setHeader('Access-Control-Allow-Origin', config.cors.origin);\nres.setHeader('Access-Control-Allow-Credentials', true);\n```\n\n","source":"_posts/express-permission.md","raw":"---\ntitle: Express 权限控制\ndate: 2016-10-25 10:28:57\ntags: [nodejs, express]\n---\n\nExpress 是一个路由和中间件 Web 框架，其自身只具有最低程度的功能：Express 应用程序基本上是一系列中间件函数调用。\n\n所谓的控制权限实际上是将资源和路由对应起来，当进入特定路由时，对用户进行权限判定。\n\n<!-- more -->\n\n项目结构参考 [[译\\]Express应用结构的最佳实践](https://segmentfault.com/a/1190000004019233)\n\n## 路由\n\n首先路由的划分应该尽可能清晰：\n\n```\n├── controllers\n│   ├── fr\n│   │   └── index.js\n│   ├── report\n│   │   └── index.js\n│   ├── user\n│   │   └── index.js\n│   └── index.js\n└── app.js\n```\n\nindex.js 是路由的入口文件，用来引用子路由以及一些没有常规前缀的路由，如首页路由。\n\n### index.js\n\n```javascript\nconst express = require('express');\nconst auth = require('../middlewares/auth');\nconst user = require('./user');\nconst fr = require('./fr');\nconst report = require('./report');\nconst router = express.Router();\n\nrouter.use(auth);\nrouter.use('/user', user);\nrouter.use('/fr', fr);\nrouter.use('/report', report);\n\nmodule.exports = router;\n```\n\n当有请求进入匹配的路由时，Express 按路由定义的先后顺序加载中间件，这也就是说，当用户请求 `/user/get` 的时候，必定会加载 `/user` 这个路由（如果这两个路由都定义过）。所以，我们可以在根路由下设置中间件，在这个中间件里控制权限。**即上面代码中的 auth**\n\n## 权限控制\n\nauth 实际上就是一个中间件，只不过这个中间件是其他所有中间件的入口。\n\n### auth.js\n\n```javascript\n'use strict';\n\nconst express = require('express');\nconst router = express.Router();\nconst user = require('../models/user');\nconst url = require('url');\n\nconst whiteAPI = ['/health', '/user/login', '/user/logout'];\n\nmodule.exports = function(req, res, next) {\n\n  let session = req.session;\n\n  // 请求路由\n  let route = url.parse(req.url).pathname;\n\n  // 无须登录的接口\n  if(whiteAPI.indexOf(route) !== -1) {\n    next();\n    return;\n  }\n\n  let username = session.username;\n\n  // 判断是否登录\n  if(!username) {\n    // 未登录\n    res.send({\n      status: 401,\n      message: '未登录'\n    })\n    return;\n  }\n\n  // 检查权限\n  user.get(username).then(info => {\n    let permission = info.permission;\n    for(let p of permission) {\n      let reg = new RegExp(p);\n      if(reg.test(route)) {\n        next();\n        return;\n      }\n    }\n    \n    // 没有权限\n    res.send({\n      status: 403,\n      message: '没有访问权限'\n    })\n  }).catch(err => {\n    res.send({\n      status: 500,\n      message: err.message\n    })\n  });\n}\n```\n\n如果没有权限或没有登录，直接返回错误状态，否则通过 `next()` 放行至下个路由。\n\n## 用户状态保存\n\n上面使用了 `session` 来保存用户信息，在express 中使用 session 可以引用 `express-session` 库。github 地址：[express-session](https://github.com/expressjs/session)\n\n### app.js\n\n```javascript\nvar session = require('express-session');\nvar RedisStore = require('connect-redis')(session);\nvar redis = require('redis');\nvar redisClient = redis.createClient({\n  host: 'your redis host',\n  port: 6379,\n  password: 'your redis password'\n});\n\n// 路由\nvar router = require('./controllers');\n\nvar app = express();\n\n// session\napp.use(session({\n  secret: 'your secret',\n  // rolling: 每次请求都重新设置session cookie，即假设你的cookie是10分钟过期，每次请求都会再设置10分钟\n  rolling: false,\n  saveUninitialized: false,\n  store: new RedisStore({\n    client: redisClient\n  }),\n  cookie: {\n    maxAge: 1 * 24 * 60 * 60 * 1000\n  }\n}));\n```\n\nexpress-session 默认是使用内存存储 session，所以一重启服务用户的状态就丢了，推荐使用 redis 或者 mongodb 来存储。上面例子使用了 redis。\n\n## 注意\n\n另外需要注意的是，如果前端是使用 ajax 进行请求，需要在 request 中带上 `withCredentials = true;`，并在服务端设置响应头 `Access-Control-Allow-Credentials: true`。\n\n```javascript\nres.setHeader('Access-Control-Allow-Origin', config.cors.origin);\nres.setHeader('Access-Control-Allow-Credentials', true);\n```\n\n","slug":"express-permission","published":1,"updated":"2017-03-17T13:40:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcvx001cn927konigf91","content":"<p>Express 是一个路由和中间件 Web 框架，其自身只具有最低程度的功能：Express 应用程序基本上是一系列中间件函数调用。</p>\n<p>所谓的控制权限实际上是将资源和路由对应起来，当进入特定路由时，对用户进行权限判定。</p>\n<a id=\"more\"></a>\n<p>项目结构参考 <a href=\"https://segmentfault.com/a/1190000004019233\" target=\"_blank\" rel=\"external\">[译]Express应用结构的最佳实践</a></p>\n<h2 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h2><p>首先路由的划分应该尽可能清晰：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">├── controllers</div><div class=\"line\">│   ├── fr</div><div class=\"line\">│   │   └── index.js</div><div class=\"line\">│   ├── report</div><div class=\"line\">│   │   └── index.js</div><div class=\"line\">│   ├── user</div><div class=\"line\">│   │   └── index.js</div><div class=\"line\">│   └── index.js</div><div class=\"line\">└── app.js</div></pre></td></tr></table></figure>\n<p>index.js 是路由的入口文件，用来引用子路由以及一些没有常规前缀的路由，如首页路由。</p>\n<h3 id=\"index-js\"><a href=\"#index-js\" class=\"headerlink\" title=\"index.js\"></a>index.js</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> auth = <span class=\"built_in\">require</span>(<span class=\"string\">'../middlewares/auth'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> user = <span class=\"built_in\">require</span>(<span class=\"string\">'./user'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> fr = <span class=\"built_in\">require</span>(<span class=\"string\">'./fr'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> report = <span class=\"built_in\">require</span>(<span class=\"string\">'./report'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> router = express.Router();</div><div class=\"line\"></div><div class=\"line\">router.use(auth);</div><div class=\"line\">router.use(<span class=\"string\">'/user'</span>, user);</div><div class=\"line\">router.use(<span class=\"string\">'/fr'</span>, fr);</div><div class=\"line\">router.use(<span class=\"string\">'/report'</span>, report);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = router;</div></pre></td></tr></table></figure>\n<p>当有请求进入匹配的路由时，Express 按路由定义的先后顺序加载中间件，这也就是说，当用户请求 <code>/user/get</code> 的时候，必定会加载 <code>/user</code> 这个路由（如果这两个路由都定义过）。所以，我们可以在根路由下设置中间件，在这个中间件里控制权限。<strong>即上面代码中的 auth</strong></p>\n<h2 id=\"权限控制\"><a href=\"#权限控制\" class=\"headerlink\" title=\"权限控制\"></a>权限控制</h2><p>auth 实际上就是一个中间件，只不过这个中间件是其他所有中间件的入口。</p>\n<h3 id=\"auth-js\"><a href=\"#auth-js\" class=\"headerlink\" title=\"auth.js\"></a>auth.js</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> router = express.Router();</div><div class=\"line\"><span class=\"keyword\">const</span> user = <span class=\"built_in\">require</span>(<span class=\"string\">'../models/user'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">'url'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> whiteAPI = [<span class=\"string\">'/health'</span>, <span class=\"string\">'/user/login'</span>, <span class=\"string\">'/user/logout'</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">let</span> session = req.session;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 请求路由</span></div><div class=\"line\">  <span class=\"keyword\">let</span> route = url.parse(req.url).pathname;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 无须登录的接口</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(whiteAPI.indexOf(route) !== <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">    next();</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">let</span> username = session.username;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 判断是否登录</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(!username) &#123;</div><div class=\"line\">    <span class=\"comment\">// 未登录</span></div><div class=\"line\">    res.send(&#123;</div><div class=\"line\">      <span class=\"attr\">status</span>: <span class=\"number\">401</span>,</div><div class=\"line\">      <span class=\"attr\">message</span>: <span class=\"string\">'未登录'</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 检查权限</span></div><div class=\"line\">  user.get(username).then(<span class=\"function\"><span class=\"params\">info</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> permission = info.permission;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> p <span class=\"keyword\">of</span> permission) &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> reg = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(p);</div><div class=\"line\">      <span class=\"keyword\">if</span>(reg.test(route)) &#123;</div><div class=\"line\">        next();</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 没有权限</span></div><div class=\"line\">    res.send(&#123;</div><div class=\"line\">      <span class=\"attr\">status</span>: <span class=\"number\">403</span>,</div><div class=\"line\">      <span class=\"attr\">message</span>: <span class=\"string\">'没有访问权限'</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;).catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</div><div class=\"line\">    res.send(&#123;</div><div class=\"line\">      <span class=\"attr\">status</span>: <span class=\"number\">500</span>,</div><div class=\"line\">      <span class=\"attr\">message</span>: err.message</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果没有权限或没有登录，直接返回错误状态，否则通过 <code>next()</code> 放行至下个路由。</p>\n<h2 id=\"用户状态保存\"><a href=\"#用户状态保存\" class=\"headerlink\" title=\"用户状态保存\"></a>用户状态保存</h2><p>上面使用了 <code>session</code> 来保存用户信息，在express 中使用 session 可以引用 <code>express-session</code> 库。github 地址：<a href=\"https://github.com/expressjs/session\" target=\"_blank\" rel=\"external\">express-session</a></p>\n<h3 id=\"app-js\"><a href=\"#app-js\" class=\"headerlink\" title=\"app.js\"></a>app.js</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> session = <span class=\"built_in\">require</span>(<span class=\"string\">'express-session'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> RedisStore = <span class=\"built_in\">require</span>(<span class=\"string\">'connect-redis'</span>)(session);</div><div class=\"line\"><span class=\"keyword\">var</span> redis = <span class=\"built_in\">require</span>(<span class=\"string\">'redis'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> redisClient = redis.createClient(&#123;</div><div class=\"line\">  <span class=\"attr\">host</span>: <span class=\"string\">'your redis host'</span>,</div><div class=\"line\">  <span class=\"attr\">port</span>: <span class=\"number\">6379</span>,</div><div class=\"line\">  <span class=\"attr\">password</span>: <span class=\"string\">'your redis password'</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 路由</span></div><div class=\"line\"><span class=\"keyword\">var</span> router = <span class=\"built_in\">require</span>(<span class=\"string\">'./controllers'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> app = express();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// session</span></div><div class=\"line\">app.use(session(&#123;</div><div class=\"line\">  <span class=\"attr\">secret</span>: <span class=\"string\">'your secret'</span>,</div><div class=\"line\">  <span class=\"comment\">// rolling: 每次请求都重新设置session cookie，即假设你的cookie是10分钟过期，每次请求都会再设置10分钟</span></div><div class=\"line\">  rolling: <span class=\"literal\">false</span>,</div><div class=\"line\">  <span class=\"attr\">saveUninitialized</span>: <span class=\"literal\">false</span>,</div><div class=\"line\">  <span class=\"attr\">store</span>: <span class=\"keyword\">new</span> RedisStore(&#123;</div><div class=\"line\">    <span class=\"attr\">client</span>: redisClient</div><div class=\"line\">  &#125;),</div><div class=\"line\">  <span class=\"attr\">cookie</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">maxAge</span>: <span class=\"number\">1</span> * <span class=\"number\">24</span> * <span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">1000</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;));</div></pre></td></tr></table></figure>\n<p>express-session 默认是使用内存存储 session，所以一重启服务用户的状态就丢了，推荐使用 redis 或者 mongodb 来存储。上面例子使用了 redis。</p>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><p>另外需要注意的是，如果前端是使用 ajax 进行请求，需要在 request 中带上 <code>withCredentials = true;</code>，并在服务端设置响应头 <code>Access-Control-Allow-Credentials: true</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">res.setHeader(<span class=\"string\">'Access-Control-Allow-Origin'</span>, config.cors.origin);</div><div class=\"line\">res.setHeader(<span class=\"string\">'Access-Control-Allow-Credentials'</span>, <span class=\"literal\">true</span>);</div></pre></td></tr></table></figure>\n","excerpt":"<p>Express 是一个路由和中间件 Web 框架，其自身只具有最低程度的功能：Express 应用程序基本上是一系列中间件函数调用。</p>\n<p>所谓的控制权限实际上是将资源和路由对应起来，当进入特定路由时，对用户进行权限判定。</p>","more":"<p>项目结构参考 <a href=\"https://segmentfault.com/a/1190000004019233\">[译]Express应用结构的最佳实践</a></p>\n<h2 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h2><p>首先路由的划分应该尽可能清晰：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">├── controllers</div><div class=\"line\">│   ├── fr</div><div class=\"line\">│   │   └── index.js</div><div class=\"line\">│   ├── report</div><div class=\"line\">│   │   └── index.js</div><div class=\"line\">│   ├── user</div><div class=\"line\">│   │   └── index.js</div><div class=\"line\">│   └── index.js</div><div class=\"line\">└── app.js</div></pre></td></tr></table></figure>\n<p>index.js 是路由的入口文件，用来引用子路由以及一些没有常规前缀的路由，如首页路由。</p>\n<h3 id=\"index-js\"><a href=\"#index-js\" class=\"headerlink\" title=\"index.js\"></a>index.js</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> auth = <span class=\"built_in\">require</span>(<span class=\"string\">'../middlewares/auth'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> user = <span class=\"built_in\">require</span>(<span class=\"string\">'./user'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> fr = <span class=\"built_in\">require</span>(<span class=\"string\">'./fr'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> report = <span class=\"built_in\">require</span>(<span class=\"string\">'./report'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> router = express.Router();</div><div class=\"line\"></div><div class=\"line\">router.use(auth);</div><div class=\"line\">router.use(<span class=\"string\">'/user'</span>, user);</div><div class=\"line\">router.use(<span class=\"string\">'/fr'</span>, fr);</div><div class=\"line\">router.use(<span class=\"string\">'/report'</span>, report);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = router;</div></pre></td></tr></table></figure>\n<p>当有请求进入匹配的路由时，Express 按路由定义的先后顺序加载中间件，这也就是说，当用户请求 <code>/user/get</code> 的时候，必定会加载 <code>/user</code> 这个路由（如果这两个路由都定义过）。所以，我们可以在根路由下设置中间件，在这个中间件里控制权限。<strong>即上面代码中的 auth</strong></p>\n<h2 id=\"权限控制\"><a href=\"#权限控制\" class=\"headerlink\" title=\"权限控制\"></a>权限控制</h2><p>auth 实际上就是一个中间件，只不过这个中间件是其他所有中间件的入口。</p>\n<h3 id=\"auth-js\"><a href=\"#auth-js\" class=\"headerlink\" title=\"auth.js\"></a>auth.js</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> router = express.Router();</div><div class=\"line\"><span class=\"keyword\">const</span> user = <span class=\"built_in\">require</span>(<span class=\"string\">'../models/user'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">'url'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> whiteAPI = [<span class=\"string\">'/health'</span>, <span class=\"string\">'/user/login'</span>, <span class=\"string\">'/user/logout'</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">let</span> session = req.session;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 请求路由</span></div><div class=\"line\">  <span class=\"keyword\">let</span> route = url.parse(req.url).pathname;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 无须登录的接口</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(whiteAPI.indexOf(route) !== <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">    next();</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">let</span> username = session.username;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 判断是否登录</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(!username) &#123;</div><div class=\"line\">    <span class=\"comment\">// 未登录</span></div><div class=\"line\">    res.send(&#123;</div><div class=\"line\">      <span class=\"attr\">status</span>: <span class=\"number\">401</span>,</div><div class=\"line\">      <span class=\"attr\">message</span>: <span class=\"string\">'未登录'</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 检查权限</span></div><div class=\"line\">  user.get(username).then(<span class=\"function\"><span class=\"params\">info</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> permission = info.permission;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> p <span class=\"keyword\">of</span> permission) &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> reg = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(p);</div><div class=\"line\">      <span class=\"keyword\">if</span>(reg.test(route)) &#123;</div><div class=\"line\">        next();</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 没有权限</span></div><div class=\"line\">    res.send(&#123;</div><div class=\"line\">      <span class=\"attr\">status</span>: <span class=\"number\">403</span>,</div><div class=\"line\">      <span class=\"attr\">message</span>: <span class=\"string\">'没有访问权限'</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;).catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</div><div class=\"line\">    res.send(&#123;</div><div class=\"line\">      <span class=\"attr\">status</span>: <span class=\"number\">500</span>,</div><div class=\"line\">      <span class=\"attr\">message</span>: err.message</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果没有权限或没有登录，直接返回错误状态，否则通过 <code>next()</code> 放行至下个路由。</p>\n<h2 id=\"用户状态保存\"><a href=\"#用户状态保存\" class=\"headerlink\" title=\"用户状态保存\"></a>用户状态保存</h2><p>上面使用了 <code>session</code> 来保存用户信息，在express 中使用 session 可以引用 <code>express-session</code> 库。github 地址：<a href=\"https://github.com/expressjs/session\">express-session</a></p>\n<h3 id=\"app-js\"><a href=\"#app-js\" class=\"headerlink\" title=\"app.js\"></a>app.js</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> session = <span class=\"built_in\">require</span>(<span class=\"string\">'express-session'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> RedisStore = <span class=\"built_in\">require</span>(<span class=\"string\">'connect-redis'</span>)(session);</div><div class=\"line\"><span class=\"keyword\">var</span> redis = <span class=\"built_in\">require</span>(<span class=\"string\">'redis'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> redisClient = redis.createClient(&#123;</div><div class=\"line\">  <span class=\"attr\">host</span>: <span class=\"string\">'your redis host'</span>,</div><div class=\"line\">  <span class=\"attr\">port</span>: <span class=\"number\">6379</span>,</div><div class=\"line\">  <span class=\"attr\">password</span>: <span class=\"string\">'your redis password'</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 路由</span></div><div class=\"line\"><span class=\"keyword\">var</span> router = <span class=\"built_in\">require</span>(<span class=\"string\">'./controllers'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> app = express();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// session</span></div><div class=\"line\">app.use(session(&#123;</div><div class=\"line\">  <span class=\"attr\">secret</span>: <span class=\"string\">'your secret'</span>,</div><div class=\"line\">  <span class=\"comment\">// rolling: 每次请求都重新设置session cookie，即假设你的cookie是10分钟过期，每次请求都会再设置10分钟</span></div><div class=\"line\">  rolling: <span class=\"literal\">false</span>,</div><div class=\"line\">  <span class=\"attr\">saveUninitialized</span>: <span class=\"literal\">false</span>,</div><div class=\"line\">  <span class=\"attr\">store</span>: <span class=\"keyword\">new</span> RedisStore(&#123;</div><div class=\"line\">    <span class=\"attr\">client</span>: redisClient</div><div class=\"line\">  &#125;),</div><div class=\"line\">  <span class=\"attr\">cookie</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">maxAge</span>: <span class=\"number\">1</span> * <span class=\"number\">24</span> * <span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">1000</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;));</div></pre></td></tr></table></figure>\n<p>express-session 默认是使用内存存储 session，所以一重启服务用户的状态就丢了，推荐使用 redis 或者 mongodb 来存储。上面例子使用了 redis。</p>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><p>另外需要注意的是，如果前端是使用 ajax 进行请求，需要在 request 中带上 <code>withCredentials = true;</code>，并在服务端设置响应头 <code>Access-Control-Allow-Credentials: true</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">res.setHeader(<span class=\"string\">'Access-Control-Allow-Origin'</span>, config.cors.origin);</div><div class=\"line\">res.setHeader(<span class=\"string\">'Access-Control-Allow-Credentials'</span>, <span class=\"literal\">true</span>);</div></pre></td></tr></table></figure>"},{"title":"如何实现五子棋 AI","date":"2016-07-31T12:57:34.000Z","_content":"\n和水哥在北戴河回来的车上除了讨论 24 点的实现方式之外，还讨论了一下五子棋的算法。昨天趁着周末凭着自己的想法试着写了一下，很不幸的是五子棋没写出来，倒是写了个三子棋（orz），网上查了一些资料，其实这里面涉及两个主要的算法，一个是**极大极小搜索**，另一个是**alpha-beta剪枝**。\n\n<!-- more -->\n\n## 博弈树\n\n下过五子棋的人都应该知道，越厉害的人，对棋面的预测程度越深。换句话讲，就是当你下完一步棋，我就能在我的脑海里假设把我所有可能下的地方都下一遍，然后考虑我下完之后你又会下在哪里，最后我根据每次预测的局势好坏来判断我的下一步棋放哪最合适。当然这只是想了一层，一个专业的棋手思考的层数会多得多。\n\n作为一个难度较大的 AI，势必也需要能够对棋局进行深入分析，然而五子棋的棋盘大小一般是 15 * 15，可以落子的地方太多，在这种情况下，电脑的性能有限，我们需要满足 AI “思考”的层数不能太低，同时算法的效率要高。\n\n以三子棋为例，AI 思考的过程就如同下面这课树一样，我们用圆圈代表玩家，叉号代表 AI，根节点是用户的落子。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/01.png)\n\n如果继续画下一层，那么下一层就是玩家下一步的落子，这也就是 AI 思考的层数又多了一层。\n\n有了这棵树，我们就需要得出每个节点的得分是多少，以判断哪一步是最优的。\n\n### 得分\n\n要考虑这一步棋是不是最优的，我们需要给每一步棋都设定一个得分，然后找出最忧的。当前棋面的得分多少，需要同时考虑玩家和 AI 分别的得分。\n\n以三子棋为例，当玩家下在左上角的时候，我们考虑 AI 下在正中间时的得分。得分的计算方法是将棋面的空白地方用棋子填满，然后得出连成三个的个数有多少。（如果是五子棋，应该只需找出当前棋面上所有连子，然后根据每种连子的权重来计算得分）\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/04.png)\n\n如图，玩家一共有 4 个成三，而 AI 一共有 5 个，所以总得分是 `5 - 4 = 1`。\n\n这里需要指出的是，在博弈树中，一个节点的得分是取决于他的子节点的，也就是说，当 AI 只思考一层，也就是上图这样，这棵树的末尾就是只有两个棋子，那么这个节点的得分就是这样计算，而如果这个节点下还有子节点，那么我们只会计算叶子节点的得分，然后从叶子节点开始，一步步倒推出父节点的得分。下面来进行解释倒推的过程。\n\n### 博弈\n\n当 AI 下棋时，我们必定要让 AI 下在得分最高的位置，这毋庸置疑。但是以 AI 的角度来考虑玩家的落子，我们需要假设玩家是“聪明的”，他会下在对自己最有利的地方，也就是得分最低的地方（因为得分 = AI 分数 - 玩家分数）。\n\n这就造成每一层的性质是不同的，在玩家落子的层里，我们要选取得分最低的；在 AI 落子的层里，我们要选取得分最高的。所以我们称玩家层为 MIN 层，AI 层为 MAX 层。\n\n## 极大极小搜索\n\n上面提到了，计算出叶子节点之后，我们需要倒推出父节点的得分，倒推的原则其实就是上面说的：MAX\n层中的节点会从子节点中挑选最大得分的节点作为它的得分，MIN 层的节点会从子节点中挑选最小得分的节点作为它的得分。\n\n以下图举例：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/02.png)\n\n因为我们是根据子节点的得分来倒推父节点的得分的，所以我们是用深度优先来遍历博弈树的，在上面这棵树中，遍历顺序是 `ABCDEFGHIJ`，赋值过程如下：\n\n1. 遍历完 A B，因为 C 是 MIN 层，所以选取 AB 中最小的，即 8 作为 C 的得分\n2. 遍历完 D E，F 的得分为 6\n3. 遍历完 G H，I 的得分为 5\n4. 因为 J 在 MAX 层，所以选取 C F I 中得分最大的，即 8 作为 I 的得分\n\n## alpha-beta 剪枝\n\n从上面可以想到，像五子棋这种可能性很多的情况，这棵树会变得非常大，当层数增加的时候，计算量也会越来越大，如果不采取一些方法，我们只能靠牺牲层数来换取运行时间。\n\n那么 alpha-beta 剪枝就是一种行之有效的方法，顾名思义，采用这种方法，我们会剪去一些不必要的树枝，也就减少了运行的时间。\n\nalpha-beta 剪枝的定义很绕口，但是原理很简单，还是以上面那课树为例：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/03.png)\n\n当遍历到 C 的时候，计算出 C 的得分是 `8`，因为 J 的得分是 C、F、I 之中最大的，所以此时可以得出 `J >= 8`。\n\n接下来遍历到 D，D 的值为 `6`，因为 F 的值是 D 和 E 之中最小的，所以即使现在还没有遍历完 F 的子节点也可以得出 `F <= 6`，那么既然 J 已经大于等于 `8` 了，所以继续遍历 F 已经没有意义了，那么我们就将 F 这条枝剪掉。\n\n同理，当 G 为 `5` 时，遍历 I 已经没有意义了，因为 I 不可能再大于 `5`，所以直接得出 J 为 `8`；\n\n可以看出，当节点很多的情况下，使用 alpha-beta 剪枝是能在一定程度上提高运行效率的。","source":"_posts/five-in-a-row-game.md","raw":"---\ntitle: 如何实现五子棋 AI\ndate: 2016-07-31 20:57:34\ntags: [总结]\n---\n\n和水哥在北戴河回来的车上除了讨论 24 点的实现方式之外，还讨论了一下五子棋的算法。昨天趁着周末凭着自己的想法试着写了一下，很不幸的是五子棋没写出来，倒是写了个三子棋（orz），网上查了一些资料，其实这里面涉及两个主要的算法，一个是**极大极小搜索**，另一个是**alpha-beta剪枝**。\n\n<!-- more -->\n\n## 博弈树\n\n下过五子棋的人都应该知道，越厉害的人，对棋面的预测程度越深。换句话讲，就是当你下完一步棋，我就能在我的脑海里假设把我所有可能下的地方都下一遍，然后考虑我下完之后你又会下在哪里，最后我根据每次预测的局势好坏来判断我的下一步棋放哪最合适。当然这只是想了一层，一个专业的棋手思考的层数会多得多。\n\n作为一个难度较大的 AI，势必也需要能够对棋局进行深入分析，然而五子棋的棋盘大小一般是 15 * 15，可以落子的地方太多，在这种情况下，电脑的性能有限，我们需要满足 AI “思考”的层数不能太低，同时算法的效率要高。\n\n以三子棋为例，AI 思考的过程就如同下面这课树一样，我们用圆圈代表玩家，叉号代表 AI，根节点是用户的落子。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/01.png)\n\n如果继续画下一层，那么下一层就是玩家下一步的落子，这也就是 AI 思考的层数又多了一层。\n\n有了这棵树，我们就需要得出每个节点的得分是多少，以判断哪一步是最优的。\n\n### 得分\n\n要考虑这一步棋是不是最优的，我们需要给每一步棋都设定一个得分，然后找出最忧的。当前棋面的得分多少，需要同时考虑玩家和 AI 分别的得分。\n\n以三子棋为例，当玩家下在左上角的时候，我们考虑 AI 下在正中间时的得分。得分的计算方法是将棋面的空白地方用棋子填满，然后得出连成三个的个数有多少。（如果是五子棋，应该只需找出当前棋面上所有连子，然后根据每种连子的权重来计算得分）\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/04.png)\n\n如图，玩家一共有 4 个成三，而 AI 一共有 5 个，所以总得分是 `5 - 4 = 1`。\n\n这里需要指出的是，在博弈树中，一个节点的得分是取决于他的子节点的，也就是说，当 AI 只思考一层，也就是上图这样，这棵树的末尾就是只有两个棋子，那么这个节点的得分就是这样计算，而如果这个节点下还有子节点，那么我们只会计算叶子节点的得分，然后从叶子节点开始，一步步倒推出父节点的得分。下面来进行解释倒推的过程。\n\n### 博弈\n\n当 AI 下棋时，我们必定要让 AI 下在得分最高的位置，这毋庸置疑。但是以 AI 的角度来考虑玩家的落子，我们需要假设玩家是“聪明的”，他会下在对自己最有利的地方，也就是得分最低的地方（因为得分 = AI 分数 - 玩家分数）。\n\n这就造成每一层的性质是不同的，在玩家落子的层里，我们要选取得分最低的；在 AI 落子的层里，我们要选取得分最高的。所以我们称玩家层为 MIN 层，AI 层为 MAX 层。\n\n## 极大极小搜索\n\n上面提到了，计算出叶子节点之后，我们需要倒推出父节点的得分，倒推的原则其实就是上面说的：MAX\n层中的节点会从子节点中挑选最大得分的节点作为它的得分，MIN 层的节点会从子节点中挑选最小得分的节点作为它的得分。\n\n以下图举例：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/02.png)\n\n因为我们是根据子节点的得分来倒推父节点的得分的，所以我们是用深度优先来遍历博弈树的，在上面这棵树中，遍历顺序是 `ABCDEFGHIJ`，赋值过程如下：\n\n1. 遍历完 A B，因为 C 是 MIN 层，所以选取 AB 中最小的，即 8 作为 C 的得分\n2. 遍历完 D E，F 的得分为 6\n3. 遍历完 G H，I 的得分为 5\n4. 因为 J 在 MAX 层，所以选取 C F I 中得分最大的，即 8 作为 I 的得分\n\n## alpha-beta 剪枝\n\n从上面可以想到，像五子棋这种可能性很多的情况，这棵树会变得非常大，当层数增加的时候，计算量也会越来越大，如果不采取一些方法，我们只能靠牺牲层数来换取运行时间。\n\n那么 alpha-beta 剪枝就是一种行之有效的方法，顾名思义，采用这种方法，我们会剪去一些不必要的树枝，也就减少了运行的时间。\n\nalpha-beta 剪枝的定义很绕口，但是原理很简单，还是以上面那课树为例：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/03.png)\n\n当遍历到 C 的时候，计算出 C 的得分是 `8`，因为 J 的得分是 C、F、I 之中最大的，所以此时可以得出 `J >= 8`。\n\n接下来遍历到 D，D 的值为 `6`，因为 F 的值是 D 和 E 之中最小的，所以即使现在还没有遍历完 F 的子节点也可以得出 `F <= 6`，那么既然 J 已经大于等于 `8` 了，所以继续遍历 F 已经没有意义了，那么我们就将 F 这条枝剪掉。\n\n同理，当 G 为 `5` 时，遍历 I 已经没有意义了，因为 I 不可能再大于 `5`，所以直接得出 J 为 `8`；\n\n可以看出，当节点很多的情况下，使用 alpha-beta 剪枝是能在一定程度上提高运行效率的。","slug":"five-in-a-row-game","published":1,"updated":"2017-03-17T13:40:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcw0001en927vunshvd9","content":"<p>和水哥在北戴河回来的车上除了讨论 24 点的实现方式之外，还讨论了一下五子棋的算法。昨天趁着周末凭着自己的想法试着写了一下，很不幸的是五子棋没写出来，倒是写了个三子棋（orz），网上查了一些资料，其实这里面涉及两个主要的算法，一个是<strong>极大极小搜索</strong>，另一个是<strong>alpha-beta剪枝</strong>。</p>\n<a id=\"more\"></a>\n<h2 id=\"博弈树\"><a href=\"#博弈树\" class=\"headerlink\" title=\"博弈树\"></a>博弈树</h2><p>下过五子棋的人都应该知道，越厉害的人，对棋面的预测程度越深。换句话讲，就是当你下完一步棋，我就能在我的脑海里假设把我所有可能下的地方都下一遍，然后考虑我下完之后你又会下在哪里，最后我根据每次预测的局势好坏来判断我的下一步棋放哪最合适。当然这只是想了一层，一个专业的棋手思考的层数会多得多。</p>\n<p>作为一个难度较大的 AI，势必也需要能够对棋局进行深入分析，然而五子棋的棋盘大小一般是 15 * 15，可以落子的地方太多，在这种情况下，电脑的性能有限，我们需要满足 AI “思考”的层数不能太低，同时算法的效率要高。</p>\n<p>以三子棋为例，AI 思考的过程就如同下面这课树一样，我们用圆圈代表玩家，叉号代表 AI，根节点是用户的落子。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/01.png\" alt=\"\"></p>\n<p>如果继续画下一层，那么下一层就是玩家下一步的落子，这也就是 AI 思考的层数又多了一层。</p>\n<p>有了这棵树，我们就需要得出每个节点的得分是多少，以判断哪一步是最优的。</p>\n<h3 id=\"得分\"><a href=\"#得分\" class=\"headerlink\" title=\"得分\"></a>得分</h3><p>要考虑这一步棋是不是最优的，我们需要给每一步棋都设定一个得分，然后找出最忧的。当前棋面的得分多少，需要同时考虑玩家和 AI 分别的得分。</p>\n<p>以三子棋为例，当玩家下在左上角的时候，我们考虑 AI 下在正中间时的得分。得分的计算方法是将棋面的空白地方用棋子填满，然后得出连成三个的个数有多少。（如果是五子棋，应该只需找出当前棋面上所有连子，然后根据每种连子的权重来计算得分）</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/04.png\" alt=\"\"></p>\n<p>如图，玩家一共有 4 个成三，而 AI 一共有 5 个，所以总得分是 <code>5 - 4 = 1</code>。</p>\n<p>这里需要指出的是，在博弈树中，一个节点的得分是取决于他的子节点的，也就是说，当 AI 只思考一层，也就是上图这样，这棵树的末尾就是只有两个棋子，那么这个节点的得分就是这样计算，而如果这个节点下还有子节点，那么我们只会计算叶子节点的得分，然后从叶子节点开始，一步步倒推出父节点的得分。下面来进行解释倒推的过程。</p>\n<h3 id=\"博弈\"><a href=\"#博弈\" class=\"headerlink\" title=\"博弈\"></a>博弈</h3><p>当 AI 下棋时，我们必定要让 AI 下在得分最高的位置，这毋庸置疑。但是以 AI 的角度来考虑玩家的落子，我们需要假设玩家是“聪明的”，他会下在对自己最有利的地方，也就是得分最低的地方（因为得分 = AI 分数 - 玩家分数）。</p>\n<p>这就造成每一层的性质是不同的，在玩家落子的层里，我们要选取得分最低的；在 AI 落子的层里，我们要选取得分最高的。所以我们称玩家层为 MIN 层，AI 层为 MAX 层。</p>\n<h2 id=\"极大极小搜索\"><a href=\"#极大极小搜索\" class=\"headerlink\" title=\"极大极小搜索\"></a>极大极小搜索</h2><p>上面提到了，计算出叶子节点之后，我们需要倒推出父节点的得分，倒推的原则其实就是上面说的：MAX<br>层中的节点会从子节点中挑选最大得分的节点作为它的得分，MIN 层的节点会从子节点中挑选最小得分的节点作为它的得分。</p>\n<p>以下图举例：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/02.png\" alt=\"\"></p>\n<p>因为我们是根据子节点的得分来倒推父节点的得分的，所以我们是用深度优先来遍历博弈树的，在上面这棵树中，遍历顺序是 <code>ABCDEFGHIJ</code>，赋值过程如下：</p>\n<ol>\n<li>遍历完 A B，因为 C 是 MIN 层，所以选取 AB 中最小的，即 8 作为 C 的得分</li>\n<li>遍历完 D E，F 的得分为 6</li>\n<li>遍历完 G H，I 的得分为 5</li>\n<li>因为 J 在 MAX 层，所以选取 C F I 中得分最大的，即 8 作为 I 的得分</li>\n</ol>\n<h2 id=\"alpha-beta-剪枝\"><a href=\"#alpha-beta-剪枝\" class=\"headerlink\" title=\"alpha-beta 剪枝\"></a>alpha-beta 剪枝</h2><p>从上面可以想到，像五子棋这种可能性很多的情况，这棵树会变得非常大，当层数增加的时候，计算量也会越来越大，如果不采取一些方法，我们只能靠牺牲层数来换取运行时间。</p>\n<p>那么 alpha-beta 剪枝就是一种行之有效的方法，顾名思义，采用这种方法，我们会剪去一些不必要的树枝，也就减少了运行的时间。</p>\n<p>alpha-beta 剪枝的定义很绕口，但是原理很简单，还是以上面那课树为例：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/03.png\" alt=\"\"></p>\n<p>当遍历到 C 的时候，计算出 C 的得分是 <code>8</code>，因为 J 的得分是 C、F、I 之中最大的，所以此时可以得出 <code>J &gt;= 8</code>。</p>\n<p>接下来遍历到 D，D 的值为 <code>6</code>，因为 F 的值是 D 和 E 之中最小的，所以即使现在还没有遍历完 F 的子节点也可以得出 <code>F &lt;= 6</code>，那么既然 J 已经大于等于 <code>8</code> 了，所以继续遍历 F 已经没有意义了，那么我们就将 F 这条枝剪掉。</p>\n<p>同理，当 G 为 <code>5</code> 时，遍历 I 已经没有意义了，因为 I 不可能再大于 <code>5</code>，所以直接得出 J 为 <code>8</code>；</p>\n<p>可以看出，当节点很多的情况下，使用 alpha-beta 剪枝是能在一定程度上提高运行效率的。</p>\n","excerpt":"<p>和水哥在北戴河回来的车上除了讨论 24 点的实现方式之外，还讨论了一下五子棋的算法。昨天趁着周末凭着自己的想法试着写了一下，很不幸的是五子棋没写出来，倒是写了个三子棋（orz），网上查了一些资料，其实这里面涉及两个主要的算法，一个是<strong>极大极小搜索</strong>，另一个是<strong>alpha-beta剪枝</strong>。</p>","more":"<h2 id=\"博弈树\"><a href=\"#博弈树\" class=\"headerlink\" title=\"博弈树\"></a>博弈树</h2><p>下过五子棋的人都应该知道，越厉害的人，对棋面的预测程度越深。换句话讲，就是当你下完一步棋，我就能在我的脑海里假设把我所有可能下的地方都下一遍，然后考虑我下完之后你又会下在哪里，最后我根据每次预测的局势好坏来判断我的下一步棋放哪最合适。当然这只是想了一层，一个专业的棋手思考的层数会多得多。</p>\n<p>作为一个难度较大的 AI，势必也需要能够对棋局进行深入分析，然而五子棋的棋盘大小一般是 15 * 15，可以落子的地方太多，在这种情况下，电脑的性能有限，我们需要满足 AI “思考”的层数不能太低，同时算法的效率要高。</p>\n<p>以三子棋为例，AI 思考的过程就如同下面这课树一样，我们用圆圈代表玩家，叉号代表 AI，根节点是用户的落子。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/01.png\" alt=\"\"></p>\n<p>如果继续画下一层，那么下一层就是玩家下一步的落子，这也就是 AI 思考的层数又多了一层。</p>\n<p>有了这棵树，我们就需要得出每个节点的得分是多少，以判断哪一步是最优的。</p>\n<h3 id=\"得分\"><a href=\"#得分\" class=\"headerlink\" title=\"得分\"></a>得分</h3><p>要考虑这一步棋是不是最优的，我们需要给每一步棋都设定一个得分，然后找出最忧的。当前棋面的得分多少，需要同时考虑玩家和 AI 分别的得分。</p>\n<p>以三子棋为例，当玩家下在左上角的时候，我们考虑 AI 下在正中间时的得分。得分的计算方法是将棋面的空白地方用棋子填满，然后得出连成三个的个数有多少。（如果是五子棋，应该只需找出当前棋面上所有连子，然后根据每种连子的权重来计算得分）</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/04.png\" alt=\"\"></p>\n<p>如图，玩家一共有 4 个成三，而 AI 一共有 5 个，所以总得分是 <code>5 - 4 = 1</code>。</p>\n<p>这里需要指出的是，在博弈树中，一个节点的得分是取决于他的子节点的，也就是说，当 AI 只思考一层，也就是上图这样，这棵树的末尾就是只有两个棋子，那么这个节点的得分就是这样计算，而如果这个节点下还有子节点，那么我们只会计算叶子节点的得分，然后从叶子节点开始，一步步倒推出父节点的得分。下面来进行解释倒推的过程。</p>\n<h3 id=\"博弈\"><a href=\"#博弈\" class=\"headerlink\" title=\"博弈\"></a>博弈</h3><p>当 AI 下棋时，我们必定要让 AI 下在得分最高的位置，这毋庸置疑。但是以 AI 的角度来考虑玩家的落子，我们需要假设玩家是“聪明的”，他会下在对自己最有利的地方，也就是得分最低的地方（因为得分 = AI 分数 - 玩家分数）。</p>\n<p>这就造成每一层的性质是不同的，在玩家落子的层里，我们要选取得分最低的；在 AI 落子的层里，我们要选取得分最高的。所以我们称玩家层为 MIN 层，AI 层为 MAX 层。</p>\n<h2 id=\"极大极小搜索\"><a href=\"#极大极小搜索\" class=\"headerlink\" title=\"极大极小搜索\"></a>极大极小搜索</h2><p>上面提到了，计算出叶子节点之后，我们需要倒推出父节点的得分，倒推的原则其实就是上面说的：MAX<br>层中的节点会从子节点中挑选最大得分的节点作为它的得分，MIN 层的节点会从子节点中挑选最小得分的节点作为它的得分。</p>\n<p>以下图举例：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/02.png\" alt=\"\"></p>\n<p>因为我们是根据子节点的得分来倒推父节点的得分的，所以我们是用深度优先来遍历博弈树的，在上面这棵树中，遍历顺序是 <code>ABCDEFGHIJ</code>，赋值过程如下：</p>\n<ol>\n<li>遍历完 A B，因为 C 是 MIN 层，所以选取 AB 中最小的，即 8 作为 C 的得分</li>\n<li>遍历完 D E，F 的得分为 6</li>\n<li>遍历完 G H，I 的得分为 5</li>\n<li>因为 J 在 MAX 层，所以选取 C F I 中得分最大的，即 8 作为 I 的得分</li>\n</ol>\n<h2 id=\"alpha-beta-剪枝\"><a href=\"#alpha-beta-剪枝\" class=\"headerlink\" title=\"alpha-beta 剪枝\"></a>alpha-beta 剪枝</h2><p>从上面可以想到，像五子棋这种可能性很多的情况，这棵树会变得非常大，当层数增加的时候，计算量也会越来越大，如果不采取一些方法，我们只能靠牺牲层数来换取运行时间。</p>\n<p>那么 alpha-beta 剪枝就是一种行之有效的方法，顾名思义，采用这种方法，我们会剪去一些不必要的树枝，也就减少了运行的时间。</p>\n<p>alpha-beta 剪枝的定义很绕口，但是原理很简单，还是以上面那课树为例：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/03.png\" alt=\"\"></p>\n<p>当遍历到 C 的时候，计算出 C 的得分是 <code>8</code>，因为 J 的得分是 C、F、I 之中最大的，所以此时可以得出 <code>J &gt;= 8</code>。</p>\n<p>接下来遍历到 D，D 的值为 <code>6</code>，因为 F 的值是 D 和 E 之中最小的，所以即使现在还没有遍历完 F 的子节点也可以得出 <code>F &lt;= 6</code>，那么既然 J 已经大于等于 <code>8</code> 了，所以继续遍历 F 已经没有意义了，那么我们就将 F 这条枝剪掉。</p>\n<p>同理，当 G 为 <code>5</code> 时，遍历 I 已经没有意义了，因为 I 不可能再大于 <code>5</code>，所以直接得出 J 为 <code>8</code>；</p>\n<p>可以看出，当节点很多的情况下，使用 alpha-beta 剪枝是能在一定程度上提高运行效率的。</p>"},{"title":"遗传算法","date":"2016-12-08T15:00:00.000Z","_content":"\n遗传算法是一个很有意思的算法。\n\n我们都知道达尔文提出了伟大的“生物进化论”，他证明了所有的生物都不是上帝创造的，而是在遗传、变异、生存斗争和自然选择中，由简单到复杂，由低等到高等，不断发展变化的。也就是：物竞天择、适者生存、优胜劣汰。\n\n达尔文的进化论给美国的科学家霍兰德留下了深刻的印象，但他从计算机科学的角度思考了这个问题，他想到，是否可以像繁育良种马和良种玉米一样繁育程序。这也就是遗传算法的由来。遗传算法借鉴了进化生物学中的一些现象，包括遗传、突变、自然选择以及杂交等。\n\n<!--more-->\n\n## 扫地机器人罗比\n\n在《复杂》这本书中有个例子，罗比是一个扫地机器人，他生活在一个 10 * 10 格子的世界里，这个世界随机散落着易拉罐，且每个格子最多只有一个易拉罐。罗比的任务是清理这些易拉罐。世界的周围都是墙壁。\n\n![罗比的世界](http://7xo08n.com1.z0.glb.clouddn.com/blog/genetic-algorithm/01.PNG)\n\n罗比的视野是有限的，他只能看到四周格子以及自己所在位置的情况，也就是上下左右和当前位置五个格子的情况。\n\n每次清理工作罗比可以执行 200 个动作，动作可以是：向上走，向下走，向左走，向右走，随机一个方向走、捡罐头、不动。每一个动作执行完以后都会有一个评分：如果捡罐头时格子中有罐头，那么罐头被捡起，加 10 分。如果捡罐头的时候格子中没有罐头，扣 1 分。如果罗比撞到了墙，扣 5 分。\n\n显然，罗比尽可能多捡到罐头、别在没罐头的时候去捡、别撞墙，分数就越高。那么，我们需要设计一套策略，让罗比根据当前所在位置的状态去执行相应的动作，能够拿到最高的分。\n\n那么，总共有多少种状态？\n\n每次罗比看到的格子为：上下左右中，一共 5 个格子，而每个格子有三种可能性：没罐头、有罐头、墙壁。我们把没罐头记为 0，有罐头记为 1，是墙壁记为 2。那么状态可以列为：\n\n```\n上下左右中\n0 0 0 0 0\n0 0 0 0 1\n0 0 0 0 2\n0 0 0 1 0\n0 0 0 1 1\n...\n2 2 2 2 2\n```\n\n显然，一共有 `3 * 3 * 3 * 3 * 3 = 243` 种状态。\n\n而对于每一种状态，罗比有 7 种动作可以执行：\n\n```\n0: 向上走\n1: 向下走\n2: 向左走\n3: 向右走\n4: 随机选取方向走\n5: 捡罐头\n6: 什么都不干\n```\n\n所以，243 个状态，每个状态 7 种动作，那么策略的总数是 `$7^243$` 个。要想遍历所有的策略去求最优解显然是不现实的，在这里可以使用遗传算法，来 **“进化”** 出一个近似最优解。\n\n## 遗传算法设计\n\n之前已经提到过了，遗传算法借鉴了自然选择中的思想，在遗传算法中，也有“种群”、“染色体”、“基因”、“杂交”、“变异”等概念。\n\n试想我们需要得到的策略是什么样子的。罗比需要根据每一种格子的状态去寻求一种动作，在上面已经提到过，格子的状态分别是 `00000`、`00001`、`00002` 以此类推。我们可以发现，这实际上就是所有的 5 位 3 进制数。\n\n那么，罗比的策略就可以用一个字符串表示，字符串的长度是格子情况的总数，每一位代表对应格子情况所需要作出的策略，比如 `152455021256444063355141362453351200451455123151604162324266004040256060052004316401456203443334225141156451050235106256354245063143011340422626044356444400300555631325215155436144345164455440161256251412661563442063025020602255536510141514365 `。这个策略的第一位是 1，这代表着罗比所处的情况是 `00000` 时，应该作出动作 1，也就是向下走。类似的，第二位是 5，代表罗比在 `00001` 时应该捡罐头。\n\n我们需要通过遗传算法找到最优的策略，这每一个策略实际上就代表着个体，我们通过一个字符串来代表它，这个字符串可以称为染色体（基因组），染色体是基因的集合，种群是染色体的集合。\n\n遗传算法首先需要随机生成一个种群，然后通过“自然选择”来筛选他们，越优秀的个体越容易留下来，并不断繁衍出优秀的子代，这样经过一代又一代的选择，最后留下的个体就是近似最优的。\n\n对应到罗比问题中来，遗传算法过程如下：\n\n1. 初始化种群：随机生成 200 个个体\n2. 计算适应度：对 200 个个体进行评分，评分的规则是让罗比打扫 1000 次世界，每次打扫世界都是随机生成的，且每次打扫罗比移动 200 步，最后算出这 1000 次打扫的平均分。\n3. 杂交：根据所有个体的得分，随机选取两个个体进行杂交，得分越高的个体越容易被选中。杂交会生成两个子代，将子代放入新种群。重复这个过程，直到新种群的个数达到 200 个。\n4. 突变：子代的一个或多个基因会有一定的概率发生突变，发生突变的基因会随机变为其他的动作，比如从 1 变为 6。\n5. 迭代：重复以上的过程，直到达到 1000 代。\n\n当然上面的 200、1000 这些数字都是人为设定的，你也可以设定其他的，只要能得到比较好的解就行。\n\n是不是很有意思，因为我们根本不用动脑去设计策略，而是全部交给了计算机。当然这里面还有适应度函数的设计、杂交的设计、参数的选定等令人伤脑筋的事情，但遗传算法的过程说起来就是这样。\n\n### 适应度\n\n在步骤 2 里面，我们对种群中所有个体进行了评分，评分的实现也比较简单，生成一个世界，根据策略在世界内进行 200 个动作，并把这个过程重复 1000 次即可，最后能拿到一个平均分。\n\n### 选取父母\n\n举个栗子，假设种群内只有 3 个个体，他们得分分别是 `1, 2, 7`，我们需要进行两次选择，且得分越高的个体越容易被选中。这里使用 **轮盘赌** 方法来选择个体。\n\n实际上也就是个求概率的问题，三个个体总分为 `1 + 2 + 7 = 10`，那么每个个体占比就可以算出来：`0.1, 0.2, 0.7`。然后让每个个体的概率加上前一个个体的概率，也就是：`0.1, 0.3, 1`。\n\n这样随机生成一个 0 到 1 的数，然后从左往右去比较，小于哪个个体就选择哪个个体即可。\n\n当出现负数怎么办，比如 `-5, 3, 9`，这里可以给每个元素都加上第一个元素的绝对值再加 1，也就是加 6，转为：`1, 9, 15 `，然后再像上面那样按轮盘赌即可。\n\n事实上，这里可以有很多种方法可以选择，比如全部调完正数后让每个元素平方，或者对所有元素加上一个总步数 * 撞墙扣分，代表一次打扫中最多可能扣掉的分。这里选择方法的选取对整个遗传算法影响也是很大的，需要设计一个比较合理的选择方式。\n\n### 杂交\n\n选择出父母之后，需要让父母进行杂交，比如选取某一个位置，取父亲的前半段加上母亲的后半段，以及父亲的后半段加母亲的前半段。\n\n```\n203651\n100344\n取后三位交叉\n203344\n100651\n```\n\n交叉算子的方式还有其他更复杂的。\n\n### 突变\n\n子代有很小的概率会发生基因突变，比如\n\n```\n203344 -> 206344\n```\n\n第三个位置的基因发生变化。\n\n## 吐槽\n\n实际上这个参数还是很麻烦。。我调了很长时间，最后进化了 2000 次，最高得分大概维持在 380 附近，这是种群平均分和种群中最高分随子代数的趋势图，可以看到种群确实在一点一点进化，如果参数更合理一点相信一定能达到几乎满分的得分的~\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/genetic-algorithm/02.png)\n\n贴一个 380 分左右的策略：`450351253450256256354356265152354252154454454351351464051353450055356644335603132054351253256352104350004552116414256156116103346453105056355052053324226604006321154130114255453253352312102112111412414140255154432364654062360530606611264324300`\n\n## 代码\n\n完整代码在 [这里](https://github.com/sunhengzhe/roby)\n","source":"_posts/genetic-algorithm.md","raw":"---\ntitle: 遗传算法\ndate: 2016-12-08 23:00:00\ntags: [算法]\n---\n\n遗传算法是一个很有意思的算法。\n\n我们都知道达尔文提出了伟大的“生物进化论”，他证明了所有的生物都不是上帝创造的，而是在遗传、变异、生存斗争和自然选择中，由简单到复杂，由低等到高等，不断发展变化的。也就是：物竞天择、适者生存、优胜劣汰。\n\n达尔文的进化论给美国的科学家霍兰德留下了深刻的印象，但他从计算机科学的角度思考了这个问题，他想到，是否可以像繁育良种马和良种玉米一样繁育程序。这也就是遗传算法的由来。遗传算法借鉴了进化生物学中的一些现象，包括遗传、突变、自然选择以及杂交等。\n\n<!--more-->\n\n## 扫地机器人罗比\n\n在《复杂》这本书中有个例子，罗比是一个扫地机器人，他生活在一个 10 * 10 格子的世界里，这个世界随机散落着易拉罐，且每个格子最多只有一个易拉罐。罗比的任务是清理这些易拉罐。世界的周围都是墙壁。\n\n![罗比的世界](http://7xo08n.com1.z0.glb.clouddn.com/blog/genetic-algorithm/01.PNG)\n\n罗比的视野是有限的，他只能看到四周格子以及自己所在位置的情况，也就是上下左右和当前位置五个格子的情况。\n\n每次清理工作罗比可以执行 200 个动作，动作可以是：向上走，向下走，向左走，向右走，随机一个方向走、捡罐头、不动。每一个动作执行完以后都会有一个评分：如果捡罐头时格子中有罐头，那么罐头被捡起，加 10 分。如果捡罐头的时候格子中没有罐头，扣 1 分。如果罗比撞到了墙，扣 5 分。\n\n显然，罗比尽可能多捡到罐头、别在没罐头的时候去捡、别撞墙，分数就越高。那么，我们需要设计一套策略，让罗比根据当前所在位置的状态去执行相应的动作，能够拿到最高的分。\n\n那么，总共有多少种状态？\n\n每次罗比看到的格子为：上下左右中，一共 5 个格子，而每个格子有三种可能性：没罐头、有罐头、墙壁。我们把没罐头记为 0，有罐头记为 1，是墙壁记为 2。那么状态可以列为：\n\n```\n上下左右中\n0 0 0 0 0\n0 0 0 0 1\n0 0 0 0 2\n0 0 0 1 0\n0 0 0 1 1\n...\n2 2 2 2 2\n```\n\n显然，一共有 `3 * 3 * 3 * 3 * 3 = 243` 种状态。\n\n而对于每一种状态，罗比有 7 种动作可以执行：\n\n```\n0: 向上走\n1: 向下走\n2: 向左走\n3: 向右走\n4: 随机选取方向走\n5: 捡罐头\n6: 什么都不干\n```\n\n所以，243 个状态，每个状态 7 种动作，那么策略的总数是 `$7^243$` 个。要想遍历所有的策略去求最优解显然是不现实的，在这里可以使用遗传算法，来 **“进化”** 出一个近似最优解。\n\n## 遗传算法设计\n\n之前已经提到过了，遗传算法借鉴了自然选择中的思想，在遗传算法中，也有“种群”、“染色体”、“基因”、“杂交”、“变异”等概念。\n\n试想我们需要得到的策略是什么样子的。罗比需要根据每一种格子的状态去寻求一种动作，在上面已经提到过，格子的状态分别是 `00000`、`00001`、`00002` 以此类推。我们可以发现，这实际上就是所有的 5 位 3 进制数。\n\n那么，罗比的策略就可以用一个字符串表示，字符串的长度是格子情况的总数，每一位代表对应格子情况所需要作出的策略，比如 `152455021256444063355141362453351200451455123151604162324266004040256060052004316401456203443334225141156451050235106256354245063143011340422626044356444400300555631325215155436144345164455440161256251412661563442063025020602255536510141514365 `。这个策略的第一位是 1，这代表着罗比所处的情况是 `00000` 时，应该作出动作 1，也就是向下走。类似的，第二位是 5，代表罗比在 `00001` 时应该捡罐头。\n\n我们需要通过遗传算法找到最优的策略，这每一个策略实际上就代表着个体，我们通过一个字符串来代表它，这个字符串可以称为染色体（基因组），染色体是基因的集合，种群是染色体的集合。\n\n遗传算法首先需要随机生成一个种群，然后通过“自然选择”来筛选他们，越优秀的个体越容易留下来，并不断繁衍出优秀的子代，这样经过一代又一代的选择，最后留下的个体就是近似最优的。\n\n对应到罗比问题中来，遗传算法过程如下：\n\n1. 初始化种群：随机生成 200 个个体\n2. 计算适应度：对 200 个个体进行评分，评分的规则是让罗比打扫 1000 次世界，每次打扫世界都是随机生成的，且每次打扫罗比移动 200 步，最后算出这 1000 次打扫的平均分。\n3. 杂交：根据所有个体的得分，随机选取两个个体进行杂交，得分越高的个体越容易被选中。杂交会生成两个子代，将子代放入新种群。重复这个过程，直到新种群的个数达到 200 个。\n4. 突变：子代的一个或多个基因会有一定的概率发生突变，发生突变的基因会随机变为其他的动作，比如从 1 变为 6。\n5. 迭代：重复以上的过程，直到达到 1000 代。\n\n当然上面的 200、1000 这些数字都是人为设定的，你也可以设定其他的，只要能得到比较好的解就行。\n\n是不是很有意思，因为我们根本不用动脑去设计策略，而是全部交给了计算机。当然这里面还有适应度函数的设计、杂交的设计、参数的选定等令人伤脑筋的事情，但遗传算法的过程说起来就是这样。\n\n### 适应度\n\n在步骤 2 里面，我们对种群中所有个体进行了评分，评分的实现也比较简单，生成一个世界，根据策略在世界内进行 200 个动作，并把这个过程重复 1000 次即可，最后能拿到一个平均分。\n\n### 选取父母\n\n举个栗子，假设种群内只有 3 个个体，他们得分分别是 `1, 2, 7`，我们需要进行两次选择，且得分越高的个体越容易被选中。这里使用 **轮盘赌** 方法来选择个体。\n\n实际上也就是个求概率的问题，三个个体总分为 `1 + 2 + 7 = 10`，那么每个个体占比就可以算出来：`0.1, 0.2, 0.7`。然后让每个个体的概率加上前一个个体的概率，也就是：`0.1, 0.3, 1`。\n\n这样随机生成一个 0 到 1 的数，然后从左往右去比较，小于哪个个体就选择哪个个体即可。\n\n当出现负数怎么办，比如 `-5, 3, 9`，这里可以给每个元素都加上第一个元素的绝对值再加 1，也就是加 6，转为：`1, 9, 15 `，然后再像上面那样按轮盘赌即可。\n\n事实上，这里可以有很多种方法可以选择，比如全部调完正数后让每个元素平方，或者对所有元素加上一个总步数 * 撞墙扣分，代表一次打扫中最多可能扣掉的分。这里选择方法的选取对整个遗传算法影响也是很大的，需要设计一个比较合理的选择方式。\n\n### 杂交\n\n选择出父母之后，需要让父母进行杂交，比如选取某一个位置，取父亲的前半段加上母亲的后半段，以及父亲的后半段加母亲的前半段。\n\n```\n203651\n100344\n取后三位交叉\n203344\n100651\n```\n\n交叉算子的方式还有其他更复杂的。\n\n### 突变\n\n子代有很小的概率会发生基因突变，比如\n\n```\n203344 -> 206344\n```\n\n第三个位置的基因发生变化。\n\n## 吐槽\n\n实际上这个参数还是很麻烦。。我调了很长时间，最后进化了 2000 次，最高得分大概维持在 380 附近，这是种群平均分和种群中最高分随子代数的趋势图，可以看到种群确实在一点一点进化，如果参数更合理一点相信一定能达到几乎满分的得分的~\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/genetic-algorithm/02.png)\n\n贴一个 380 分左右的策略：`450351253450256256354356265152354252154454454351351464051353450055356644335603132054351253256352104350004552116414256156116103346453105056355052053324226604006321154130114255453253352312102112111412414140255154432364654062360530606611264324300`\n\n## 代码\n\n完整代码在 [这里](https://github.com/sunhengzhe/roby)\n","slug":"genetic-algorithm","published":1,"updated":"2016-12-19T02:47:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcw2001hn9273zf7o024","content":"<p>遗传算法是一个很有意思的算法。</p>\n<p>我们都知道达尔文提出了伟大的“生物进化论”，他证明了所有的生物都不是上帝创造的，而是在遗传、变异、生存斗争和自然选择中，由简单到复杂，由低等到高等，不断发展变化的。也就是：物竞天择、适者生存、优胜劣汰。</p>\n<p>达尔文的进化论给美国的科学家霍兰德留下了深刻的印象，但他从计算机科学的角度思考了这个问题，他想到，是否可以像繁育良种马和良种玉米一样繁育程序。这也就是遗传算法的由来。遗传算法借鉴了进化生物学中的一些现象，包括遗传、突变、自然选择以及杂交等。</p>\n<a id=\"more\"></a>\n<h2 id=\"扫地机器人罗比\"><a href=\"#扫地机器人罗比\" class=\"headerlink\" title=\"扫地机器人罗比\"></a>扫地机器人罗比</h2><p>在《复杂》这本书中有个例子，罗比是一个扫地机器人，他生活在一个 10 * 10 格子的世界里，这个世界随机散落着易拉罐，且每个格子最多只有一个易拉罐。罗比的任务是清理这些易拉罐。世界的周围都是墙壁。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/genetic-algorithm/01.PNG\" alt=\"罗比的世界\"></p>\n<p>罗比的视野是有限的，他只能看到四周格子以及自己所在位置的情况，也就是上下左右和当前位置五个格子的情况。</p>\n<p>每次清理工作罗比可以执行 200 个动作，动作可以是：向上走，向下走，向左走，向右走，随机一个方向走、捡罐头、不动。每一个动作执行完以后都会有一个评分：如果捡罐头时格子中有罐头，那么罐头被捡起，加 10 分。如果捡罐头的时候格子中没有罐头，扣 1 分。如果罗比撞到了墙，扣 5 分。</p>\n<p>显然，罗比尽可能多捡到罐头、别在没罐头的时候去捡、别撞墙，分数就越高。那么，我们需要设计一套策略，让罗比根据当前所在位置的状态去执行相应的动作，能够拿到最高的分。</p>\n<p>那么，总共有多少种状态？</p>\n<p>每次罗比看到的格子为：上下左右中，一共 5 个格子，而每个格子有三种可能性：没罐头、有罐头、墙壁。我们把没罐头记为 0，有罐头记为 1，是墙壁记为 2。那么状态可以列为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">上下左右中</div><div class=\"line\">0 0 0 0 0</div><div class=\"line\">0 0 0 0 1</div><div class=\"line\">0 0 0 0 2</div><div class=\"line\">0 0 0 1 0</div><div class=\"line\">0 0 0 1 1</div><div class=\"line\">...</div><div class=\"line\">2 2 2 2 2</div></pre></td></tr></table></figure>\n<p>显然，一共有 <code>3 * 3 * 3 * 3 * 3 = 243</code> 种状态。</p>\n<p>而对于每一种状态，罗比有 7 种动作可以执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">0: 向上走</div><div class=\"line\">1: 向下走</div><div class=\"line\">2: 向左走</div><div class=\"line\">3: 向右走</div><div class=\"line\">4: 随机选取方向走</div><div class=\"line\">5: 捡罐头</div><div class=\"line\">6: 什么都不干</div></pre></td></tr></table></figure>\n<p>所以，243 个状态，每个状态 7 种动作，那么策略的总数是 <code>$7^243$</code> 个。要想遍历所有的策略去求最优解显然是不现实的，在这里可以使用遗传算法，来 <strong>“进化”</strong> 出一个近似最优解。</p>\n<h2 id=\"遗传算法设计\"><a href=\"#遗传算法设计\" class=\"headerlink\" title=\"遗传算法设计\"></a>遗传算法设计</h2><p>之前已经提到过了，遗传算法借鉴了自然选择中的思想，在遗传算法中，也有“种群”、“染色体”、“基因”、“杂交”、“变异”等概念。</p>\n<p>试想我们需要得到的策略是什么样子的。罗比需要根据每一种格子的状态去寻求一种动作，在上面已经提到过，格子的状态分别是 <code>00000</code>、<code>00001</code>、<code>00002</code> 以此类推。我们可以发现，这实际上就是所有的 5 位 3 进制数。</p>\n<p>那么，罗比的策略就可以用一个字符串表示，字符串的长度是格子情况的总数，每一位代表对应格子情况所需要作出的策略，比如 <code>152455021256444063355141362453351200451455123151604162324266004040256060052004316401456203443334225141156451050235106256354245063143011340422626044356444400300555631325215155436144345164455440161256251412661563442063025020602255536510141514365</code>。这个策略的第一位是 1，这代表着罗比所处的情况是 <code>00000</code> 时，应该作出动作 1，也就是向下走。类似的，第二位是 5，代表罗比在 <code>00001</code> 时应该捡罐头。</p>\n<p>我们需要通过遗传算法找到最优的策略，这每一个策略实际上就代表着个体，我们通过一个字符串来代表它，这个字符串可以称为染色体（基因组），染色体是基因的集合，种群是染色体的集合。</p>\n<p>遗传算法首先需要随机生成一个种群，然后通过“自然选择”来筛选他们，越优秀的个体越容易留下来，并不断繁衍出优秀的子代，这样经过一代又一代的选择，最后留下的个体就是近似最优的。</p>\n<p>对应到罗比问题中来，遗传算法过程如下：</p>\n<ol>\n<li>初始化种群：随机生成 200 个个体</li>\n<li>计算适应度：对 200 个个体进行评分，评分的规则是让罗比打扫 1000 次世界，每次打扫世界都是随机生成的，且每次打扫罗比移动 200 步，最后算出这 1000 次打扫的平均分。</li>\n<li>杂交：根据所有个体的得分，随机选取两个个体进行杂交，得分越高的个体越容易被选中。杂交会生成两个子代，将子代放入新种群。重复这个过程，直到新种群的个数达到 200 个。</li>\n<li>突变：子代的一个或多个基因会有一定的概率发生突变，发生突变的基因会随机变为其他的动作，比如从 1 变为 6。</li>\n<li>迭代：重复以上的过程，直到达到 1000 代。</li>\n</ol>\n<p>当然上面的 200、1000 这些数字都是人为设定的，你也可以设定其他的，只要能得到比较好的解就行。</p>\n<p>是不是很有意思，因为我们根本不用动脑去设计策略，而是全部交给了计算机。当然这里面还有适应度函数的设计、杂交的设计、参数的选定等令人伤脑筋的事情，但遗传算法的过程说起来就是这样。</p>\n<h3 id=\"适应度\"><a href=\"#适应度\" class=\"headerlink\" title=\"适应度\"></a>适应度</h3><p>在步骤 2 里面，我们对种群中所有个体进行了评分，评分的实现也比较简单，生成一个世界，根据策略在世界内进行 200 个动作，并把这个过程重复 1000 次即可，最后能拿到一个平均分。</p>\n<h3 id=\"选取父母\"><a href=\"#选取父母\" class=\"headerlink\" title=\"选取父母\"></a>选取父母</h3><p>举个栗子，假设种群内只有 3 个个体，他们得分分别是 <code>1, 2, 7</code>，我们需要进行两次选择，且得分越高的个体越容易被选中。这里使用 <strong>轮盘赌</strong> 方法来选择个体。</p>\n<p>实际上也就是个求概率的问题，三个个体总分为 <code>1 + 2 + 7 = 10</code>，那么每个个体占比就可以算出来：<code>0.1, 0.2, 0.7</code>。然后让每个个体的概率加上前一个个体的概率，也就是：<code>0.1, 0.3, 1</code>。</p>\n<p>这样随机生成一个 0 到 1 的数，然后从左往右去比较，小于哪个个体就选择哪个个体即可。</p>\n<p>当出现负数怎么办，比如 <code>-5, 3, 9</code>，这里可以给每个元素都加上第一个元素的绝对值再加 1，也就是加 6，转为：<code>1, 9, 15</code>，然后再像上面那样按轮盘赌即可。</p>\n<p>事实上，这里可以有很多种方法可以选择，比如全部调完正数后让每个元素平方，或者对所有元素加上一个总步数 * 撞墙扣分，代表一次打扫中最多可能扣掉的分。这里选择方法的选取对整个遗传算法影响也是很大的，需要设计一个比较合理的选择方式。</p>\n<h3 id=\"杂交\"><a href=\"#杂交\" class=\"headerlink\" title=\"杂交\"></a>杂交</h3><p>选择出父母之后，需要让父母进行杂交，比如选取某一个位置，取父亲的前半段加上母亲的后半段，以及父亲的后半段加母亲的前半段。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">203651</div><div class=\"line\">100344</div><div class=\"line\">取后三位交叉</div><div class=\"line\">203344</div><div class=\"line\">100651</div></pre></td></tr></table></figure>\n<p>交叉算子的方式还有其他更复杂的。</p>\n<h3 id=\"突变\"><a href=\"#突变\" class=\"headerlink\" title=\"突变\"></a>突变</h3><p>子代有很小的概率会发生基因突变，比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">203344 -&gt; 206344</div></pre></td></tr></table></figure>\n<p>第三个位置的基因发生变化。</p>\n<h2 id=\"吐槽\"><a href=\"#吐槽\" class=\"headerlink\" title=\"吐槽\"></a>吐槽</h2><p>实际上这个参数还是很麻烦。。我调了很长时间，最后进化了 2000 次，最高得分大概维持在 380 附近，这是种群平均分和种群中最高分随子代数的趋势图，可以看到种群确实在一点一点进化，如果参数更合理一点相信一定能达到几乎满分的得分的~</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/genetic-algorithm/02.png\" alt=\"\"></p>\n<p>贴一个 380 分左右的策略：<code>450351253450256256354356265152354252154454454351351464051353450055356644335603132054351253256352104350004552116414256156116103346453105056355052053324226604006321154130114255453253352312102112111412414140255154432364654062360530606611264324300</code></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>完整代码在 <a href=\"https://github.com/sunhengzhe/roby\" target=\"_blank\" rel=\"external\">这里</a></p>\n","excerpt":"<p>遗传算法是一个很有意思的算法。</p>\n<p>我们都知道达尔文提出了伟大的“生物进化论”，他证明了所有的生物都不是上帝创造的，而是在遗传、变异、生存斗争和自然选择中，由简单到复杂，由低等到高等，不断发展变化的。也就是：物竞天择、适者生存、优胜劣汰。</p>\n<p>达尔文的进化论给美国的科学家霍兰德留下了深刻的印象，但他从计算机科学的角度思考了这个问题，他想到，是否可以像繁育良种马和良种玉米一样繁育程序。这也就是遗传算法的由来。遗传算法借鉴了进化生物学中的一些现象，包括遗传、突变、自然选择以及杂交等。</p>","more":"<h2 id=\"扫地机器人罗比\"><a href=\"#扫地机器人罗比\" class=\"headerlink\" title=\"扫地机器人罗比\"></a>扫地机器人罗比</h2><p>在《复杂》这本书中有个例子，罗比是一个扫地机器人，他生活在一个 10 * 10 格子的世界里，这个世界随机散落着易拉罐，且每个格子最多只有一个易拉罐。罗比的任务是清理这些易拉罐。世界的周围都是墙壁。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/genetic-algorithm/01.PNG\" alt=\"罗比的世界\"></p>\n<p>罗比的视野是有限的，他只能看到四周格子以及自己所在位置的情况，也就是上下左右和当前位置五个格子的情况。</p>\n<p>每次清理工作罗比可以执行 200 个动作，动作可以是：向上走，向下走，向左走，向右走，随机一个方向走、捡罐头、不动。每一个动作执行完以后都会有一个评分：如果捡罐头时格子中有罐头，那么罐头被捡起，加 10 分。如果捡罐头的时候格子中没有罐头，扣 1 分。如果罗比撞到了墙，扣 5 分。</p>\n<p>显然，罗比尽可能多捡到罐头、别在没罐头的时候去捡、别撞墙，分数就越高。那么，我们需要设计一套策略，让罗比根据当前所在位置的状态去执行相应的动作，能够拿到最高的分。</p>\n<p>那么，总共有多少种状态？</p>\n<p>每次罗比看到的格子为：上下左右中，一共 5 个格子，而每个格子有三种可能性：没罐头、有罐头、墙壁。我们把没罐头记为 0，有罐头记为 1，是墙壁记为 2。那么状态可以列为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">上下左右中</div><div class=\"line\">0 0 0 0 0</div><div class=\"line\">0 0 0 0 1</div><div class=\"line\">0 0 0 0 2</div><div class=\"line\">0 0 0 1 0</div><div class=\"line\">0 0 0 1 1</div><div class=\"line\">...</div><div class=\"line\">2 2 2 2 2</div></pre></td></tr></table></figure>\n<p>显然，一共有 <code>3 * 3 * 3 * 3 * 3 = 243</code> 种状态。</p>\n<p>而对于每一种状态，罗比有 7 种动作可以执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">0: 向上走</div><div class=\"line\">1: 向下走</div><div class=\"line\">2: 向左走</div><div class=\"line\">3: 向右走</div><div class=\"line\">4: 随机选取方向走</div><div class=\"line\">5: 捡罐头</div><div class=\"line\">6: 什么都不干</div></pre></td></tr></table></figure>\n<p>所以，243 个状态，每个状态 7 种动作，那么策略的总数是 <code>$7^243$</code> 个。要想遍历所有的策略去求最优解显然是不现实的，在这里可以使用遗传算法，来 <strong>“进化”</strong> 出一个近似最优解。</p>\n<h2 id=\"遗传算法设计\"><a href=\"#遗传算法设计\" class=\"headerlink\" title=\"遗传算法设计\"></a>遗传算法设计</h2><p>之前已经提到过了，遗传算法借鉴了自然选择中的思想，在遗传算法中，也有“种群”、“染色体”、“基因”、“杂交”、“变异”等概念。</p>\n<p>试想我们需要得到的策略是什么样子的。罗比需要根据每一种格子的状态去寻求一种动作，在上面已经提到过，格子的状态分别是 <code>00000</code>、<code>00001</code>、<code>00002</code> 以此类推。我们可以发现，这实际上就是所有的 5 位 3 进制数。</p>\n<p>那么，罗比的策略就可以用一个字符串表示，字符串的长度是格子情况的总数，每一位代表对应格子情况所需要作出的策略，比如 <code>152455021256444063355141362453351200451455123151604162324266004040256060052004316401456203443334225141156451050235106256354245063143011340422626044356444400300555631325215155436144345164455440161256251412661563442063025020602255536510141514365</code>。这个策略的第一位是 1，这代表着罗比所处的情况是 <code>00000</code> 时，应该作出动作 1，也就是向下走。类似的，第二位是 5，代表罗比在 <code>00001</code> 时应该捡罐头。</p>\n<p>我们需要通过遗传算法找到最优的策略，这每一个策略实际上就代表着个体，我们通过一个字符串来代表它，这个字符串可以称为染色体（基因组），染色体是基因的集合，种群是染色体的集合。</p>\n<p>遗传算法首先需要随机生成一个种群，然后通过“自然选择”来筛选他们，越优秀的个体越容易留下来，并不断繁衍出优秀的子代，这样经过一代又一代的选择，最后留下的个体就是近似最优的。</p>\n<p>对应到罗比问题中来，遗传算法过程如下：</p>\n<ol>\n<li>初始化种群：随机生成 200 个个体</li>\n<li>计算适应度：对 200 个个体进行评分，评分的规则是让罗比打扫 1000 次世界，每次打扫世界都是随机生成的，且每次打扫罗比移动 200 步，最后算出这 1000 次打扫的平均分。</li>\n<li>杂交：根据所有个体的得分，随机选取两个个体进行杂交，得分越高的个体越容易被选中。杂交会生成两个子代，将子代放入新种群。重复这个过程，直到新种群的个数达到 200 个。</li>\n<li>突变：子代的一个或多个基因会有一定的概率发生突变，发生突变的基因会随机变为其他的动作，比如从 1 变为 6。</li>\n<li>迭代：重复以上的过程，直到达到 1000 代。</li>\n</ol>\n<p>当然上面的 200、1000 这些数字都是人为设定的，你也可以设定其他的，只要能得到比较好的解就行。</p>\n<p>是不是很有意思，因为我们根本不用动脑去设计策略，而是全部交给了计算机。当然这里面还有适应度函数的设计、杂交的设计、参数的选定等令人伤脑筋的事情，但遗传算法的过程说起来就是这样。</p>\n<h3 id=\"适应度\"><a href=\"#适应度\" class=\"headerlink\" title=\"适应度\"></a>适应度</h3><p>在步骤 2 里面，我们对种群中所有个体进行了评分，评分的实现也比较简单，生成一个世界，根据策略在世界内进行 200 个动作，并把这个过程重复 1000 次即可，最后能拿到一个平均分。</p>\n<h3 id=\"选取父母\"><a href=\"#选取父母\" class=\"headerlink\" title=\"选取父母\"></a>选取父母</h3><p>举个栗子，假设种群内只有 3 个个体，他们得分分别是 <code>1, 2, 7</code>，我们需要进行两次选择，且得分越高的个体越容易被选中。这里使用 <strong>轮盘赌</strong> 方法来选择个体。</p>\n<p>实际上也就是个求概率的问题，三个个体总分为 <code>1 + 2 + 7 = 10</code>，那么每个个体占比就可以算出来：<code>0.1, 0.2, 0.7</code>。然后让每个个体的概率加上前一个个体的概率，也就是：<code>0.1, 0.3, 1</code>。</p>\n<p>这样随机生成一个 0 到 1 的数，然后从左往右去比较，小于哪个个体就选择哪个个体即可。</p>\n<p>当出现负数怎么办，比如 <code>-5, 3, 9</code>，这里可以给每个元素都加上第一个元素的绝对值再加 1，也就是加 6，转为：<code>1, 9, 15</code>，然后再像上面那样按轮盘赌即可。</p>\n<p>事实上，这里可以有很多种方法可以选择，比如全部调完正数后让每个元素平方，或者对所有元素加上一个总步数 * 撞墙扣分，代表一次打扫中最多可能扣掉的分。这里选择方法的选取对整个遗传算法影响也是很大的，需要设计一个比较合理的选择方式。</p>\n<h3 id=\"杂交\"><a href=\"#杂交\" class=\"headerlink\" title=\"杂交\"></a>杂交</h3><p>选择出父母之后，需要让父母进行杂交，比如选取某一个位置，取父亲的前半段加上母亲的后半段，以及父亲的后半段加母亲的前半段。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">203651</div><div class=\"line\">100344</div><div class=\"line\">取后三位交叉</div><div class=\"line\">203344</div><div class=\"line\">100651</div></pre></td></tr></table></figure>\n<p>交叉算子的方式还有其他更复杂的。</p>\n<h3 id=\"突变\"><a href=\"#突变\" class=\"headerlink\" title=\"突变\"></a>突变</h3><p>子代有很小的概率会发生基因突变，比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">203344 -&gt; 206344</div></pre></td></tr></table></figure>\n<p>第三个位置的基因发生变化。</p>\n<h2 id=\"吐槽\"><a href=\"#吐槽\" class=\"headerlink\" title=\"吐槽\"></a>吐槽</h2><p>实际上这个参数还是很麻烦。。我调了很长时间，最后进化了 2000 次，最高得分大概维持在 380 附近，这是种群平均分和种群中最高分随子代数的趋势图，可以看到种群确实在一点一点进化，如果参数更合理一点相信一定能达到几乎满分的得分的~</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/genetic-algorithm/02.png\" alt=\"\"></p>\n<p>贴一个 380 分左右的策略：<code>450351253450256256354356265152354252154454454351351464051353450055356644335603132054351253256352104350004552116414256156116103346453105056355052053324226604006321154130114255453253352312102112111412414140255154432364654062360530606611264324300</code></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>完整代码在 <a href=\"https://github.com/sunhengzhe/roby\">这里</a></p>"},{"title":"hexo 中使用 mathjax 遇到的问题","date":"2017-01-21T13:30:45.000Z","_content":"\n这个博客里面用到的数学公式都是用 mathjax 写的，关于 mathjax 可以参考 [Mathjax与LaTex公式简介](http://mlworks.cn/posts/introduction-to-mathjax-and-latex-expression/) 这篇文章。\n\n这里记录使用 mathjax 过程中遇到的问题。\n\n<!--more-->\n\n### 与 markdown 冲突\n\n#### 下划线 _\n\nmathjax 里，使用下划线 _ 表示下标，但是在 markdown 里，下划线表示斜体的意思，所以在使用下标的时候，会碰到冲突的问题。\n\n**解决办法**：在 `_` 前添加转义符：`\\_`\n\n### 公式对齐\n\n在 mathjax 里，& 代表需要对齐的地方，在结尾处添加 `\\\\` 表示换行，但是在 markdown 中显示为了一整行：\n\n$$\n\\begin{align}\n\\frac{\\sum\\_{i=1}^n(x\\_i - \\overline{X})^2}{n} & = \\frac1n\\sum\\_{i=1}^n(x\\_i - \\overline{X})^2 \\\\\n& = \\frac1n\\sum\\_{i=1}^n[(x\\_i - \\mu) + (\\mu - \\overline{X})]^2 \\\\\n\\end{align}\n$$\n\n**解决办法**：将 `\\\\` 换成 `\\\\\\`。\n","source":"_posts/hexo-mathjax.md","raw":"---\ntitle: hexo 中使用 mathjax 遇到的问题\ndate: 2017-01-21 21:30:45\ntags: [总结]\n---\n\n这个博客里面用到的数学公式都是用 mathjax 写的，关于 mathjax 可以参考 [Mathjax与LaTex公式简介](http://mlworks.cn/posts/introduction-to-mathjax-and-latex-expression/) 这篇文章。\n\n这里记录使用 mathjax 过程中遇到的问题。\n\n<!--more-->\n\n### 与 markdown 冲突\n\n#### 下划线 _\n\nmathjax 里，使用下划线 _ 表示下标，但是在 markdown 里，下划线表示斜体的意思，所以在使用下标的时候，会碰到冲突的问题。\n\n**解决办法**：在 `_` 前添加转义符：`\\_`\n\n### 公式对齐\n\n在 mathjax 里，& 代表需要对齐的地方，在结尾处添加 `\\\\` 表示换行，但是在 markdown 中显示为了一整行：\n\n$$\n\\begin{align}\n\\frac{\\sum\\_{i=1}^n(x\\_i - \\overline{X})^2}{n} & = \\frac1n\\sum\\_{i=1}^n(x\\_i - \\overline{X})^2 \\\\\n& = \\frac1n\\sum\\_{i=1}^n[(x\\_i - \\mu) + (\\mu - \\overline{X})]^2 \\\\\n\\end{align}\n$$\n\n**解决办法**：将 `\\\\` 换成 `\\\\\\`。\n","slug":"hexo-mathjax","published":1,"updated":"2017-01-21T16:31:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcw3001jn927r1mzkwyg","content":"<p>这个博客里面用到的数学公式都是用 mathjax 写的，关于 mathjax 可以参考 <a href=\"http://mlworks.cn/posts/introduction-to-mathjax-and-latex-expression/\" target=\"_blank\" rel=\"external\">Mathjax与LaTex公式简介</a> 这篇文章。</p>\n<p>这里记录使用 mathjax 过程中遇到的问题。</p>\n<a id=\"more\"></a>\n<h3 id=\"与-markdown-冲突\"><a href=\"#与-markdown-冲突\" class=\"headerlink\" title=\"与 markdown 冲突\"></a>与 markdown 冲突</h3><h4 id=\"下划线\"><a href=\"#下划线\" class=\"headerlink\" title=\"下划线 _\"></a>下划线 _</h4><p>mathjax 里，使用下划线 _ 表示下标，但是在 markdown 里，下划线表示斜体的意思，所以在使用下标的时候，会碰到冲突的问题。</p>\n<p><strong>解决办法</strong>：在 <code>_</code> 前添加转义符：<code>\\_</code></p>\n<h3 id=\"公式对齐\"><a href=\"#公式对齐\" class=\"headerlink\" title=\"公式对齐\"></a>公式对齐</h3><p>在 mathjax 里，&amp; 代表需要对齐的地方，在结尾处添加 <code>\\\\</code> 表示换行，但是在 markdown 中显示为了一整行：</p>\n<p>$$<br>\\begin{align}<br>\\frac{\\sum_{i=1}^n(x_i - \\overline{X})^2}{n} &amp; = \\frac1n\\sum_{i=1}^n(x_i - \\overline{X})^2 \\<br>&amp; = \\frac1n\\sum_{i=1}^n[(x_i - \\mu) + (\\mu - \\overline{X})]^2 \\<br>\\end{align}<br>$$</p>\n<p><strong>解决办法</strong>：将 <code>\\\\</code> 换成 <code>\\\\\\</code>。</p>\n","excerpt":"<p>这个博客里面用到的数学公式都是用 mathjax 写的，关于 mathjax 可以参考 <a href=\"http://mlworks.cn/posts/introduction-to-mathjax-and-latex-expression/\">Mathjax与LaTex公式简介</a> 这篇文章。</p>\n<p>这里记录使用 mathjax 过程中遇到的问题。</p>","more":"<h3 id=\"与-markdown-冲突\"><a href=\"#与-markdown-冲突\" class=\"headerlink\" title=\"与 markdown 冲突\"></a>与 markdown 冲突</h3><h4 id=\"下划线\"><a href=\"#下划线\" class=\"headerlink\" title=\"下划线 _\"></a>下划线 _</h4><p>mathjax 里，使用下划线 _ 表示下标，但是在 markdown 里，下划线表示斜体的意思，所以在使用下标的时候，会碰到冲突的问题。</p>\n<p><strong>解决办法</strong>：在 <code>_</code> 前添加转义符：<code>\\_</code></p>\n<h3 id=\"公式对齐\"><a href=\"#公式对齐\" class=\"headerlink\" title=\"公式对齐\"></a>公式对齐</h3><p>在 mathjax 里，&amp; 代表需要对齐的地方，在结尾处添加 <code>\\\\</code> 表示换行，但是在 markdown 中显示为了一整行：</p>\n<p>$$<br>\\begin{align}<br>\\frac{\\sum_{i=1}^n(x_i - \\overline{X})^2}{n} &amp; = \\frac1n\\sum_{i=1}^n(x_i - \\overline{X})^2 \\<br>&amp; = \\frac1n\\sum_{i=1}^n[(x_i - \\mu) + (\\mu - \\overline{X})]^2 \\<br>\\end{align}<br>$$</p>\n<p><strong>解决办法</strong>：将 <code>\\\\</code> 换成 <code>\\\\\\</code>。</p>"},{"title":"假设检验和 p 值","date":"2017-02-13T15:36:45.000Z","_content":"\n当分析两件事情的发生有没有关联的时候，比如每天吃宵夜和长胖，我想知道这两件事情到底有没有关联，那么我们可以做出两个假设。\n\n1. 每天吃宵夜和长胖没有关联，也就是 **零假设**。\n2. 每天吃宵夜和长胖有关联，也就是 **备择假设**。\n\n那么我们到底是接受零假设还是备择假设呢，当然要用数据来说话，我们可以这样做：我们先假设零假设是正确的，然后对样本进行分析，如果分析得到的结果表示：若零假设成立（两件事情没有关联），得到这个样本的概率是极小的，那么我们就能推翻零假设，也就是 **拒绝零假设**，转而接受备择假设。反之，如果结果表示得到样本的概率并不小，那么可以认为零假设是正确的。\n\n<!-- more -->\n\n举个栗子。\n\n已知没有注射药物的老鼠平均反应时间是 1.2 秒，有 100 只注射了药物的老鼠，平均反应时间是 1.05 秒，标准差为 0.5 秒，那么，你认为该药物对反应时间有效果吗？\n\n### 假设检验\n\n首先，我们可以建立两个假设：\n\n1. 零假设（$H_0$）：药物没有效果，注射后的老鼠平均反应时间 $\\mu$ 依旧等于 1.2\n2. 备择假设（$H_1$）：药物有效果，注射后的老鼠平均反应时间 $\\mu \\neq 1.2$\n\n我们先假设零假设是正确的，然后分析得到样本均值为 1.05、标准差为 0.5 这一结果的概率有多大，如果产生这个样本的概率非常小，那么我们就拒绝零假设，反之接受它。\n\n因为样本容量为 100，大于 30，所以可以认为样本均值的抽样分布近似为正态分布，且\n\n$$\n\\mu\\_{\\overline{X}} = 1.2\n$$\n$$\n\\sigma\\_{\\overline{X}} = \\frac{\\sigma}{\\sqrt{n}} \\approx \\frac{s}{\\sqrt{n}} = 0.05\n$$\n\n那么，均值为 1.05 的样本落在样本均值的抽样分布上的概率是多少？我们先求出 z 分数：\n\n$$\nz-score = \\frac{1.05 - 1.2}{0.05} = -3\n$$\n\n也就是说这个样本落在了距样本均值的抽样分布的均值的 3 个标准差的位置，根据正态分布的经验法则，得到距离 3 个标准差的位置（左右各一处）的概率为 $100 - 99.7 = 0.3$，只有 0.3% 的概率。\n\n这个结果说明若零假设成立，也就是样本均值的抽样分布的均值还是 1.2 的话，得到这个样本的概率是很小的，那么就能说明零假设很有可能是错误的。\n\n### p 值\n\n上面这个概率也称为 p 值，一般而言，我们把 p 值上限设置为 5%，当概率小于 5% 时，说明得到这个样本的概率是很小的，换句话说，若零假设成立，应该不太可能得到这个样本，那么我们就说零假设可能是错的，我们转而接受备择假设。在这个例子里面，也就是药物是有效果的。\n\n### 第一型错误\n\n当然，虽然概率小，但是还是有 0.3% 的概率能够得到这个样本，也就是我们的推论有 0.3% 的可能是错误的，这种错误称为第一型错误，在这个例子里面，即拒绝零假设存在 0.3% 的概率犯第一型错误。\n","source":"_posts/hypothesis-testing.md","raw":"---\ntitle: 假设检验和 p 值\ndate: 2017-02-13 23:36:45\ntags: [统计学]\n---\n\n当分析两件事情的发生有没有关联的时候，比如每天吃宵夜和长胖，我想知道这两件事情到底有没有关联，那么我们可以做出两个假设。\n\n1. 每天吃宵夜和长胖没有关联，也就是 **零假设**。\n2. 每天吃宵夜和长胖有关联，也就是 **备择假设**。\n\n那么我们到底是接受零假设还是备择假设呢，当然要用数据来说话，我们可以这样做：我们先假设零假设是正确的，然后对样本进行分析，如果分析得到的结果表示：若零假设成立（两件事情没有关联），得到这个样本的概率是极小的，那么我们就能推翻零假设，也就是 **拒绝零假设**，转而接受备择假设。反之，如果结果表示得到样本的概率并不小，那么可以认为零假设是正确的。\n\n<!-- more -->\n\n举个栗子。\n\n已知没有注射药物的老鼠平均反应时间是 1.2 秒，有 100 只注射了药物的老鼠，平均反应时间是 1.05 秒，标准差为 0.5 秒，那么，你认为该药物对反应时间有效果吗？\n\n### 假设检验\n\n首先，我们可以建立两个假设：\n\n1. 零假设（$H_0$）：药物没有效果，注射后的老鼠平均反应时间 $\\mu$ 依旧等于 1.2\n2. 备择假设（$H_1$）：药物有效果，注射后的老鼠平均反应时间 $\\mu \\neq 1.2$\n\n我们先假设零假设是正确的，然后分析得到样本均值为 1.05、标准差为 0.5 这一结果的概率有多大，如果产生这个样本的概率非常小，那么我们就拒绝零假设，反之接受它。\n\n因为样本容量为 100，大于 30，所以可以认为样本均值的抽样分布近似为正态分布，且\n\n$$\n\\mu\\_{\\overline{X}} = 1.2\n$$\n$$\n\\sigma\\_{\\overline{X}} = \\frac{\\sigma}{\\sqrt{n}} \\approx \\frac{s}{\\sqrt{n}} = 0.05\n$$\n\n那么，均值为 1.05 的样本落在样本均值的抽样分布上的概率是多少？我们先求出 z 分数：\n\n$$\nz-score = \\frac{1.05 - 1.2}{0.05} = -3\n$$\n\n也就是说这个样本落在了距样本均值的抽样分布的均值的 3 个标准差的位置，根据正态分布的经验法则，得到距离 3 个标准差的位置（左右各一处）的概率为 $100 - 99.7 = 0.3$，只有 0.3% 的概率。\n\n这个结果说明若零假设成立，也就是样本均值的抽样分布的均值还是 1.2 的话，得到这个样本的概率是很小的，那么就能说明零假设很有可能是错误的。\n\n### p 值\n\n上面这个概率也称为 p 值，一般而言，我们把 p 值上限设置为 5%，当概率小于 5% 时，说明得到这个样本的概率是很小的，换句话说，若零假设成立，应该不太可能得到这个样本，那么我们就说零假设可能是错的，我们转而接受备择假设。在这个例子里面，也就是药物是有效果的。\n\n### 第一型错误\n\n当然，虽然概率小，但是还是有 0.3% 的概率能够得到这个样本，也就是我们的推论有 0.3% 的可能是错误的，这种错误称为第一型错误，在这个例子里面，即拒绝零假设存在 0.3% 的概率犯第一型错误。\n","slug":"hypothesis-testing","published":1,"updated":"2017-02-13T15:59:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcw5001ln927prno9jl6","content":"<p>当分析两件事情的发生有没有关联的时候，比如每天吃宵夜和长胖，我想知道这两件事情到底有没有关联，那么我们可以做出两个假设。</p>\n<ol>\n<li>每天吃宵夜和长胖没有关联，也就是 <strong>零假设</strong>。</li>\n<li>每天吃宵夜和长胖有关联，也就是 <strong>备择假设</strong>。</li>\n</ol>\n<p>那么我们到底是接受零假设还是备择假设呢，当然要用数据来说话，我们可以这样做：我们先假设零假设是正确的，然后对样本进行分析，如果分析得到的结果表示：若零假设成立（两件事情没有关联），得到这个样本的概率是极小的，那么我们就能推翻零假设，也就是 <strong>拒绝零假设</strong>，转而接受备择假设。反之，如果结果表示得到样本的概率并不小，那么可以认为零假设是正确的。</p>\n<a id=\"more\"></a>\n<p>举个栗子。</p>\n<p>已知没有注射药物的老鼠平均反应时间是 1.2 秒，有 100 只注射了药物的老鼠，平均反应时间是 1.05 秒，标准差为 0.5 秒，那么，你认为该药物对反应时间有效果吗？</p>\n<h3 id=\"假设检验\"><a href=\"#假设检验\" class=\"headerlink\" title=\"假设检验\"></a>假设检验</h3><p>首先，我们可以建立两个假设：</p>\n<ol>\n<li>零假设（$H_0$）：药物没有效果，注射后的老鼠平均反应时间 $\\mu$ 依旧等于 1.2</li>\n<li>备择假设（$H_1$）：药物有效果，注射后的老鼠平均反应时间 $\\mu \\neq 1.2$</li>\n</ol>\n<p>我们先假设零假设是正确的，然后分析得到样本均值为 1.05、标准差为 0.5 这一结果的概率有多大，如果产生这个样本的概率非常小，那么我们就拒绝零假设，反之接受它。</p>\n<p>因为样本容量为 100，大于 30，所以可以认为样本均值的抽样分布近似为正态分布，且</p>\n<p>$$<br>\\mu_{\\overline{X}} = 1.2<br>$$<br>$$<br>\\sigma_{\\overline{X}} = \\frac{\\sigma}{\\sqrt{n}} \\approx \\frac{s}{\\sqrt{n}} = 0.05<br>$$</p>\n<p>那么，均值为 1.05 的样本落在样本均值的抽样分布上的概率是多少？我们先求出 z 分数：</p>\n<p>$$<br>z-score = \\frac{1.05 - 1.2}{0.05} = -3<br>$$</p>\n<p>也就是说这个样本落在了距样本均值的抽样分布的均值的 3 个标准差的位置，根据正态分布的经验法则，得到距离 3 个标准差的位置（左右各一处）的概率为 $100 - 99.7 = 0.3$，只有 0.3% 的概率。</p>\n<p>这个结果说明若零假设成立，也就是样本均值的抽样分布的均值还是 1.2 的话，得到这个样本的概率是很小的，那么就能说明零假设很有可能是错误的。</p>\n<h3 id=\"p-值\"><a href=\"#p-值\" class=\"headerlink\" title=\"p 值\"></a>p 值</h3><p>上面这个概率也称为 p 值，一般而言，我们把 p 值上限设置为 5%，当概率小于 5% 时，说明得到这个样本的概率是很小的，换句话说，若零假设成立，应该不太可能得到这个样本，那么我们就说零假设可能是错的，我们转而接受备择假设。在这个例子里面，也就是药物是有效果的。</p>\n<h3 id=\"第一型错误\"><a href=\"#第一型错误\" class=\"headerlink\" title=\"第一型错误\"></a>第一型错误</h3><p>当然，虽然概率小，但是还是有 0.3% 的概率能够得到这个样本，也就是我们的推论有 0.3% 的可能是错误的，这种错误称为第一型错误，在这个例子里面，即拒绝零假设存在 0.3% 的概率犯第一型错误。</p>\n","excerpt":"<p>当分析两件事情的发生有没有关联的时候，比如每天吃宵夜和长胖，我想知道这两件事情到底有没有关联，那么我们可以做出两个假设。</p>\n<ol>\n<li>每天吃宵夜和长胖没有关联，也就是 <strong>零假设</strong>。</li>\n<li>每天吃宵夜和长胖有关联，也就是 <strong>备择假设</strong>。</li>\n</ol>\n<p>那么我们到底是接受零假设还是备择假设呢，当然要用数据来说话，我们可以这样做：我们先假设零假设是正确的，然后对样本进行分析，如果分析得到的结果表示：若零假设成立（两件事情没有关联），得到这个样本的概率是极小的，那么我们就能推翻零假设，也就是 <strong>拒绝零假设</strong>，转而接受备择假设。反之，如果结果表示得到样本的概率并不小，那么可以认为零假设是正确的。</p>","more":"<p>举个栗子。</p>\n<p>已知没有注射药物的老鼠平均反应时间是 1.2 秒，有 100 只注射了药物的老鼠，平均反应时间是 1.05 秒，标准差为 0.5 秒，那么，你认为该药物对反应时间有效果吗？</p>\n<h3 id=\"假设检验\"><a href=\"#假设检验\" class=\"headerlink\" title=\"假设检验\"></a>假设检验</h3><p>首先，我们可以建立两个假设：</p>\n<ol>\n<li>零假设（$H_0$）：药物没有效果，注射后的老鼠平均反应时间 $\\mu$ 依旧等于 1.2</li>\n<li>备择假设（$H_1$）：药物有效果，注射后的老鼠平均反应时间 $\\mu \\neq 1.2$</li>\n</ol>\n<p>我们先假设零假设是正确的，然后分析得到样本均值为 1.05、标准差为 0.5 这一结果的概率有多大，如果产生这个样本的概率非常小，那么我们就拒绝零假设，反之接受它。</p>\n<p>因为样本容量为 100，大于 30，所以可以认为样本均值的抽样分布近似为正态分布，且</p>\n<p>$$<br>\\mu_{\\overline{X}} = 1.2<br>$$<br>$$<br>\\sigma_{\\overline{X}} = \\frac{\\sigma}{\\sqrt{n}} \\approx \\frac{s}{\\sqrt{n}} = 0.05<br>$$</p>\n<p>那么，均值为 1.05 的样本落在样本均值的抽样分布上的概率是多少？我们先求出 z 分数：</p>\n<p>$$<br>z-score = \\frac{1.05 - 1.2}{0.05} = -3<br>$$</p>\n<p>也就是说这个样本落在了距样本均值的抽样分布的均值的 3 个标准差的位置，根据正态分布的经验法则，得到距离 3 个标准差的位置（左右各一处）的概率为 $100 - 99.7 = 0.3$，只有 0.3% 的概率。</p>\n<p>这个结果说明若零假设成立，也就是样本均值的抽样分布的均值还是 1.2 的话，得到这个样本的概率是很小的，那么就能说明零假设很有可能是错误的。</p>\n<h3 id=\"p-值\"><a href=\"#p-值\" class=\"headerlink\" title=\"p 值\"></a>p 值</h3><p>上面这个概率也称为 p 值，一般而言，我们把 p 值上限设置为 5%，当概率小于 5% 时，说明得到这个样本的概率是很小的，换句话说，若零假设成立，应该不太可能得到这个样本，那么我们就说零假设可能是错的，我们转而接受备择假设。在这个例子里面，也就是药物是有效果的。</p>\n<h3 id=\"第一型错误\"><a href=\"#第一型错误\" class=\"headerlink\" title=\"第一型错误\"></a>第一型错误</h3><p>当然，虽然概率小，但是还是有 0.3% 的概率能够得到这个样本，也就是我们的推论有 0.3% 的可能是错误的，这种错误称为第一型错误，在这个例子里面，即拒绝零假设存在 0.3% 的概率犯第一型错误。</p>"},{"title":"HEXO 搭博客中的坑","date":"2016-08-27T01:10:57.000Z","_content":"\n怎么用 hexo 搭博客其实官网已经写的很清楚了，这里只纪录一些问题和心得。\n\n<!-- more -->\n\n## 过程\n\n写博客的时候，我们并不是在主分支，而是比如在 codes 分支，主分支上存放的是静态文件，也就是供用户访问的 html、css 等，这些都是 hexo 生成的。\n\n当博客写完以后，过程如下：\n\n```\nhexo g\n```\n\n生成静态文件，此时所有静态文件存放在 `public` 目录下。\n\n```\nhexo s\n```\n\n搭建本地静态服务器，默认监听 4000 端口，此时可以通过 `localhost:4000` 访问你的网站，可以预览，看下有没有问题。\n\n```\nhexo d\n```\n\n部署博客，根据 `_config.yml` 部署到远程服务器上，如果使用的是 git，那么你应该部署到 master 分支上。\n\n这样别人就能通过你的 `[username].github.io` 访问你的网站了，如果要关联你自己的域名，需要在 `source` 里添加 CNAME 文件，并使用\n\n```\nPlugins:\n  - hexo-generator-cname\n```\n\n插件，注意大小写敏感。否则会报 `ERROR Deployer not found: git` 错误。\n\n总结来看就是：\n\n你在 codes 分支上写博客 -> `hexo g` -> `hexo d` -> hexo 将静态文件部署到远程 master 分支\n\n## 404\n\n如果你一不小心把 codes 分支覆盖到 master 上了，网站就报 404 了，根据上面的过程，很明显我们只需要让 hexo 重新部署一遍就可以了。\n\n但是运行这两个命令之后并没有什么卵用，在执行这两个命令之前，你需要清空部署目录：\n\n```\nrm -rf .deploy_git/\n```\n\n然后继续 `hexo g`、`hexo d` 即可。\n\n## 不处理 html\n\n如果在 source 里面想放置自己的 html，默认情况下是会被 hexo 渲染的，如果不想，在该 html 顶部添加：\n\n```\nlayout: false\n---\n```","source":"_posts/keng-in-hexo.md","raw":"---\ntitle: HEXO 搭博客中的坑\ndate: 2016-08-27 09:10:57\ntags: [总结, hexo]\n---\n\n怎么用 hexo 搭博客其实官网已经写的很清楚了，这里只纪录一些问题和心得。\n\n<!-- more -->\n\n## 过程\n\n写博客的时候，我们并不是在主分支，而是比如在 codes 分支，主分支上存放的是静态文件，也就是供用户访问的 html、css 等，这些都是 hexo 生成的。\n\n当博客写完以后，过程如下：\n\n```\nhexo g\n```\n\n生成静态文件，此时所有静态文件存放在 `public` 目录下。\n\n```\nhexo s\n```\n\n搭建本地静态服务器，默认监听 4000 端口，此时可以通过 `localhost:4000` 访问你的网站，可以预览，看下有没有问题。\n\n```\nhexo d\n```\n\n部署博客，根据 `_config.yml` 部署到远程服务器上，如果使用的是 git，那么你应该部署到 master 分支上。\n\n这样别人就能通过你的 `[username].github.io` 访问你的网站了，如果要关联你自己的域名，需要在 `source` 里添加 CNAME 文件，并使用\n\n```\nPlugins:\n  - hexo-generator-cname\n```\n\n插件，注意大小写敏感。否则会报 `ERROR Deployer not found: git` 错误。\n\n总结来看就是：\n\n你在 codes 分支上写博客 -> `hexo g` -> `hexo d` -> hexo 将静态文件部署到远程 master 分支\n\n## 404\n\n如果你一不小心把 codes 分支覆盖到 master 上了，网站就报 404 了，根据上面的过程，很明显我们只需要让 hexo 重新部署一遍就可以了。\n\n但是运行这两个命令之后并没有什么卵用，在执行这两个命令之前，你需要清空部署目录：\n\n```\nrm -rf .deploy_git/\n```\n\n然后继续 `hexo g`、`hexo d` 即可。\n\n## 不处理 html\n\n如果在 source 里面想放置自己的 html，默认情况下是会被 hexo 渲染的，如果不想，在该 html 顶部添加：\n\n```\nlayout: false\n---\n```","slug":"keng-in-hexo","published":1,"updated":"2017-03-17T13:40:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcw8001on927qud2ugep","content":"<p>怎么用 hexo 搭博客其实官网已经写的很清楚了，这里只纪录一些问题和心得。</p>\n<a id=\"more\"></a>\n<h2 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h2><p>写博客的时候，我们并不是在主分支，而是比如在 codes 分支，主分支上存放的是静态文件，也就是供用户访问的 html、css 等，这些都是 hexo 生成的。</p>\n<p>当博客写完以后，过程如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo g</div></pre></td></tr></table></figure>\n<p>生成静态文件，此时所有静态文件存放在 <code>public</code> 目录下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo s</div></pre></td></tr></table></figure>\n<p>搭建本地静态服务器，默认监听 4000 端口，此时可以通过 <code>localhost:4000</code> 访问你的网站，可以预览，看下有没有问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo d</div></pre></td></tr></table></figure>\n<p>部署博客，根据 <code>_config.yml</code> 部署到远程服务器上，如果使用的是 git，那么你应该部署到 master 分支上。</p>\n<p>这样别人就能通过你的 <code>[username].github.io</code> 访问你的网站了，如果要关联你自己的域名，需要在 <code>source</code> 里添加 CNAME 文件，并使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Plugins:</div><div class=\"line\">  - hexo-generator-cname</div></pre></td></tr></table></figure>\n<p>插件，注意大小写敏感。否则会报 <code>ERROR Deployer not found: git</code> 错误。</p>\n<p>总结来看就是：</p>\n<p>你在 codes 分支上写博客 -&gt; <code>hexo g</code> -&gt; <code>hexo d</code> -&gt; hexo 将静态文件部署到远程 master 分支</p>\n<h2 id=\"404\"><a href=\"#404\" class=\"headerlink\" title=\"404\"></a>404</h2><p>如果你一不小心把 codes 分支覆盖到 master 上了，网站就报 404 了，根据上面的过程，很明显我们只需要让 hexo 重新部署一遍就可以了。</p>\n<p>但是运行这两个命令之后并没有什么卵用，在执行这两个命令之前，你需要清空部署目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">rm -rf .deploy_git/</div></pre></td></tr></table></figure>\n<p>然后继续 <code>hexo g</code>、<code>hexo d</code> 即可。</p>\n<h2 id=\"不处理-html\"><a href=\"#不处理-html\" class=\"headerlink\" title=\"不处理 html\"></a>不处理 html</h2><p>如果在 source 里面想放置自己的 html，默认情况下是会被 hexo 渲染的，如果不想，在该 html 顶部添加：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">layout: false</div><div class=\"line\">---</div></pre></td></tr></table></figure>","excerpt":"<p>怎么用 hexo 搭博客其实官网已经写的很清楚了，这里只纪录一些问题和心得。</p>","more":"<h2 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h2><p>写博客的时候，我们并不是在主分支，而是比如在 codes 分支，主分支上存放的是静态文件，也就是供用户访问的 html、css 等，这些都是 hexo 生成的。</p>\n<p>当博客写完以后，过程如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo g</div></pre></td></tr></table></figure>\n<p>生成静态文件，此时所有静态文件存放在 <code>public</code> 目录下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo s</div></pre></td></tr></table></figure>\n<p>搭建本地静态服务器，默认监听 4000 端口，此时可以通过 <code>localhost:4000</code> 访问你的网站，可以预览，看下有没有问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo d</div></pre></td></tr></table></figure>\n<p>部署博客，根据 <code>_config.yml</code> 部署到远程服务器上，如果使用的是 git，那么你应该部署到 master 分支上。</p>\n<p>这样别人就能通过你的 <code>[username].github.io</code> 访问你的网站了，如果要关联你自己的域名，需要在 <code>source</code> 里添加 CNAME 文件，并使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Plugins:</div><div class=\"line\">  - hexo-generator-cname</div></pre></td></tr></table></figure>\n<p>插件，注意大小写敏感。否则会报 <code>ERROR Deployer not found: git</code> 错误。</p>\n<p>总结来看就是：</p>\n<p>你在 codes 分支上写博客 -&gt; <code>hexo g</code> -&gt; <code>hexo d</code> -&gt; hexo 将静态文件部署到远程 master 分支</p>\n<h2 id=\"404\"><a href=\"#404\" class=\"headerlink\" title=\"404\"></a>404</h2><p>如果你一不小心把 codes 分支覆盖到 master 上了，网站就报 404 了，根据上面的过程，很明显我们只需要让 hexo 重新部署一遍就可以了。</p>\n<p>但是运行这两个命令之后并没有什么卵用，在执行这两个命令之前，你需要清空部署目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">rm -rf .deploy_git/</div></pre></td></tr></table></figure>\n<p>然后继续 <code>hexo g</code>、<code>hexo d</code> 即可。</p>\n<h2 id=\"不处理-html\"><a href=\"#不处理-html\" class=\"headerlink\" title=\"不处理 html\"></a>不处理 html</h2><p>如果在 source 里面想放置自己的 html，默认情况下是会被 hexo 渲染的，如果不想，在该 html 顶部添加：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">layout: false</div><div class=\"line\">---</div></pre></td></tr></table></figure>"},{"title":"ROP 项目所得","date":"2017-03-17T14:28:59.000Z","_content":"\n最近几周一直在做 ROP 的权限模块，包括了前端和后端接口，前端使用了 `react`，UI 使用 `ant design`，后端使用 `nodejs` + `mongodb`，框架使用 `keystone`。好久没写 `react` 了，趁此机会也把 `react` 好好捡了捡，也发现了一些以前没有注意到的不合理的或者错误的用法。\n\n因为是中途加入项目，也总结了一些问题，在此都做下记录。\n\nPS. `ant design` 和 `keystone` 真是好用\n\n<!-- more -->\n\n## React\n\n### 1.不在 JSX 的属性使用 bind()\n\n而是在构造函数中使用 `bind()`\n\n以前的用法是：\n\n```jsx\nrender() {\n  return (\n    <Table\n      onChange={this.handleTableChange.bind(this)}\n    />\n  );\n}\n```\n\n正确的方式应该是在构造函数中绑定 `this`:\n\n```jsx\nconstructor(...args) {\n    super(...args);\n    // 绑定 this\n    this.handleTableChange = this.handleTableChange.bind(this);\n}\n\nhandleTableChange() {\n    //...\n}\n\nrender() {\n    return (\n        <Table\n            onChange={this.handleTableChange}\n        />\n    );\n}\n```\n\n或者直接使用 `es7` 风格：\n\n```jsx\nhandleTableChange = () => {\n  //...\n}\n\nrender() {\n    return (\n        <Table\n            onChange={this.handleTableChange}\n        />\n    );\n}\n```\n\n### 2.使用 props 传递数据流 / 不要滥用 ref\n\n在使用 `react` 的过程中，经常会出现父组件要获取子组件内部状态的情况，在我之前使用 `react` 的过程中，我一直都是用的 `ref`，今天反思了一下，可能是在发现 `ref` 可以获取组件的 `DOM` 和实例之后觉得这个东西非常好用才开始滥用 `ref` 的。。\n\n以前的使用方式：\n\n```jsx\n// 父组件\nclass Parent extends React.Component {\n\n    handleClick = () => {\n        const dog = this.refs.child.getDog();\n        //...\n    }\n\n    render() {\n        return (\n            <div>\n                <Child ref=\"child\" />\n                <Button onClick={this.handleClick} />\n            </div>\n        );\n    }\n}\n\n// 子组件\nclass Child extends React.Component {\n\n    state = {\n        dog: 'aoliao',\n    };\n\n    getDog = () => {\n        return this.state.dog;\n    }\n\n    render() {\n        const { dog } = this.state;\n        return (\n            <div>\n                {dog}\n            </div>\n        );\n    }\n}\n```\n\n我不知道有没有人和我一样这样用。。本来我还觉得是很正常的使用方法，其实因为过度使用 `ref`，使得整个设计都会有问题，因为可以通过 `ref` 拿子组件内部的数据，所以就让每个子组件自己维护自己的内容，好像独立了起来（听起来还挺有道理），但是长此下去，整个数据流就变得很混乱，也会出现过度封装的情况。\n\n正确的方式是使用 `props` 来传递数据，既然 `dog` 这个属性在父组件要用到，那么就把 `dog` 放在父组件中，处理逻辑也就都移到父组件里去了，子组件只是通过 `prop` 拿着父组件的 `dog` 去干事情，但最终 `dog` 还是在父组件中，就好像角色倒过来了一样。\n\n```jsx\n// 父组件\nclass Parent extends React.Component {\n\n    state = {\n        dog: 'aoliao',\n    }\n\n    handleClick = () => {\n        const { dog } = this.state;\n        //...\n    }\n\n    render() {\n        const { dog } = this.state;\n        return (\n            <div>\n                <Child dog={dog} />\n                <Button onClick={this.handleClick} />\n            </div>\n        );\n    }\n}\n\n// 子组件\nclass Child extends React.Component {\n\n    state = {\n        dog: this.props.dog,\n    }\n\n    // 如果属性会变化，使用 componentWillReceiveProps 监听属性的变化\n    componentWillReceiveProps = (nextProps) => {\n        // 比较新老属性的不同\n        if (this.props.dog != nextProps.dog) {\n            this.setState({\n                dog: nextProps.dog,\n            });\n        }\n    }\n\n    render() {\n        const { dog } = this.state;\n        return (\n            <div>\n                {dog}\n            </div>\n        );\n    }\n}\n```\n\n### 3.定义 propTypes 时使用 shape 代替 object\n\n当组件需要接收属性时，定义 `propTypes` 检查是一个好的习惯。\n\n另外根据 `eslint` 中的 `react/forbid-prop-types` 校验规则，应该避免使用 `object` 和 `array`，而使用更详细的 `shape` 和 `arrayOf()`\n\n```jsx\n// bad\nUserDetailsPanel.propTypes = {\n    form: React.PropTypes.object,\n    checkedKeys: React.PropTypes.array,\n};\n\n// good!\nUserDetailsPanel.propTypes = {\n    form: React.PropTypes.shape({\n        getFieldDecorator: React.PropTypes.func,\n        getFieldsError: React.PropTypes.func,\n        setFieldsValue: React.PropTypes.func,\n        validateFields: React.PropTypes.func,\n    }),\n    checkedKeys: React.PropTypes.arrayOf(React.Proptypes.string),\n};\n```\n\n### 4.ant design 里异步加载树数据时 Cannot set property 'checked' of undefined\n\n这个问题找了好一会，起初是发现同时设置 `onCheck`和 `checkedKeys` 属性时会报错，后来发现是异步加载数据的问题。\n\n其实 ant design 文档的最后也有说明，当树的数据是异步加载时，应该使用：\n\n```jsx\n{\n    loading ? '...' : (\n        <Tree>{this.state.treeData.map(data => <TreeNode />)}</Tree>\n    )\n}\n```\n\n### 5.无状态的组件使用纯函数(pure function)\n```jsx\nexport default () => (\n  <div>\n    这个页面可不是一般人能看见的\n  </div>\n);\n```\n\n## 配置\n\n### 1.webpackJsonp is not defined 错误\n\n原因是使用了 `CommonChunkPlugin` 但没有首先引用公共文件\n\n```jsx\n// webpack.config.js\nmodule.exports = {\n    // 在这里使用了 CommonChunkPlugin 插件\n    plugins: [\n        new webpack.optimize.CommonsChunkPlugin({ name: 'commons' })\n    ]\n}\n\n// index.jade\nextends ../layouts/default\n\nblock content\n    .container\n        div#app\n\t// 必须要引入 commons.js\n    script(src= baseUrl + 'commons.js')\n```\n\n### 2.regeneratorRuntime is not defined 错误\n\n这个错误是我想在前端引入 react，并使用 es6 风格编码时发生的。\n\n原因是没有引入 `babel-polyfill`\n\n```jsx\n// webpack.config.js\nmodule.exports = {\n    entry: {\n        // '文件名': '引用的模块'\n        'babel-polyfill': 'babel-polyfill',\n        // ...\n    }\n    //...\n}\n\n// index.jade\nextends ../layouts/default\n\nblock content\n    .container\n        div#app\n\t// 根据 config 文件中定义的文件名引入 babel-polyfill.js\n    script(src= baseUrl + 'babel-polyfill.js')\n```\n\n### 3.eslint 开启 es7 风格\n\n`babel-eslint` 默认支持 es7 风格的检查，在配置文件 `.eslintrc.js` 中添加一个属性即可。\n\n```jsx\nmodule.exports = {\n    parser: \"babel-eslint\",\n    // ...\n}\n```\n","source":"_posts/learn-from-rop.md","raw":"---\ntitle: ROP 项目所得\ndate: 2017-03-17 22:28:59\ntags: [总结]\n---\n\n最近几周一直在做 ROP 的权限模块，包括了前端和后端接口，前端使用了 `react`，UI 使用 `ant design`，后端使用 `nodejs` + `mongodb`，框架使用 `keystone`。好久没写 `react` 了，趁此机会也把 `react` 好好捡了捡，也发现了一些以前没有注意到的不合理的或者错误的用法。\n\n因为是中途加入项目，也总结了一些问题，在此都做下记录。\n\nPS. `ant design` 和 `keystone` 真是好用\n\n<!-- more -->\n\n## React\n\n### 1.不在 JSX 的属性使用 bind()\n\n而是在构造函数中使用 `bind()`\n\n以前的用法是：\n\n```jsx\nrender() {\n  return (\n    <Table\n      onChange={this.handleTableChange.bind(this)}\n    />\n  );\n}\n```\n\n正确的方式应该是在构造函数中绑定 `this`:\n\n```jsx\nconstructor(...args) {\n    super(...args);\n    // 绑定 this\n    this.handleTableChange = this.handleTableChange.bind(this);\n}\n\nhandleTableChange() {\n    //...\n}\n\nrender() {\n    return (\n        <Table\n            onChange={this.handleTableChange}\n        />\n    );\n}\n```\n\n或者直接使用 `es7` 风格：\n\n```jsx\nhandleTableChange = () => {\n  //...\n}\n\nrender() {\n    return (\n        <Table\n            onChange={this.handleTableChange}\n        />\n    );\n}\n```\n\n### 2.使用 props 传递数据流 / 不要滥用 ref\n\n在使用 `react` 的过程中，经常会出现父组件要获取子组件内部状态的情况，在我之前使用 `react` 的过程中，我一直都是用的 `ref`，今天反思了一下，可能是在发现 `ref` 可以获取组件的 `DOM` 和实例之后觉得这个东西非常好用才开始滥用 `ref` 的。。\n\n以前的使用方式：\n\n```jsx\n// 父组件\nclass Parent extends React.Component {\n\n    handleClick = () => {\n        const dog = this.refs.child.getDog();\n        //...\n    }\n\n    render() {\n        return (\n            <div>\n                <Child ref=\"child\" />\n                <Button onClick={this.handleClick} />\n            </div>\n        );\n    }\n}\n\n// 子组件\nclass Child extends React.Component {\n\n    state = {\n        dog: 'aoliao',\n    };\n\n    getDog = () => {\n        return this.state.dog;\n    }\n\n    render() {\n        const { dog } = this.state;\n        return (\n            <div>\n                {dog}\n            </div>\n        );\n    }\n}\n```\n\n我不知道有没有人和我一样这样用。。本来我还觉得是很正常的使用方法，其实因为过度使用 `ref`，使得整个设计都会有问题，因为可以通过 `ref` 拿子组件内部的数据，所以就让每个子组件自己维护自己的内容，好像独立了起来（听起来还挺有道理），但是长此下去，整个数据流就变得很混乱，也会出现过度封装的情况。\n\n正确的方式是使用 `props` 来传递数据，既然 `dog` 这个属性在父组件要用到，那么就把 `dog` 放在父组件中，处理逻辑也就都移到父组件里去了，子组件只是通过 `prop` 拿着父组件的 `dog` 去干事情，但最终 `dog` 还是在父组件中，就好像角色倒过来了一样。\n\n```jsx\n// 父组件\nclass Parent extends React.Component {\n\n    state = {\n        dog: 'aoliao',\n    }\n\n    handleClick = () => {\n        const { dog } = this.state;\n        //...\n    }\n\n    render() {\n        const { dog } = this.state;\n        return (\n            <div>\n                <Child dog={dog} />\n                <Button onClick={this.handleClick} />\n            </div>\n        );\n    }\n}\n\n// 子组件\nclass Child extends React.Component {\n\n    state = {\n        dog: this.props.dog,\n    }\n\n    // 如果属性会变化，使用 componentWillReceiveProps 监听属性的变化\n    componentWillReceiveProps = (nextProps) => {\n        // 比较新老属性的不同\n        if (this.props.dog != nextProps.dog) {\n            this.setState({\n                dog: nextProps.dog,\n            });\n        }\n    }\n\n    render() {\n        const { dog } = this.state;\n        return (\n            <div>\n                {dog}\n            </div>\n        );\n    }\n}\n```\n\n### 3.定义 propTypes 时使用 shape 代替 object\n\n当组件需要接收属性时，定义 `propTypes` 检查是一个好的习惯。\n\n另外根据 `eslint` 中的 `react/forbid-prop-types` 校验规则，应该避免使用 `object` 和 `array`，而使用更详细的 `shape` 和 `arrayOf()`\n\n```jsx\n// bad\nUserDetailsPanel.propTypes = {\n    form: React.PropTypes.object,\n    checkedKeys: React.PropTypes.array,\n};\n\n// good!\nUserDetailsPanel.propTypes = {\n    form: React.PropTypes.shape({\n        getFieldDecorator: React.PropTypes.func,\n        getFieldsError: React.PropTypes.func,\n        setFieldsValue: React.PropTypes.func,\n        validateFields: React.PropTypes.func,\n    }),\n    checkedKeys: React.PropTypes.arrayOf(React.Proptypes.string),\n};\n```\n\n### 4.ant design 里异步加载树数据时 Cannot set property 'checked' of undefined\n\n这个问题找了好一会，起初是发现同时设置 `onCheck`和 `checkedKeys` 属性时会报错，后来发现是异步加载数据的问题。\n\n其实 ant design 文档的最后也有说明，当树的数据是异步加载时，应该使用：\n\n```jsx\n{\n    loading ? '...' : (\n        <Tree>{this.state.treeData.map(data => <TreeNode />)}</Tree>\n    )\n}\n```\n\n### 5.无状态的组件使用纯函数(pure function)\n```jsx\nexport default () => (\n  <div>\n    这个页面可不是一般人能看见的\n  </div>\n);\n```\n\n## 配置\n\n### 1.webpackJsonp is not defined 错误\n\n原因是使用了 `CommonChunkPlugin` 但没有首先引用公共文件\n\n```jsx\n// webpack.config.js\nmodule.exports = {\n    // 在这里使用了 CommonChunkPlugin 插件\n    plugins: [\n        new webpack.optimize.CommonsChunkPlugin({ name: 'commons' })\n    ]\n}\n\n// index.jade\nextends ../layouts/default\n\nblock content\n    .container\n        div#app\n\t// 必须要引入 commons.js\n    script(src= baseUrl + 'commons.js')\n```\n\n### 2.regeneratorRuntime is not defined 错误\n\n这个错误是我想在前端引入 react，并使用 es6 风格编码时发生的。\n\n原因是没有引入 `babel-polyfill`\n\n```jsx\n// webpack.config.js\nmodule.exports = {\n    entry: {\n        // '文件名': '引用的模块'\n        'babel-polyfill': 'babel-polyfill',\n        // ...\n    }\n    //...\n}\n\n// index.jade\nextends ../layouts/default\n\nblock content\n    .container\n        div#app\n\t// 根据 config 文件中定义的文件名引入 babel-polyfill.js\n    script(src= baseUrl + 'babel-polyfill.js')\n```\n\n### 3.eslint 开启 es7 风格\n\n`babel-eslint` 默认支持 es7 风格的检查，在配置文件 `.eslintrc.js` 中添加一个属性即可。\n\n```jsx\nmodule.exports = {\n    parser: \"babel-eslint\",\n    // ...\n}\n```\n","slug":"learn-from-rop","published":1,"updated":"2017-03-21T03:07:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcwc001qn927iqnsku4v","content":"<p>最近几周一直在做 ROP 的权限模块，包括了前端和后端接口，前端使用了 <code>react</code>，UI 使用 <code>ant design</code>，后端使用 <code>nodejs</code> + <code>mongodb</code>，框架使用 <code>keystone</code>。好久没写 <code>react</code> 了，趁此机会也把 <code>react</code> 好好捡了捡，也发现了一些以前没有注意到的不合理的或者错误的用法。</p>\n<p>因为是中途加入项目，也总结了一些问题，在此都做下记录。</p>\n<p>PS. <code>ant design</code> 和 <code>keystone</code> 真是好用</p>\n<a id=\"more\"></a>\n<h2 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h2><h3 id=\"1-不在-JSX-的属性使用-bind\"><a href=\"#1-不在-JSX-的属性使用-bind\" class=\"headerlink\" title=\"1.不在 JSX 的属性使用 bind()\"></a>1.不在 JSX 的属性使用 bind()</h3><p>而是在构造函数中使用 <code>bind()</code></p>\n<p>以前的用法是：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">render() &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    &lt;Table</div><div class=\"line\">      onChange=&#123;this.handleTableChange.bind(this)&#125;</div><div class=\"line\">    /&gt;</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>正确的方式应该是在构造函数中绑定 <code>this</code>:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">constructor</span>(...args) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(...args);</div><div class=\"line\">    <span class=\"comment\">// 绑定 this</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.handleTableChange = <span class=\"keyword\">this</span>.handleTableChange.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">handleTableChange() &#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">        &lt;Table</div><div class=\"line\">            onChange=&#123;this.handleTableChange&#125;</div><div class=\"line\">        /&gt;</div><div class=\"line\">    );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>或者直接使用 <code>es7</code> 风格：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">handleTableChange = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">        &lt;Table</div><div class=\"line\">            onChange=&#123;this.handleTableChange&#125;</div><div class=\"line\">        /&gt;</div><div class=\"line\">    );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2-使用-props-传递数据流-不要滥用-ref\"><a href=\"#2-使用-props-传递数据流-不要滥用-ref\" class=\"headerlink\" title=\"2.使用 props 传递数据流 / 不要滥用 ref\"></a>2.使用 props 传递数据流 / 不要滥用 ref</h3><p>在使用 <code>react</code> 的过程中，经常会出现父组件要获取子组件内部状态的情况，在我之前使用 <code>react</code> 的过程中，我一直都是用的 <code>ref</code>，今天反思了一下，可能是在发现 <code>ref</code> 可以获取组件的 <code>DOM</code> 和实例之后觉得这个东西非常好用才开始滥用 <code>ref</code> 的。。</p>\n<p>以前的使用方式：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 父组件</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    handleClick = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> dog = <span class=\"keyword\">this</span>.refs.child.getDog();</div><div class=\"line\">        <span class=\"comment\">//...</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    render() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            &lt;div&gt;</div><div class=\"line\">                &lt;Child ref=\"child\" /&gt;</div><div class=\"line\">                &lt;Button onClick=&#123;this.handleClick&#125; /&gt;</div><div class=\"line\">            &lt;/div&gt;</div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 子组件</div><div class=\"line\">class Child extends React.Component &#123;</div><div class=\"line\"></div><div class=\"line\">    state = &#123;</div><div class=\"line\">        dog: 'aoliao',</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    getDog = () =&gt; &#123;</div><div class=\"line\">        return this.state.dog;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    render() &#123;</div><div class=\"line\">        const &#123; dog &#125; = this.state;</div><div class=\"line\">        return (</div><div class=\"line\">            &lt;div&gt;</div><div class=\"line\">                &#123;dog&#125;</div><div class=\"line\">            &lt;/div&gt;</div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我不知道有没有人和我一样这样用。。本来我还觉得是很正常的使用方法，其实因为过度使用 <code>ref</code>，使得整个设计都会有问题，因为可以通过 <code>ref</code> 拿子组件内部的数据，所以就让每个子组件自己维护自己的内容，好像独立了起来（听起来还挺有道理），但是长此下去，整个数据流就变得很混乱，也会出现过度封装的情况。</p>\n<p>正确的方式是使用 <code>props</code> 来传递数据，既然 <code>dog</code> 这个属性在父组件要用到，那么就把 <code>dog</code> 放在父组件中，处理逻辑也就都移到父组件里去了，子组件只是通过 <code>prop</code> 拿着父组件的 <code>dog</code> 去干事情，但最终 <code>dog</code> 还是在父组件中，就好像角色倒过来了一样。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 父组件</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    state = &#123;</div><div class=\"line\">        <span class=\"attr\">dog</span>: <span class=\"string\">'aoliao'</span>,</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    handleClick = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> &#123; dog &#125; = <span class=\"keyword\">this</span>.state;</div><div class=\"line\">        <span class=\"comment\">//...</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    render() &#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> &#123; dog &#125; = <span class=\"keyword\">this</span>.state;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            &lt;div&gt;</div><div class=\"line\">                &lt;Child dog=&#123;dog&#125; /&gt;</div><div class=\"line\">                &lt;Button onClick=&#123;this.handleClick&#125; /&gt;</div><div class=\"line\">            &lt;/div&gt;</div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 子组件</div><div class=\"line\">class Child extends React.Component &#123;</div><div class=\"line\"></div><div class=\"line\">    state = &#123;</div><div class=\"line\">        dog: this.props.dog,</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // 如果属性会变化，使用 componentWillReceiveProps 监听属性的变化</div><div class=\"line\">    componentWillReceiveProps = (nextProps) =&gt; &#123;</div><div class=\"line\">        // 比较新老属性的不同</div><div class=\"line\">        if (this.props.dog != nextProps.dog) &#123;</div><div class=\"line\">            this.setState(&#123;</div><div class=\"line\">                dog: nextProps.dog,</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    render() &#123;</div><div class=\"line\">        const &#123; dog &#125; = this.state;</div><div class=\"line\">        return (</div><div class=\"line\">            &lt;div&gt;</div><div class=\"line\">                &#123;dog&#125;</div><div class=\"line\">            &lt;/div&gt;</div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-定义-propTypes-时使用-shape-代替-object\"><a href=\"#3-定义-propTypes-时使用-shape-代替-object\" class=\"headerlink\" title=\"3.定义 propTypes 时使用 shape 代替 object\"></a>3.定义 propTypes 时使用 shape 代替 object</h3><p>当组件需要接收属性时，定义 <code>propTypes</code> 检查是一个好的习惯。</p>\n<p>另外根据 <code>eslint</code> 中的 <code>react/forbid-prop-types</code> 校验规则，应该避免使用 <code>object</code> 和 <code>array</code>，而使用更详细的 <code>shape</code> 和 <code>arrayOf()</code></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// bad</span></div><div class=\"line\">UserDetailsPanel.propTypes = &#123;</div><div class=\"line\">    <span class=\"attr\">form</span>: React.PropTypes.object,</div><div class=\"line\">    <span class=\"attr\">checkedKeys</span>: React.PropTypes.array,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// good!</span></div><div class=\"line\">UserDetailsPanel.propTypes = &#123;</div><div class=\"line\">    <span class=\"attr\">form</span>: React.PropTypes.shape(&#123;</div><div class=\"line\">        <span class=\"attr\">getFieldDecorator</span>: React.PropTypes.func,</div><div class=\"line\">        <span class=\"attr\">getFieldsError</span>: React.PropTypes.func,</div><div class=\"line\">        <span class=\"attr\">setFieldsValue</span>: React.PropTypes.func,</div><div class=\"line\">        <span class=\"attr\">validateFields</span>: React.PropTypes.func,</div><div class=\"line\">    &#125;),</div><div class=\"line\">    <span class=\"attr\">checkedKeys</span>: React.PropTypes.arrayOf(React.Proptypes.string),</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"4-ant-design-里异步加载树数据时-Cannot-set-property-‘checked’-of-undefined\"><a href=\"#4-ant-design-里异步加载树数据时-Cannot-set-property-‘checked’-of-undefined\" class=\"headerlink\" title=\"4.ant design 里异步加载树数据时 Cannot set property ‘checked’ of undefined\"></a>4.ant design 里异步加载树数据时 Cannot set property ‘checked’ of undefined</h3><p>这个问题找了好一会，起初是发现同时设置 <code>onCheck</code>和 <code>checkedKeys</code> 属性时会报错，后来发现是异步加载数据的问题。</p>\n<p>其实 ant design 文档的最后也有说明，当树的数据是异步加载时，应该使用：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    loading ? <span class=\"string\">'...'</span> : (</div><div class=\"line\">        &lt;Tree&gt;&#123;this.state.treeData.map(data =&gt; &lt;TreeNode /&gt;)&#125;&lt;/Tree&gt;</div><div class=\"line\">    )</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"5-无状态的组件使用纯函数-pure-function\"><a href=\"#5-无状态的组件使用纯函数-pure-function\" class=\"headerlink\" title=\"5.无状态的组件使用纯函数(pure function)\"></a>5.无状态的组件使用纯函数(pure function)</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; (</div><div class=\"line\">  &lt;div&gt;</div><div class=\"line\">    这个页面可不是一般人能看见的</div><div class=\"line\">  &lt;/div&gt;</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><h3 id=\"1-webpackJsonp-is-not-defined-错误\"><a href=\"#1-webpackJsonp-is-not-defined-错误\" class=\"headerlink\" title=\"1.webpackJsonp is not defined 错误\"></a>1.webpackJsonp is not defined 错误</h3><p>原因是使用了 <code>CommonChunkPlugin</code> 但没有首先引用公共文件</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">// webpack.config.js</div><div class=\"line\">module.exports = &#123;</div><div class=\"line\">    // 在这里使用了 CommonChunkPlugin 插件</div><div class=\"line\">    plugins: [</div><div class=\"line\">        new webpack.optimize.CommonsChunkPlugin(&#123; name: 'commons' &#125;)</div><div class=\"line\">    ]</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// index.jade</div><div class=\"line\">extends ../layouts/default</div><div class=\"line\"></div><div class=\"line\">block content</div><div class=\"line\">    .container</div><div class=\"line\">        div#app</div><div class=\"line\">\t// 必须要引入 commons.js</div><div class=\"line\">    script(src= baseUrl + 'commons.js')</div></pre></td></tr></table></figure>\n<h3 id=\"2-regeneratorRuntime-is-not-defined-错误\"><a href=\"#2-regeneratorRuntime-is-not-defined-错误\" class=\"headerlink\" title=\"2.regeneratorRuntime is not defined 错误\"></a>2.regeneratorRuntime is not defined 错误</h3><p>这个错误是我想在前端引入 react，并使用 es6 风格编码时发生的。</p>\n<p>原因是没有引入 <code>babel-polyfill</code></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">// webpack.config.js</div><div class=\"line\">module.exports = &#123;</div><div class=\"line\">    entry: &#123;</div><div class=\"line\">        // '文件名': '引用的模块'</div><div class=\"line\">        'babel-polyfill': 'babel-polyfill',</div><div class=\"line\">        // ...</div><div class=\"line\">    &#125;</div><div class=\"line\">    //...</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// index.jade</div><div class=\"line\">extends ../layouts/default</div><div class=\"line\"></div><div class=\"line\">block content</div><div class=\"line\">    .container</div><div class=\"line\">        div#app</div><div class=\"line\">\t// 根据 config 文件中定义的文件名引入 babel-polyfill.js</div><div class=\"line\">    script(src= baseUrl + 'babel-polyfill.js')</div></pre></td></tr></table></figure>\n<h3 id=\"3-eslint-开启-es7-风格\"><a href=\"#3-eslint-开启-es7-风格\" class=\"headerlink\" title=\"3.eslint 开启 es7 风格\"></a>3.eslint 开启 es7 风格</h3><p><code>babel-eslint</code> 默认支持 es7 风格的检查，在配置文件 <code>.eslintrc.js</code> 中添加一个属性即可。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">    <span class=\"attr\">parser</span>: <span class=\"string\">\"babel-eslint\"</span>,</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"<p>最近几周一直在做 ROP 的权限模块，包括了前端和后端接口，前端使用了 <code>react</code>，UI 使用 <code>ant design</code>，后端使用 <code>nodejs</code> + <code>mongodb</code>，框架使用 <code>keystone</code>。好久没写 <code>react</code> 了，趁此机会也把 <code>react</code> 好好捡了捡，也发现了一些以前没有注意到的不合理的或者错误的用法。</p>\n<p>因为是中途加入项目，也总结了一些问题，在此都做下记录。</p>\n<p>PS. <code>ant design</code> 和 <code>keystone</code> 真是好用</p>","more":"<h2 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h2><h3 id=\"1-不在-JSX-的属性使用-bind\"><a href=\"#1-不在-JSX-的属性使用-bind\" class=\"headerlink\" title=\"1.不在 JSX 的属性使用 bind()\"></a>1.不在 JSX 的属性使用 bind()</h3><p>而是在构造函数中使用 <code>bind()</code></p>\n<p>以前的用法是：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">render() &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    &lt;Table</div><div class=\"line\">      onChange=&#123;this.handleTableChange.bind(this)&#125;</div><div class=\"line\">    /&gt;</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>正确的方式应该是在构造函数中绑定 <code>this</code>:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">constructor</span>(...args) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(...args);</div><div class=\"line\">    <span class=\"comment\">// 绑定 this</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.handleTableChange = <span class=\"keyword\">this</span>.handleTableChange.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">handleTableChange() &#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">        &lt;Table</div><div class=\"line\">            onChange=&#123;this.handleTableChange&#125;</div><div class=\"line\">        /&gt;</div><div class=\"line\">    );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>或者直接使用 <code>es7</code> 风格：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">handleTableChange = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">        &lt;Table</div><div class=\"line\">            onChange=&#123;this.handleTableChange&#125;</div><div class=\"line\">        /&gt;</div><div class=\"line\">    );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2-使用-props-传递数据流-不要滥用-ref\"><a href=\"#2-使用-props-传递数据流-不要滥用-ref\" class=\"headerlink\" title=\"2.使用 props 传递数据流 / 不要滥用 ref\"></a>2.使用 props 传递数据流 / 不要滥用 ref</h3><p>在使用 <code>react</code> 的过程中，经常会出现父组件要获取子组件内部状态的情况，在我之前使用 <code>react</code> 的过程中，我一直都是用的 <code>ref</code>，今天反思了一下，可能是在发现 <code>ref</code> 可以获取组件的 <code>DOM</code> 和实例之后觉得这个东西非常好用才开始滥用 <code>ref</code> 的。。</p>\n<p>以前的使用方式：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 父组件</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    handleClick = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> dog = <span class=\"keyword\">this</span>.refs.child.getDog();</div><div class=\"line\">        <span class=\"comment\">//...</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    render() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            &lt;div&gt;</div><div class=\"line\">                &lt;Child ref=\"child\" /&gt;</div><div class=\"line\">                &lt;Button onClick=&#123;this.handleClick&#125; /&gt;</div><div class=\"line\">            &lt;/div&gt;</div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 子组件</div><div class=\"line\">class Child extends React.Component &#123;</div><div class=\"line\"></div><div class=\"line\">    state = &#123;</div><div class=\"line\">        dog: 'aoliao',</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    getDog = () =&gt; &#123;</div><div class=\"line\">        return this.state.dog;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    render() &#123;</div><div class=\"line\">        const &#123; dog &#125; = this.state;</div><div class=\"line\">        return (</div><div class=\"line\">            &lt;div&gt;</div><div class=\"line\">                &#123;dog&#125;</div><div class=\"line\">            &lt;/div&gt;</div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我不知道有没有人和我一样这样用。。本来我还觉得是很正常的使用方法，其实因为过度使用 <code>ref</code>，使得整个设计都会有问题，因为可以通过 <code>ref</code> 拿子组件内部的数据，所以就让每个子组件自己维护自己的内容，好像独立了起来（听起来还挺有道理），但是长此下去，整个数据流就变得很混乱，也会出现过度封装的情况。</p>\n<p>正确的方式是使用 <code>props</code> 来传递数据，既然 <code>dog</code> 这个属性在父组件要用到，那么就把 <code>dog</code> 放在父组件中，处理逻辑也就都移到父组件里去了，子组件只是通过 <code>prop</code> 拿着父组件的 <code>dog</code> 去干事情，但最终 <code>dog</code> 还是在父组件中，就好像角色倒过来了一样。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 父组件</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    state = &#123;</div><div class=\"line\">        <span class=\"attr\">dog</span>: <span class=\"string\">'aoliao'</span>,</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    handleClick = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> &#123; dog &#125; = <span class=\"keyword\">this</span>.state;</div><div class=\"line\">        <span class=\"comment\">//...</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    render() &#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> &#123; dog &#125; = <span class=\"keyword\">this</span>.state;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            &lt;div&gt;</div><div class=\"line\">                &lt;Child dog=&#123;dog&#125; /&gt;</div><div class=\"line\">                &lt;Button onClick=&#123;this.handleClick&#125; /&gt;</div><div class=\"line\">            &lt;/div&gt;</div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 子组件</div><div class=\"line\">class Child extends React.Component &#123;</div><div class=\"line\"></div><div class=\"line\">    state = &#123;</div><div class=\"line\">        dog: this.props.dog,</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // 如果属性会变化，使用 componentWillReceiveProps 监听属性的变化</div><div class=\"line\">    componentWillReceiveProps = (nextProps) =&gt; &#123;</div><div class=\"line\">        // 比较新老属性的不同</div><div class=\"line\">        if (this.props.dog != nextProps.dog) &#123;</div><div class=\"line\">            this.setState(&#123;</div><div class=\"line\">                dog: nextProps.dog,</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    render() &#123;</div><div class=\"line\">        const &#123; dog &#125; = this.state;</div><div class=\"line\">        return (</div><div class=\"line\">            &lt;div&gt;</div><div class=\"line\">                &#123;dog&#125;</div><div class=\"line\">            &lt;/div&gt;</div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-定义-propTypes-时使用-shape-代替-object\"><a href=\"#3-定义-propTypes-时使用-shape-代替-object\" class=\"headerlink\" title=\"3.定义 propTypes 时使用 shape 代替 object\"></a>3.定义 propTypes 时使用 shape 代替 object</h3><p>当组件需要接收属性时，定义 <code>propTypes</code> 检查是一个好的习惯。</p>\n<p>另外根据 <code>eslint</code> 中的 <code>react/forbid-prop-types</code> 校验规则，应该避免使用 <code>object</code> 和 <code>array</code>，而使用更详细的 <code>shape</code> 和 <code>arrayOf()</code></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// bad</span></div><div class=\"line\">UserDetailsPanel.propTypes = &#123;</div><div class=\"line\">    <span class=\"attr\">form</span>: React.PropTypes.object,</div><div class=\"line\">    <span class=\"attr\">checkedKeys</span>: React.PropTypes.array,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// good!</span></div><div class=\"line\">UserDetailsPanel.propTypes = &#123;</div><div class=\"line\">    <span class=\"attr\">form</span>: React.PropTypes.shape(&#123;</div><div class=\"line\">        <span class=\"attr\">getFieldDecorator</span>: React.PropTypes.func,</div><div class=\"line\">        <span class=\"attr\">getFieldsError</span>: React.PropTypes.func,</div><div class=\"line\">        <span class=\"attr\">setFieldsValue</span>: React.PropTypes.func,</div><div class=\"line\">        <span class=\"attr\">validateFields</span>: React.PropTypes.func,</div><div class=\"line\">    &#125;),</div><div class=\"line\">    <span class=\"attr\">checkedKeys</span>: React.PropTypes.arrayOf(React.Proptypes.string),</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"4-ant-design-里异步加载树数据时-Cannot-set-property-‘checked’-of-undefined\"><a href=\"#4-ant-design-里异步加载树数据时-Cannot-set-property-‘checked’-of-undefined\" class=\"headerlink\" title=\"4.ant design 里异步加载树数据时 Cannot set property ‘checked’ of undefined\"></a>4.ant design 里异步加载树数据时 Cannot set property ‘checked’ of undefined</h3><p>这个问题找了好一会，起初是发现同时设置 <code>onCheck</code>和 <code>checkedKeys</code> 属性时会报错，后来发现是异步加载数据的问题。</p>\n<p>其实 ant design 文档的最后也有说明，当树的数据是异步加载时，应该使用：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    loading ? <span class=\"string\">'...'</span> : (</div><div class=\"line\">        &lt;Tree&gt;&#123;this.state.treeData.map(data =&gt; &lt;TreeNode /&gt;)&#125;&lt;/Tree&gt;</div><div class=\"line\">    )</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"5-无状态的组件使用纯函数-pure-function\"><a href=\"#5-无状态的组件使用纯函数-pure-function\" class=\"headerlink\" title=\"5.无状态的组件使用纯函数(pure function)\"></a>5.无状态的组件使用纯函数(pure function)</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; (</div><div class=\"line\">  &lt;div&gt;</div><div class=\"line\">    这个页面可不是一般人能看见的</div><div class=\"line\">  &lt;/div&gt;</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><h3 id=\"1-webpackJsonp-is-not-defined-错误\"><a href=\"#1-webpackJsonp-is-not-defined-错误\" class=\"headerlink\" title=\"1.webpackJsonp is not defined 错误\"></a>1.webpackJsonp is not defined 错误</h3><p>原因是使用了 <code>CommonChunkPlugin</code> 但没有首先引用公共文件</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">// webpack.config.js</div><div class=\"line\">module.exports = &#123;</div><div class=\"line\">    // 在这里使用了 CommonChunkPlugin 插件</div><div class=\"line\">    plugins: [</div><div class=\"line\">        new webpack.optimize.CommonsChunkPlugin(&#123; name: 'commons' &#125;)</div><div class=\"line\">    ]</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// index.jade</div><div class=\"line\">extends ../layouts/default</div><div class=\"line\"></div><div class=\"line\">block content</div><div class=\"line\">    .container</div><div class=\"line\">        div#app</div><div class=\"line\">\t// 必须要引入 commons.js</div><div class=\"line\">    script(src= baseUrl + 'commons.js')</div></pre></td></tr></table></figure>\n<h3 id=\"2-regeneratorRuntime-is-not-defined-错误\"><a href=\"#2-regeneratorRuntime-is-not-defined-错误\" class=\"headerlink\" title=\"2.regeneratorRuntime is not defined 错误\"></a>2.regeneratorRuntime is not defined 错误</h3><p>这个错误是我想在前端引入 react，并使用 es6 风格编码时发生的。</p>\n<p>原因是没有引入 <code>babel-polyfill</code></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">// webpack.config.js</div><div class=\"line\">module.exports = &#123;</div><div class=\"line\">    entry: &#123;</div><div class=\"line\">        // '文件名': '引用的模块'</div><div class=\"line\">        'babel-polyfill': 'babel-polyfill',</div><div class=\"line\">        // ...</div><div class=\"line\">    &#125;</div><div class=\"line\">    //...</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// index.jade</div><div class=\"line\">extends ../layouts/default</div><div class=\"line\"></div><div class=\"line\">block content</div><div class=\"line\">    .container</div><div class=\"line\">        div#app</div><div class=\"line\">\t// 根据 config 文件中定义的文件名引入 babel-polyfill.js</div><div class=\"line\">    script(src= baseUrl + 'babel-polyfill.js')</div></pre></td></tr></table></figure>\n<h3 id=\"3-eslint-开启-es7-风格\"><a href=\"#3-eslint-开启-es7-风格\" class=\"headerlink\" title=\"3.eslint 开启 es7 风格\"></a>3.eslint 开启 es7 风格</h3><p><code>babel-eslint</code> 默认支持 es7 风格的检查，在配置文件 <code>.eslintrc.js</code> 中添加一个属性即可。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">    <span class=\"attr\">parser</span>: <span class=\"string\">\"babel-eslint\"</span>,</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"隐函数微分法","date":"2017-02-25T11:40:50.000Z","_content":"\n用隐函数微分法可以求导任意反函数，只要知道原函数的导数。\n\n<!-- more -->\n\n## 隐函数微分法\n\n在 `求导四则运算和常见求导公式的推导` 一节里讨论了 $(x^n)'$ 在 n 为整数时的情况，现在试求 $y = x^{m/n}$(m、n 均为整数)的导数。\n\n因为我们只知道当 n 为整数时 $x^n$ 的导数，所以给两边同时取 n 次方，得\n\n$$\ny^n = x^m\n$$\n\n实际上这就是把显函数转为了隐函数，两边同时微分，得\n\n$$\n\\begin{align}\n\\cfrac{d}{dx}y^n &= \\cfrac{d}{dx}x^m \\\\\\\nny^{n - 1}y' &= mx^{m - 1} \\\\\\\ny' &= \\cfrac{m}{n} \\cdot \\cfrac{x^{m - 1}}{y^{n - 1}} \\\\\\\n&= \\cfrac{m}{n} \\cdot \\cfrac {x^{m - 1}}{(x^{\\frac{m}{n}})^{n - 1}} \\\\\\\n&= \\frac{m}{n} x^{m - 1 - \\frac{m}{n}(n - 1)} \\\\\\\n&= \\frac{m}{n} x^{\\frac{m}{n} - 1}\n\\end{align}\n$$\n\n即 $(x^{\\frac{m}{n}})' = \\frac{m}{n} x^{\\frac{m}{n} - 1}$，由此说明当 n 为分数时，$(x^n)' = nx^{n - 1}$ 同样适用。\n\n## 反函数\n\n设有 $y = \\sqrt{x}, x > 0$\n\n那么可得 $x = y^2$\n\n设 $y = f(x) = \\sqrt{x}$，$x = g(y) = y^2$\n\n称 f 和 g 互为反函数，记 $g = f^{-1}$，$f = g^{-1}$\n\n## 使用隐函数微分法求导反函数\n\n### 1) $\\arctan x$\n\n试求 $y = \\tan^{-1} x$ 的导数\n\n因为 $\\arctan$ 和 $\\tan$ 互为反函数，两边取 $\\tan$ 得\n\n$$\n\\begin{align}\ny &= \\tan^{-1} x \\\\\\\n\\tan y &= x \\\\\\\n\\cfrac{d}{dx} \\tan y &= \\cfrac{d}{dx} x \\\\\\\n\\cfrac{1}{\\cos^2 y} \\cdot y' &= 1 \\\\\\\ny' &= \\cos^2 y\n\\end{align}\n$$\n\n根据 $\\tan y = x$，我们可以构建如下直角三角形\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/implicit-differentiation/01.png)\n\n那么，$\\cos y = \\cfrac{1}{\\sqrt{1 + x^2}}$，$\\cos^2 y = \\cfrac{1}{1 + x^2}$\n\n所以，$(\\arctan x)' = \\cfrac{1}{1 + x^2}$\n\n### 2) $\\arcsin x$\n\n$$\n\\begin{align}\ny &= \\sin^{-1} x \\\\\\\n\\sin y &= x \\\\\\\n\\cfrac{d}{dx} \\sin y &= \\cfrac{d}{dx} x \\\\\\\n\\cos y \\cdot y' &= 1 \\\\\\\ny' &= \\cfrac{1}{\\cos y} \\\\\\\n&= \\cfrac{1}{\\sqrt{1 - \\sin^2 y}} \\\\\\\n\\end{align}\n$$\n\n而 $\\sin y = x$，所以 $y' = \\cfrac{1}{\\sqrt{1 - x^2}}$\n\n即 $(\\arcsin x)' = \\cfrac{1}{\\sqrt{1 - x^2}}$\n","source":"_posts/implicit-differentiation.md","raw":"---\ntitle: 隐函数微分法\ndate: 2017-02-25 19:40:50\ntags: [单变量微积分]\n---\n\n用隐函数微分法可以求导任意反函数，只要知道原函数的导数。\n\n<!-- more -->\n\n## 隐函数微分法\n\n在 `求导四则运算和常见求导公式的推导` 一节里讨论了 $(x^n)'$ 在 n 为整数时的情况，现在试求 $y = x^{m/n}$(m、n 均为整数)的导数。\n\n因为我们只知道当 n 为整数时 $x^n$ 的导数，所以给两边同时取 n 次方，得\n\n$$\ny^n = x^m\n$$\n\n实际上这就是把显函数转为了隐函数，两边同时微分，得\n\n$$\n\\begin{align}\n\\cfrac{d}{dx}y^n &= \\cfrac{d}{dx}x^m \\\\\\\nny^{n - 1}y' &= mx^{m - 1} \\\\\\\ny' &= \\cfrac{m}{n} \\cdot \\cfrac{x^{m - 1}}{y^{n - 1}} \\\\\\\n&= \\cfrac{m}{n} \\cdot \\cfrac {x^{m - 1}}{(x^{\\frac{m}{n}})^{n - 1}} \\\\\\\n&= \\frac{m}{n} x^{m - 1 - \\frac{m}{n}(n - 1)} \\\\\\\n&= \\frac{m}{n} x^{\\frac{m}{n} - 1}\n\\end{align}\n$$\n\n即 $(x^{\\frac{m}{n}})' = \\frac{m}{n} x^{\\frac{m}{n} - 1}$，由此说明当 n 为分数时，$(x^n)' = nx^{n - 1}$ 同样适用。\n\n## 反函数\n\n设有 $y = \\sqrt{x}, x > 0$\n\n那么可得 $x = y^2$\n\n设 $y = f(x) = \\sqrt{x}$，$x = g(y) = y^2$\n\n称 f 和 g 互为反函数，记 $g = f^{-1}$，$f = g^{-1}$\n\n## 使用隐函数微分法求导反函数\n\n### 1) $\\arctan x$\n\n试求 $y = \\tan^{-1} x$ 的导数\n\n因为 $\\arctan$ 和 $\\tan$ 互为反函数，两边取 $\\tan$ 得\n\n$$\n\\begin{align}\ny &= \\tan^{-1} x \\\\\\\n\\tan y &= x \\\\\\\n\\cfrac{d}{dx} \\tan y &= \\cfrac{d}{dx} x \\\\\\\n\\cfrac{1}{\\cos^2 y} \\cdot y' &= 1 \\\\\\\ny' &= \\cos^2 y\n\\end{align}\n$$\n\n根据 $\\tan y = x$，我们可以构建如下直角三角形\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/implicit-differentiation/01.png)\n\n那么，$\\cos y = \\cfrac{1}{\\sqrt{1 + x^2}}$，$\\cos^2 y = \\cfrac{1}{1 + x^2}$\n\n所以，$(\\arctan x)' = \\cfrac{1}{1 + x^2}$\n\n### 2) $\\arcsin x$\n\n$$\n\\begin{align}\ny &= \\sin^{-1} x \\\\\\\n\\sin y &= x \\\\\\\n\\cfrac{d}{dx} \\sin y &= \\cfrac{d}{dx} x \\\\\\\n\\cos y \\cdot y' &= 1 \\\\\\\ny' &= \\cfrac{1}{\\cos y} \\\\\\\n&= \\cfrac{1}{\\sqrt{1 - \\sin^2 y}} \\\\\\\n\\end{align}\n$$\n\n而 $\\sin y = x$，所以 $y' = \\cfrac{1}{\\sqrt{1 - x^2}}$\n\n即 $(\\arcsin x)' = \\cfrac{1}{\\sqrt{1 - x^2}}$\n","slug":"implicit-differentiation","published":1,"updated":"2017-02-25T14:25:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcwe001tn9279c3qlchr","content":"<p>用隐函数微分法可以求导任意反函数，只要知道原函数的导数。</p>\n<a id=\"more\"></a>\n<h2 id=\"隐函数微分法\"><a href=\"#隐函数微分法\" class=\"headerlink\" title=\"隐函数微分法\"></a>隐函数微分法</h2><p>在 <code>求导四则运算和常见求导公式的推导</code> 一节里讨论了 $(x^n)’$ 在 n 为整数时的情况，现在试求 $y = x^{m/n}$(m、n 均为整数)的导数。</p>\n<p>因为我们只知道当 n 为整数时 $x^n$ 的导数，所以给两边同时取 n 次方，得</p>\n<p>$$<br>y^n = x^m<br>$$</p>\n<p>实际上这就是把显函数转为了隐函数，两边同时微分，得</p>\n<p>$$<br>\\begin{align}<br>\\cfrac{d}{dx}y^n &amp;= \\cfrac{d}{dx}x^m \\\\<br>ny^{n - 1}y’ &amp;= mx^{m - 1} \\\\<br>y’ &amp;= \\cfrac{m}{n} \\cdot \\cfrac{x^{m - 1}}{y^{n - 1}} \\\\<br>&amp;= \\cfrac{m}{n} \\cdot \\cfrac {x^{m - 1}}{(x^{\\frac{m}{n}})^{n - 1}} \\\\<br>&amp;= \\frac{m}{n} x^{m - 1 - \\frac{m}{n}(n - 1)} \\\\<br>&amp;= \\frac{m}{n} x^{\\frac{m}{n} - 1}<br>\\end{align}<br>$$</p>\n<p>即 $(x^{\\frac{m}{n}})’ = \\frac{m}{n} x^{\\frac{m}{n} - 1}$，由此说明当 n 为分数时，$(x^n)’ = nx^{n - 1}$ 同样适用。</p>\n<h2 id=\"反函数\"><a href=\"#反函数\" class=\"headerlink\" title=\"反函数\"></a>反函数</h2><p>设有 $y = \\sqrt{x}, x &gt; 0$</p>\n<p>那么可得 $x = y^2$</p>\n<p>设 $y = f(x) = \\sqrt{x}$，$x = g(y) = y^2$</p>\n<p>称 f 和 g 互为反函数，记 $g = f^{-1}$，$f = g^{-1}$</p>\n<h2 id=\"使用隐函数微分法求导反函数\"><a href=\"#使用隐函数微分法求导反函数\" class=\"headerlink\" title=\"使用隐函数微分法求导反函数\"></a>使用隐函数微分法求导反函数</h2><h3 id=\"1-arctan-x\"><a href=\"#1-arctan-x\" class=\"headerlink\" title=\"1) $\\arctan x$\"></a>1) $\\arctan x$</h3><p>试求 $y = \\tan^{-1} x$ 的导数</p>\n<p>因为 $\\arctan$ 和 $\\tan$ 互为反函数，两边取 $\\tan$ 得</p>\n<p>$$<br>\\begin{align}<br>y &amp;= \\tan^{-1} x \\\\<br>\\tan y &amp;= x \\\\<br>\\cfrac{d}{dx} \\tan y &amp;= \\cfrac{d}{dx} x \\\\<br>\\cfrac{1}{\\cos^2 y} \\cdot y’ &amp;= 1 \\\\<br>y’ &amp;= \\cos^2 y<br>\\end{align}<br>$$</p>\n<p>根据 $\\tan y = x$，我们可以构建如下直角三角形</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/implicit-differentiation/01.png\" alt=\"\"></p>\n<p>那么，$\\cos y = \\cfrac{1}{\\sqrt{1 + x^2}}$，$\\cos^2 y = \\cfrac{1}{1 + x^2}$</p>\n<p>所以，$(\\arctan x)’ = \\cfrac{1}{1 + x^2}$</p>\n<h3 id=\"2-arcsin-x\"><a href=\"#2-arcsin-x\" class=\"headerlink\" title=\"2) $\\arcsin x$\"></a>2) $\\arcsin x$</h3><p>$$<br>\\begin{align}<br>y &amp;= \\sin^{-1} x \\\\<br>\\sin y &amp;= x \\\\<br>\\cfrac{d}{dx} \\sin y &amp;= \\cfrac{d}{dx} x \\\\<br>\\cos y \\cdot y’ &amp;= 1 \\\\<br>y’ &amp;= \\cfrac{1}{\\cos y} \\\\<br>&amp;= \\cfrac{1}{\\sqrt{1 - \\sin^2 y}} \\\\<br>\\end{align}<br>$$</p>\n<p>而 $\\sin y = x$，所以 $y’ = \\cfrac{1}{\\sqrt{1 - x^2}}$</p>\n<p>即 $(\\arcsin x)’ = \\cfrac{1}{\\sqrt{1 - x^2}}$</p>\n","excerpt":"<p>用隐函数微分法可以求导任意反函数，只要知道原函数的导数。</p>","more":"<h2 id=\"隐函数微分法\"><a href=\"#隐函数微分法\" class=\"headerlink\" title=\"隐函数微分法\"></a>隐函数微分法</h2><p>在 <code>求导四则运算和常见求导公式的推导</code> 一节里讨论了 $(x^n)’$ 在 n 为整数时的情况，现在试求 $y = x^{m/n}$(m、n 均为整数)的导数。</p>\n<p>因为我们只知道当 n 为整数时 $x^n$ 的导数，所以给两边同时取 n 次方，得</p>\n<p>$$<br>y^n = x^m<br>$$</p>\n<p>实际上这就是把显函数转为了隐函数，两边同时微分，得</p>\n<p>$$<br>\\begin{align}<br>\\cfrac{d}{dx}y^n &amp;= \\cfrac{d}{dx}x^m \\\\<br>ny^{n - 1}y’ &amp;= mx^{m - 1} \\\\<br>y’ &amp;= \\cfrac{m}{n} \\cdot \\cfrac{x^{m - 1}}{y^{n - 1}} \\\\<br>&amp;= \\cfrac{m}{n} \\cdot \\cfrac {x^{m - 1}}{(x^{\\frac{m}{n}})^{n - 1}} \\\\<br>&amp;= \\frac{m}{n} x^{m - 1 - \\frac{m}{n}(n - 1)} \\\\<br>&amp;= \\frac{m}{n} x^{\\frac{m}{n} - 1}<br>\\end{align}<br>$$</p>\n<p>即 $(x^{\\frac{m}{n}})’ = \\frac{m}{n} x^{\\frac{m}{n} - 1}$，由此说明当 n 为分数时，$(x^n)’ = nx^{n - 1}$ 同样适用。</p>\n<h2 id=\"反函数\"><a href=\"#反函数\" class=\"headerlink\" title=\"反函数\"></a>反函数</h2><p>设有 $y = \\sqrt{x}, x &gt; 0$</p>\n<p>那么可得 $x = y^2$</p>\n<p>设 $y = f(x) = \\sqrt{x}$，$x = g(y) = y^2$</p>\n<p>称 f 和 g 互为反函数，记 $g = f^{-1}$，$f = g^{-1}$</p>\n<h2 id=\"使用隐函数微分法求导反函数\"><a href=\"#使用隐函数微分法求导反函数\" class=\"headerlink\" title=\"使用隐函数微分法求导反函数\"></a>使用隐函数微分法求导反函数</h2><h3 id=\"1-arctan-x\"><a href=\"#1-arctan-x\" class=\"headerlink\" title=\"1) $\\arctan x$\"></a>1) $\\arctan x$</h3><p>试求 $y = \\tan^{-1} x$ 的导数</p>\n<p>因为 $\\arctan$ 和 $\\tan$ 互为反函数，两边取 $\\tan$ 得</p>\n<p>$$<br>\\begin{align}<br>y &amp;= \\tan^{-1} x \\\\<br>\\tan y &amp;= x \\\\<br>\\cfrac{d}{dx} \\tan y &amp;= \\cfrac{d}{dx} x \\\\<br>\\cfrac{1}{\\cos^2 y} \\cdot y’ &amp;= 1 \\\\<br>y’ &amp;= \\cos^2 y<br>\\end{align}<br>$$</p>\n<p>根据 $\\tan y = x$，我们可以构建如下直角三角形</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/implicit-differentiation/01.png\" alt=\"\"></p>\n<p>那么，$\\cos y = \\cfrac{1}{\\sqrt{1 + x^2}}$，$\\cos^2 y = \\cfrac{1}{1 + x^2}$</p>\n<p>所以，$(\\arctan x)’ = \\cfrac{1}{1 + x^2}$</p>\n<h3 id=\"2-arcsin-x\"><a href=\"#2-arcsin-x\" class=\"headerlink\" title=\"2) $\\arcsin x$\"></a>2) $\\arcsin x$</h3><p>$$<br>\\begin{align}<br>y &amp;= \\sin^{-1} x \\\\<br>\\sin y &amp;= x \\\\<br>\\cfrac{d}{dx} \\sin y &amp;= \\cfrac{d}{dx} x \\\\<br>\\cos y \\cdot y’ &amp;= 1 \\\\<br>y’ &amp;= \\cfrac{1}{\\cos y} \\\\<br>&amp;= \\cfrac{1}{\\sqrt{1 - \\sin^2 y}} \\\\<br>\\end{align}<br>$$</p>\n<p>而 $\\sin y = x$，所以 $y’ = \\cfrac{1}{\\sqrt{1 - x^2}}$</p>\n<p>即 $(\\arcsin x)’ = \\cfrac{1}{\\sqrt{1 - x^2}}$</p>"},{"title":"Kafka 基础","date":"2016-09-30T06:33:57.000Z","_content":"\n## Kafka 基础概念\n\nKafka是由LinkedIn开发的一个分布式的，基于发布/订阅的消息系统。\n\n<!-- more -->\n\n### 关键词\n\n#### Broker\nKafka 集群包含一个或多个服务器，这种服务器被称为broker\n\n#### Topic\n每条发布到 Kafka 集群的消息都有一个类别，这个类别被称为 Topic。（物理上不同 Topic 的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个 broker 上但用户只需指定消息的 Topic 即可生产或消费数据而不必关心数据存于何处）\n\n#### Partition\nParition 是物理上的概念，每个 Topic 包含一个或多个 Partition\n\n#### Producer\n负责发布消息到 Kafka broker\n\n#### Consumer\n消息消费者，向 Kafka broker 读取消息的客户端。\n\n#### Consumer Group\n每个Consumer 属于一个特定的 Consumer Group（可为每个 Consumer 指定 group name，若不指定 group name 则属于默认的 group）。\n\n### 拓扑结构\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/learn-kafka/kafka-01.jpeg)\n\nKafka 通过 Zookeeper 管理集群配置，选举 leader，以及在 Consumer Group 发生变化时进行 rebalance。Producer 使用 push 模式将消息发布到 broker，Consumer 使用 pull 模式从 broker 订阅并消费消息。\n\n### 概念说明\n\n#### Topic & Partition\n\nTopic 在 **逻辑上** 可以认为是一个 queue，每条消息必须指定一个 topic，也就是将这条消息放进某一个 queue。\n\n为了使得 Kafka 的吞吐率可以线性提高，**物理上** 把 Topic 分成一个或多个Partition，每个 Partition 在物理上对应一个文件夹，该文件夹下存储这个 Partition 的所有消息和索引文件。因为每条消息都被 append 到该 Partition 中，属于顺序写磁盘，因此效率非常高（经验证，顺序写磁盘效率比随机写内存还要高，这是Kafka高吞吐率的一个很重要的保证）。\n\n如果一个 Topic 对应一个文件，那这个文件所在的机器 I/O 将会成为这个 Topic 的性能瓶颈，而有了 Partition后，不同的消息可以并行写入不同 broker 的不同 Partition 里，极大的提高了吞吐率。可以在$KAFKA_HOME/config/server.properties 中通过配置项 num.partitions 来指定新建 Topic 的默认 Partition 数量：\n\n```dockerfile\n# The default number of log partitions per topic. More partitions allow greater\n# parallelism for consumption, but this will also result in more files across\n# the brokers.\nnum.partitions=1\n```\n\n也可在创建 Topic 时通过参数指定，同时也可以在 Topic 创建之后通过 Kafka 提供的工具修改。\n\n#### Product\n\nProduct 负责发布消息到 Kafka broker，每次发布消息时，如上所述，Product 必须指定该消息的 Topic，至于消息会放到哪个 Partition，会根据 Paritition 机制选择将其存储到哪一个 Partition。如果 Partition 机制设置合理，所有消息可以均匀分布到不同的 Partition 里，这样就实现了负载均衡。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/learn-kafka/kafka-02.jpeg)\n\n常见的机制有：\n\n- 随机\n- 设置 key 和 partition num 取余\n- 顺序循环\n\n等等。\n\n#### 信息消费\n\n对于传统的 message queue 而言，一般会删除已经被消费的消息，而 Kafka 集群会保留所有的消息，无论其被消费与否。当然，因为磁盘限制，不可能永久保留所有数据（实际上也没必要），因此 Kafka 提供两种策略删除旧数据。一是基于时间，二是基于 Partition 文件大小。例如可以通过配置 $KAFKA_HOME/config/server.properties，让 Kafka 删除一周前的数据，也可在 Partition 文件超过1GB时删除旧数据，配置信息如下：\n\n```dockerfile\n# The minimum age of a log file to be eligible for deletion\nlog.retention.hours=168\n\n# A size-based retention policy for logs. Segments are pruned from the log as long as the remaining\n# segments don't drop below log.retention.bytes.\n#log.retention.bytes=1073741824\n\n# The maximum size of a log segment file. When this size is reached a new log segment will be created.\nlog.segment.bytes=1073741824\n\n# The interval at which log segments are checked to see if they can be deleted according\n# to the retention policies\nlog.retention.check.interval.ms=300000\n```\n\n这里要注意，因为 Kafka 读取特定消息的时间复杂度为 O(1)，即与文件大小无关，所以这里删除过期文件与提高 Kafka 性能无关。选择怎样的删除策略只与磁盘以及具体的需求有关。\n\n#### Consumer Group\n\n通常来讲，消息模型可以分为两种， 队列和发布-订阅式。 队列的处理方式是 一组消费者从服务器读取消息，一条消息只有其中的一个消费者来处理。在发布-订阅模型中，消息被广播给所有的消费者，接收到消息的消费者都可以处理此消息。Kafka为这两种模型提供了单一的消费者抽象模型： 消费者组 （consumer group）。\n\n消费者用一个消费者组名标记自己。 一个发布在 Topic 上消息被分发给此消费者组中的一个消费者。那么显而易见地：\n\n- 假如所有的消费者都在一个组中，那么这就变成了queue模型。\n- 假如所有的消费者都在不同的组中，那么就完全变成了发布-订阅模型。\n\n更通用的， 我们可以创建一些消费者组作为逻辑上的订阅者。每个组包含数目不等的消费者， 一个组内多个消费者可以用来扩展性能和容错。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/learn-kafka/kafka-03.jpeg)\n\n#### Consumer\n\nConsumer 是消息的消费者，Consumer 在从 broker 读取消息后，可以选择 commit，该操作会在 Zookeeper 中保存该 Consumer在该 Partition 中读取的消息的 offset。该 Consumer 下一次再读该 Partition 时会从下一条开始读取。如未 commit，下一次读取的开始位置会跟上一次 commit 之后的开始位置相同。当然可以将 Consumer 设置为 autocommit，即 Consumer 一旦读到数据立即自动 commit。\n\nKafka 会为每一个 Consumer Group 保留一些 metadata 信息包括 offset。这个 offset 由Consumer控制。正常情况下 Consumer 会在消费完一条消息后递增该 offset。当然，Consumer 也可将 offset 设成一个较小的值，重新消费一些消息。因为 offet 由 Consumer 控制，所以 Kafka broker 是无状态的，它不需要标记哪些消息被哪些消费过，也不需要通过 broker 去保证同一个 Consumer Group 只有一个 Consumer 能消费某一条消息，因此也就不需要锁机制，这也为 Kafka 的高吞吐率提供了有力保障。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/learn-kafka/kafka-05.jpeg)\n\n#### High Level Consumer\n\nHigh Level 的意思实际上是更高 Level 的 API，而不是说这种 Consumer 更高级。很多时候，客户程序只是希望从 Kafka 读取数据，不太关心消息 offset 的处理。同时也希望提供一些语义，例如同一条消息只被某一个 Consumer 消费（单播）或被所有 Consumer 消费（广播）。因此，High Level Consumer 提供了一个从 Kafka 消费数据的高层抽象，从而屏蔽掉其中的细节并提供丰富的语义。它提供了一个从 Kafka 消费数据的高层抽象，从而屏蔽掉其中的细节并提供丰富的语义。\n\n使用 Consumer high level API 时，同一Topic的一条消息只能被同一个 Consumer Group 内的一个 Consumer 消费，但多个 Consumer Group 可同时消费这一消息。\n\n假设有一个 Topic (名为 topic1，包含3个 Partition)，有两个 Consumer Group：group1 包含 consumer 1，group 2 包含 consumer2, consumer3, consumer 4)。现通过 Producer 向 topic1 发送key分别为1，2，3的消息。那么将发现属于 group1 的 Consumer 收到了所有的这三条消息，同时 group2 中的 3 个 Consumer 分别收到了 key 为 1，2，3 的消息。如下图所示。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/learn-kafka/kafka-04.png)\n\n### 安装kafka\n\ngoogle，安装 kafka 之前需安装 jdk\n\n### 查看所有topic\n\n```bash\n# 打开 kafka 所在目录\ncd YOUR_KAFKA_HOME\n# 列出所有 topic\n./bin/kafka-topics.sh --list --zookeeper YOUR_ZOOKEEPR_IPS\n# 查看 topic 明细\n./bin/kafka-topics.sh --topic test --describe --zookeeper YOUR_ZOOKEEPR_IPS\n```\n\n## 业务背景\n\n需要订阅业务平台的 Kafka 中的 c1 和 c2 的通话记录。\n\n## 技术方案\n\n使用 node 包：[kafka-node](https://github.com/SOHU-Co/kafka-node)﻿\n\n```javascript\nconst kafka = require('kafka-node');\n// 创建连接\nconst client = new kafka.Client(KAFKA_SERVER_IP);      \n// 创建 HLC\nconst consumer = new HighLevelConsumer(\n\tclient,\n\t[\n\t\t// 订阅话题，如果需要从指定 offset 读起，填 offset 参数\n\t\t{ topic: TOPIC_NAME, offset: 0}\n\t],\n\t{\n\t\t// 指定 groupId\n        groupId: 'eagle_eye',\n        autoCommit: true,\n        autoCommitIntervalMs: 5000,\n        fetchMaxWaitMs: 100,\n        fetchMinBytes: 1,\n        fetchMaxBytes: 1024 * 1024,\n        // 需要从指定 offset 读起\n        fromOffset: true,\n        encoding: 'utf8'\n\t}\n);\n\nconsumer.on('message', function (message) {\n  // 订阅消息\n})\n```\n\n### 关于 offsetOutOfRange\n如果想消费一个不存在的 offset(该 offset 可能确实不存在，也可能被 Kafka auto-delete 了)，这时候 consumer 会抛出 offsetOutOfRange 错误，在 HighLevelConsumer 中，监听到这个错误时会从当前 partition 的最小的一个 offset 开始重新消费。对于通用的 Consumer，客户端需要监听 offsetOutOfRange 事件自己来处理。\n\n\n## Zookeeper\n\n### 安装 Zookeeper\n\nmac 下可以直接使用 brew 安装 zookeeper，安装前需要先安装 jdk\n\n```shell\nbrew install zookeeper\n```\n\n### 连接到 Zookeeper 服务\n\n```shell\nzkCli -server YOUR_ZOOKEEPR_IPS\n```\n### Zookeeper 命令\n\n```shell\n# 使用ls命令查看当前Zookeeper中所包含的内容\nls /\t# 输出 [brokers, consumers, config 等]\nls /consumers\t# [consumer-group-1, test-group 等]\nls /consumers/test-group\n# 依次类推\n\n# 删除某个节点\ndelete /you-want-to-delete\n```\n\n## Kafka 在 Zookeeper 中的存储结构\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/learn-kafka/kafka-05.png)\n\n## 参考\n1. [Kafka架构原理](http://wenku.baidu.com/link?url=67RIEmD9ZesDewsvFuuALe1AF4yNdXN7e4eeca0FxpjA9voYrV1NkKOTdtmKIH9xAp0wzbO0nBCUsYK7HinB68Lmk2_zxQP0W_OGTTihEB3)\n2. [Kafka剖析系列文章](http://www.infoq.com/cn/articles/kafka-analysis-part-1)\n3. [[Kafka分区机制介绍与示例](http://lxw1234.com/archives/2015/10/538.htm)](http://lxw1234.com/archives/2015/10/538.htm)\n4. [Kafka快速入门](http://colobu.com/2014/08/06/kafka-quickstart/)\n5. [Kafka常用操作](https://my.oschina.net/u/218540/blog/223501)\n6. [apache kafka系列之在zookeeper中存储结构](http://blog.csdn.net/lizhitao/article/details/23744675)\n7. [kafka在zookeeper中一些存储结构](http://blog.csdn.net/ouyang111222/article/details/51094912)\n","source":"_posts/learn-kafka.md","raw":"---\ntitle: Kafka 基础\ndate: 2016-09-30 14:33:57\ntags: [总结, kafka]\n---\n\n## Kafka 基础概念\n\nKafka是由LinkedIn开发的一个分布式的，基于发布/订阅的消息系统。\n\n<!-- more -->\n\n### 关键词\n\n#### Broker\nKafka 集群包含一个或多个服务器，这种服务器被称为broker\n\n#### Topic\n每条发布到 Kafka 集群的消息都有一个类别，这个类别被称为 Topic。（物理上不同 Topic 的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个 broker 上但用户只需指定消息的 Topic 即可生产或消费数据而不必关心数据存于何处）\n\n#### Partition\nParition 是物理上的概念，每个 Topic 包含一个或多个 Partition\n\n#### Producer\n负责发布消息到 Kafka broker\n\n#### Consumer\n消息消费者，向 Kafka broker 读取消息的客户端。\n\n#### Consumer Group\n每个Consumer 属于一个特定的 Consumer Group（可为每个 Consumer 指定 group name，若不指定 group name 则属于默认的 group）。\n\n### 拓扑结构\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/learn-kafka/kafka-01.jpeg)\n\nKafka 通过 Zookeeper 管理集群配置，选举 leader，以及在 Consumer Group 发生变化时进行 rebalance。Producer 使用 push 模式将消息发布到 broker，Consumer 使用 pull 模式从 broker 订阅并消费消息。\n\n### 概念说明\n\n#### Topic & Partition\n\nTopic 在 **逻辑上** 可以认为是一个 queue，每条消息必须指定一个 topic，也就是将这条消息放进某一个 queue。\n\n为了使得 Kafka 的吞吐率可以线性提高，**物理上** 把 Topic 分成一个或多个Partition，每个 Partition 在物理上对应一个文件夹，该文件夹下存储这个 Partition 的所有消息和索引文件。因为每条消息都被 append 到该 Partition 中，属于顺序写磁盘，因此效率非常高（经验证，顺序写磁盘效率比随机写内存还要高，这是Kafka高吞吐率的一个很重要的保证）。\n\n如果一个 Topic 对应一个文件，那这个文件所在的机器 I/O 将会成为这个 Topic 的性能瓶颈，而有了 Partition后，不同的消息可以并行写入不同 broker 的不同 Partition 里，极大的提高了吞吐率。可以在$KAFKA_HOME/config/server.properties 中通过配置项 num.partitions 来指定新建 Topic 的默认 Partition 数量：\n\n```dockerfile\n# The default number of log partitions per topic. More partitions allow greater\n# parallelism for consumption, but this will also result in more files across\n# the brokers.\nnum.partitions=1\n```\n\n也可在创建 Topic 时通过参数指定，同时也可以在 Topic 创建之后通过 Kafka 提供的工具修改。\n\n#### Product\n\nProduct 负责发布消息到 Kafka broker，每次发布消息时，如上所述，Product 必须指定该消息的 Topic，至于消息会放到哪个 Partition，会根据 Paritition 机制选择将其存储到哪一个 Partition。如果 Partition 机制设置合理，所有消息可以均匀分布到不同的 Partition 里，这样就实现了负载均衡。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/learn-kafka/kafka-02.jpeg)\n\n常见的机制有：\n\n- 随机\n- 设置 key 和 partition num 取余\n- 顺序循环\n\n等等。\n\n#### 信息消费\n\n对于传统的 message queue 而言，一般会删除已经被消费的消息，而 Kafka 集群会保留所有的消息，无论其被消费与否。当然，因为磁盘限制，不可能永久保留所有数据（实际上也没必要），因此 Kafka 提供两种策略删除旧数据。一是基于时间，二是基于 Partition 文件大小。例如可以通过配置 $KAFKA_HOME/config/server.properties，让 Kafka 删除一周前的数据，也可在 Partition 文件超过1GB时删除旧数据，配置信息如下：\n\n```dockerfile\n# The minimum age of a log file to be eligible for deletion\nlog.retention.hours=168\n\n# A size-based retention policy for logs. Segments are pruned from the log as long as the remaining\n# segments don't drop below log.retention.bytes.\n#log.retention.bytes=1073741824\n\n# The maximum size of a log segment file. When this size is reached a new log segment will be created.\nlog.segment.bytes=1073741824\n\n# The interval at which log segments are checked to see if they can be deleted according\n# to the retention policies\nlog.retention.check.interval.ms=300000\n```\n\n这里要注意，因为 Kafka 读取特定消息的时间复杂度为 O(1)，即与文件大小无关，所以这里删除过期文件与提高 Kafka 性能无关。选择怎样的删除策略只与磁盘以及具体的需求有关。\n\n#### Consumer Group\n\n通常来讲，消息模型可以分为两种， 队列和发布-订阅式。 队列的处理方式是 一组消费者从服务器读取消息，一条消息只有其中的一个消费者来处理。在发布-订阅模型中，消息被广播给所有的消费者，接收到消息的消费者都可以处理此消息。Kafka为这两种模型提供了单一的消费者抽象模型： 消费者组 （consumer group）。\n\n消费者用一个消费者组名标记自己。 一个发布在 Topic 上消息被分发给此消费者组中的一个消费者。那么显而易见地：\n\n- 假如所有的消费者都在一个组中，那么这就变成了queue模型。\n- 假如所有的消费者都在不同的组中，那么就完全变成了发布-订阅模型。\n\n更通用的， 我们可以创建一些消费者组作为逻辑上的订阅者。每个组包含数目不等的消费者， 一个组内多个消费者可以用来扩展性能和容错。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/learn-kafka/kafka-03.jpeg)\n\n#### Consumer\n\nConsumer 是消息的消费者，Consumer 在从 broker 读取消息后，可以选择 commit，该操作会在 Zookeeper 中保存该 Consumer在该 Partition 中读取的消息的 offset。该 Consumer 下一次再读该 Partition 时会从下一条开始读取。如未 commit，下一次读取的开始位置会跟上一次 commit 之后的开始位置相同。当然可以将 Consumer 设置为 autocommit，即 Consumer 一旦读到数据立即自动 commit。\n\nKafka 会为每一个 Consumer Group 保留一些 metadata 信息包括 offset。这个 offset 由Consumer控制。正常情况下 Consumer 会在消费完一条消息后递增该 offset。当然，Consumer 也可将 offset 设成一个较小的值，重新消费一些消息。因为 offet 由 Consumer 控制，所以 Kafka broker 是无状态的，它不需要标记哪些消息被哪些消费过，也不需要通过 broker 去保证同一个 Consumer Group 只有一个 Consumer 能消费某一条消息，因此也就不需要锁机制，这也为 Kafka 的高吞吐率提供了有力保障。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/learn-kafka/kafka-05.jpeg)\n\n#### High Level Consumer\n\nHigh Level 的意思实际上是更高 Level 的 API，而不是说这种 Consumer 更高级。很多时候，客户程序只是希望从 Kafka 读取数据，不太关心消息 offset 的处理。同时也希望提供一些语义，例如同一条消息只被某一个 Consumer 消费（单播）或被所有 Consumer 消费（广播）。因此，High Level Consumer 提供了一个从 Kafka 消费数据的高层抽象，从而屏蔽掉其中的细节并提供丰富的语义。它提供了一个从 Kafka 消费数据的高层抽象，从而屏蔽掉其中的细节并提供丰富的语义。\n\n使用 Consumer high level API 时，同一Topic的一条消息只能被同一个 Consumer Group 内的一个 Consumer 消费，但多个 Consumer Group 可同时消费这一消息。\n\n假设有一个 Topic (名为 topic1，包含3个 Partition)，有两个 Consumer Group：group1 包含 consumer 1，group 2 包含 consumer2, consumer3, consumer 4)。现通过 Producer 向 topic1 发送key分别为1，2，3的消息。那么将发现属于 group1 的 Consumer 收到了所有的这三条消息，同时 group2 中的 3 个 Consumer 分别收到了 key 为 1，2，3 的消息。如下图所示。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/learn-kafka/kafka-04.png)\n\n### 安装kafka\n\ngoogle，安装 kafka 之前需安装 jdk\n\n### 查看所有topic\n\n```bash\n# 打开 kafka 所在目录\ncd YOUR_KAFKA_HOME\n# 列出所有 topic\n./bin/kafka-topics.sh --list --zookeeper YOUR_ZOOKEEPR_IPS\n# 查看 topic 明细\n./bin/kafka-topics.sh --topic test --describe --zookeeper YOUR_ZOOKEEPR_IPS\n```\n\n## 业务背景\n\n需要订阅业务平台的 Kafka 中的 c1 和 c2 的通话记录。\n\n## 技术方案\n\n使用 node 包：[kafka-node](https://github.com/SOHU-Co/kafka-node)﻿\n\n```javascript\nconst kafka = require('kafka-node');\n// 创建连接\nconst client = new kafka.Client(KAFKA_SERVER_IP);      \n// 创建 HLC\nconst consumer = new HighLevelConsumer(\n\tclient,\n\t[\n\t\t// 订阅话题，如果需要从指定 offset 读起，填 offset 参数\n\t\t{ topic: TOPIC_NAME, offset: 0}\n\t],\n\t{\n\t\t// 指定 groupId\n        groupId: 'eagle_eye',\n        autoCommit: true,\n        autoCommitIntervalMs: 5000,\n        fetchMaxWaitMs: 100,\n        fetchMinBytes: 1,\n        fetchMaxBytes: 1024 * 1024,\n        // 需要从指定 offset 读起\n        fromOffset: true,\n        encoding: 'utf8'\n\t}\n);\n\nconsumer.on('message', function (message) {\n  // 订阅消息\n})\n```\n\n### 关于 offsetOutOfRange\n如果想消费一个不存在的 offset(该 offset 可能确实不存在，也可能被 Kafka auto-delete 了)，这时候 consumer 会抛出 offsetOutOfRange 错误，在 HighLevelConsumer 中，监听到这个错误时会从当前 partition 的最小的一个 offset 开始重新消费。对于通用的 Consumer，客户端需要监听 offsetOutOfRange 事件自己来处理。\n\n\n## Zookeeper\n\n### 安装 Zookeeper\n\nmac 下可以直接使用 brew 安装 zookeeper，安装前需要先安装 jdk\n\n```shell\nbrew install zookeeper\n```\n\n### 连接到 Zookeeper 服务\n\n```shell\nzkCli -server YOUR_ZOOKEEPR_IPS\n```\n### Zookeeper 命令\n\n```shell\n# 使用ls命令查看当前Zookeeper中所包含的内容\nls /\t# 输出 [brokers, consumers, config 等]\nls /consumers\t# [consumer-group-1, test-group 等]\nls /consumers/test-group\n# 依次类推\n\n# 删除某个节点\ndelete /you-want-to-delete\n```\n\n## Kafka 在 Zookeeper 中的存储结构\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/learn-kafka/kafka-05.png)\n\n## 参考\n1. [Kafka架构原理](http://wenku.baidu.com/link?url=67RIEmD9ZesDewsvFuuALe1AF4yNdXN7e4eeca0FxpjA9voYrV1NkKOTdtmKIH9xAp0wzbO0nBCUsYK7HinB68Lmk2_zxQP0W_OGTTihEB3)\n2. [Kafka剖析系列文章](http://www.infoq.com/cn/articles/kafka-analysis-part-1)\n3. [[Kafka分区机制介绍与示例](http://lxw1234.com/archives/2015/10/538.htm)](http://lxw1234.com/archives/2015/10/538.htm)\n4. [Kafka快速入门](http://colobu.com/2014/08/06/kafka-quickstart/)\n5. [Kafka常用操作](https://my.oschina.net/u/218540/blog/223501)\n6. [apache kafka系列之在zookeeper中存储结构](http://blog.csdn.net/lizhitao/article/details/23744675)\n7. [kafka在zookeeper中一些存储结构](http://blog.csdn.net/ouyang111222/article/details/51094912)\n","slug":"learn-kafka","published":1,"updated":"2017-03-17T13:40:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcwf001vn927di2ikjj8","content":"<h2 id=\"Kafka-基础概念\"><a href=\"#Kafka-基础概念\" class=\"headerlink\" title=\"Kafka 基础概念\"></a>Kafka 基础概念</h2><p>Kafka是由LinkedIn开发的一个分布式的，基于发布/订阅的消息系统。</p>\n<a id=\"more\"></a>\n<h3 id=\"关键词\"><a href=\"#关键词\" class=\"headerlink\" title=\"关键词\"></a>关键词</h3><h4 id=\"Broker\"><a href=\"#Broker\" class=\"headerlink\" title=\"Broker\"></a>Broker</h4><p>Kafka 集群包含一个或多个服务器，这种服务器被称为broker</p>\n<h4 id=\"Topic\"><a href=\"#Topic\" class=\"headerlink\" title=\"Topic\"></a>Topic</h4><p>每条发布到 Kafka 集群的消息都有一个类别，这个类别被称为 Topic。（物理上不同 Topic 的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个 broker 上但用户只需指定消息的 Topic 即可生产或消费数据而不必关心数据存于何处）</p>\n<h4 id=\"Partition\"><a href=\"#Partition\" class=\"headerlink\" title=\"Partition\"></a>Partition</h4><p>Parition 是物理上的概念，每个 Topic 包含一个或多个 Partition</p>\n<h4 id=\"Producer\"><a href=\"#Producer\" class=\"headerlink\" title=\"Producer\"></a>Producer</h4><p>负责发布消息到 Kafka broker</p>\n<h4 id=\"Consumer\"><a href=\"#Consumer\" class=\"headerlink\" title=\"Consumer\"></a>Consumer</h4><p>消息消费者，向 Kafka broker 读取消息的客户端。</p>\n<h4 id=\"Consumer-Group\"><a href=\"#Consumer-Group\" class=\"headerlink\" title=\"Consumer Group\"></a>Consumer Group</h4><p>每个Consumer 属于一个特定的 Consumer Group（可为每个 Consumer 指定 group name，若不指定 group name 则属于默认的 group）。</p>\n<h3 id=\"拓扑结构\"><a href=\"#拓扑结构\" class=\"headerlink\" title=\"拓扑结构\"></a>拓扑结构</h3><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/learn-kafka/kafka-01.jpeg\" alt=\"\"></p>\n<p>Kafka 通过 Zookeeper 管理集群配置，选举 leader，以及在 Consumer Group 发生变化时进行 rebalance。Producer 使用 push 模式将消息发布到 broker，Consumer 使用 pull 模式从 broker 订阅并消费消息。</p>\n<h3 id=\"概念说明\"><a href=\"#概念说明\" class=\"headerlink\" title=\"概念说明\"></a>概念说明</h3><h4 id=\"Topic-amp-Partition\"><a href=\"#Topic-amp-Partition\" class=\"headerlink\" title=\"Topic &amp; Partition\"></a>Topic &amp; Partition</h4><p>Topic 在 <strong>逻辑上</strong> 可以认为是一个 queue，每条消息必须指定一个 topic，也就是将这条消息放进某一个 queue。</p>\n<p>为了使得 Kafka 的吞吐率可以线性提高，<strong>物理上</strong> 把 Topic 分成一个或多个Partition，每个 Partition 在物理上对应一个文件夹，该文件夹下存储这个 Partition 的所有消息和索引文件。因为每条消息都被 append 到该 Partition 中，属于顺序写磁盘，因此效率非常高（经验证，顺序写磁盘效率比随机写内存还要高，这是Kafka高吞吐率的一个很重要的保证）。</p>\n<p>如果一个 Topic 对应一个文件，那这个文件所在的机器 I/O 将会成为这个 Topic 的性能瓶颈，而有了 Partition后，不同的消息可以并行写入不同 broker 的不同 Partition 里，极大的提高了吞吐率。可以在$KAFKA_HOME/config/server.properties 中通过配置项 num.partitions 来指定新建 Topic 的默认 Partition 数量：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># The default number of log partitions per topic. More partitions allow greater</span></div><div class=\"line\"><span class=\"comment\"># parallelism for consumption, but this will also result in more files across</span></div><div class=\"line\"><span class=\"comment\"># the brokers.</span></div><div class=\"line\">num.partitions=<span class=\"number\">1</span></div></pre></td></tr></table></figure>\n<p>也可在创建 Topic 时通过参数指定，同时也可以在 Topic 创建之后通过 Kafka 提供的工具修改。</p>\n<h4 id=\"Product\"><a href=\"#Product\" class=\"headerlink\" title=\"Product\"></a>Product</h4><p>Product 负责发布消息到 Kafka broker，每次发布消息时，如上所述，Product 必须指定该消息的 Topic，至于消息会放到哪个 Partition，会根据 Paritition 机制选择将其存储到哪一个 Partition。如果 Partition 机制设置合理，所有消息可以均匀分布到不同的 Partition 里，这样就实现了负载均衡。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/learn-kafka/kafka-02.jpeg\" alt=\"\"></p>\n<p>常见的机制有：</p>\n<ul>\n<li>随机</li>\n<li>设置 key 和 partition num 取余</li>\n<li>顺序循环</li>\n</ul>\n<p>等等。</p>\n<h4 id=\"信息消费\"><a href=\"#信息消费\" class=\"headerlink\" title=\"信息消费\"></a>信息消费</h4><p>对于传统的 message queue 而言，一般会删除已经被消费的消息，而 Kafka 集群会保留所有的消息，无论其被消费与否。当然，因为磁盘限制，不可能永久保留所有数据（实际上也没必要），因此 Kafka 提供两种策略删除旧数据。一是基于时间，二是基于 Partition 文件大小。例如可以通过配置 $KAFKA_HOME/config/server.properties，让 Kafka 删除一周前的数据，也可在 Partition 文件超过1GB时删除旧数据，配置信息如下：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># The minimum age of a log file to be eligible for deletion</span></div><div class=\"line\">log.retention.hours=<span class=\"number\">168</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># A size-based retention policy for logs. Segments are pruned from the log as long as the remaining</span></div><div class=\"line\"><span class=\"comment\"># segments don't drop below log.retention.bytes.</span></div><div class=\"line\"><span class=\"comment\">#log.retention.bytes=1073741824</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># The maximum size of a log segment file. When this size is reached a new log segment will be created.</span></div><div class=\"line\">log.segment.bytes=<span class=\"number\">1073741824</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># The interval at which log segments are checked to see if they can be deleted according</span></div><div class=\"line\"><span class=\"comment\"># to the retention policies</span></div><div class=\"line\">log.retention.check.interval.ms=<span class=\"number\">300000</span></div></pre></td></tr></table></figure>\n<p>这里要注意，因为 Kafka 读取特定消息的时间复杂度为 O(1)，即与文件大小无关，所以这里删除过期文件与提高 Kafka 性能无关。选择怎样的删除策略只与磁盘以及具体的需求有关。</p>\n<h4 id=\"Consumer-Group-1\"><a href=\"#Consumer-Group-1\" class=\"headerlink\" title=\"Consumer Group\"></a>Consumer Group</h4><p>通常来讲，消息模型可以分为两种， 队列和发布-订阅式。 队列的处理方式是 一组消费者从服务器读取消息，一条消息只有其中的一个消费者来处理。在发布-订阅模型中，消息被广播给所有的消费者，接收到消息的消费者都可以处理此消息。Kafka为这两种模型提供了单一的消费者抽象模型： 消费者组 （consumer group）。</p>\n<p>消费者用一个消费者组名标记自己。 一个发布在 Topic 上消息被分发给此消费者组中的一个消费者。那么显而易见地：</p>\n<ul>\n<li>假如所有的消费者都在一个组中，那么这就变成了queue模型。</li>\n<li>假如所有的消费者都在不同的组中，那么就完全变成了发布-订阅模型。</li>\n</ul>\n<p>更通用的， 我们可以创建一些消费者组作为逻辑上的订阅者。每个组包含数目不等的消费者， 一个组内多个消费者可以用来扩展性能和容错。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/learn-kafka/kafka-03.jpeg\" alt=\"\"></p>\n<h4 id=\"Consumer-1\"><a href=\"#Consumer-1\" class=\"headerlink\" title=\"Consumer\"></a>Consumer</h4><p>Consumer 是消息的消费者，Consumer 在从 broker 读取消息后，可以选择 commit，该操作会在 Zookeeper 中保存该 Consumer在该 Partition 中读取的消息的 offset。该 Consumer 下一次再读该 Partition 时会从下一条开始读取。如未 commit，下一次读取的开始位置会跟上一次 commit 之后的开始位置相同。当然可以将 Consumer 设置为 autocommit，即 Consumer 一旦读到数据立即自动 commit。</p>\n<p>Kafka 会为每一个 Consumer Group 保留一些 metadata 信息包括 offset。这个 offset 由Consumer控制。正常情况下 Consumer 会在消费完一条消息后递增该 offset。当然，Consumer 也可将 offset 设成一个较小的值，重新消费一些消息。因为 offet 由 Consumer 控制，所以 Kafka broker 是无状态的，它不需要标记哪些消息被哪些消费过，也不需要通过 broker 去保证同一个 Consumer Group 只有一个 Consumer 能消费某一条消息，因此也就不需要锁机制，这也为 Kafka 的高吞吐率提供了有力保障。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/learn-kafka/kafka-05.jpeg\" alt=\"\"></p>\n<h4 id=\"High-Level-Consumer\"><a href=\"#High-Level-Consumer\" class=\"headerlink\" title=\"High Level Consumer\"></a>High Level Consumer</h4><p>High Level 的意思实际上是更高 Level 的 API，而不是说这种 Consumer 更高级。很多时候，客户程序只是希望从 Kafka 读取数据，不太关心消息 offset 的处理。同时也希望提供一些语义，例如同一条消息只被某一个 Consumer 消费（单播）或被所有 Consumer 消费（广播）。因此，High Level Consumer 提供了一个从 Kafka 消费数据的高层抽象，从而屏蔽掉其中的细节并提供丰富的语义。它提供了一个从 Kafka 消费数据的高层抽象，从而屏蔽掉其中的细节并提供丰富的语义。</p>\n<p>使用 Consumer high level API 时，同一Topic的一条消息只能被同一个 Consumer Group 内的一个 Consumer 消费，但多个 Consumer Group 可同时消费这一消息。</p>\n<p>假设有一个 Topic (名为 topic1，包含3个 Partition)，有两个 Consumer Group：group1 包含 consumer 1，group 2 包含 consumer2, consumer3, consumer 4)。现通过 Producer 向 topic1 发送key分别为1，2，3的消息。那么将发现属于 group1 的 Consumer 收到了所有的这三条消息，同时 group2 中的 3 个 Consumer 分别收到了 key 为 1，2，3 的消息。如下图所示。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/learn-kafka/kafka-04.png\" alt=\"\"></p>\n<h3 id=\"安装kafka\"><a href=\"#安装kafka\" class=\"headerlink\" title=\"安装kafka\"></a>安装kafka</h3><p>google，安装 kafka 之前需安装 jdk</p>\n<h3 id=\"查看所有topic\"><a href=\"#查看所有topic\" class=\"headerlink\" title=\"查看所有topic\"></a>查看所有topic</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 打开 kafka 所在目录</span></div><div class=\"line\"><span class=\"built_in\">cd</span> YOUR_KAFKA_HOME</div><div class=\"line\"><span class=\"comment\"># 列出所有 topic</span></div><div class=\"line\">./bin/kafka-topics.sh --list --zookeeper YOUR_ZOOKEEPR_IPS</div><div class=\"line\"><span class=\"comment\"># 查看 topic 明细</span></div><div class=\"line\">./bin/kafka-topics.sh --topic <span class=\"built_in\">test</span> --describe --zookeeper YOUR_ZOOKEEPR_IPS</div></pre></td></tr></table></figure>\n<h2 id=\"业务背景\"><a href=\"#业务背景\" class=\"headerlink\" title=\"业务背景\"></a>业务背景</h2><p>需要订阅业务平台的 Kafka 中的 c1 和 c2 的通话记录。</p>\n<h2 id=\"技术方案\"><a href=\"#技术方案\" class=\"headerlink\" title=\"技术方案\"></a>技术方案</h2><p>使用 node 包：<a href=\"https://github.com/SOHU-Co/kafka-node\" target=\"_blank\" rel=\"external\">kafka-node</a>﻿</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> kafka = <span class=\"built_in\">require</span>(<span class=\"string\">'kafka-node'</span>);</div><div class=\"line\"><span class=\"comment\">// 创建连接</span></div><div class=\"line\"><span class=\"keyword\">const</span> client = <span class=\"keyword\">new</span> kafka.Client(KAFKA_SERVER_IP);      </div><div class=\"line\"><span class=\"comment\">// 创建 HLC</span></div><div class=\"line\"><span class=\"keyword\">const</span> consumer = <span class=\"keyword\">new</span> HighLevelConsumer(</div><div class=\"line\">\tclient,</div><div class=\"line\">\t[</div><div class=\"line\">\t\t<span class=\"comment\">// 订阅话题，如果需要从指定 offset 读起，填 offset 参数</span></div><div class=\"line\">\t\t&#123; <span class=\"attr\">topic</span>: TOPIC_NAME, <span class=\"attr\">offset</span>: <span class=\"number\">0</span>&#125;</div><div class=\"line\">\t],</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// 指定 groupId</span></div><div class=\"line\">        groupId: <span class=\"string\">'eagle_eye'</span>,</div><div class=\"line\">        <span class=\"attr\">autoCommit</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">        <span class=\"attr\">autoCommitIntervalMs</span>: <span class=\"number\">5000</span>,</div><div class=\"line\">        <span class=\"attr\">fetchMaxWaitMs</span>: <span class=\"number\">100</span>,</div><div class=\"line\">        <span class=\"attr\">fetchMinBytes</span>: <span class=\"number\">1</span>,</div><div class=\"line\">        <span class=\"attr\">fetchMaxBytes</span>: <span class=\"number\">1024</span> * <span class=\"number\">1024</span>,</div><div class=\"line\">        <span class=\"comment\">// 需要从指定 offset 读起</span></div><div class=\"line\">        fromOffset: <span class=\"literal\">true</span>,</div><div class=\"line\">        <span class=\"attr\">encoding</span>: <span class=\"string\">'utf8'</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">);</div><div class=\"line\"></div><div class=\"line\">consumer.on(<span class=\"string\">'message'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">message</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 订阅消息</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"关于-offsetOutOfRange\"><a href=\"#关于-offsetOutOfRange\" class=\"headerlink\" title=\"关于 offsetOutOfRange\"></a>关于 offsetOutOfRange</h3><p>如果想消费一个不存在的 offset(该 offset 可能确实不存在，也可能被 Kafka auto-delete 了)，这时候 consumer 会抛出 offsetOutOfRange 错误，在 HighLevelConsumer 中，监听到这个错误时会从当前 partition 的最小的一个 offset 开始重新消费。对于通用的 Consumer，客户端需要监听 offsetOutOfRange 事件自己来处理。</p>\n<h2 id=\"Zookeeper\"><a href=\"#Zookeeper\" class=\"headerlink\" title=\"Zookeeper\"></a>Zookeeper</h2><h3 id=\"安装-Zookeeper\"><a href=\"#安装-Zookeeper\" class=\"headerlink\" title=\"安装 Zookeeper\"></a>安装 Zookeeper</h3><p>mac 下可以直接使用 brew 安装 zookeeper，安装前需要先安装 jdk</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew install zookeeper</div></pre></td></tr></table></figure>\n<h3 id=\"连接到-Zookeeper-服务\"><a href=\"#连接到-Zookeeper-服务\" class=\"headerlink\" title=\"连接到 Zookeeper 服务\"></a>连接到 Zookeeper 服务</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">zkCli -server YOUR_ZOOKEEPR_IPS</div></pre></td></tr></table></figure>\n<h3 id=\"Zookeeper-命令\"><a href=\"#Zookeeper-命令\" class=\"headerlink\" title=\"Zookeeper 命令\"></a>Zookeeper 命令</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 使用ls命令查看当前Zookeeper中所包含的内容</div><div class=\"line\">ls /\t# 输出 [brokers, consumers, config 等]</div><div class=\"line\">ls /consumers\t# [consumer-group-1, test-group 等]</div><div class=\"line\">ls /consumers/test-group</div><div class=\"line\"># 依次类推</div><div class=\"line\"></div><div class=\"line\"># 删除某个节点</div><div class=\"line\">delete /you-want-to-delete</div></pre></td></tr></table></figure>\n<h2 id=\"Kafka-在-Zookeeper-中的存储结构\"><a href=\"#Kafka-在-Zookeeper-中的存储结构\" class=\"headerlink\" title=\"Kafka 在 Zookeeper 中的存储结构\"></a>Kafka 在 Zookeeper 中的存储结构</h2><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/learn-kafka/kafka-05.png\" alt=\"\"></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"http://wenku.baidu.com/link?url=67RIEmD9ZesDewsvFuuALe1AF4yNdXN7e4eeca0FxpjA9voYrV1NkKOTdtmKIH9xAp0wzbO0nBCUsYK7HinB68Lmk2_zxQP0W_OGTTihEB3\" target=\"_blank\" rel=\"external\">Kafka架构原理</a></li>\n<li><a href=\"http://www.infoq.com/cn/articles/kafka-analysis-part-1\" target=\"_blank\" rel=\"external\">Kafka剖析系列文章</a></li>\n<li><a href=\"http://lxw1234.com/archives/2015/10/538.htm\" target=\"_blank\" rel=\"external\"><a href=\"http://lxw1234.com/archives/2015/10/538.htm\" target=\"_blank\" rel=\"external\">Kafka分区机制介绍与示例</a></a></li>\n<li><a href=\"http://colobu.com/2014/08/06/kafka-quickstart/\" target=\"_blank\" rel=\"external\">Kafka快速入门</a></li>\n<li><a href=\"https://my.oschina.net/u/218540/blog/223501\" target=\"_blank\" rel=\"external\">Kafka常用操作</a></li>\n<li><a href=\"http://blog.csdn.net/lizhitao/article/details/23744675\" target=\"_blank\" rel=\"external\">apache kafka系列之在zookeeper中存储结构</a></li>\n<li><a href=\"http://blog.csdn.net/ouyang111222/article/details/51094912\" target=\"_blank\" rel=\"external\">kafka在zookeeper中一些存储结构</a></li>\n</ol>\n","excerpt":"<h2 id=\"Kafka-基础概念\"><a href=\"#Kafka-基础概念\" class=\"headerlink\" title=\"Kafka 基础概念\"></a>Kafka 基础概念</h2><p>Kafka是由LinkedIn开发的一个分布式的，基于发布/订阅的消息系统。</p>","more":"<h3 id=\"关键词\"><a href=\"#关键词\" class=\"headerlink\" title=\"关键词\"></a>关键词</h3><h4 id=\"Broker\"><a href=\"#Broker\" class=\"headerlink\" title=\"Broker\"></a>Broker</h4><p>Kafka 集群包含一个或多个服务器，这种服务器被称为broker</p>\n<h4 id=\"Topic\"><a href=\"#Topic\" class=\"headerlink\" title=\"Topic\"></a>Topic</h4><p>每条发布到 Kafka 集群的消息都有一个类别，这个类别被称为 Topic。（物理上不同 Topic 的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个 broker 上但用户只需指定消息的 Topic 即可生产或消费数据而不必关心数据存于何处）</p>\n<h4 id=\"Partition\"><a href=\"#Partition\" class=\"headerlink\" title=\"Partition\"></a>Partition</h4><p>Parition 是物理上的概念，每个 Topic 包含一个或多个 Partition</p>\n<h4 id=\"Producer\"><a href=\"#Producer\" class=\"headerlink\" title=\"Producer\"></a>Producer</h4><p>负责发布消息到 Kafka broker</p>\n<h4 id=\"Consumer\"><a href=\"#Consumer\" class=\"headerlink\" title=\"Consumer\"></a>Consumer</h4><p>消息消费者，向 Kafka broker 读取消息的客户端。</p>\n<h4 id=\"Consumer-Group\"><a href=\"#Consumer-Group\" class=\"headerlink\" title=\"Consumer Group\"></a>Consumer Group</h4><p>每个Consumer 属于一个特定的 Consumer Group（可为每个 Consumer 指定 group name，若不指定 group name 则属于默认的 group）。</p>\n<h3 id=\"拓扑结构\"><a href=\"#拓扑结构\" class=\"headerlink\" title=\"拓扑结构\"></a>拓扑结构</h3><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/learn-kafka/kafka-01.jpeg\" alt=\"\"></p>\n<p>Kafka 通过 Zookeeper 管理集群配置，选举 leader，以及在 Consumer Group 发生变化时进行 rebalance。Producer 使用 push 模式将消息发布到 broker，Consumer 使用 pull 模式从 broker 订阅并消费消息。</p>\n<h3 id=\"概念说明\"><a href=\"#概念说明\" class=\"headerlink\" title=\"概念说明\"></a>概念说明</h3><h4 id=\"Topic-amp-Partition\"><a href=\"#Topic-amp-Partition\" class=\"headerlink\" title=\"Topic &amp; Partition\"></a>Topic &amp; Partition</h4><p>Topic 在 <strong>逻辑上</strong> 可以认为是一个 queue，每条消息必须指定一个 topic，也就是将这条消息放进某一个 queue。</p>\n<p>为了使得 Kafka 的吞吐率可以线性提高，<strong>物理上</strong> 把 Topic 分成一个或多个Partition，每个 Partition 在物理上对应一个文件夹，该文件夹下存储这个 Partition 的所有消息和索引文件。因为每条消息都被 append 到该 Partition 中，属于顺序写磁盘，因此效率非常高（经验证，顺序写磁盘效率比随机写内存还要高，这是Kafka高吞吐率的一个很重要的保证）。</p>\n<p>如果一个 Topic 对应一个文件，那这个文件所在的机器 I/O 将会成为这个 Topic 的性能瓶颈，而有了 Partition后，不同的消息可以并行写入不同 broker 的不同 Partition 里，极大的提高了吞吐率。可以在$KAFKA_HOME/config/server.properties 中通过配置项 num.partitions 来指定新建 Topic 的默认 Partition 数量：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># The default number of log partitions per topic. More partitions allow greater</span></div><div class=\"line\"><span class=\"comment\"># parallelism for consumption, but this will also result in more files across</span></div><div class=\"line\"><span class=\"comment\"># the brokers.</span></div><div class=\"line\">num.partitions=<span class=\"number\">1</span></div></pre></td></tr></table></figure>\n<p>也可在创建 Topic 时通过参数指定，同时也可以在 Topic 创建之后通过 Kafka 提供的工具修改。</p>\n<h4 id=\"Product\"><a href=\"#Product\" class=\"headerlink\" title=\"Product\"></a>Product</h4><p>Product 负责发布消息到 Kafka broker，每次发布消息时，如上所述，Product 必须指定该消息的 Topic，至于消息会放到哪个 Partition，会根据 Paritition 机制选择将其存储到哪一个 Partition。如果 Partition 机制设置合理，所有消息可以均匀分布到不同的 Partition 里，这样就实现了负载均衡。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/learn-kafka/kafka-02.jpeg\" alt=\"\"></p>\n<p>常见的机制有：</p>\n<ul>\n<li>随机</li>\n<li>设置 key 和 partition num 取余</li>\n<li>顺序循环</li>\n</ul>\n<p>等等。</p>\n<h4 id=\"信息消费\"><a href=\"#信息消费\" class=\"headerlink\" title=\"信息消费\"></a>信息消费</h4><p>对于传统的 message queue 而言，一般会删除已经被消费的消息，而 Kafka 集群会保留所有的消息，无论其被消费与否。当然，因为磁盘限制，不可能永久保留所有数据（实际上也没必要），因此 Kafka 提供两种策略删除旧数据。一是基于时间，二是基于 Partition 文件大小。例如可以通过配置 $KAFKA_HOME/config/server.properties，让 Kafka 删除一周前的数据，也可在 Partition 文件超过1GB时删除旧数据，配置信息如下：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># The minimum age of a log file to be eligible for deletion</span></div><div class=\"line\">log.retention.hours=<span class=\"number\">168</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># A size-based retention policy for logs. Segments are pruned from the log as long as the remaining</span></div><div class=\"line\"><span class=\"comment\"># segments don't drop below log.retention.bytes.</span></div><div class=\"line\"><span class=\"comment\">#log.retention.bytes=1073741824</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># The maximum size of a log segment file. When this size is reached a new log segment will be created.</span></div><div class=\"line\">log.segment.bytes=<span class=\"number\">1073741824</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># The interval at which log segments are checked to see if they can be deleted according</span></div><div class=\"line\"><span class=\"comment\"># to the retention policies</span></div><div class=\"line\">log.retention.check.interval.ms=<span class=\"number\">300000</span></div></pre></td></tr></table></figure>\n<p>这里要注意，因为 Kafka 读取特定消息的时间复杂度为 O(1)，即与文件大小无关，所以这里删除过期文件与提高 Kafka 性能无关。选择怎样的删除策略只与磁盘以及具体的需求有关。</p>\n<h4 id=\"Consumer-Group-1\"><a href=\"#Consumer-Group-1\" class=\"headerlink\" title=\"Consumer Group\"></a>Consumer Group</h4><p>通常来讲，消息模型可以分为两种， 队列和发布-订阅式。 队列的处理方式是 一组消费者从服务器读取消息，一条消息只有其中的一个消费者来处理。在发布-订阅模型中，消息被广播给所有的消费者，接收到消息的消费者都可以处理此消息。Kafka为这两种模型提供了单一的消费者抽象模型： 消费者组 （consumer group）。</p>\n<p>消费者用一个消费者组名标记自己。 一个发布在 Topic 上消息被分发给此消费者组中的一个消费者。那么显而易见地：</p>\n<ul>\n<li>假如所有的消费者都在一个组中，那么这就变成了queue模型。</li>\n<li>假如所有的消费者都在不同的组中，那么就完全变成了发布-订阅模型。</li>\n</ul>\n<p>更通用的， 我们可以创建一些消费者组作为逻辑上的订阅者。每个组包含数目不等的消费者， 一个组内多个消费者可以用来扩展性能和容错。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/learn-kafka/kafka-03.jpeg\" alt=\"\"></p>\n<h4 id=\"Consumer-1\"><a href=\"#Consumer-1\" class=\"headerlink\" title=\"Consumer\"></a>Consumer</h4><p>Consumer 是消息的消费者，Consumer 在从 broker 读取消息后，可以选择 commit，该操作会在 Zookeeper 中保存该 Consumer在该 Partition 中读取的消息的 offset。该 Consumer 下一次再读该 Partition 时会从下一条开始读取。如未 commit，下一次读取的开始位置会跟上一次 commit 之后的开始位置相同。当然可以将 Consumer 设置为 autocommit，即 Consumer 一旦读到数据立即自动 commit。</p>\n<p>Kafka 会为每一个 Consumer Group 保留一些 metadata 信息包括 offset。这个 offset 由Consumer控制。正常情况下 Consumer 会在消费完一条消息后递增该 offset。当然，Consumer 也可将 offset 设成一个较小的值，重新消费一些消息。因为 offet 由 Consumer 控制，所以 Kafka broker 是无状态的，它不需要标记哪些消息被哪些消费过，也不需要通过 broker 去保证同一个 Consumer Group 只有一个 Consumer 能消费某一条消息，因此也就不需要锁机制，这也为 Kafka 的高吞吐率提供了有力保障。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/learn-kafka/kafka-05.jpeg\" alt=\"\"></p>\n<h4 id=\"High-Level-Consumer\"><a href=\"#High-Level-Consumer\" class=\"headerlink\" title=\"High Level Consumer\"></a>High Level Consumer</h4><p>High Level 的意思实际上是更高 Level 的 API，而不是说这种 Consumer 更高级。很多时候，客户程序只是希望从 Kafka 读取数据，不太关心消息 offset 的处理。同时也希望提供一些语义，例如同一条消息只被某一个 Consumer 消费（单播）或被所有 Consumer 消费（广播）。因此，High Level Consumer 提供了一个从 Kafka 消费数据的高层抽象，从而屏蔽掉其中的细节并提供丰富的语义。它提供了一个从 Kafka 消费数据的高层抽象，从而屏蔽掉其中的细节并提供丰富的语义。</p>\n<p>使用 Consumer high level API 时，同一Topic的一条消息只能被同一个 Consumer Group 内的一个 Consumer 消费，但多个 Consumer Group 可同时消费这一消息。</p>\n<p>假设有一个 Topic (名为 topic1，包含3个 Partition)，有两个 Consumer Group：group1 包含 consumer 1，group 2 包含 consumer2, consumer3, consumer 4)。现通过 Producer 向 topic1 发送key分别为1，2，3的消息。那么将发现属于 group1 的 Consumer 收到了所有的这三条消息，同时 group2 中的 3 个 Consumer 分别收到了 key 为 1，2，3 的消息。如下图所示。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/learn-kafka/kafka-04.png\" alt=\"\"></p>\n<h3 id=\"安装kafka\"><a href=\"#安装kafka\" class=\"headerlink\" title=\"安装kafka\"></a>安装kafka</h3><p>google，安装 kafka 之前需安装 jdk</p>\n<h3 id=\"查看所有topic\"><a href=\"#查看所有topic\" class=\"headerlink\" title=\"查看所有topic\"></a>查看所有topic</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 打开 kafka 所在目录</span></div><div class=\"line\"><span class=\"built_in\">cd</span> YOUR_KAFKA_HOME</div><div class=\"line\"><span class=\"comment\"># 列出所有 topic</span></div><div class=\"line\">./bin/kafka-topics.sh --list --zookeeper YOUR_ZOOKEEPR_IPS</div><div class=\"line\"><span class=\"comment\"># 查看 topic 明细</span></div><div class=\"line\">./bin/kafka-topics.sh --topic <span class=\"built_in\">test</span> --describe --zookeeper YOUR_ZOOKEEPR_IPS</div></pre></td></tr></table></figure>\n<h2 id=\"业务背景\"><a href=\"#业务背景\" class=\"headerlink\" title=\"业务背景\"></a>业务背景</h2><p>需要订阅业务平台的 Kafka 中的 c1 和 c2 的通话记录。</p>\n<h2 id=\"技术方案\"><a href=\"#技术方案\" class=\"headerlink\" title=\"技术方案\"></a>技术方案</h2><p>使用 node 包：<a href=\"https://github.com/SOHU-Co/kafka-node\">kafka-node</a>﻿</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> kafka = <span class=\"built_in\">require</span>(<span class=\"string\">'kafka-node'</span>);</div><div class=\"line\"><span class=\"comment\">// 创建连接</span></div><div class=\"line\"><span class=\"keyword\">const</span> client = <span class=\"keyword\">new</span> kafka.Client(KAFKA_SERVER_IP);      </div><div class=\"line\"><span class=\"comment\">// 创建 HLC</span></div><div class=\"line\"><span class=\"keyword\">const</span> consumer = <span class=\"keyword\">new</span> HighLevelConsumer(</div><div class=\"line\">\tclient,</div><div class=\"line\">\t[</div><div class=\"line\">\t\t<span class=\"comment\">// 订阅话题，如果需要从指定 offset 读起，填 offset 参数</span></div><div class=\"line\">\t\t&#123; <span class=\"attr\">topic</span>: TOPIC_NAME, <span class=\"attr\">offset</span>: <span class=\"number\">0</span>&#125;</div><div class=\"line\">\t],</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// 指定 groupId</span></div><div class=\"line\">        groupId: <span class=\"string\">'eagle_eye'</span>,</div><div class=\"line\">        <span class=\"attr\">autoCommit</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">        <span class=\"attr\">autoCommitIntervalMs</span>: <span class=\"number\">5000</span>,</div><div class=\"line\">        <span class=\"attr\">fetchMaxWaitMs</span>: <span class=\"number\">100</span>,</div><div class=\"line\">        <span class=\"attr\">fetchMinBytes</span>: <span class=\"number\">1</span>,</div><div class=\"line\">        <span class=\"attr\">fetchMaxBytes</span>: <span class=\"number\">1024</span> * <span class=\"number\">1024</span>,</div><div class=\"line\">        <span class=\"comment\">// 需要从指定 offset 读起</span></div><div class=\"line\">        fromOffset: <span class=\"literal\">true</span>,</div><div class=\"line\">        <span class=\"attr\">encoding</span>: <span class=\"string\">'utf8'</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">);</div><div class=\"line\"></div><div class=\"line\">consumer.on(<span class=\"string\">'message'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">message</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 订阅消息</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"关于-offsetOutOfRange\"><a href=\"#关于-offsetOutOfRange\" class=\"headerlink\" title=\"关于 offsetOutOfRange\"></a>关于 offsetOutOfRange</h3><p>如果想消费一个不存在的 offset(该 offset 可能确实不存在，也可能被 Kafka auto-delete 了)，这时候 consumer 会抛出 offsetOutOfRange 错误，在 HighLevelConsumer 中，监听到这个错误时会从当前 partition 的最小的一个 offset 开始重新消费。对于通用的 Consumer，客户端需要监听 offsetOutOfRange 事件自己来处理。</p>\n<h2 id=\"Zookeeper\"><a href=\"#Zookeeper\" class=\"headerlink\" title=\"Zookeeper\"></a>Zookeeper</h2><h3 id=\"安装-Zookeeper\"><a href=\"#安装-Zookeeper\" class=\"headerlink\" title=\"安装 Zookeeper\"></a>安装 Zookeeper</h3><p>mac 下可以直接使用 brew 安装 zookeeper，安装前需要先安装 jdk</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew install zookeeper</div></pre></td></tr></table></figure>\n<h3 id=\"连接到-Zookeeper-服务\"><a href=\"#连接到-Zookeeper-服务\" class=\"headerlink\" title=\"连接到 Zookeeper 服务\"></a>连接到 Zookeeper 服务</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">zkCli -server YOUR_ZOOKEEPR_IPS</div></pre></td></tr></table></figure>\n<h3 id=\"Zookeeper-命令\"><a href=\"#Zookeeper-命令\" class=\"headerlink\" title=\"Zookeeper 命令\"></a>Zookeeper 命令</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 使用ls命令查看当前Zookeeper中所包含的内容</div><div class=\"line\">ls /\t# 输出 [brokers, consumers, config 等]</div><div class=\"line\">ls /consumers\t# [consumer-group-1, test-group 等]</div><div class=\"line\">ls /consumers/test-group</div><div class=\"line\"># 依次类推</div><div class=\"line\"></div><div class=\"line\"># 删除某个节点</div><div class=\"line\">delete /you-want-to-delete</div></pre></td></tr></table></figure>\n<h2 id=\"Kafka-在-Zookeeper-中的存储结构\"><a href=\"#Kafka-在-Zookeeper-中的存储结构\" class=\"headerlink\" title=\"Kafka 在 Zookeeper 中的存储结构\"></a>Kafka 在 Zookeeper 中的存储结构</h2><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/learn-kafka/kafka-05.png\" alt=\"\"></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"http://wenku.baidu.com/link?url=67RIEmD9ZesDewsvFuuALe1AF4yNdXN7e4eeca0FxpjA9voYrV1NkKOTdtmKIH9xAp0wzbO0nBCUsYK7HinB68Lmk2_zxQP0W_OGTTihEB3\">Kafka架构原理</a></li>\n<li><a href=\"http://www.infoq.com/cn/articles/kafka-analysis-part-1\">Kafka剖析系列文章</a></li>\n<li><a href=\"http://lxw1234.com/archives/2015/10/538.htm\"><a href=\"http://lxw1234.com/archives/2015/10/538.htm\">Kafka分区机制介绍与示例</a></a></li>\n<li><a href=\"http://colobu.com/2014/08/06/kafka-quickstart/\">Kafka快速入门</a></li>\n<li><a href=\"https://my.oschina.net/u/218540/blog/223501\">Kafka常用操作</a></li>\n<li><a href=\"http://blog.csdn.net/lizhitao/article/details/23744675\">apache kafka系列之在zookeeper中存储结构</a></li>\n<li><a href=\"http://blog.csdn.net/ouyang111222/article/details/51094912\">kafka在zookeeper中一些存储结构</a></li>\n</ol>"},{"title":"线性回归","date":"2017-02-14T13:40:45.000Z","_content":"\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/linear-regression/1.png)\n\n<!-- more -->\n\n上图坐标轴中随机散落了一些点，现在想求出一条直线，使得这些点到这条直线的距离是最小的，如下图。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/linear-regression/2.png)\n\n设这条直线的方程为 $y = mx + b$，即要找出 m, b，让上面蓝色的箭头之和最小。那么，所有点到直线的距离之和为：\n\n$$\n\\begin{align}\nSE &= (y\\_1 - (mx\\_1 + b))^2 + (y\\_2 - (mx\\_2 + b))^2 + ... + (y\\_n - (mx_n + b))^2 \\\\\\\n&= (y\\_1^2 - 2y\\_1(mx\\_1 + b) + (mx\\_1 + b)^2) + (y\\_2^2 - 2y\\_2(mx\\_2 + b) + (mx\\_2 + b)^2) \\\\\\\n&+ ... + (y\\_n^2 - 2y\\_n(mx\\_n + b) + (mx\\_n + b)^2) \\\\\\\n&= (y\\_1^2 - 2mx\\_1y\\_1 - 2by\\_1 + m^2x\\_1^2 + 2mbx\\_1 + b^2) + (y\\_2^2 - 2mx\\_2y\\_2 - 2by\\_2 + m^2x\\_2^2 + 2mbx\\_2 + b^2) \\\\\\\n&+ ... + (y\\_n^2 - 2mx\\_ny\\_n - 2by\\_n + m^2x\\_n^2 + 2mbx\\_n + b^2) \\\\\\\n&= (y\\_1^2 + y\\_2^2 + ... + y\\_n^2) - 2m(x\\_1y\\_1 + x\\_2y\\_2 + ... + x\\_ny\\_n^2) - 2b(y\\_1 + y\\_2 + ... + y\\_n) \\\\\\\n&+ m^2(x\\_1^2 + x\\_2^2 + ... + x\\_n^2) + 2mb(x\\_1 + x\\_2 + ... + x\\_n) + nb^2 \\\\\\\n\\end{align}\n$$\n\n设 $x\\_1$、$x\\_2$、...、$x\\_n$ 的平均数为 $\\overline{x}$，同样，可以计算出 $\\overline{y}$，$\\overline{xy}$，$\\overline{x^2}$，$\\overline{y^2}$，将平均数带入，即\n\n$$\n\\begin{align}\nSE &= (y\\_1^2 + y\\_2^2 + ... + y\\_n^2) - 2m(x\\_1y\\_1 + x\\_2y\\_2 + ... + x_ny\\_n) - 2b(y\\_1 + y\\_2 + ... + y\\_n) \\\\\\\n&+ m^2(x\\_1^2 + x\\_2^2 + ... + x\\_n^2) + 2mb(x\\_1 + x\\_2 + ... + x\\_n) + nb^2 \\\\\\\n&= (n\\overline{y^2}) - 2m(n\\overline{xy}) - 2b(n\\overline{y}) + m^2(n\\overline{x^2}) + 2mb(n\\overline{x}) + nb^2 \\\\\\\n\\end{align}\n$$\n\n因为各项平均数是可以求出来的，所以这是一个关于 m、b 的方程式，实际上，这是一个碗状的图像，要求出让 SE 最小的 m、n，即求出这个图像的最低点，此时，对 m 和 b 分别求偏导得到的结果为 0，即\n\n$$\n\\begin{align}\n\\frac{\\partial{SE}}{\\partial{m}} = -2n\\overline{xy} + 2mn\\overline{x^2} + 2bn\\overline{x} &= 0 \\\\\\\n\\frac{\\partial{SE}}{\\partial{b}} = -2n\\overline{y} + 2mn\\overline{x} + 2nb &= 0 \\\\\\\n\\end{align}\n$$\n\n化简得\n\n$$\n\\begin{align}\n\\overline{x^2}m + \\overline{x}b - \\overline{xy} &= 0 \\\\\\\n\\overline{x}m - \\overline{y} + b &= 0 \\\\\\\n\\end{align}\n$$\n\n可以得到，该直线必定经过 $(\\overline{x}, \\overline{y})$ 和 $(\\frac{\\overline{x^2}}{\\overline{x}}, \\frac{\\overline{xy}}{\\overline{y}})$\n\n当然，这条直线的方程也就能得到了：\n\n$$\n\\begin{align}\nm &= \\frac{\\overline{y} - \\frac{\\overline{xy}}{\\overline{x}}}{\\overline{x} - \\frac{\\overline{x^2}}{\\overline{x}}} \\\\\\\n&= \\frac{\\overline{x} * \\overline{y} - \\overline{xy}}{(\\overline{x})^2 - \\overline{x^2}} \\\\\\\nb &= \\overline{y} - m\\overline{x}\n\\end{align}\n$$\n\n举个栗子。\n\n还是上面那个例子，这些点的坐标如下：\n\n```\n[10.0, 8.04],\n[8.0, 6.95],\n[13.0, 7.58],\n[9.0, 8.81],\n[11.0, 8.33],\n[14.0, 9.96],\n[6.0, 7.24],\n[4.0, 4.26],\n[12.0, 10.84],\n[7.0, 4.82],\n[5.0, 5.68]\n```\n\n具体计算过程就不列了。。列个计算代码\n\n```javascript\nvar data = [\n    [10.0, 8.04],\n    [8.0, 6.95],\n    [13.0, 7.58],\n    [9.0, 8.81],\n    [11.0, 8.33],\n    [14.0, 9.96],\n    [6.0, 7.24],\n    [4.0, 4.26],\n    [12.0, 10.84],\n    [7.0, 4.82],\n    [5.0, 5.68]\n];\n\nlet sumX = 0, sumY = 0, sumX2 = 0, sumY2 = 0, sumXY = 0;\n\nfor (let i = 0; i < data.length; i++) {\n    const x = data[i][0], y = data[i][1];\n\n    sumX += x;\n    sumY += y;\n    sumX2 += x * x;\n    sumXY += x * y;\n}\n\nconst averX = sumX / data.length;\nconst averY = sumY / data.length;\nconst averX2 = sumX2 / data.length;\nconst averXY = sumXY / data.length;\n\nconst m = (averY - averXY / averX) / (averX - averX2 / averX);\nconst b = averY - m * averX;\n\n// 0.5, 3\nconsole.log(m, b);\n```\n\n对应直线即\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/linear-regression/3.png)\n","source":"_posts/linear-regression.md","raw":"---\ntitle: 线性回归\ndate: 2017-02-14 21:40:45\ntags: [统计学]\n---\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/linear-regression/1.png)\n\n<!-- more -->\n\n上图坐标轴中随机散落了一些点，现在想求出一条直线，使得这些点到这条直线的距离是最小的，如下图。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/linear-regression/2.png)\n\n设这条直线的方程为 $y = mx + b$，即要找出 m, b，让上面蓝色的箭头之和最小。那么，所有点到直线的距离之和为：\n\n$$\n\\begin{align}\nSE &= (y\\_1 - (mx\\_1 + b))^2 + (y\\_2 - (mx\\_2 + b))^2 + ... + (y\\_n - (mx_n + b))^2 \\\\\\\n&= (y\\_1^2 - 2y\\_1(mx\\_1 + b) + (mx\\_1 + b)^2) + (y\\_2^2 - 2y\\_2(mx\\_2 + b) + (mx\\_2 + b)^2) \\\\\\\n&+ ... + (y\\_n^2 - 2y\\_n(mx\\_n + b) + (mx\\_n + b)^2) \\\\\\\n&= (y\\_1^2 - 2mx\\_1y\\_1 - 2by\\_1 + m^2x\\_1^2 + 2mbx\\_1 + b^2) + (y\\_2^2 - 2mx\\_2y\\_2 - 2by\\_2 + m^2x\\_2^2 + 2mbx\\_2 + b^2) \\\\\\\n&+ ... + (y\\_n^2 - 2mx\\_ny\\_n - 2by\\_n + m^2x\\_n^2 + 2mbx\\_n + b^2) \\\\\\\n&= (y\\_1^2 + y\\_2^2 + ... + y\\_n^2) - 2m(x\\_1y\\_1 + x\\_2y\\_2 + ... + x\\_ny\\_n^2) - 2b(y\\_1 + y\\_2 + ... + y\\_n) \\\\\\\n&+ m^2(x\\_1^2 + x\\_2^2 + ... + x\\_n^2) + 2mb(x\\_1 + x\\_2 + ... + x\\_n) + nb^2 \\\\\\\n\\end{align}\n$$\n\n设 $x\\_1$、$x\\_2$、...、$x\\_n$ 的平均数为 $\\overline{x}$，同样，可以计算出 $\\overline{y}$，$\\overline{xy}$，$\\overline{x^2}$，$\\overline{y^2}$，将平均数带入，即\n\n$$\n\\begin{align}\nSE &= (y\\_1^2 + y\\_2^2 + ... + y\\_n^2) - 2m(x\\_1y\\_1 + x\\_2y\\_2 + ... + x_ny\\_n) - 2b(y\\_1 + y\\_2 + ... + y\\_n) \\\\\\\n&+ m^2(x\\_1^2 + x\\_2^2 + ... + x\\_n^2) + 2mb(x\\_1 + x\\_2 + ... + x\\_n) + nb^2 \\\\\\\n&= (n\\overline{y^2}) - 2m(n\\overline{xy}) - 2b(n\\overline{y}) + m^2(n\\overline{x^2}) + 2mb(n\\overline{x}) + nb^2 \\\\\\\n\\end{align}\n$$\n\n因为各项平均数是可以求出来的，所以这是一个关于 m、b 的方程式，实际上，这是一个碗状的图像，要求出让 SE 最小的 m、n，即求出这个图像的最低点，此时，对 m 和 b 分别求偏导得到的结果为 0，即\n\n$$\n\\begin{align}\n\\frac{\\partial{SE}}{\\partial{m}} = -2n\\overline{xy} + 2mn\\overline{x^2} + 2bn\\overline{x} &= 0 \\\\\\\n\\frac{\\partial{SE}}{\\partial{b}} = -2n\\overline{y} + 2mn\\overline{x} + 2nb &= 0 \\\\\\\n\\end{align}\n$$\n\n化简得\n\n$$\n\\begin{align}\n\\overline{x^2}m + \\overline{x}b - \\overline{xy} &= 0 \\\\\\\n\\overline{x}m - \\overline{y} + b &= 0 \\\\\\\n\\end{align}\n$$\n\n可以得到，该直线必定经过 $(\\overline{x}, \\overline{y})$ 和 $(\\frac{\\overline{x^2}}{\\overline{x}}, \\frac{\\overline{xy}}{\\overline{y}})$\n\n当然，这条直线的方程也就能得到了：\n\n$$\n\\begin{align}\nm &= \\frac{\\overline{y} - \\frac{\\overline{xy}}{\\overline{x}}}{\\overline{x} - \\frac{\\overline{x^2}}{\\overline{x}}} \\\\\\\n&= \\frac{\\overline{x} * \\overline{y} - \\overline{xy}}{(\\overline{x})^2 - \\overline{x^2}} \\\\\\\nb &= \\overline{y} - m\\overline{x}\n\\end{align}\n$$\n\n举个栗子。\n\n还是上面那个例子，这些点的坐标如下：\n\n```\n[10.0, 8.04],\n[8.0, 6.95],\n[13.0, 7.58],\n[9.0, 8.81],\n[11.0, 8.33],\n[14.0, 9.96],\n[6.0, 7.24],\n[4.0, 4.26],\n[12.0, 10.84],\n[7.0, 4.82],\n[5.0, 5.68]\n```\n\n具体计算过程就不列了。。列个计算代码\n\n```javascript\nvar data = [\n    [10.0, 8.04],\n    [8.0, 6.95],\n    [13.0, 7.58],\n    [9.0, 8.81],\n    [11.0, 8.33],\n    [14.0, 9.96],\n    [6.0, 7.24],\n    [4.0, 4.26],\n    [12.0, 10.84],\n    [7.0, 4.82],\n    [5.0, 5.68]\n];\n\nlet sumX = 0, sumY = 0, sumX2 = 0, sumY2 = 0, sumXY = 0;\n\nfor (let i = 0; i < data.length; i++) {\n    const x = data[i][0], y = data[i][1];\n\n    sumX += x;\n    sumY += y;\n    sumX2 += x * x;\n    sumXY += x * y;\n}\n\nconst averX = sumX / data.length;\nconst averY = sumY / data.length;\nconst averX2 = sumX2 / data.length;\nconst averXY = sumXY / data.length;\n\nconst m = (averY - averXY / averX) / (averX - averX2 / averX);\nconst b = averY - m * averX;\n\n// 0.5, 3\nconsole.log(m, b);\n```\n\n对应直线即\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/linear-regression/3.png)\n","slug":"linear-regression","published":1,"updated":"2017-02-14T16:14:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcwi001yn927bgh8iv8m","content":"<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/linear-regression/1.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>上图坐标轴中随机散落了一些点，现在想求出一条直线，使得这些点到这条直线的距离是最小的，如下图。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/linear-regression/2.png\" alt=\"\"></p>\n<p>设这条直线的方程为 $y = mx + b$，即要找出 m, b，让上面蓝色的箭头之和最小。那么，所有点到直线的距离之和为：</p>\n<p>$$<br>\\begin{align}<br>SE &amp;= (y_1 - (mx_1 + b))^2 + (y_2 - (mx_2 + b))^2 + … + (y_n - (mx_n + b))^2 \\\\<br>&amp;= (y_1^2 - 2y_1(mx_1 + b) + (mx_1 + b)^2) + (y_2^2 - 2y_2(mx_2 + b) + (mx_2 + b)^2) \\\\<br>&amp;+ … + (y_n^2 - 2y_n(mx_n + b) + (mx_n + b)^2) \\\\<br>&amp;= (y_1^2 - 2mx_1y_1 - 2by_1 + m^2x_1^2 + 2mbx_1 + b^2) + (y_2^2 - 2mx_2y_2 - 2by_2 + m^2x_2^2 + 2mbx_2 + b^2) \\\\<br>&amp;+ … + (y_n^2 - 2mx_ny_n - 2by_n + m^2x_n^2 + 2mbx_n + b^2) \\\\<br>&amp;= (y_1^2 + y_2^2 + … + y_n^2) - 2m(x_1y_1 + x_2y_2 + … + x_ny_n^2) - 2b(y_1 + y_2 + … + y_n) \\\\<br>&amp;+ m^2(x_1^2 + x_2^2 + … + x_n^2) + 2mb(x_1 + x_2 + … + x_n) + nb^2 \\\\<br>\\end{align}<br>$$</p>\n<p>设 $x_1$、$x_2$、…、$x_n$ 的平均数为 $\\overline{x}$，同样，可以计算出 $\\overline{y}$，$\\overline{xy}$，$\\overline{x^2}$，$\\overline{y^2}$，将平均数带入，即</p>\n<p>$$<br>\\begin{align}<br>SE &amp;= (y_1^2 + y_2^2 + … + y_n^2) - 2m(x_1y_1 + x_2y_2 + … + x_ny_n) - 2b(y_1 + y_2 + … + y_n) \\\\<br>&amp;+ m^2(x_1^2 + x_2^2 + … + x_n^2) + 2mb(x_1 + x_2 + … + x_n) + nb^2 \\\\<br>&amp;= (n\\overline{y^2}) - 2m(n\\overline{xy}) - 2b(n\\overline{y}) + m^2(n\\overline{x^2}) + 2mb(n\\overline{x}) + nb^2 \\\\<br>\\end{align}<br>$$</p>\n<p>因为各项平均数是可以求出来的，所以这是一个关于 m、b 的方程式，实际上，这是一个碗状的图像，要求出让 SE 最小的 m、n，即求出这个图像的最低点，此时，对 m 和 b 分别求偏导得到的结果为 0，即</p>\n<p>$$<br>\\begin{align}<br>\\frac{\\partial{SE}}{\\partial{m}} = -2n\\overline{xy} + 2mn\\overline{x^2} + 2bn\\overline{x} &amp;= 0 \\\\<br>\\frac{\\partial{SE}}{\\partial{b}} = -2n\\overline{y} + 2mn\\overline{x} + 2nb &amp;= 0 \\\\<br>\\end{align}<br>$$</p>\n<p>化简得</p>\n<p>$$<br>\\begin{align}<br>\\overline{x^2}m + \\overline{x}b - \\overline{xy} &amp;= 0 \\\\<br>\\overline{x}m - \\overline{y} + b &amp;= 0 \\\\<br>\\end{align}<br>$$</p>\n<p>可以得到，该直线必定经过 $(\\overline{x}, \\overline{y})$ 和 $(\\frac{\\overline{x^2}}{\\overline{x}}, \\frac{\\overline{xy}}{\\overline{y}})$</p>\n<p>当然，这条直线的方程也就能得到了：</p>\n<p>$$<br>\\begin{align}<br>m &amp;= \\frac{\\overline{y} - \\frac{\\overline{xy}}{\\overline{x}}}{\\overline{x} - \\frac{\\overline{x^2}}{\\overline{x}}} \\\\<br>&amp;= \\frac{\\overline{x} * \\overline{y} - \\overline{xy}}{(\\overline{x})^2 - \\overline{x^2}} \\\\<br>b &amp;= \\overline{y} - m\\overline{x}<br>\\end{align}<br>$$</p>\n<p>举个栗子。</p>\n<p>还是上面那个例子，这些点的坐标如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">[10.0, 8.04],</div><div class=\"line\">[8.0, 6.95],</div><div class=\"line\">[13.0, 7.58],</div><div class=\"line\">[9.0, 8.81],</div><div class=\"line\">[11.0, 8.33],</div><div class=\"line\">[14.0, 9.96],</div><div class=\"line\">[6.0, 7.24],</div><div class=\"line\">[4.0, 4.26],</div><div class=\"line\">[12.0, 10.84],</div><div class=\"line\">[7.0, 4.82],</div><div class=\"line\">[5.0, 5.68]</div></pre></td></tr></table></figure>\n<p>具体计算过程就不列了。。列个计算代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = [</div><div class=\"line\">    [<span class=\"number\">10.0</span>, <span class=\"number\">8.04</span>],</div><div class=\"line\">    [<span class=\"number\">8.0</span>, <span class=\"number\">6.95</span>],</div><div class=\"line\">    [<span class=\"number\">13.0</span>, <span class=\"number\">7.58</span>],</div><div class=\"line\">    [<span class=\"number\">9.0</span>, <span class=\"number\">8.81</span>],</div><div class=\"line\">    [<span class=\"number\">11.0</span>, <span class=\"number\">8.33</span>],</div><div class=\"line\">    [<span class=\"number\">14.0</span>, <span class=\"number\">9.96</span>],</div><div class=\"line\">    [<span class=\"number\">6.0</span>, <span class=\"number\">7.24</span>],</div><div class=\"line\">    [<span class=\"number\">4.0</span>, <span class=\"number\">4.26</span>],</div><div class=\"line\">    [<span class=\"number\">12.0</span>, <span class=\"number\">10.84</span>],</div><div class=\"line\">    [<span class=\"number\">7.0</span>, <span class=\"number\">4.82</span>],</div><div class=\"line\">    [<span class=\"number\">5.0</span>, <span class=\"number\">5.68</span>]</div><div class=\"line\">];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> sumX = <span class=\"number\">0</span>, sumY = <span class=\"number\">0</span>, sumX2 = <span class=\"number\">0</span>, sumY2 = <span class=\"number\">0</span>, sumXY = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; data.length; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> x = data[i][<span class=\"number\">0</span>], y = data[i][<span class=\"number\">1</span>];</div><div class=\"line\"></div><div class=\"line\">    sumX += x;</div><div class=\"line\">    sumY += y;</div><div class=\"line\">    sumX2 += x * x;</div><div class=\"line\">    sumXY += x * y;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> averX = sumX / data.length;</div><div class=\"line\"><span class=\"keyword\">const</span> averY = sumY / data.length;</div><div class=\"line\"><span class=\"keyword\">const</span> averX2 = sumX2 / data.length;</div><div class=\"line\"><span class=\"keyword\">const</span> averXY = sumXY / data.length;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> m = (averY - averXY / averX) / (averX - averX2 / averX);</div><div class=\"line\"><span class=\"keyword\">const</span> b = averY - m * averX;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 0.5, 3</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(m, b);</div></pre></td></tr></table></figure>\n<p>对应直线即</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/linear-regression/3.png\" alt=\"\"></p>\n","excerpt":"<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/linear-regression/1.png\" alt=\"\"></p>","more":"<p>上图坐标轴中随机散落了一些点，现在想求出一条直线，使得这些点到这条直线的距离是最小的，如下图。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/linear-regression/2.png\" alt=\"\"></p>\n<p>设这条直线的方程为 $y = mx + b$，即要找出 m, b，让上面蓝色的箭头之和最小。那么，所有点到直线的距离之和为：</p>\n<p>$$<br>\\begin{align}<br>SE &amp;= (y_1 - (mx_1 + b))^2 + (y_2 - (mx_2 + b))^2 + … + (y_n - (mx_n + b))^2 \\\\<br>&amp;= (y_1^2 - 2y_1(mx_1 + b) + (mx_1 + b)^2) + (y_2^2 - 2y_2(mx_2 + b) + (mx_2 + b)^2) \\\\<br>&amp;+ … + (y_n^2 - 2y_n(mx_n + b) + (mx_n + b)^2) \\\\<br>&amp;= (y_1^2 - 2mx_1y_1 - 2by_1 + m^2x_1^2 + 2mbx_1 + b^2) + (y_2^2 - 2mx_2y_2 - 2by_2 + m^2x_2^2 + 2mbx_2 + b^2) \\\\<br>&amp;+ … + (y_n^2 - 2mx_ny_n - 2by_n + m^2x_n^2 + 2mbx_n + b^2) \\\\<br>&amp;= (y_1^2 + y_2^2 + … + y_n^2) - 2m(x_1y_1 + x_2y_2 + … + x_ny_n^2) - 2b(y_1 + y_2 + … + y_n) \\\\<br>&amp;+ m^2(x_1^2 + x_2^2 + … + x_n^2) + 2mb(x_1 + x_2 + … + x_n) + nb^2 \\\\<br>\\end{align}<br>$$</p>\n<p>设 $x_1$、$x_2$、…、$x_n$ 的平均数为 $\\overline{x}$，同样，可以计算出 $\\overline{y}$，$\\overline{xy}$，$\\overline{x^2}$，$\\overline{y^2}$，将平均数带入，即</p>\n<p>$$<br>\\begin{align}<br>SE &amp;= (y_1^2 + y_2^2 + … + y_n^2) - 2m(x_1y_1 + x_2y_2 + … + x_ny_n) - 2b(y_1 + y_2 + … + y_n) \\\\<br>&amp;+ m^2(x_1^2 + x_2^2 + … + x_n^2) + 2mb(x_1 + x_2 + … + x_n) + nb^2 \\\\<br>&amp;= (n\\overline{y^2}) - 2m(n\\overline{xy}) - 2b(n\\overline{y}) + m^2(n\\overline{x^2}) + 2mb(n\\overline{x}) + nb^2 \\\\<br>\\end{align}<br>$$</p>\n<p>因为各项平均数是可以求出来的，所以这是一个关于 m、b 的方程式，实际上，这是一个碗状的图像，要求出让 SE 最小的 m、n，即求出这个图像的最低点，此时，对 m 和 b 分别求偏导得到的结果为 0，即</p>\n<p>$$<br>\\begin{align}<br>\\frac{\\partial{SE}}{\\partial{m}} = -2n\\overline{xy} + 2mn\\overline{x^2} + 2bn\\overline{x} &amp;= 0 \\\\<br>\\frac{\\partial{SE}}{\\partial{b}} = -2n\\overline{y} + 2mn\\overline{x} + 2nb &amp;= 0 \\\\<br>\\end{align}<br>$$</p>\n<p>化简得</p>\n<p>$$<br>\\begin{align}<br>\\overline{x^2}m + \\overline{x}b - \\overline{xy} &amp;= 0 \\\\<br>\\overline{x}m - \\overline{y} + b &amp;= 0 \\\\<br>\\end{align}<br>$$</p>\n<p>可以得到，该直线必定经过 $(\\overline{x}, \\overline{y})$ 和 $(\\frac{\\overline{x^2}}{\\overline{x}}, \\frac{\\overline{xy}}{\\overline{y}})$</p>\n<p>当然，这条直线的方程也就能得到了：</p>\n<p>$$<br>\\begin{align}<br>m &amp;= \\frac{\\overline{y} - \\frac{\\overline{xy}}{\\overline{x}}}{\\overline{x} - \\frac{\\overline{x^2}}{\\overline{x}}} \\\\<br>&amp;= \\frac{\\overline{x} * \\overline{y} - \\overline{xy}}{(\\overline{x})^2 - \\overline{x^2}} \\\\<br>b &amp;= \\overline{y} - m\\overline{x}<br>\\end{align}<br>$$</p>\n<p>举个栗子。</p>\n<p>还是上面那个例子，这些点的坐标如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">[10.0, 8.04],</div><div class=\"line\">[8.0, 6.95],</div><div class=\"line\">[13.0, 7.58],</div><div class=\"line\">[9.0, 8.81],</div><div class=\"line\">[11.0, 8.33],</div><div class=\"line\">[14.0, 9.96],</div><div class=\"line\">[6.0, 7.24],</div><div class=\"line\">[4.0, 4.26],</div><div class=\"line\">[12.0, 10.84],</div><div class=\"line\">[7.0, 4.82],</div><div class=\"line\">[5.0, 5.68]</div></pre></td></tr></table></figure>\n<p>具体计算过程就不列了。。列个计算代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = [</div><div class=\"line\">    [<span class=\"number\">10.0</span>, <span class=\"number\">8.04</span>],</div><div class=\"line\">    [<span class=\"number\">8.0</span>, <span class=\"number\">6.95</span>],</div><div class=\"line\">    [<span class=\"number\">13.0</span>, <span class=\"number\">7.58</span>],</div><div class=\"line\">    [<span class=\"number\">9.0</span>, <span class=\"number\">8.81</span>],</div><div class=\"line\">    [<span class=\"number\">11.0</span>, <span class=\"number\">8.33</span>],</div><div class=\"line\">    [<span class=\"number\">14.0</span>, <span class=\"number\">9.96</span>],</div><div class=\"line\">    [<span class=\"number\">6.0</span>, <span class=\"number\">7.24</span>],</div><div class=\"line\">    [<span class=\"number\">4.0</span>, <span class=\"number\">4.26</span>],</div><div class=\"line\">    [<span class=\"number\">12.0</span>, <span class=\"number\">10.84</span>],</div><div class=\"line\">    [<span class=\"number\">7.0</span>, <span class=\"number\">4.82</span>],</div><div class=\"line\">    [<span class=\"number\">5.0</span>, <span class=\"number\">5.68</span>]</div><div class=\"line\">];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> sumX = <span class=\"number\">0</span>, sumY = <span class=\"number\">0</span>, sumX2 = <span class=\"number\">0</span>, sumY2 = <span class=\"number\">0</span>, sumXY = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; data.length; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> x = data[i][<span class=\"number\">0</span>], y = data[i][<span class=\"number\">1</span>];</div><div class=\"line\"></div><div class=\"line\">    sumX += x;</div><div class=\"line\">    sumY += y;</div><div class=\"line\">    sumX2 += x * x;</div><div class=\"line\">    sumXY += x * y;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> averX = sumX / data.length;</div><div class=\"line\"><span class=\"keyword\">const</span> averY = sumY / data.length;</div><div class=\"line\"><span class=\"keyword\">const</span> averX2 = sumX2 / data.length;</div><div class=\"line\"><span class=\"keyword\">const</span> averXY = sumXY / data.length;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> m = (averY - averXY / averX) / (averX - averX2 / averX);</div><div class=\"line\"><span class=\"keyword\">const</span> b = averY - m * averX;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 0.5, 3</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(m, b);</div></pre></td></tr></table></figure>\n<p>对应直线即</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/linear-regression/3.png\" alt=\"\"></p>"},{"title":"自然语言处理（一）","date":"2016-07-10T15:28:24.000Z","_content":"\n如果想实现聊天机器人，必然要让程序能够正确响应用户的信息，而用户对机器输入的往往是我们平时使用的语言，也就是自然语言，想让机器能“理解”用户的信息，并能够返回用户需要的信息，这就涉及到了**自然语言处理**。从上个世纪50年代起，科学家们就已经开始着手研究这个问题，到现在为止，已经取得了非常大的突破。\n\n<!-- more -->\n\n## 自然语言处理的两个阶段\n\n在自然语言处理 60 多年的发展过程中，基本上可以分成两个阶段。早期的 20 多年，即从上个世纪 60 年代到70年代，是科学家们走弯路的阶段。当时，学术界对人工智能和自然语言理解的普遍认为：要让机器完成翻译或者语音识别等只有人类才能做到的事，就必须先让计算机理解自然语言，而做到这一点就必须让计算机拥有类似我们人类这样的智能。\n\n> 而事实上当然不是这样。对人类来讲，一个要把英文翻译成中文的人，必然要能很好地理解这两种语言，这就是直觉的作用。在人工智能领域，包括自然语言处理领域，这种方法论被称作“鸟飞派”，也就是看看鸟是怎么飞的就能模仿鸟造出的飞机，而不需要了解空气动力学。事实上，怀特兄弟发明飞机靠的是空气动力学而不是仿生学。\n\n### 基于规则的自然语言处理\n\n在 20 世纪 60 年代，当时普遍认识是首先做好两件事，即**分析语句**和**获取语义**。这是因为当时的语言学家们已经对各种自然语言进行了非常形式化的总结，形成了十分完备的体系。就好像学习西方语言，都要学习*语法规则*、*词性*和*构词法*等。而恰恰这些语法规则又很容易用计算机的算法描述，这就让大家对**基于规则的自然语言处理**充满了信心。\n\n当时对自然语言处理从研究到应用的依赖关系如下：\n\n- **应用层**：`语言识别`、`机器翻译`、`自动问答`、`自动摘要`等\n- **认知层**：`自然语言理解`\n- **基础层**：`句法分析`、`语义分析`\n\n首先我们关注句法分析。\n\n句法分析首先对一个句子进行拆分，得到一颗**文法分析树**，以` “徐志摩喜欢林徽因。”` 这句话来说，这句话分为主语、动词短语（即谓语）和句号三部分，得到的文法分析树如下：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/natural-language-processing-1/01.png)\n\n接下来分析出句子采用的文法规则，这个过程成为重写规则。具体到这个例子，重写规则包括：\n\n- 句子     --> 主语谓语句号\n- 主语     --> 名词\n- 谓语     --> 动词 名词短语\n- 名词短语 --> 名词\n- 名词     --> 徐志摩\n- 动词     --> 喜欢\n- 名词     --> 林徽因\n- 句号     --> 。\n\n从上面可以看出，短短几个字的句子，就需要一颗这么复杂的二维树结构和八条文法规则，而随着句子的复杂化，要处理起来就变得相当困难了，一个句子的文法分析树将变得非常巨大，也非常复杂。\n\n这里面至少有两个越不过去的坎。首先，想通过文法规则覆盖哪怕 20% 的真实语句，文法规则的数量也是几万条。随着覆盖语句的增加，文法规则的数量还会越来越多。\n\n其次，自然语言在演变的过程中，产生了词义和上下文相关的特性，因此，它的文法是**上下文有关文法**，而程序语言是人为设定的，是便于计算机解码的**上下文无关文法**，相比自然语言简单的多。两者计算量不可同日而语。\n\n> 在计算机科学中，图灵奖最高得主高德纳提出用计算复杂度来衡量算法的耗时。对于上下文无关语法，算法的复杂度基本上是语句长度的二次方，而对于上下文有关语法，计算复杂度基本上是语句长度的**六次方**。也就是说，长度同为 10 的程序语言语句和自然语言语句，计算机对它们进行文法分析的计算量，后者是前者的 10000 倍。而随着长度增加，这个差异会以非常快的速度扩大。所以在那个年代，即使是 IBM 公司，也几乎是不可能采用规则的方法来分析一些真实语句。\n\n在上个世纪 70 年代，基于规则的句法分析很快就走到了尽头，而对于语义处理则遇到了更大的麻烦，自然语言中的词的多义性很难用规则来描述，而是严重依赖于上下文，甚至是常识。\n\n举例来说，`the box is in the pen` 这句话，意思是 `盒子在围栏里`，但是 `pen` 到底翻译成钢笔还是围栏是取决于什么？是取决于常识：因为盒子不可能装在钢笔里，这个例子非常清晰地说明了自然语言处理研究方法上存在的问题。\n\n这时候，**基于统计的自然语言处理**重获了新生，并取得了今天的非凡成就。\n\n### 基于统计的自然语言处理\n\n(待续)\n","source":"_posts/natural-language-processing-1.md","raw":"---\ntitle: 自然语言处理（一）\ndate: 2016-07-10 23:28:24\ntags: [自然语言处理 读书笔记]\n---\n\n如果想实现聊天机器人，必然要让程序能够正确响应用户的信息，而用户对机器输入的往往是我们平时使用的语言，也就是自然语言，想让机器能“理解”用户的信息，并能够返回用户需要的信息，这就涉及到了**自然语言处理**。从上个世纪50年代起，科学家们就已经开始着手研究这个问题，到现在为止，已经取得了非常大的突破。\n\n<!-- more -->\n\n## 自然语言处理的两个阶段\n\n在自然语言处理 60 多年的发展过程中，基本上可以分成两个阶段。早期的 20 多年，即从上个世纪 60 年代到70年代，是科学家们走弯路的阶段。当时，学术界对人工智能和自然语言理解的普遍认为：要让机器完成翻译或者语音识别等只有人类才能做到的事，就必须先让计算机理解自然语言，而做到这一点就必须让计算机拥有类似我们人类这样的智能。\n\n> 而事实上当然不是这样。对人类来讲，一个要把英文翻译成中文的人，必然要能很好地理解这两种语言，这就是直觉的作用。在人工智能领域，包括自然语言处理领域，这种方法论被称作“鸟飞派”，也就是看看鸟是怎么飞的就能模仿鸟造出的飞机，而不需要了解空气动力学。事实上，怀特兄弟发明飞机靠的是空气动力学而不是仿生学。\n\n### 基于规则的自然语言处理\n\n在 20 世纪 60 年代，当时普遍认识是首先做好两件事，即**分析语句**和**获取语义**。这是因为当时的语言学家们已经对各种自然语言进行了非常形式化的总结，形成了十分完备的体系。就好像学习西方语言，都要学习*语法规则*、*词性*和*构词法*等。而恰恰这些语法规则又很容易用计算机的算法描述，这就让大家对**基于规则的自然语言处理**充满了信心。\n\n当时对自然语言处理从研究到应用的依赖关系如下：\n\n- **应用层**：`语言识别`、`机器翻译`、`自动问答`、`自动摘要`等\n- **认知层**：`自然语言理解`\n- **基础层**：`句法分析`、`语义分析`\n\n首先我们关注句法分析。\n\n句法分析首先对一个句子进行拆分，得到一颗**文法分析树**，以` “徐志摩喜欢林徽因。”` 这句话来说，这句话分为主语、动词短语（即谓语）和句号三部分，得到的文法分析树如下：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/natural-language-processing-1/01.png)\n\n接下来分析出句子采用的文法规则，这个过程成为重写规则。具体到这个例子，重写规则包括：\n\n- 句子     --> 主语谓语句号\n- 主语     --> 名词\n- 谓语     --> 动词 名词短语\n- 名词短语 --> 名词\n- 名词     --> 徐志摩\n- 动词     --> 喜欢\n- 名词     --> 林徽因\n- 句号     --> 。\n\n从上面可以看出，短短几个字的句子，就需要一颗这么复杂的二维树结构和八条文法规则，而随着句子的复杂化，要处理起来就变得相当困难了，一个句子的文法分析树将变得非常巨大，也非常复杂。\n\n这里面至少有两个越不过去的坎。首先，想通过文法规则覆盖哪怕 20% 的真实语句，文法规则的数量也是几万条。随着覆盖语句的增加，文法规则的数量还会越来越多。\n\n其次，自然语言在演变的过程中，产生了词义和上下文相关的特性，因此，它的文法是**上下文有关文法**，而程序语言是人为设定的，是便于计算机解码的**上下文无关文法**，相比自然语言简单的多。两者计算量不可同日而语。\n\n> 在计算机科学中，图灵奖最高得主高德纳提出用计算复杂度来衡量算法的耗时。对于上下文无关语法，算法的复杂度基本上是语句长度的二次方，而对于上下文有关语法，计算复杂度基本上是语句长度的**六次方**。也就是说，长度同为 10 的程序语言语句和自然语言语句，计算机对它们进行文法分析的计算量，后者是前者的 10000 倍。而随着长度增加，这个差异会以非常快的速度扩大。所以在那个年代，即使是 IBM 公司，也几乎是不可能采用规则的方法来分析一些真实语句。\n\n在上个世纪 70 年代，基于规则的句法分析很快就走到了尽头，而对于语义处理则遇到了更大的麻烦，自然语言中的词的多义性很难用规则来描述，而是严重依赖于上下文，甚至是常识。\n\n举例来说，`the box is in the pen` 这句话，意思是 `盒子在围栏里`，但是 `pen` 到底翻译成钢笔还是围栏是取决于什么？是取决于常识：因为盒子不可能装在钢笔里，这个例子非常清晰地说明了自然语言处理研究方法上存在的问题。\n\n这时候，**基于统计的自然语言处理**重获了新生，并取得了今天的非凡成就。\n\n### 基于统计的自然语言处理\n\n(待续)\n","slug":"natural-language-processing-1","published":1,"updated":"2016-08-27T00:03:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcwl0020n9277bxk7dj7","content":"<p>如果想实现聊天机器人，必然要让程序能够正确响应用户的信息，而用户对机器输入的往往是我们平时使用的语言，也就是自然语言，想让机器能“理解”用户的信息，并能够返回用户需要的信息，这就涉及到了<strong>自然语言处理</strong>。从上个世纪50年代起，科学家们就已经开始着手研究这个问题，到现在为止，已经取得了非常大的突破。</p>\n<a id=\"more\"></a>\n<h2 id=\"自然语言处理的两个阶段\"><a href=\"#自然语言处理的两个阶段\" class=\"headerlink\" title=\"自然语言处理的两个阶段\"></a>自然语言处理的两个阶段</h2><p>在自然语言处理 60 多年的发展过程中，基本上可以分成两个阶段。早期的 20 多年，即从上个世纪 60 年代到70年代，是科学家们走弯路的阶段。当时，学术界对人工智能和自然语言理解的普遍认为：要让机器完成翻译或者语音识别等只有人类才能做到的事，就必须先让计算机理解自然语言，而做到这一点就必须让计算机拥有类似我们人类这样的智能。</p>\n<blockquote>\n<p>而事实上当然不是这样。对人类来讲，一个要把英文翻译成中文的人，必然要能很好地理解这两种语言，这就是直觉的作用。在人工智能领域，包括自然语言处理领域，这种方法论被称作“鸟飞派”，也就是看看鸟是怎么飞的就能模仿鸟造出的飞机，而不需要了解空气动力学。事实上，怀特兄弟发明飞机靠的是空气动力学而不是仿生学。</p>\n</blockquote>\n<h3 id=\"基于规则的自然语言处理\"><a href=\"#基于规则的自然语言处理\" class=\"headerlink\" title=\"基于规则的自然语言处理\"></a>基于规则的自然语言处理</h3><p>在 20 世纪 60 年代，当时普遍认识是首先做好两件事，即<strong>分析语句</strong>和<strong>获取语义</strong>。这是因为当时的语言学家们已经对各种自然语言进行了非常形式化的总结，形成了十分完备的体系。就好像学习西方语言，都要学习<em>语法规则</em>、<em>词性</em>和<em>构词法</em>等。而恰恰这些语法规则又很容易用计算机的算法描述，这就让大家对<strong>基于规则的自然语言处理</strong>充满了信心。</p>\n<p>当时对自然语言处理从研究到应用的依赖关系如下：</p>\n<ul>\n<li><strong>应用层</strong>：<code>语言识别</code>、<code>机器翻译</code>、<code>自动问答</code>、<code>自动摘要</code>等</li>\n<li><strong>认知层</strong>：<code>自然语言理解</code></li>\n<li><strong>基础层</strong>：<code>句法分析</code>、<code>语义分析</code></li>\n</ul>\n<p>首先我们关注句法分析。</p>\n<p>句法分析首先对一个句子进行拆分，得到一颗<strong>文法分析树</strong>，以<code>“徐志摩喜欢林徽因。”</code> 这句话来说，这句话分为主语、动词短语（即谓语）和句号三部分，得到的文法分析树如下：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/natural-language-processing-1/01.png\" alt=\"\"></p>\n<p>接下来分析出句子采用的文法规则，这个过程成为重写规则。具体到这个例子，重写规则包括：</p>\n<ul>\n<li>句子     –&gt; 主语谓语句号</li>\n<li>主语     –&gt; 名词</li>\n<li>谓语     –&gt; 动词 名词短语</li>\n<li>名词短语 –&gt; 名词</li>\n<li>名词     –&gt; 徐志摩</li>\n<li>动词     –&gt; 喜欢</li>\n<li>名词     –&gt; 林徽因</li>\n<li>句号     –&gt; 。</li>\n</ul>\n<p>从上面可以看出，短短几个字的句子，就需要一颗这么复杂的二维树结构和八条文法规则，而随着句子的复杂化，要处理起来就变得相当困难了，一个句子的文法分析树将变得非常巨大，也非常复杂。</p>\n<p>这里面至少有两个越不过去的坎。首先，想通过文法规则覆盖哪怕 20% 的真实语句，文法规则的数量也是几万条。随着覆盖语句的增加，文法规则的数量还会越来越多。</p>\n<p>其次，自然语言在演变的过程中，产生了词义和上下文相关的特性，因此，它的文法是<strong>上下文有关文法</strong>，而程序语言是人为设定的，是便于计算机解码的<strong>上下文无关文法</strong>，相比自然语言简单的多。两者计算量不可同日而语。</p>\n<blockquote>\n<p>在计算机科学中，图灵奖最高得主高德纳提出用计算复杂度来衡量算法的耗时。对于上下文无关语法，算法的复杂度基本上是语句长度的二次方，而对于上下文有关语法，计算复杂度基本上是语句长度的<strong>六次方</strong>。也就是说，长度同为 10 的程序语言语句和自然语言语句，计算机对它们进行文法分析的计算量，后者是前者的 10000 倍。而随着长度增加，这个差异会以非常快的速度扩大。所以在那个年代，即使是 IBM 公司，也几乎是不可能采用规则的方法来分析一些真实语句。</p>\n</blockquote>\n<p>在上个世纪 70 年代，基于规则的句法分析很快就走到了尽头，而对于语义处理则遇到了更大的麻烦，自然语言中的词的多义性很难用规则来描述，而是严重依赖于上下文，甚至是常识。</p>\n<p>举例来说，<code>the box is in the pen</code> 这句话，意思是 <code>盒子在围栏里</code>，但是 <code>pen</code> 到底翻译成钢笔还是围栏是取决于什么？是取决于常识：因为盒子不可能装在钢笔里，这个例子非常清晰地说明了自然语言处理研究方法上存在的问题。</p>\n<p>这时候，<strong>基于统计的自然语言处理</strong>重获了新生，并取得了今天的非凡成就。</p>\n<h3 id=\"基于统计的自然语言处理\"><a href=\"#基于统计的自然语言处理\" class=\"headerlink\" title=\"基于统计的自然语言处理\"></a>基于统计的自然语言处理</h3><p>(待续)</p>\n","excerpt":"<p>如果想实现聊天机器人，必然要让程序能够正确响应用户的信息，而用户对机器输入的往往是我们平时使用的语言，也就是自然语言，想让机器能“理解”用户的信息，并能够返回用户需要的信息，这就涉及到了<strong>自然语言处理</strong>。从上个世纪50年代起，科学家们就已经开始着手研究这个问题，到现在为止，已经取得了非常大的突破。</p>","more":"<h2 id=\"自然语言处理的两个阶段\"><a href=\"#自然语言处理的两个阶段\" class=\"headerlink\" title=\"自然语言处理的两个阶段\"></a>自然语言处理的两个阶段</h2><p>在自然语言处理 60 多年的发展过程中，基本上可以分成两个阶段。早期的 20 多年，即从上个世纪 60 年代到70年代，是科学家们走弯路的阶段。当时，学术界对人工智能和自然语言理解的普遍认为：要让机器完成翻译或者语音识别等只有人类才能做到的事，就必须先让计算机理解自然语言，而做到这一点就必须让计算机拥有类似我们人类这样的智能。</p>\n<blockquote>\n<p>而事实上当然不是这样。对人类来讲，一个要把英文翻译成中文的人，必然要能很好地理解这两种语言，这就是直觉的作用。在人工智能领域，包括自然语言处理领域，这种方法论被称作“鸟飞派”，也就是看看鸟是怎么飞的就能模仿鸟造出的飞机，而不需要了解空气动力学。事实上，怀特兄弟发明飞机靠的是空气动力学而不是仿生学。</p>\n</blockquote>\n<h3 id=\"基于规则的自然语言处理\"><a href=\"#基于规则的自然语言处理\" class=\"headerlink\" title=\"基于规则的自然语言处理\"></a>基于规则的自然语言处理</h3><p>在 20 世纪 60 年代，当时普遍认识是首先做好两件事，即<strong>分析语句</strong>和<strong>获取语义</strong>。这是因为当时的语言学家们已经对各种自然语言进行了非常形式化的总结，形成了十分完备的体系。就好像学习西方语言，都要学习<em>语法规则</em>、<em>词性</em>和<em>构词法</em>等。而恰恰这些语法规则又很容易用计算机的算法描述，这就让大家对<strong>基于规则的自然语言处理</strong>充满了信心。</p>\n<p>当时对自然语言处理从研究到应用的依赖关系如下：</p>\n<ul>\n<li><strong>应用层</strong>：<code>语言识别</code>、<code>机器翻译</code>、<code>自动问答</code>、<code>自动摘要</code>等</li>\n<li><strong>认知层</strong>：<code>自然语言理解</code></li>\n<li><strong>基础层</strong>：<code>句法分析</code>、<code>语义分析</code></li>\n</ul>\n<p>首先我们关注句法分析。</p>\n<p>句法分析首先对一个句子进行拆分，得到一颗<strong>文法分析树</strong>，以<code>“徐志摩喜欢林徽因。”</code> 这句话来说，这句话分为主语、动词短语（即谓语）和句号三部分，得到的文法分析树如下：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/natural-language-processing-1/01.png\" alt=\"\"></p>\n<p>接下来分析出句子采用的文法规则，这个过程成为重写规则。具体到这个例子，重写规则包括：</p>\n<ul>\n<li>句子     –&gt; 主语谓语句号</li>\n<li>主语     –&gt; 名词</li>\n<li>谓语     –&gt; 动词 名词短语</li>\n<li>名词短语 –&gt; 名词</li>\n<li>名词     –&gt; 徐志摩</li>\n<li>动词     –&gt; 喜欢</li>\n<li>名词     –&gt; 林徽因</li>\n<li>句号     –&gt; 。</li>\n</ul>\n<p>从上面可以看出，短短几个字的句子，就需要一颗这么复杂的二维树结构和八条文法规则，而随着句子的复杂化，要处理起来就变得相当困难了，一个句子的文法分析树将变得非常巨大，也非常复杂。</p>\n<p>这里面至少有两个越不过去的坎。首先，想通过文法规则覆盖哪怕 20% 的真实语句，文法规则的数量也是几万条。随着覆盖语句的增加，文法规则的数量还会越来越多。</p>\n<p>其次，自然语言在演变的过程中，产生了词义和上下文相关的特性，因此，它的文法是<strong>上下文有关文法</strong>，而程序语言是人为设定的，是便于计算机解码的<strong>上下文无关文法</strong>，相比自然语言简单的多。两者计算量不可同日而语。</p>\n<blockquote>\n<p>在计算机科学中，图灵奖最高得主高德纳提出用计算复杂度来衡量算法的耗时。对于上下文无关语法，算法的复杂度基本上是语句长度的二次方，而对于上下文有关语法，计算复杂度基本上是语句长度的<strong>六次方</strong>。也就是说，长度同为 10 的程序语言语句和自然语言语句，计算机对它们进行文法分析的计算量，后者是前者的 10000 倍。而随着长度增加，这个差异会以非常快的速度扩大。所以在那个年代，即使是 IBM 公司，也几乎是不可能采用规则的方法来分析一些真实语句。</p>\n</blockquote>\n<p>在上个世纪 70 年代，基于规则的句法分析很快就走到了尽头，而对于语义处理则遇到了更大的麻烦，自然语言中的词的多义性很难用规则来描述，而是严重依赖于上下文，甚至是常识。</p>\n<p>举例来说，<code>the box is in the pen</code> 这句话，意思是 <code>盒子在围栏里</code>，但是 <code>pen</code> 到底翻译成钢笔还是围栏是取决于什么？是取决于常识：因为盒子不可能装在钢笔里，这个例子非常清晰地说明了自然语言处理研究方法上存在的问题。</p>\n<p>这时候，<strong>基于统计的自然语言处理</strong>重获了新生，并取得了今天的非凡成就。</p>\n<h3 id=\"基于统计的自然语言处理\"><a href=\"#基于统计的自然语言处理\" class=\"headerlink\" title=\"基于统计的自然语言处理\"></a>基于统计的自然语言处理</h3><p>(待续)</p>"},{"title":"幂级数","date":"2017-03-25T00:44:25.000Z","_content":"\n幂级数的形式为 $a\\_0 + a\\_1x + a\\_2x^2 + \\cdots$，记为 $\\sum\\_{n = 0}^{\\infty}a\\_nx^n$。\n\n<!-- more -->\n\n## 幂级数的收敛性\n\n设 $S\\_N = \\sum\\_{n = 0}^{N}a\\_nx^n$，幂级数之和即 $S = \\sum\\_{n = 0}^{\\infty}a\\_nx^n = \\lim\\_{N to \\infty}S\\_N$，当极限存在时，幂级数收敛，极限不存在，幂级数发散。\n\n若 $|x| < R$ 时，幂级数收敛，则称 R 为幂级数的 **收敛半径**。\n\n### 几何级数\n\n当 $a\\_0 = a\\_2 = a\\_3 = \\cdots = 1$ 时，幂级数 $1 + x + x^2 + x^3 + \\cdots$ 可以看做公比为 x 的几何级数。\n\n$$\n\\begin{align}\nS &= 1 + x + x^2 + x^3 + \\cdots \\\\\\\nS \\cdot x &= x + x^2 + x^3 + x^4 + \\cdots \\\\\\\nS - S \\cdot x &= 1 \\\\\\\nS &= \\cfrac{1}{1 - x}\n\\end{align}\n$$\n\n前提是 S 是存在的，如果 $x > 1$，S 趋近于无穷大，就得不到上式了，所以几何级数的收敛半径为 1.\n\n## 泰勒公式\n\n通过泰勒公式可以将函数转化为幂级数展开式。\n\n泰勒公式的一般形式为\n\n$$\nf(x) = \\sum\\_{n = 0}^{\\infty}\\cfrac{f^{(n)}(0)}{n!}x^n\n$$\n\n一般地，$a\\_n = \\cfrac{f^{(n)}(0)}{n!}$\n\n### 栗子\n\n#### 1. $e^x$\n\n因为 $f(x) = e^x$，则 $f^{(n)}(x) = e^x$，$f^{(n)}(0) = 1$\n\n所以 $e^x = \\sum\\_{n = 0}^{\\infty}\\cfrac{1}{n!}x^n = 1 + x + \\cfrac{x^2}{2!} + \\cfrac{x^3}{3!} + \\cdots$，收敛半径 $R = \\infty$\n\n当 $x = 1$ 时，有 $e = 1 + 1 + \\cfrac{1}{2!} + \\cfrac{1}{3!} + \\cdots$\n\n#### 2. $\\frac{1}{1 + x}$\n\n与几何级数非常类似，可求得\n\n$1 - x + x^2 - x^3 + \\cdots = \\cfrac{1}{1 + x}$，收敛半径 $R = 1$\n\n#### 3. $\\sin x$\n\n$f(x) = \\sin x$，$f'(x) = \\cos x$，$f''(x) = - \\sin x$，依次类推，可求得 $a\\_0 = 0$，$a\\_1 = 1$，$a\\_2 = 0$，$a\\_3 = -1$，$a\\_4 = 0$，每四项一循环。\n\n所以 $\\sin x = x - \\cfrac{x^3}{3!} + \\cfrac{x^5}{5!} - \\cfrac{x^7}{7!} + \\cdots$，收敛半径 $R = \\infty$\n\n## 幂级展开式的性质\n\n### 乘积\n\n$x\\sin x = x^2 - \\cfrac{x^4}{3!} + \\cfrac{x^6}{5!} - cfrac{x^8}{7!} + \\cdots$，收敛半径等于较小的那个，$R = \\infty$\n\n### 求导\n\n因为 $\\cos x = \\sin' x$，而 $\\sin x$ 的幂级展开式已经在上面求出。\n\n则 $\\cos x = 1 - \\cfrac{x^2}{2!} + \\cfrac{x^4}{4!} - \\cfrac{x^6}{6!} + \\cdots$，收敛半径不变，$R = \\infty$\n\n### 积分\n\n$$\n\\begin{align}\n\\ln (1 + x) = \\int\\_0^x\\cfrac{dt}{1 + t} &= \\int\\_0^x(1 - t + t^2 - t^3 + \\cdots)dt \\\\\\\n&= \\left[ t - \\cfrac{t^2}{2} + \\cfrac{t^3}{3} - \\cfrac{t^4}{4} + \\cdots \\right]\\_0^x \\\\\\\n&= x - \\cfrac{x^2}{2} + \\cfrac{x^3}{3} - \\cfrac{x^4}{4} + \\cdots\n\\end{align}\n$$\n\n收敛半径 $R = 1$。\n\n### 变量替换\n\n求 $e^{-t^2}$，令 $x = -t^2$\n\n$$\n\\begin{align}\ne^{-t^2} &= 1 + (-t^2) + \\cfrac{(-t^2)^2}{2!} + \\cfrac{(-t^2)^3}{3!} + \\cdots \\\\\\\n&= 1 - t^2 + \\cfrac{t^4}{2!} - \\cfrac{t^6}{3!} + \\cdots\n\\end{align}\n$$\n","source":"_posts/power-series.md","raw":"---\ntitle: 幂级数\ndate: 2017-03-25 08:44:25\ntags: [单变量微积分]\n---\n\n幂级数的形式为 $a\\_0 + a\\_1x + a\\_2x^2 + \\cdots$，记为 $\\sum\\_{n = 0}^{\\infty}a\\_nx^n$。\n\n<!-- more -->\n\n## 幂级数的收敛性\n\n设 $S\\_N = \\sum\\_{n = 0}^{N}a\\_nx^n$，幂级数之和即 $S = \\sum\\_{n = 0}^{\\infty}a\\_nx^n = \\lim\\_{N to \\infty}S\\_N$，当极限存在时，幂级数收敛，极限不存在，幂级数发散。\n\n若 $|x| < R$ 时，幂级数收敛，则称 R 为幂级数的 **收敛半径**。\n\n### 几何级数\n\n当 $a\\_0 = a\\_2 = a\\_3 = \\cdots = 1$ 时，幂级数 $1 + x + x^2 + x^3 + \\cdots$ 可以看做公比为 x 的几何级数。\n\n$$\n\\begin{align}\nS &= 1 + x + x^2 + x^3 + \\cdots \\\\\\\nS \\cdot x &= x + x^2 + x^3 + x^4 + \\cdots \\\\\\\nS - S \\cdot x &= 1 \\\\\\\nS &= \\cfrac{1}{1 - x}\n\\end{align}\n$$\n\n前提是 S 是存在的，如果 $x > 1$，S 趋近于无穷大，就得不到上式了，所以几何级数的收敛半径为 1.\n\n## 泰勒公式\n\n通过泰勒公式可以将函数转化为幂级数展开式。\n\n泰勒公式的一般形式为\n\n$$\nf(x) = \\sum\\_{n = 0}^{\\infty}\\cfrac{f^{(n)}(0)}{n!}x^n\n$$\n\n一般地，$a\\_n = \\cfrac{f^{(n)}(0)}{n!}$\n\n### 栗子\n\n#### 1. $e^x$\n\n因为 $f(x) = e^x$，则 $f^{(n)}(x) = e^x$，$f^{(n)}(0) = 1$\n\n所以 $e^x = \\sum\\_{n = 0}^{\\infty}\\cfrac{1}{n!}x^n = 1 + x + \\cfrac{x^2}{2!} + \\cfrac{x^3}{3!} + \\cdots$，收敛半径 $R = \\infty$\n\n当 $x = 1$ 时，有 $e = 1 + 1 + \\cfrac{1}{2!} + \\cfrac{1}{3!} + \\cdots$\n\n#### 2. $\\frac{1}{1 + x}$\n\n与几何级数非常类似，可求得\n\n$1 - x + x^2 - x^3 + \\cdots = \\cfrac{1}{1 + x}$，收敛半径 $R = 1$\n\n#### 3. $\\sin x$\n\n$f(x) = \\sin x$，$f'(x) = \\cos x$，$f''(x) = - \\sin x$，依次类推，可求得 $a\\_0 = 0$，$a\\_1 = 1$，$a\\_2 = 0$，$a\\_3 = -1$，$a\\_4 = 0$，每四项一循环。\n\n所以 $\\sin x = x - \\cfrac{x^3}{3!} + \\cfrac{x^5}{5!} - \\cfrac{x^7}{7!} + \\cdots$，收敛半径 $R = \\infty$\n\n## 幂级展开式的性质\n\n### 乘积\n\n$x\\sin x = x^2 - \\cfrac{x^4}{3!} + \\cfrac{x^6}{5!} - cfrac{x^8}{7!} + \\cdots$，收敛半径等于较小的那个，$R = \\infty$\n\n### 求导\n\n因为 $\\cos x = \\sin' x$，而 $\\sin x$ 的幂级展开式已经在上面求出。\n\n则 $\\cos x = 1 - \\cfrac{x^2}{2!} + \\cfrac{x^4}{4!} - \\cfrac{x^6}{6!} + \\cdots$，收敛半径不变，$R = \\infty$\n\n### 积分\n\n$$\n\\begin{align}\n\\ln (1 + x) = \\int\\_0^x\\cfrac{dt}{1 + t} &= \\int\\_0^x(1 - t + t^2 - t^3 + \\cdots)dt \\\\\\\n&= \\left[ t - \\cfrac{t^2}{2} + \\cfrac{t^3}{3} - \\cfrac{t^4}{4} + \\cdots \\right]\\_0^x \\\\\\\n&= x - \\cfrac{x^2}{2} + \\cfrac{x^3}{3} - \\cfrac{x^4}{4} + \\cdots\n\\end{align}\n$$\n\n收敛半径 $R = 1$。\n\n### 变量替换\n\n求 $e^{-t^2}$，令 $x = -t^2$\n\n$$\n\\begin{align}\ne^{-t^2} &= 1 + (-t^2) + \\cfrac{(-t^2)^2}{2!} + \\cfrac{(-t^2)^3}{3!} + \\cdots \\\\\\\n&= 1 - t^2 + \\cfrac{t^4}{2!} - \\cfrac{t^6}{3!} + \\cdots\n\\end{align}\n$$\n","slug":"power-series","published":1,"updated":"2017-03-25T01:41:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcwm0023n927hjygjztg","content":"<p>幂级数的形式为 $a_0 + a_1x + a_2x^2 + \\cdots$，记为 $\\sum_{n = 0}^{\\infty}a_nx^n$。</p>\n<a id=\"more\"></a>\n<h2 id=\"幂级数的收敛性\"><a href=\"#幂级数的收敛性\" class=\"headerlink\" title=\"幂级数的收敛性\"></a>幂级数的收敛性</h2><p>设 $S_N = \\sum_{n = 0}^{N}a_nx^n$，幂级数之和即 $S = \\sum_{n = 0}^{\\infty}a_nx^n = \\lim_{N to \\infty}S_N$，当极限存在时，幂级数收敛，极限不存在，幂级数发散。</p>\n<p>若 $|x| &lt; R$ 时，幂级数收敛，则称 R 为幂级数的 <strong>收敛半径</strong>。</p>\n<h3 id=\"几何级数\"><a href=\"#几何级数\" class=\"headerlink\" title=\"几何级数\"></a>几何级数</h3><p>当 $a_0 = a_2 = a_3 = \\cdots = 1$ 时，幂级数 $1 + x + x^2 + x^3 + \\cdots$ 可以看做公比为 x 的几何级数。</p>\n<p>$$<br>\\begin{align}<br>S &amp;= 1 + x + x^2 + x^3 + \\cdots \\\\<br>S \\cdot x &amp;= x + x^2 + x^3 + x^4 + \\cdots \\\\<br>S - S \\cdot x &amp;= 1 \\\\<br>S &amp;= \\cfrac{1}{1 - x}<br>\\end{align}<br>$$</p>\n<p>前提是 S 是存在的，如果 $x &gt; 1$，S 趋近于无穷大，就得不到上式了，所以几何级数的收敛半径为 1.</p>\n<h2 id=\"泰勒公式\"><a href=\"#泰勒公式\" class=\"headerlink\" title=\"泰勒公式\"></a>泰勒公式</h2><p>通过泰勒公式可以将函数转化为幂级数展开式。</p>\n<p>泰勒公式的一般形式为</p>\n<p>$$<br>f(x) = \\sum_{n = 0}^{\\infty}\\cfrac{f^{(n)}(0)}{n!}x^n<br>$$</p>\n<p>一般地，$a_n = \\cfrac{f^{(n)}(0)}{n!}$</p>\n<h3 id=\"栗子\"><a href=\"#栗子\" class=\"headerlink\" title=\"栗子\"></a>栗子</h3><h4 id=\"1-e-x\"><a href=\"#1-e-x\" class=\"headerlink\" title=\"1. $e^x$\"></a>1. $e^x$</h4><p>因为 $f(x) = e^x$，则 $f^{(n)}(x) = e^x$，$f^{(n)}(0) = 1$</p>\n<p>所以 $e^x = \\sum_{n = 0}^{\\infty}\\cfrac{1}{n!}x^n = 1 + x + \\cfrac{x^2}{2!} + \\cfrac{x^3}{3!} + \\cdots$，收敛半径 $R = \\infty$</p>\n<p>当 $x = 1$ 时，有 $e = 1 + 1 + \\cfrac{1}{2!} + \\cfrac{1}{3!} + \\cdots$</p>\n<h4 id=\"2-frac-1-1-x\"><a href=\"#2-frac-1-1-x\" class=\"headerlink\" title=\"2. $\\frac{1}{1 + x}$\"></a>2. $\\frac{1}{1 + x}$</h4><p>与几何级数非常类似，可求得</p>\n<p>$1 - x + x^2 - x^3 + \\cdots = \\cfrac{1}{1 + x}$，收敛半径 $R = 1$</p>\n<h4 id=\"3-sin-x\"><a href=\"#3-sin-x\" class=\"headerlink\" title=\"3. $\\sin x$\"></a>3. $\\sin x$</h4><p>$f(x) = \\sin x$，$f’(x) = \\cos x$，$f’’(x) = - \\sin x$，依次类推，可求得 $a_0 = 0$，$a_1 = 1$，$a_2 = 0$，$a_3 = -1$，$a_4 = 0$，每四项一循环。</p>\n<p>所以 $\\sin x = x - \\cfrac{x^3}{3!} + \\cfrac{x^5}{5!} - \\cfrac{x^7}{7!} + \\cdots$，收敛半径 $R = \\infty$</p>\n<h2 id=\"幂级展开式的性质\"><a href=\"#幂级展开式的性质\" class=\"headerlink\" title=\"幂级展开式的性质\"></a>幂级展开式的性质</h2><h3 id=\"乘积\"><a href=\"#乘积\" class=\"headerlink\" title=\"乘积\"></a>乘积</h3><p>$x\\sin x = x^2 - \\cfrac{x^4}{3!} + \\cfrac{x^6}{5!} - cfrac{x^8}{7!} + \\cdots$，收敛半径等于较小的那个，$R = \\infty$</p>\n<h3 id=\"求导\"><a href=\"#求导\" class=\"headerlink\" title=\"求导\"></a>求导</h3><p>因为 $\\cos x = \\sin’ x$，而 $\\sin x$ 的幂级展开式已经在上面求出。</p>\n<p>则 $\\cos x = 1 - \\cfrac{x^2}{2!} + \\cfrac{x^4}{4!} - \\cfrac{x^6}{6!} + \\cdots$，收敛半径不变，$R = \\infty$</p>\n<h3 id=\"积分\"><a href=\"#积分\" class=\"headerlink\" title=\"积分\"></a>积分</h3><p>$$<br>\\begin{align}<br>\\ln (1 + x) = \\int_0^x\\cfrac{dt}{1 + t} &amp;= \\int_0^x(1 - t + t^2 - t^3 + \\cdots)dt \\\\<br>&amp;= \\left[ t - \\cfrac{t^2}{2} + \\cfrac{t^3}{3} - \\cfrac{t^4}{4} + \\cdots \\right]_0^x \\\\<br>&amp;= x - \\cfrac{x^2}{2} + \\cfrac{x^3}{3} - \\cfrac{x^4}{4} + \\cdots<br>\\end{align}<br>$$</p>\n<p>收敛半径 $R = 1$。</p>\n<h3 id=\"变量替换\"><a href=\"#变量替换\" class=\"headerlink\" title=\"变量替换\"></a>变量替换</h3><p>求 $e^{-t^2}$，令 $x = -t^2$</p>\n<p>$$<br>\\begin{align}<br>e^{-t^2} &amp;= 1 + (-t^2) + \\cfrac{(-t^2)^2}{2!} + \\cfrac{(-t^2)^3}{3!} + \\cdots \\\\<br>&amp;= 1 - t^2 + \\cfrac{t^4}{2!} - \\cfrac{t^6}{3!} + \\cdots<br>\\end{align}<br>$$</p>\n","excerpt":"<p>幂级数的形式为 $a_0 + a_1x + a_2x^2 + \\cdots$，记为 $\\sum_{n = 0}^{\\infty}a_nx^n$。</p>","more":"<h2 id=\"幂级数的收敛性\"><a href=\"#幂级数的收敛性\" class=\"headerlink\" title=\"幂级数的收敛性\"></a>幂级数的收敛性</h2><p>设 $S_N = \\sum_{n = 0}^{N}a_nx^n$，幂级数之和即 $S = \\sum_{n = 0}^{\\infty}a_nx^n = \\lim_{N to \\infty}S_N$，当极限存在时，幂级数收敛，极限不存在，幂级数发散。</p>\n<p>若 $|x| &lt; R$ 时，幂级数收敛，则称 R 为幂级数的 <strong>收敛半径</strong>。</p>\n<h3 id=\"几何级数\"><a href=\"#几何级数\" class=\"headerlink\" title=\"几何级数\"></a>几何级数</h3><p>当 $a_0 = a_2 = a_3 = \\cdots = 1$ 时，幂级数 $1 + x + x^2 + x^3 + \\cdots$ 可以看做公比为 x 的几何级数。</p>\n<p>$$<br>\\begin{align}<br>S &amp;= 1 + x + x^2 + x^3 + \\cdots \\\\<br>S \\cdot x &amp;= x + x^2 + x^3 + x^4 + \\cdots \\\\<br>S - S \\cdot x &amp;= 1 \\\\<br>S &amp;= \\cfrac{1}{1 - x}<br>\\end{align}<br>$$</p>\n<p>前提是 S 是存在的，如果 $x &gt; 1$，S 趋近于无穷大，就得不到上式了，所以几何级数的收敛半径为 1.</p>\n<h2 id=\"泰勒公式\"><a href=\"#泰勒公式\" class=\"headerlink\" title=\"泰勒公式\"></a>泰勒公式</h2><p>通过泰勒公式可以将函数转化为幂级数展开式。</p>\n<p>泰勒公式的一般形式为</p>\n<p>$$<br>f(x) = \\sum_{n = 0}^{\\infty}\\cfrac{f^{(n)}(0)}{n!}x^n<br>$$</p>\n<p>一般地，$a_n = \\cfrac{f^{(n)}(0)}{n!}$</p>\n<h3 id=\"栗子\"><a href=\"#栗子\" class=\"headerlink\" title=\"栗子\"></a>栗子</h3><h4 id=\"1-e-x\"><a href=\"#1-e-x\" class=\"headerlink\" title=\"1. $e^x$\"></a>1. $e^x$</h4><p>因为 $f(x) = e^x$，则 $f^{(n)}(x) = e^x$，$f^{(n)}(0) = 1$</p>\n<p>所以 $e^x = \\sum_{n = 0}^{\\infty}\\cfrac{1}{n!}x^n = 1 + x + \\cfrac{x^2}{2!} + \\cfrac{x^3}{3!} + \\cdots$，收敛半径 $R = \\infty$</p>\n<p>当 $x = 1$ 时，有 $e = 1 + 1 + \\cfrac{1}{2!} + \\cfrac{1}{3!} + \\cdots$</p>\n<h4 id=\"2-frac-1-1-x\"><a href=\"#2-frac-1-1-x\" class=\"headerlink\" title=\"2. $\\frac{1}{1 + x}$\"></a>2. $\\frac{1}{1 + x}$</h4><p>与几何级数非常类似，可求得</p>\n<p>$1 - x + x^2 - x^3 + \\cdots = \\cfrac{1}{1 + x}$，收敛半径 $R = 1$</p>\n<h4 id=\"3-sin-x\"><a href=\"#3-sin-x\" class=\"headerlink\" title=\"3. $\\sin x$\"></a>3. $\\sin x$</h4><p>$f(x) = \\sin x$，$f’(x) = \\cos x$，$f’’(x) = - \\sin x$，依次类推，可求得 $a_0 = 0$，$a_1 = 1$，$a_2 = 0$，$a_3 = -1$，$a_4 = 0$，每四项一循环。</p>\n<p>所以 $\\sin x = x - \\cfrac{x^3}{3!} + \\cfrac{x^5}{5!} - \\cfrac{x^7}{7!} + \\cdots$，收敛半径 $R = \\infty$</p>\n<h2 id=\"幂级展开式的性质\"><a href=\"#幂级展开式的性质\" class=\"headerlink\" title=\"幂级展开式的性质\"></a>幂级展开式的性质</h2><h3 id=\"乘积\"><a href=\"#乘积\" class=\"headerlink\" title=\"乘积\"></a>乘积</h3><p>$x\\sin x = x^2 - \\cfrac{x^4}{3!} + \\cfrac{x^6}{5!} - cfrac{x^8}{7!} + \\cdots$，收敛半径等于较小的那个，$R = \\infty$</p>\n<h3 id=\"求导\"><a href=\"#求导\" class=\"headerlink\" title=\"求导\"></a>求导</h3><p>因为 $\\cos x = \\sin’ x$，而 $\\sin x$ 的幂级展开式已经在上面求出。</p>\n<p>则 $\\cos x = 1 - \\cfrac{x^2}{2!} + \\cfrac{x^4}{4!} - \\cfrac{x^6}{6!} + \\cdots$，收敛半径不变，$R = \\infty$</p>\n<h3 id=\"积分\"><a href=\"#积分\" class=\"headerlink\" title=\"积分\"></a>积分</h3><p>$$<br>\\begin{align}<br>\\ln (1 + x) = \\int_0^x\\cfrac{dt}{1 + t} &amp;= \\int_0^x(1 - t + t^2 - t^3 + \\cdots)dt \\\\<br>&amp;= \\left[ t - \\cfrac{t^2}{2} + \\cfrac{t^3}{3} - \\cfrac{t^4}{4} + \\cdots \\right]_0^x \\\\<br>&amp;= x - \\cfrac{x^2}{2} + \\cfrac{x^3}{3} - \\cfrac{x^4}{4} + \\cdots<br>\\end{align}<br>$$</p>\n<p>收敛半径 $R = 1$。</p>\n<h3 id=\"变量替换\"><a href=\"#变量替换\" class=\"headerlink\" title=\"变量替换\"></a>变量替换</h3><p>求 $e^{-t^2}$，令 $x = -t^2$</p>\n<p>$$<br>\\begin{align}<br>e^{-t^2} &amp;= 1 + (-t^2) + \\cfrac{(-t^2)^2}{2!} + \\cfrac{(-t^2)^3}{3!} + \\cdots \\\\<br>&amp;= 1 - t^2 + \\cfrac{t^4}{2!} - \\cfrac{t^6}{3!} + \\cdots<br>\\end{align}<br>$$</p>"},{"title":"线性近似和二阶近似","date":"2017-03-12T01:45:00.000Z","_content":"\n线性近似和二阶近似是导数的重要应用之一，通过近似能够简化函数。一个合理的近似常常可以帮助解决问题。\n\n<!-- more -->\n\n## 线性近似\n\n线性近似也就是一阶近似，通过直线来拟合函数。如在 $f(x) = \\sin x$ 中，当 $x$ 无限接近 0 时，此时 $\\sin x$ 的图像近似于 $\\sin x$ 在 $x = 0$ 处的切线，即:\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/linear-and-quadratic-approximation/1.png)\n\n根据导数的定义\n\n$$\n\\begin{align}\n\\lim\\_{\\Delta x \\to 0}\\frac{\\Delta f}{\\Delta x} &= f'(x\\_0) \\\\\\\n\\frac{\\Delta f}{\\Delta x} &\\approx f'(x\\_0) \\\\\\\n\\Delta f &\\approx f'(x\\_0) \\cdot \\Delta x \\\\\\\nf(x) - f(x\\_0) &\\approx f'(x\\_0) \\cdot (x - x\\_0) \\\\\\\nf(x) &\\approx f(x\\_0) + f'(x\\_0) \\cdot (x - x\\_0)\n\\end{align}\n$$\n\n所以，线性近似的公式为:\n\n$$\n当 x \\approx x\\_0 时，f(x) \\approx f(x\\_0) + f'(x\\_0)(x - x\\_0)\n$$\n\n### 常见函数的线性近似\n\n**当 $x \\approx 1$ 时，**\n\n$$\n\\ln x \\approx \\ln 1 + \\cfrac{1}{1}(x - 1) = x - 1\n$$\n\n**当 $x \\approx 0$ 时，**\n\n$$\n\\begin{align}\n\\sin x &\\approx \\sin 0 + \\cos 0 \\cdot x = x \\\\\\\n\\cos x &\\approx \\cos 0 - \\sin 0 \\cdot x = 1 \\\\\\\ne^x &\\approx e^0 + e^0 \\cdot x = x + 1 \\\\\\\n\\ln (1 + x) &\\approx \\ln (1 + 0) + \\cfrac{1}{1 + 0} \\cdot x = x \\\\\\\n(1 + x)^r &\\approx (1 + 0)^r + r \\cdot (1 + 0)^{r - 1} \\cdot x = rx + 1\n\\end{align}\n$$\n\n需要注意的是，因为线性近似是使用直线拟合，所以求线性近似时，需要在得到的结果中需要舍弃高次项（大于 1 次的项）。\n\n### 栗子\n\n求 $\\cfrac{e^{-3x}}{\\sqrt{1 + x}}$ 在 $x \\approx 0$ 时的线性近似。\n\n$$\n\\begin{align}\n\\cfrac{e^{-3x}}{\\sqrt{1 + x}} &= e^{-3x} \\cdot (1 + x)^{\\cfrac{1}{2}} \\\\\\\n&\\approx (1 - 3x)(\\frac{1}{2}x + 1) \\\\\\\n&= 1 - \\frac{7}{2}x + \\frac{3}{2} x^2 \\\\\\\n&\\approx 1 - \\frac{7}{2}x\n\\end{align}\n$$\n\n## 二阶近似\n\n二阶近似比线性近似更精确一点，在线性近似精确度不够的时候使用\n\n$$\nf(x) \\approx f(x\\_0) + f'(x\\_0)(x - x\\_0) + \\cfrac{f''(x\\_0)}{2}(x - x\\_0)^2\n$$\n\n可以看出，二阶近似实际上是一阶近似 + $\\cfrac{f''(x\\_0)}{2}(x - x\\_0)^2$\n\n### 为什么二阶导数要除 2？\n\n对于抛物线来讲，二阶近似就是它本身\n\n设有抛物线 $f(x) = a + bx + cx^2$，那么它的线性近似函数也为 $f(x) = a + bx + cx^2$。\n\n而 $f(0) = a$，$f'(0) = b$，$f''(0) = 2c$\n\n所以 $a = f(0)$，$b = f'(0)$，$c = \\cfrac{f''(0)}{2}$\n\n### 常见函数的二阶近似\n\n**当 $x \\approx 0$ 时，**\n\n$$\n\\begin{align}\n\\sin x &\\approx x + \\cfrac{-\\sin 0}{2}x^2 = x \\\\\\\n\\cos x &\\approx 1 + \\cfrac{-\\cos 0}{2}x^2 = 1 - \\cfrac{1}{2}x^2 \\\\\\\ne^x &\\approx x + 1 + \\cfrac{e^0}{2}x^2 = 1 + x + \\cfrac{1}{2}x^2 \\\\\\\n\\ln (1 + x) &\\approx x + \\cfrac{-(1 + 0)^{-2}}{2}x^2 = x - \\cfrac{1}{2}x^2 \\\\\\\n(1 + x)^r &\\approx 1 + rx + \\cfrac{r(r - 1)(1 + 0)^{r - 2}}{2}x^2 = 1 + rx + \\cfrac{r(r - 1)}{2}x^2\n\\end{align}\n$$\n\n同样地，求二阶近似时，需要在得到的结果中需要舍弃大于 2 次的项。\n\n### 几何意义\n\n对高阶函数来说，二阶近似相比一阶近似更逼近原函数\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/linear-and-quadratic-approximation/2.png)\n","source":"_posts/linear-and-quadratic-approximation.md","raw":"---\ntitle: 线性近似和二阶近似\ndate: 2017-03-12 09:45:00\ntags: [单变量微积分]\n---\n\n线性近似和二阶近似是导数的重要应用之一，通过近似能够简化函数。一个合理的近似常常可以帮助解决问题。\n\n<!-- more -->\n\n## 线性近似\n\n线性近似也就是一阶近似，通过直线来拟合函数。如在 $f(x) = \\sin x$ 中，当 $x$ 无限接近 0 时，此时 $\\sin x$ 的图像近似于 $\\sin x$ 在 $x = 0$ 处的切线，即:\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/linear-and-quadratic-approximation/1.png)\n\n根据导数的定义\n\n$$\n\\begin{align}\n\\lim\\_{\\Delta x \\to 0}\\frac{\\Delta f}{\\Delta x} &= f'(x\\_0) \\\\\\\n\\frac{\\Delta f}{\\Delta x} &\\approx f'(x\\_0) \\\\\\\n\\Delta f &\\approx f'(x\\_0) \\cdot \\Delta x \\\\\\\nf(x) - f(x\\_0) &\\approx f'(x\\_0) \\cdot (x - x\\_0) \\\\\\\nf(x) &\\approx f(x\\_0) + f'(x\\_0) \\cdot (x - x\\_0)\n\\end{align}\n$$\n\n所以，线性近似的公式为:\n\n$$\n当 x \\approx x\\_0 时，f(x) \\approx f(x\\_0) + f'(x\\_0)(x - x\\_0)\n$$\n\n### 常见函数的线性近似\n\n**当 $x \\approx 1$ 时，**\n\n$$\n\\ln x \\approx \\ln 1 + \\cfrac{1}{1}(x - 1) = x - 1\n$$\n\n**当 $x \\approx 0$ 时，**\n\n$$\n\\begin{align}\n\\sin x &\\approx \\sin 0 + \\cos 0 \\cdot x = x \\\\\\\n\\cos x &\\approx \\cos 0 - \\sin 0 \\cdot x = 1 \\\\\\\ne^x &\\approx e^0 + e^0 \\cdot x = x + 1 \\\\\\\n\\ln (1 + x) &\\approx \\ln (1 + 0) + \\cfrac{1}{1 + 0} \\cdot x = x \\\\\\\n(1 + x)^r &\\approx (1 + 0)^r + r \\cdot (1 + 0)^{r - 1} \\cdot x = rx + 1\n\\end{align}\n$$\n\n需要注意的是，因为线性近似是使用直线拟合，所以求线性近似时，需要在得到的结果中需要舍弃高次项（大于 1 次的项）。\n\n### 栗子\n\n求 $\\cfrac{e^{-3x}}{\\sqrt{1 + x}}$ 在 $x \\approx 0$ 时的线性近似。\n\n$$\n\\begin{align}\n\\cfrac{e^{-3x}}{\\sqrt{1 + x}} &= e^{-3x} \\cdot (1 + x)^{\\cfrac{1}{2}} \\\\\\\n&\\approx (1 - 3x)(\\frac{1}{2}x + 1) \\\\\\\n&= 1 - \\frac{7}{2}x + \\frac{3}{2} x^2 \\\\\\\n&\\approx 1 - \\frac{7}{2}x\n\\end{align}\n$$\n\n## 二阶近似\n\n二阶近似比线性近似更精确一点，在线性近似精确度不够的时候使用\n\n$$\nf(x) \\approx f(x\\_0) + f'(x\\_0)(x - x\\_0) + \\cfrac{f''(x\\_0)}{2}(x - x\\_0)^2\n$$\n\n可以看出，二阶近似实际上是一阶近似 + $\\cfrac{f''(x\\_0)}{2}(x - x\\_0)^2$\n\n### 为什么二阶导数要除 2？\n\n对于抛物线来讲，二阶近似就是它本身\n\n设有抛物线 $f(x) = a + bx + cx^2$，那么它的线性近似函数也为 $f(x) = a + bx + cx^2$。\n\n而 $f(0) = a$，$f'(0) = b$，$f''(0) = 2c$\n\n所以 $a = f(0)$，$b = f'(0)$，$c = \\cfrac{f''(0)}{2}$\n\n### 常见函数的二阶近似\n\n**当 $x \\approx 0$ 时，**\n\n$$\n\\begin{align}\n\\sin x &\\approx x + \\cfrac{-\\sin 0}{2}x^2 = x \\\\\\\n\\cos x &\\approx 1 + \\cfrac{-\\cos 0}{2}x^2 = 1 - \\cfrac{1}{2}x^2 \\\\\\\ne^x &\\approx x + 1 + \\cfrac{e^0}{2}x^2 = 1 + x + \\cfrac{1}{2}x^2 \\\\\\\n\\ln (1 + x) &\\approx x + \\cfrac{-(1 + 0)^{-2}}{2}x^2 = x - \\cfrac{1}{2}x^2 \\\\\\\n(1 + x)^r &\\approx 1 + rx + \\cfrac{r(r - 1)(1 + 0)^{r - 2}}{2}x^2 = 1 + rx + \\cfrac{r(r - 1)}{2}x^2\n\\end{align}\n$$\n\n同样地，求二阶近似时，需要在得到的结果中需要舍弃大于 2 次的项。\n\n### 几何意义\n\n对高阶函数来说，二阶近似相比一阶近似更逼近原函数\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/linear-and-quadratic-approximation/2.png)\n","slug":"linear-and-quadratic-approximation","published":1,"updated":"2017-03-12T03:05:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcwo0025n927t3c3vn08","content":"<p>线性近似和二阶近似是导数的重要应用之一，通过近似能够简化函数。一个合理的近似常常可以帮助解决问题。</p>\n<a id=\"more\"></a>\n<h2 id=\"线性近似\"><a href=\"#线性近似\" class=\"headerlink\" title=\"线性近似\"></a>线性近似</h2><p>线性近似也就是一阶近似，通过直线来拟合函数。如在 $f(x) = \\sin x$ 中，当 $x$ 无限接近 0 时，此时 $\\sin x$ 的图像近似于 $\\sin x$ 在 $x = 0$ 处的切线，即:</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/linear-and-quadratic-approximation/1.png\" alt=\"\"></p>\n<p>根据导数的定义</p>\n<p>$$<br>\\begin{align}<br>\\lim_{\\Delta x \\to 0}\\frac{\\Delta f}{\\Delta x} &amp;= f’(x_0) \\\\<br>\\frac{\\Delta f}{\\Delta x} &amp;\\approx f’(x_0) \\\\<br>\\Delta f &amp;\\approx f’(x_0) \\cdot \\Delta x \\\\<br>f(x) - f(x_0) &amp;\\approx f’(x_0) \\cdot (x - x_0) \\\\<br>f(x) &amp;\\approx f(x_0) + f’(x_0) \\cdot (x - x_0)<br>\\end{align}<br>$$</p>\n<p>所以，线性近似的公式为:</p>\n<p>$$<br>当 x \\approx x_0 时，f(x) \\approx f(x_0) + f’(x_0)(x - x_0)<br>$$</p>\n<h3 id=\"常见函数的线性近似\"><a href=\"#常见函数的线性近似\" class=\"headerlink\" title=\"常见函数的线性近似\"></a>常见函数的线性近似</h3><p><strong>当 $x \\approx 1$ 时，</strong></p>\n<p>$$<br>\\ln x \\approx \\ln 1 + \\cfrac{1}{1}(x - 1) = x - 1<br>$$</p>\n<p><strong>当 $x \\approx 0$ 时，</strong></p>\n<p>$$<br>\\begin{align}<br>\\sin x &amp;\\approx \\sin 0 + \\cos 0 \\cdot x = x \\\\<br>\\cos x &amp;\\approx \\cos 0 - \\sin 0 \\cdot x = 1 \\\\<br>e^x &amp;\\approx e^0 + e^0 \\cdot x = x + 1 \\\\<br>\\ln (1 + x) &amp;\\approx \\ln (1 + 0) + \\cfrac{1}{1 + 0} \\cdot x = x \\\\<br>(1 + x)^r &amp;\\approx (1 + 0)^r + r \\cdot (1 + 0)^{r - 1} \\cdot x = rx + 1<br>\\end{align}<br>$$</p>\n<p>需要注意的是，因为线性近似是使用直线拟合，所以求线性近似时，需要在得到的结果中需要舍弃高次项（大于 1 次的项）。</p>\n<h3 id=\"栗子\"><a href=\"#栗子\" class=\"headerlink\" title=\"栗子\"></a>栗子</h3><p>求 $\\cfrac{e^{-3x}}{\\sqrt{1 + x}}$ 在 $x \\approx 0$ 时的线性近似。</p>\n<p>$$<br>\\begin{align}<br>\\cfrac{e^{-3x}}{\\sqrt{1 + x}} &amp;= e^{-3x} \\cdot (1 + x)^{\\cfrac{1}{2}} \\\\<br>&amp;\\approx (1 - 3x)(\\frac{1}{2}x + 1) \\\\<br>&amp;= 1 - \\frac{7}{2}x + \\frac{3}{2} x^2 \\\\<br>&amp;\\approx 1 - \\frac{7}{2}x<br>\\end{align}<br>$$</p>\n<h2 id=\"二阶近似\"><a href=\"#二阶近似\" class=\"headerlink\" title=\"二阶近似\"></a>二阶近似</h2><p>二阶近似比线性近似更精确一点，在线性近似精确度不够的时候使用</p>\n<p>$$<br>f(x) \\approx f(x_0) + f’(x_0)(x - x_0) + \\cfrac{f’’(x_0)}{2}(x - x_0)^2<br>$$</p>\n<p>可以看出，二阶近似实际上是一阶近似 + $\\cfrac{f’’(x_0)}{2}(x - x_0)^2$</p>\n<h3 id=\"为什么二阶导数要除-2？\"><a href=\"#为什么二阶导数要除-2？\" class=\"headerlink\" title=\"为什么二阶导数要除 2？\"></a>为什么二阶导数要除 2？</h3><p>对于抛物线来讲，二阶近似就是它本身</p>\n<p>设有抛物线 $f(x) = a + bx + cx^2$，那么它的线性近似函数也为 $f(x) = a + bx + cx^2$。</p>\n<p>而 $f(0) = a$，$f’(0) = b$，$f’’(0) = 2c$</p>\n<p>所以 $a = f(0)$，$b = f’(0)$，$c = \\cfrac{f’’(0)}{2}$</p>\n<h3 id=\"常见函数的二阶近似\"><a href=\"#常见函数的二阶近似\" class=\"headerlink\" title=\"常见函数的二阶近似\"></a>常见函数的二阶近似</h3><p><strong>当 $x \\approx 0$ 时，</strong></p>\n<p>$$<br>\\begin{align}<br>\\sin x &amp;\\approx x + \\cfrac{-\\sin 0}{2}x^2 = x \\\\<br>\\cos x &amp;\\approx 1 + \\cfrac{-\\cos 0}{2}x^2 = 1 - \\cfrac{1}{2}x^2 \\\\<br>e^x &amp;\\approx x + 1 + \\cfrac{e^0}{2}x^2 = 1 + x + \\cfrac{1}{2}x^2 \\\\<br>\\ln (1 + x) &amp;\\approx x + \\cfrac{-(1 + 0)^{-2}}{2}x^2 = x - \\cfrac{1}{2}x^2 \\\\<br>(1 + x)^r &amp;\\approx 1 + rx + \\cfrac{r(r - 1)(1 + 0)^{r - 2}}{2}x^2 = 1 + rx + \\cfrac{r(r - 1)}{2}x^2<br>\\end{align}<br>$$</p>\n<p>同样地，求二阶近似时，需要在得到的结果中需要舍弃大于 2 次的项。</p>\n<h3 id=\"几何意义\"><a href=\"#几何意义\" class=\"headerlink\" title=\"几何意义\"></a>几何意义</h3><p>对高阶函数来说，二阶近似相比一阶近似更逼近原函数</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/linear-and-quadratic-approximation/2.png\" alt=\"\"></p>\n","excerpt":"<p>线性近似和二阶近似是导数的重要应用之一，通过近似能够简化函数。一个合理的近似常常可以帮助解决问题。</p>","more":"<h2 id=\"线性近似\"><a href=\"#线性近似\" class=\"headerlink\" title=\"线性近似\"></a>线性近似</h2><p>线性近似也就是一阶近似，通过直线来拟合函数。如在 $f(x) = \\sin x$ 中，当 $x$ 无限接近 0 时，此时 $\\sin x$ 的图像近似于 $\\sin x$ 在 $x = 0$ 处的切线，即:</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/linear-and-quadratic-approximation/1.png\" alt=\"\"></p>\n<p>根据导数的定义</p>\n<p>$$<br>\\begin{align}<br>\\lim_{\\Delta x \\to 0}\\frac{\\Delta f}{\\Delta x} &amp;= f’(x_0) \\\\<br>\\frac{\\Delta f}{\\Delta x} &amp;\\approx f’(x_0) \\\\<br>\\Delta f &amp;\\approx f’(x_0) \\cdot \\Delta x \\\\<br>f(x) - f(x_0) &amp;\\approx f’(x_0) \\cdot (x - x_0) \\\\<br>f(x) &amp;\\approx f(x_0) + f’(x_0) \\cdot (x - x_0)<br>\\end{align}<br>$$</p>\n<p>所以，线性近似的公式为:</p>\n<p>$$<br>当 x \\approx x_0 时，f(x) \\approx f(x_0) + f’(x_0)(x - x_0)<br>$$</p>\n<h3 id=\"常见函数的线性近似\"><a href=\"#常见函数的线性近似\" class=\"headerlink\" title=\"常见函数的线性近似\"></a>常见函数的线性近似</h3><p><strong>当 $x \\approx 1$ 时，</strong></p>\n<p>$$<br>\\ln x \\approx \\ln 1 + \\cfrac{1}{1}(x - 1) = x - 1<br>$$</p>\n<p><strong>当 $x \\approx 0$ 时，</strong></p>\n<p>$$<br>\\begin{align}<br>\\sin x &amp;\\approx \\sin 0 + \\cos 0 \\cdot x = x \\\\<br>\\cos x &amp;\\approx \\cos 0 - \\sin 0 \\cdot x = 1 \\\\<br>e^x &amp;\\approx e^0 + e^0 \\cdot x = x + 1 \\\\<br>\\ln (1 + x) &amp;\\approx \\ln (1 + 0) + \\cfrac{1}{1 + 0} \\cdot x = x \\\\<br>(1 + x)^r &amp;\\approx (1 + 0)^r + r \\cdot (1 + 0)^{r - 1} \\cdot x = rx + 1<br>\\end{align}<br>$$</p>\n<p>需要注意的是，因为线性近似是使用直线拟合，所以求线性近似时，需要在得到的结果中需要舍弃高次项（大于 1 次的项）。</p>\n<h3 id=\"栗子\"><a href=\"#栗子\" class=\"headerlink\" title=\"栗子\"></a>栗子</h3><p>求 $\\cfrac{e^{-3x}}{\\sqrt{1 + x}}$ 在 $x \\approx 0$ 时的线性近似。</p>\n<p>$$<br>\\begin{align}<br>\\cfrac{e^{-3x}}{\\sqrt{1 + x}} &amp;= e^{-3x} \\cdot (1 + x)^{\\cfrac{1}{2}} \\\\<br>&amp;\\approx (1 - 3x)(\\frac{1}{2}x + 1) \\\\<br>&amp;= 1 - \\frac{7}{2}x + \\frac{3}{2} x^2 \\\\<br>&amp;\\approx 1 - \\frac{7}{2}x<br>\\end{align}<br>$$</p>\n<h2 id=\"二阶近似\"><a href=\"#二阶近似\" class=\"headerlink\" title=\"二阶近似\"></a>二阶近似</h2><p>二阶近似比线性近似更精确一点，在线性近似精确度不够的时候使用</p>\n<p>$$<br>f(x) \\approx f(x_0) + f’(x_0)(x - x_0) + \\cfrac{f’’(x_0)}{2}(x - x_0)^2<br>$$</p>\n<p>可以看出，二阶近似实际上是一阶近似 + $\\cfrac{f’’(x_0)}{2}(x - x_0)^2$</p>\n<h3 id=\"为什么二阶导数要除-2？\"><a href=\"#为什么二阶导数要除-2？\" class=\"headerlink\" title=\"为什么二阶导数要除 2？\"></a>为什么二阶导数要除 2？</h3><p>对于抛物线来讲，二阶近似就是它本身</p>\n<p>设有抛物线 $f(x) = a + bx + cx^2$，那么它的线性近似函数也为 $f(x) = a + bx + cx^2$。</p>\n<p>而 $f(0) = a$，$f’(0) = b$，$f’’(0) = 2c$</p>\n<p>所以 $a = f(0)$，$b = f’(0)$，$c = \\cfrac{f’’(0)}{2}$</p>\n<h3 id=\"常见函数的二阶近似\"><a href=\"#常见函数的二阶近似\" class=\"headerlink\" title=\"常见函数的二阶近似\"></a>常见函数的二阶近似</h3><p><strong>当 $x \\approx 0$ 时，</strong></p>\n<p>$$<br>\\begin{align}<br>\\sin x &amp;\\approx x + \\cfrac{-\\sin 0}{2}x^2 = x \\\\<br>\\cos x &amp;\\approx 1 + \\cfrac{-\\cos 0}{2}x^2 = 1 - \\cfrac{1}{2}x^2 \\\\<br>e^x &amp;\\approx x + 1 + \\cfrac{e^0}{2}x^2 = 1 + x + \\cfrac{1}{2}x^2 \\\\<br>\\ln (1 + x) &amp;\\approx x + \\cfrac{-(1 + 0)^{-2}}{2}x^2 = x - \\cfrac{1}{2}x^2 \\\\<br>(1 + x)^r &amp;\\approx 1 + rx + \\cfrac{r(r - 1)(1 + 0)^{r - 2}}{2}x^2 = 1 + rx + \\cfrac{r(r - 1)}{2}x^2<br>\\end{align}<br>$$</p>\n<p>同样地，求二阶近似时，需要在得到的结果中需要舍弃大于 2 次的项。</p>\n<h3 id=\"几何意义\"><a href=\"#几何意义\" class=\"headerlink\" title=\"几何意义\"></a>几何意义</h3><p>对高阶函数来说，二阶近似相比一阶近似更逼近原函数</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/linear-and-quadratic-approximation/2.png\" alt=\"\"></p>"},{"title":"牛顿迭代法","date":"2017-03-12T03:08:12.000Z","_content":"\n牛顿迭代法是微积分中最伟大的应用之一。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/newton-iteration-method/1.png)\n\n<!--more-->\n\n如图，在抛物线 $f(x)$ 上取一点 $(x\\_0, y\\_0)$，作切线与 x 轴交于点 $x\\_1$ 处，再作点 $(x\\_1, f(x\\_1))$ 处的切线，与 x 轴交于点 x2 ...\n\n依次类推，$x\\_n$ 将无限趋近于抛物线与 x 轴的交点。\n\n### 推导过程\n\n设 $(x\\_0, y\\_0)$ 处的切线方程为 $y - y\\_0 = m(x - x\\_0)$\n\n那么可求切线与 x 轴的交点 $(x\\_1, 0)$\n\n$$\n\\begin{align}\n-y\\_0 &= m(x\\_1 - x\\_0) \\\\\\\nx\\_1 &= x\\_0 - \\cfrac{y\\_0}{m} \\\\\\\n\\end{align}\n$$\n\n即 $x\\_1 = x\\_0 - \\cfrac{f(x\\_0)}{f'(x\\_0)}$\n\n以此类推下去，牛顿迭代法的公式即\n\n$$\nx\\_{n + 1} = x\\_n - \\cfrac{f(x\\_n)}{f'(x\\_n)}\n$$\n\nn 越大，越接近于真实值。\n\n牛顿迭代法的一个重要用途是误差分析，设误差为 E\n\n$E1 = |x - x\\_1|$\n$E2 = |x - x\\_2|$\n...\n其中 $E\\_{n + 1} \\sim E\\_n^2$\n\n牛顿迭代法的性质很好，但要注意的是\n\n- $|f'|$ 不能太小\n- $|f''|$ 不能太大\n- $x\\_0$ 应选在 x 的附近\n\n比如在上面的例子里，如果 $x\\_0$ 选在了 $x = 0$ 处，那么就永远都求不出 x 了。\n","source":"_posts/newton-iteration-method.md","raw":"---\ntitle: 牛顿迭代法\ndate: 2017-03-12 11:08:12\ntags: [单变量微积分]\n---\n\n牛顿迭代法是微积分中最伟大的应用之一。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/newton-iteration-method/1.png)\n\n<!--more-->\n\n如图，在抛物线 $f(x)$ 上取一点 $(x\\_0, y\\_0)$，作切线与 x 轴交于点 $x\\_1$ 处，再作点 $(x\\_1, f(x\\_1))$ 处的切线，与 x 轴交于点 x2 ...\n\n依次类推，$x\\_n$ 将无限趋近于抛物线与 x 轴的交点。\n\n### 推导过程\n\n设 $(x\\_0, y\\_0)$ 处的切线方程为 $y - y\\_0 = m(x - x\\_0)$\n\n那么可求切线与 x 轴的交点 $(x\\_1, 0)$\n\n$$\n\\begin{align}\n-y\\_0 &= m(x\\_1 - x\\_0) \\\\\\\nx\\_1 &= x\\_0 - \\cfrac{y\\_0}{m} \\\\\\\n\\end{align}\n$$\n\n即 $x\\_1 = x\\_0 - \\cfrac{f(x\\_0)}{f'(x\\_0)}$\n\n以此类推下去，牛顿迭代法的公式即\n\n$$\nx\\_{n + 1} = x\\_n - \\cfrac{f(x\\_n)}{f'(x\\_n)}\n$$\n\nn 越大，越接近于真实值。\n\n牛顿迭代法的一个重要用途是误差分析，设误差为 E\n\n$E1 = |x - x\\_1|$\n$E2 = |x - x\\_2|$\n...\n其中 $E\\_{n + 1} \\sim E\\_n^2$\n\n牛顿迭代法的性质很好，但要注意的是\n\n- $|f'|$ 不能太小\n- $|f''|$ 不能太大\n- $x\\_0$ 应选在 x 的附近\n\n比如在上面的例子里，如果 $x\\_0$ 选在了 $x = 0$ 处，那么就永远都求不出 x 了。\n","slug":"newton-iteration-method","published":1,"updated":"2017-03-12T09:35:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcwq0028n927bwz5ygrv","content":"<p>牛顿迭代法是微积分中最伟大的应用之一。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/newton-iteration-method/1.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>如图，在抛物线 $f(x)$ 上取一点 $(x_0, y_0)$，作切线与 x 轴交于点 $x_1$ 处，再作点 $(x_1, f(x_1))$ 处的切线，与 x 轴交于点 x2 …</p>\n<p>依次类推，$x_n$ 将无限趋近于抛物线与 x 轴的交点。</p>\n<h3 id=\"推导过程\"><a href=\"#推导过程\" class=\"headerlink\" title=\"推导过程\"></a>推导过程</h3><p>设 $(x_0, y_0)$ 处的切线方程为 $y - y_0 = m(x - x_0)$</p>\n<p>那么可求切线与 x 轴的交点 $(x_1, 0)$</p>\n<p>$$<br>\\begin{align}<br>-y_0 &amp;= m(x_1 - x_0) \\\\<br>x_1 &amp;= x_0 - \\cfrac{y_0}{m} \\\\<br>\\end{align}<br>$$</p>\n<p>即 $x_1 = x_0 - \\cfrac{f(x_0)}{f’(x_0)}$</p>\n<p>以此类推下去，牛顿迭代法的公式即</p>\n<p>$$<br>x_{n + 1} = x_n - \\cfrac{f(x_n)}{f’(x_n)}<br>$$</p>\n<p>n 越大，越接近于真实值。</p>\n<p>牛顿迭代法的一个重要用途是误差分析，设误差为 E</p>\n<p>$E1 = |x - x_1|$<br>$E2 = |x - x_2|$<br>…<br>其中 $E_{n + 1} \\sim E_n^2$</p>\n<p>牛顿迭代法的性质很好，但要注意的是</p>\n<ul>\n<li>$|f’|$ 不能太小</li>\n<li>$|f’’|$ 不能太大</li>\n<li>$x_0$ 应选在 x 的附近</li>\n</ul>\n<p>比如在上面的例子里，如果 $x_0$ 选在了 $x = 0$ 处，那么就永远都求不出 x 了。</p>\n","excerpt":"<p>牛顿迭代法是微积分中最伟大的应用之一。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/newton-iteration-method/1.png\" alt=\"\"></p>","more":"<p>如图，在抛物线 $f(x)$ 上取一点 $(x_0, y_0)$，作切线与 x 轴交于点 $x_1$ 处，再作点 $(x_1, f(x_1))$ 处的切线，与 x 轴交于点 x2 …</p>\n<p>依次类推，$x_n$ 将无限趋近于抛物线与 x 轴的交点。</p>\n<h3 id=\"推导过程\"><a href=\"#推导过程\" class=\"headerlink\" title=\"推导过程\"></a>推导过程</h3><p>设 $(x_0, y_0)$ 处的切线方程为 $y - y_0 = m(x - x_0)$</p>\n<p>那么可求切线与 x 轴的交点 $(x_1, 0)$</p>\n<p>$$<br>\\begin{align}<br>-y_0 &amp;= m(x_1 - x_0) \\\\<br>x_1 &amp;= x_0 - \\cfrac{y_0}{m} \\\\<br>\\end{align}<br>$$</p>\n<p>即 $x_1 = x_0 - \\cfrac{f(x_0)}{f’(x_0)}$</p>\n<p>以此类推下去，牛顿迭代法的公式即</p>\n<p>$$<br>x_{n + 1} = x_n - \\cfrac{f(x_n)}{f’(x_n)}<br>$$</p>\n<p>n 越大，越接近于真实值。</p>\n<p>牛顿迭代法的一个重要用途是误差分析，设误差为 E</p>\n<p>$E1 = |x - x_1|$<br>$E2 = |x - x_2|$<br>…<br>其中 $E_{n + 1} \\sim E_n^2$</p>\n<p>牛顿迭代法的性质很好，但要注意的是</p>\n<ul>\n<li>$|f’|$ 不能太小</li>\n<li>$|f’’|$ 不能太大</li>\n<li>$x_0$ 应选在 x 的附近</li>\n</ul>\n<p>比如在上面的例子里，如果 $x_0$ 选在了 $x = 0$ 处，那么就永远都求不出 x 了。</p>"},{"title":"node-canvas 中的中文乱码问题","date":"2016-11-18T11:20:14.000Z","_content":"\n因为有小伙伴说使用 node-canvas 中文乱码，使用上一篇的方法也没能解决，于是我又上网找了一下，发现了这篇文章：[Nodejs图片编辑和中文乱码](http://www.jianshu.com/p/a651258c9135)\n\n虽然原作者是使用的 gm，但他提到了一种解决方案：\n\n<!-- more -->\n\n> 我们来分析下解决乱码的两个条件：\n>\n> 1. 文档utf-8编码：这里utf-8编码是指要求文件的存储编码方式是utf-8，而不是对字符进行utf-8编码（如js中的encodeURI）。通过对IDE或者其他方式确定文件的编码方式，如有问题可自行百度。\n> 2. 指定中文字体库：可以通过 `.font('/Library/Fonts/微软雅黑.ttf') //mac系统下` 或 `.font('/usr/share/fonts/微软雅黑.ttf')  //linux系统下`指定。 font函数的参数是字体在系统中的存储路径。\n>\n> 文／狐尼克朱迪（简书作者）\n> 原文链接：http://www.jianshu.com/p/a651258c9135\n> 著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。\n\n也就是自己下载字体包，然后自行引用。扔一个下载地址：[字体下载](http://ztxz.org/)\n\n于是我马上去 node-canvas 找了一下，非常开心地发现 node-canvas 也提供了这样的方法：[Canvas.registerFont for bundled fonts](https://github.com/Automattic/node-canvas/tree/master/.github#canvasregisterfont-for-bundled-fonts)，使用方法也是大同小异，设置字体路径，然后定义字体即可：\n\n```javascript\n// You need to call it before the Canvas is created\nCanvas.registerFont('comicsans.ttf', {family: 'Comic Sans'});\n\nvar canvas = new Canvas(500, 500),\n  ctx = canvas.getContext('2d');\n\nctx.font = '12px \"Comic Sans\"';\nctx.fillText(250, 10, 'Everyone hates this font :(');\n```\n\n结果一刷新网页发现竟然报了 `Canvas.registerFont is not a function`。一脸懵逼，明明 README 里面是这么写的啊！\n\n又去查了一下，找到了这个 issue：[issue#838](https://github.com/Automattic/node-canvas/issues/838)，大兄弟的问题和我一模一样。\n\n按照他们说的，这个方法在 npm 上还没有，但是 github 这个分支是有的：[https://github.com/chearon/node-canvas#12971f64a66b](https://github.com/chearon/node-canvas#12971f64a66b)\n\n于是我把这个分支 clone 下来，然后把 `require('canvas')` 改成了 `require('../node-canvas')`\n\n运行！Perfect！\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/node-canvas-chinese/01.png)\n\n泪流满面","source":"_posts/node-canvas-chinese.md","raw":"---\ntitle: node-canvas 中的中文乱码问题\ndate: 2016-11-18 19:20:14\ntags: [nodejs]\n---\n\n因为有小伙伴说使用 node-canvas 中文乱码，使用上一篇的方法也没能解决，于是我又上网找了一下，发现了这篇文章：[Nodejs图片编辑和中文乱码](http://www.jianshu.com/p/a651258c9135)\n\n虽然原作者是使用的 gm，但他提到了一种解决方案：\n\n<!-- more -->\n\n> 我们来分析下解决乱码的两个条件：\n>\n> 1. 文档utf-8编码：这里utf-8编码是指要求文件的存储编码方式是utf-8，而不是对字符进行utf-8编码（如js中的encodeURI）。通过对IDE或者其他方式确定文件的编码方式，如有问题可自行百度。\n> 2. 指定中文字体库：可以通过 `.font('/Library/Fonts/微软雅黑.ttf') //mac系统下` 或 `.font('/usr/share/fonts/微软雅黑.ttf')  //linux系统下`指定。 font函数的参数是字体在系统中的存储路径。\n>\n> 文／狐尼克朱迪（简书作者）\n> 原文链接：http://www.jianshu.com/p/a651258c9135\n> 著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。\n\n也就是自己下载字体包，然后自行引用。扔一个下载地址：[字体下载](http://ztxz.org/)\n\n于是我马上去 node-canvas 找了一下，非常开心地发现 node-canvas 也提供了这样的方法：[Canvas.registerFont for bundled fonts](https://github.com/Automattic/node-canvas/tree/master/.github#canvasregisterfont-for-bundled-fonts)，使用方法也是大同小异，设置字体路径，然后定义字体即可：\n\n```javascript\n// You need to call it before the Canvas is created\nCanvas.registerFont('comicsans.ttf', {family: 'Comic Sans'});\n\nvar canvas = new Canvas(500, 500),\n  ctx = canvas.getContext('2d');\n\nctx.font = '12px \"Comic Sans\"';\nctx.fillText(250, 10, 'Everyone hates this font :(');\n```\n\n结果一刷新网页发现竟然报了 `Canvas.registerFont is not a function`。一脸懵逼，明明 README 里面是这么写的啊！\n\n又去查了一下，找到了这个 issue：[issue#838](https://github.com/Automattic/node-canvas/issues/838)，大兄弟的问题和我一模一样。\n\n按照他们说的，这个方法在 npm 上还没有，但是 github 这个分支是有的：[https://github.com/chearon/node-canvas#12971f64a66b](https://github.com/chearon/node-canvas#12971f64a66b)\n\n于是我把这个分支 clone 下来，然后把 `require('canvas')` 改成了 `require('../node-canvas')`\n\n运行！Perfect！\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/node-canvas-chinese/01.png)\n\n泪流满面","slug":"node-canvas-chinese","published":1,"updated":"2017-03-17T14:48:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcws002an927v4o41a0g","content":"<p>因为有小伙伴说使用 node-canvas 中文乱码，使用上一篇的方法也没能解决，于是我又上网找了一下，发现了这篇文章：<a href=\"http://www.jianshu.com/p/a651258c9135\" target=\"_blank\" rel=\"external\">Nodejs图片编辑和中文乱码</a></p>\n<p>虽然原作者是使用的 gm，但他提到了一种解决方案：</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>我们来分析下解决乱码的两个条件：</p>\n<ol>\n<li>文档utf-8编码：这里utf-8编码是指要求文件的存储编码方式是utf-8，而不是对字符进行utf-8编码（如js中的encodeURI）。通过对IDE或者其他方式确定文件的编码方式，如有问题可自行百度。</li>\n<li>指定中文字体库：可以通过 <code>.font(&#39;/Library/Fonts/微软雅黑.ttf&#39;) //mac系统下</code> 或 <code>.font(&#39;/usr/share/fonts/微软雅黑.ttf&#39;)  //linux系统下</code>指定。 font函数的参数是字体在系统中的存储路径。</li>\n</ol>\n<p>文／狐尼克朱迪（简书作者）<br>原文链接：<a href=\"http://www.jianshu.com/p/a651258c9135\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/a651258c9135</a><br>著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。</p>\n</blockquote>\n<p>也就是自己下载字体包，然后自行引用。扔一个下载地址：<a href=\"http://ztxz.org/\" target=\"_blank\" rel=\"external\">字体下载</a></p>\n<p>于是我马上去 node-canvas 找了一下，非常开心地发现 node-canvas 也提供了这样的方法：<a href=\"https://github.com/Automattic/node-canvas/tree/master/.github#canvasregisterfont-for-bundled-fonts\" target=\"_blank\" rel=\"external\">Canvas.registerFont for bundled fonts</a>，使用方法也是大同小异，设置字体路径，然后定义字体即可：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// You need to call it before the Canvas is created</span></div><div class=\"line\">Canvas.registerFont(<span class=\"string\">'comicsans.ttf'</span>, &#123;<span class=\"attr\">family</span>: <span class=\"string\">'Comic Sans'</span>&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> canvas = <span class=\"keyword\">new</span> Canvas(<span class=\"number\">500</span>, <span class=\"number\">500</span>),</div><div class=\"line\">  ctx = canvas.getContext(<span class=\"string\">'2d'</span>);</div><div class=\"line\"></div><div class=\"line\">ctx.font = <span class=\"string\">'12px \"Comic Sans\"'</span>;</div><div class=\"line\">ctx.fillText(<span class=\"number\">250</span>, <span class=\"number\">10</span>, <span class=\"string\">'Everyone hates this font :('</span>);</div></pre></td></tr></table></figure>\n<p>结果一刷新网页发现竟然报了 <code>Canvas.registerFont is not a function</code>。一脸懵逼，明明 README 里面是这么写的啊！</p>\n<p>又去查了一下，找到了这个 issue：<a href=\"https://github.com/Automattic/node-canvas/issues/838\" target=\"_blank\" rel=\"external\">issue#838</a>，大兄弟的问题和我一模一样。</p>\n<p>按照他们说的，这个方法在 npm 上还没有，但是 github 这个分支是有的：<a href=\"https://github.com/chearon/node-canvas#12971f64a66b\" target=\"_blank\" rel=\"external\">https://github.com/chearon/node-canvas#12971f64a66b</a></p>\n<p>于是我把这个分支 clone 下来，然后把 <code>require(&#39;canvas&#39;)</code> 改成了 <code>require(&#39;../node-canvas&#39;)</code></p>\n<p>运行！Perfect！</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/node-canvas-chinese/01.png\" alt=\"\"></p>\n<p>泪流满面</p>\n","excerpt":"<p>因为有小伙伴说使用 node-canvas 中文乱码，使用上一篇的方法也没能解决，于是我又上网找了一下，发现了这篇文章：<a href=\"http://www.jianshu.com/p/a651258c9135\">Nodejs图片编辑和中文乱码</a></p>\n<p>虽然原作者是使用的 gm，但他提到了一种解决方案：</p>","more":"<blockquote>\n<p>我们来分析下解决乱码的两个条件：</p>\n<ol>\n<li>文档utf-8编码：这里utf-8编码是指要求文件的存储编码方式是utf-8，而不是对字符进行utf-8编码（如js中的encodeURI）。通过对IDE或者其他方式确定文件的编码方式，如有问题可自行百度。</li>\n<li>指定中文字体库：可以通过 <code>.font(&#39;/Library/Fonts/微软雅黑.ttf&#39;) //mac系统下</code> 或 <code>.font(&#39;/usr/share/fonts/微软雅黑.ttf&#39;)  //linux系统下</code>指定。 font函数的参数是字体在系统中的存储路径。</li>\n</ol>\n<p>文／狐尼克朱迪（简书作者）<br>原文链接：<a href=\"http://www.jianshu.com/p/a651258c9135\">http://www.jianshu.com/p/a651258c9135</a><br>著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。</p>\n</blockquote>\n<p>也就是自己下载字体包，然后自行引用。扔一个下载地址：<a href=\"http://ztxz.org/\">字体下载</a></p>\n<p>于是我马上去 node-canvas 找了一下，非常开心地发现 node-canvas 也提供了这样的方法：<a href=\"https://github.com/Automattic/node-canvas/tree/master/.github#canvasregisterfont-for-bundled-fonts\">Canvas.registerFont for bundled fonts</a>，使用方法也是大同小异，设置字体路径，然后定义字体即可：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// You need to call it before the Canvas is created</span></div><div class=\"line\">Canvas.registerFont(<span class=\"string\">'comicsans.ttf'</span>, &#123;<span class=\"attr\">family</span>: <span class=\"string\">'Comic Sans'</span>&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> canvas = <span class=\"keyword\">new</span> Canvas(<span class=\"number\">500</span>, <span class=\"number\">500</span>),</div><div class=\"line\">  ctx = canvas.getContext(<span class=\"string\">'2d'</span>);</div><div class=\"line\"></div><div class=\"line\">ctx.font = <span class=\"string\">'12px \"Comic Sans\"'</span>;</div><div class=\"line\">ctx.fillText(<span class=\"number\">250</span>, <span class=\"number\">10</span>, <span class=\"string\">'Everyone hates this font :('</span>);</div></pre></td></tr></table></figure>\n<p>结果一刷新网页发现竟然报了 <code>Canvas.registerFont is not a function</code>。一脸懵逼，明明 README 里面是这么写的啊！</p>\n<p>又去查了一下，找到了这个 issue：<a href=\"https://github.com/Automattic/node-canvas/issues/838\">issue#838</a>，大兄弟的问题和我一模一样。</p>\n<p>按照他们说的，这个方法在 npm 上还没有，但是 github 这个分支是有的：<a href=\"https://github.com/chearon/node-canvas#12971f64a66b\">https://github.com/chearon/node-canvas#12971f64a66b</a></p>\n<p>于是我把这个分支 clone 下来，然后把 <code>require(&#39;canvas&#39;)</code> 改成了 <code>require(&#39;../node-canvas&#39;)</code></p>\n<p>运行！Perfect！</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/node-canvas-chinese/01.png\" alt=\"\"></p>\n<p>泪流满面</p>"},{"title":"反向代理解决跨域问题","date":"2017-05-13T12:58:45.000Z","_content":"\n跨域问题是前端开发中经常会遇到的问题。\n\n后端同学开发好了一些接口并部署到了服务器上，这时他提供给我们的地址是 `10.172.1.1`，而我们在本地开发时，一般都开的是 node 服务，比如 `localhost:3000`，此时使用 ajax 调用远程服务就会出现跨域问题。\n\n解决跨域问题有很多种方法，比如 jsonp，但是我在工作中很少会碰到使用 jsonp 解决跨域问题的场景。\n\n另外一种办法是在服务端设置跨域头 CORS，这是很常见的一种做法，也比较简单，但需要后端同学配合。本文主要探讨的是使用 nginx 配置反向代理来解决跨域问题。\n\n### 配置\n\n首先启动 node 服务，以监听 3000 端口为例。这时访问 `localhost:3000` 为前端页面。\n\n#### 配置 nginx\n\n```nginx\nhttp {\n    server {\n        listen    2199;\n        location / {\n            proxy_set_header  X-Real-IP  $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_pass http://localhost:3000;\n        }\n\n        location ^~ /api/ {\n            proxy_set_header  X-Real-IP  $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_pass http://10.172.1.1;\n        }\n    }\n}\n```\n\n然后访问 `http://localhost:2199`，当后面为 `/api/..` 时，nginx 会转发给 `10.172.1.1`，而其他的非 api 接口，则转发给 node 服务。这样相当于从 `http://localhost:2199` 请求到 `http://localhost:2199/api/`，则解决了跨域问题。\n","source":"_posts/reverse-proxy-to-solve-cross-origin.md","raw":"---\ntitle: 反向代理解决跨域问题\ndate: 2017-05-13 20:58:45\ntags: [nginx]\n---\n\n跨域问题是前端开发中经常会遇到的问题。\n\n后端同学开发好了一些接口并部署到了服务器上，这时他提供给我们的地址是 `10.172.1.1`，而我们在本地开发时，一般都开的是 node 服务，比如 `localhost:3000`，此时使用 ajax 调用远程服务就会出现跨域问题。\n\n解决跨域问题有很多种方法，比如 jsonp，但是我在工作中很少会碰到使用 jsonp 解决跨域问题的场景。\n\n另外一种办法是在服务端设置跨域头 CORS，这是很常见的一种做法，也比较简单，但需要后端同学配合。本文主要探讨的是使用 nginx 配置反向代理来解决跨域问题。\n\n### 配置\n\n首先启动 node 服务，以监听 3000 端口为例。这时访问 `localhost:3000` 为前端页面。\n\n#### 配置 nginx\n\n```nginx\nhttp {\n    server {\n        listen    2199;\n        location / {\n            proxy_set_header  X-Real-IP  $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_pass http://localhost:3000;\n        }\n\n        location ^~ /api/ {\n            proxy_set_header  X-Real-IP  $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_pass http://10.172.1.1;\n        }\n    }\n}\n```\n\n然后访问 `http://localhost:2199`，当后面为 `/api/..` 时，nginx 会转发给 `10.172.1.1`，而其他的非 api 接口，则转发给 node 服务。这样相当于从 `http://localhost:2199` 请求到 `http://localhost:2199/api/`，则解决了跨域问题。\n","slug":"reverse-proxy-to-solve-cross-origin","published":1,"updated":"2017-05-13T13:20:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcwu002dn9275nvxqz4b","content":"<p>跨域问题是前端开发中经常会遇到的问题。</p>\n<p>后端同学开发好了一些接口并部署到了服务器上，这时他提供给我们的地址是 <code>10.172.1.1</code>，而我们在本地开发时，一般都开的是 node 服务，比如 <code>localhost:3000</code>，此时使用 ajax 调用远程服务就会出现跨域问题。</p>\n<p>解决跨域问题有很多种方法，比如 jsonp，但是我在工作中很少会碰到使用 jsonp 解决跨域问题的场景。</p>\n<p>另外一种办法是在服务端设置跨域头 CORS，这是很常见的一种做法，也比较简单，但需要后端同学配合。本文主要探讨的是使用 nginx 配置反向代理来解决跨域问题。</p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>首先启动 node 服务，以监听 3000 端口为例。这时访问 <code>localhost:3000</code> 为前端页面。</p>\n<h4 id=\"配置-nginx\"><a href=\"#配置-nginx\" class=\"headerlink\" title=\"配置 nginx\"></a>配置 nginx</h4><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"section\">http</span> &#123;</div><div class=\"line\">    <span class=\"section\">server</span> &#123;</div><div class=\"line\">        <span class=\"attribute\">listen</span>    <span class=\"number\">2199</span>;</div><div class=\"line\">        <span class=\"attribute\">location</span> / &#123;</div><div class=\"line\">            <span class=\"attribute\">proxy_set_header</span>  X-Real-IP  <span class=\"variable\">$remote_addr</span>;</div><div class=\"line\">            <span class=\"attribute\">proxy_set_header</span> X-Forwarded-For <span class=\"variable\">$proxy_add_x_forwarded_for</span>;</div><div class=\"line\">            <span class=\"attribute\">proxy_pass</span> http://localhost:3000;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"attribute\">location</span><span class=\"regexp\"> ^~</span> /api/ &#123;</div><div class=\"line\">            <span class=\"attribute\">proxy_set_header</span>  X-Real-IP  <span class=\"variable\">$remote_addr</span>;</div><div class=\"line\">            <span class=\"attribute\">proxy_set_header</span> X-Forwarded-For <span class=\"variable\">$proxy_add_x_forwarded_for</span>;</div><div class=\"line\">            <span class=\"attribute\">proxy_pass</span> http://10.172.1.1;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后访问 <code>http://localhost:2199</code>，当后面为 <code>/api/..</code> 时，nginx 会转发给 <code>10.172.1.1</code>，而其他的非 api 接口，则转发给 node 服务。这样相当于从 <code>http://localhost:2199</code> 请求到 <code>http://localhost:2199/api/</code>，则解决了跨域问题。</p>\n","excerpt":"","more":"<p>跨域问题是前端开发中经常会遇到的问题。</p>\n<p>后端同学开发好了一些接口并部署到了服务器上，这时他提供给我们的地址是 <code>10.172.1.1</code>，而我们在本地开发时，一般都开的是 node 服务，比如 <code>localhost:3000</code>，此时使用 ajax 调用远程服务就会出现跨域问题。</p>\n<p>解决跨域问题有很多种方法，比如 jsonp，但是我在工作中很少会碰到使用 jsonp 解决跨域问题的场景。</p>\n<p>另外一种办法是在服务端设置跨域头 CORS，这是很常见的一种做法，也比较简单，但需要后端同学配合。本文主要探讨的是使用 nginx 配置反向代理来解决跨域问题。</p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>首先启动 node 服务，以监听 3000 端口为例。这时访问 <code>localhost:3000</code> 为前端页面。</p>\n<h4 id=\"配置-nginx\"><a href=\"#配置-nginx\" class=\"headerlink\" title=\"配置 nginx\"></a>配置 nginx</h4><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"section\">http</span> &#123;</div><div class=\"line\">    <span class=\"section\">server</span> &#123;</div><div class=\"line\">        <span class=\"attribute\">listen</span>    <span class=\"number\">2199</span>;</div><div class=\"line\">        <span class=\"attribute\">location</span> / &#123;</div><div class=\"line\">            <span class=\"attribute\">proxy_set_header</span>  X-Real-IP  <span class=\"variable\">$remote_addr</span>;</div><div class=\"line\">            <span class=\"attribute\">proxy_set_header</span> X-Forwarded-For <span class=\"variable\">$proxy_add_x_forwarded_for</span>;</div><div class=\"line\">            <span class=\"attribute\">proxy_pass</span> http://localhost:3000;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"attribute\">location</span><span class=\"regexp\"> ^~</span> /api/ &#123;</div><div class=\"line\">            <span class=\"attribute\">proxy_set_header</span>  X-Real-IP  <span class=\"variable\">$remote_addr</span>;</div><div class=\"line\">            <span class=\"attribute\">proxy_set_header</span> X-Forwarded-For <span class=\"variable\">$proxy_add_x_forwarded_for</span>;</div><div class=\"line\">            <span class=\"attribute\">proxy_pass</span> http://10.172.1.1;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后访问 <code>http://localhost:2199</code>，当后面为 <code>/api/..</code> 时，nginx 会转发给 <code>10.172.1.1</code>，而其他的非 api 接口，则转发给 node 服务。这样相当于从 <code>http://localhost:2199</code> 请求到 <code>http://localhost:2199/api/</code>，则解决了跨域问题。</p>\n"},{"title":"项目开发流程","date":"2017-02-14T09:36:45.000Z","_content":"\n建房子需要先设计房子的结构，然后才能添砖加瓦。做项目也是一样，在写代码之前需要进行详细的设计，然后才开始写代码。一个工程师更应专注于设计的部分，设计做好了，写代码就只是一个简单的工作了。\n\n<!-- more -->\n\n## 思路\n\n### Step 1\n阅读需求文档\n\n### Step 2\n需求 **分类**、**细化**，抽解出 **非功能性需求**（性能要求、用户体验等）。\n\n### Step 3\n技术上进行抽象，分析模块，UML建模\n\n### Step 4\n制定方案（API、实现方案等）\n\n### Step 5\n对需求进行评估，与 Step 2 中分解出的需求进行逐一核对，验证是否满足需求且是否具备可行性\n\n### Step 6\n项目评审\n\n### Step 7\n写代码\n\n## 产出文档\n\n项目评审前，需要产出一份文档，让参会的人对设计进行评审（你总不能空手去吧），文档应该体现项目中的各种设计和考虑。\n\n### 1. 业务\n这个项目的背景是什么、项目的目标是什么、项目有哪些约束\n\n### 2. 系统设计计划\n一期打算实现哪些功能，二期打算增加哪些功能，三期打算实现哪些功能等等\n\n针对每一期，描述这期要实现的功能点\n\n### 3. 设计及考虑\n设计包括数据格式、调用形式、技术选型等等\n考虑包括对并发、异常处理、安全等问题的考虑和解决方案等\n\n## 评审\n参与评审的人员要准备一份清单（checklist），该清单包括对功能性和非功能性的要求，参会人员应针对每一项对设计者进行提问，如果设计者没有考虑到这个问题，或者设计不能满足需求，那么需要将问题记录下来，在会后进行完善，之后根据情况决定是否进行下一次评审。\n\n清单可以去网上找，设计的时候也可以对着清单看有没有遗漏。比如\n\n```\n- 功能点\n  - A 功能\n  - B 功能\n- 非功能点\n  - 扩展性\n  - 性能\n  - 维护\n  - 可用性\n  - 易用性\n等等\n```\n\n## 计划\n不仅在写代码的时候要对功能实现的时间有计划，在设计的时候，也要有计划。\n\n计划根据产出文档的步骤进行设定，比如 `今天下午-小名、小红-讨论 1.业务 和 2.系统设计计划`","source":"_posts/project-development-process.md","raw":"---\ntitle: 项目开发流程\ndate: 2017-02-14 17:36:45\ntags: [总结]\n---\n\n建房子需要先设计房子的结构，然后才能添砖加瓦。做项目也是一样，在写代码之前需要进行详细的设计，然后才开始写代码。一个工程师更应专注于设计的部分，设计做好了，写代码就只是一个简单的工作了。\n\n<!-- more -->\n\n## 思路\n\n### Step 1\n阅读需求文档\n\n### Step 2\n需求 **分类**、**细化**，抽解出 **非功能性需求**（性能要求、用户体验等）。\n\n### Step 3\n技术上进行抽象，分析模块，UML建模\n\n### Step 4\n制定方案（API、实现方案等）\n\n### Step 5\n对需求进行评估，与 Step 2 中分解出的需求进行逐一核对，验证是否满足需求且是否具备可行性\n\n### Step 6\n项目评审\n\n### Step 7\n写代码\n\n## 产出文档\n\n项目评审前，需要产出一份文档，让参会的人对设计进行评审（你总不能空手去吧），文档应该体现项目中的各种设计和考虑。\n\n### 1. 业务\n这个项目的背景是什么、项目的目标是什么、项目有哪些约束\n\n### 2. 系统设计计划\n一期打算实现哪些功能，二期打算增加哪些功能，三期打算实现哪些功能等等\n\n针对每一期，描述这期要实现的功能点\n\n### 3. 设计及考虑\n设计包括数据格式、调用形式、技术选型等等\n考虑包括对并发、异常处理、安全等问题的考虑和解决方案等\n\n## 评审\n参与评审的人员要准备一份清单（checklist），该清单包括对功能性和非功能性的要求，参会人员应针对每一项对设计者进行提问，如果设计者没有考虑到这个问题，或者设计不能满足需求，那么需要将问题记录下来，在会后进行完善，之后根据情况决定是否进行下一次评审。\n\n清单可以去网上找，设计的时候也可以对着清单看有没有遗漏。比如\n\n```\n- 功能点\n  - A 功能\n  - B 功能\n- 非功能点\n  - 扩展性\n  - 性能\n  - 维护\n  - 可用性\n  - 易用性\n等等\n```\n\n## 计划\n不仅在写代码的时候要对功能实现的时间有计划，在设计的时候，也要有计划。\n\n计划根据产出文档的步骤进行设定，比如 `今天下午-小名、小红-讨论 1.业务 和 2.系统设计计划`","slug":"project-development-process","published":1,"updated":"2017-02-14T09:49:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcwv002fn927g22d3uvp","content":"<p>建房子需要先设计房子的结构，然后才能添砖加瓦。做项目也是一样，在写代码之前需要进行详细的设计，然后才开始写代码。一个工程师更应专注于设计的部分，设计做好了，写代码就只是一个简单的工作了。</p>\n<a id=\"more\"></a>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><h3 id=\"Step-1\"><a href=\"#Step-1\" class=\"headerlink\" title=\"Step 1\"></a>Step 1</h3><p>阅读需求文档</p>\n<h3 id=\"Step-2\"><a href=\"#Step-2\" class=\"headerlink\" title=\"Step 2\"></a>Step 2</h3><p>需求 <strong>分类</strong>、<strong>细化</strong>，抽解出 <strong>非功能性需求</strong>（性能要求、用户体验等）。</p>\n<h3 id=\"Step-3\"><a href=\"#Step-3\" class=\"headerlink\" title=\"Step 3\"></a>Step 3</h3><p>技术上进行抽象，分析模块，UML建模</p>\n<h3 id=\"Step-4\"><a href=\"#Step-4\" class=\"headerlink\" title=\"Step 4\"></a>Step 4</h3><p>制定方案（API、实现方案等）</p>\n<h3 id=\"Step-5\"><a href=\"#Step-5\" class=\"headerlink\" title=\"Step 5\"></a>Step 5</h3><p>对需求进行评估，与 Step 2 中分解出的需求进行逐一核对，验证是否满足需求且是否具备可行性</p>\n<h3 id=\"Step-6\"><a href=\"#Step-6\" class=\"headerlink\" title=\"Step 6\"></a>Step 6</h3><p>项目评审</p>\n<h3 id=\"Step-7\"><a href=\"#Step-7\" class=\"headerlink\" title=\"Step 7\"></a>Step 7</h3><p>写代码</p>\n<h2 id=\"产出文档\"><a href=\"#产出文档\" class=\"headerlink\" title=\"产出文档\"></a>产出文档</h2><p>项目评审前，需要产出一份文档，让参会的人对设计进行评审（你总不能空手去吧），文档应该体现项目中的各种设计和考虑。</p>\n<h3 id=\"1-业务\"><a href=\"#1-业务\" class=\"headerlink\" title=\"1. 业务\"></a>1. 业务</h3><p>这个项目的背景是什么、项目的目标是什么、项目有哪些约束</p>\n<h3 id=\"2-系统设计计划\"><a href=\"#2-系统设计计划\" class=\"headerlink\" title=\"2. 系统设计计划\"></a>2. 系统设计计划</h3><p>一期打算实现哪些功能，二期打算增加哪些功能，三期打算实现哪些功能等等</p>\n<p>针对每一期，描述这期要实现的功能点</p>\n<h3 id=\"3-设计及考虑\"><a href=\"#3-设计及考虑\" class=\"headerlink\" title=\"3. 设计及考虑\"></a>3. 设计及考虑</h3><p>设计包括数据格式、调用形式、技术选型等等<br>考虑包括对并发、异常处理、安全等问题的考虑和解决方案等</p>\n<h2 id=\"评审\"><a href=\"#评审\" class=\"headerlink\" title=\"评审\"></a>评审</h2><p>参与评审的人员要准备一份清单（checklist），该清单包括对功能性和非功能性的要求，参会人员应针对每一项对设计者进行提问，如果设计者没有考虑到这个问题，或者设计不能满足需求，那么需要将问题记录下来，在会后进行完善，之后根据情况决定是否进行下一次评审。</p>\n<p>清单可以去网上找，设计的时候也可以对着清单看有没有遗漏。比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">- 功能点</div><div class=\"line\">  - A 功能</div><div class=\"line\">  - B 功能</div><div class=\"line\">- 非功能点</div><div class=\"line\">  - 扩展性</div><div class=\"line\">  - 性能</div><div class=\"line\">  - 维护</div><div class=\"line\">  - 可用性</div><div class=\"line\">  - 易用性</div><div class=\"line\">等等</div></pre></td></tr></table></figure>\n<h2 id=\"计划\"><a href=\"#计划\" class=\"headerlink\" title=\"计划\"></a>计划</h2><p>不仅在写代码的时候要对功能实现的时间有计划，在设计的时候，也要有计划。</p>\n<p>计划根据产出文档的步骤进行设定，比如 <code>今天下午-小名、小红-讨论 1.业务 和 2.系统设计计划</code></p>\n","excerpt":"<p>建房子需要先设计房子的结构，然后才能添砖加瓦。做项目也是一样，在写代码之前需要进行详细的设计，然后才开始写代码。一个工程师更应专注于设计的部分，设计做好了，写代码就只是一个简单的工作了。</p>","more":"<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><h3 id=\"Step-1\"><a href=\"#Step-1\" class=\"headerlink\" title=\"Step 1\"></a>Step 1</h3><p>阅读需求文档</p>\n<h3 id=\"Step-2\"><a href=\"#Step-2\" class=\"headerlink\" title=\"Step 2\"></a>Step 2</h3><p>需求 <strong>分类</strong>、<strong>细化</strong>，抽解出 <strong>非功能性需求</strong>（性能要求、用户体验等）。</p>\n<h3 id=\"Step-3\"><a href=\"#Step-3\" class=\"headerlink\" title=\"Step 3\"></a>Step 3</h3><p>技术上进行抽象，分析模块，UML建模</p>\n<h3 id=\"Step-4\"><a href=\"#Step-4\" class=\"headerlink\" title=\"Step 4\"></a>Step 4</h3><p>制定方案（API、实现方案等）</p>\n<h3 id=\"Step-5\"><a href=\"#Step-5\" class=\"headerlink\" title=\"Step 5\"></a>Step 5</h3><p>对需求进行评估，与 Step 2 中分解出的需求进行逐一核对，验证是否满足需求且是否具备可行性</p>\n<h3 id=\"Step-6\"><a href=\"#Step-6\" class=\"headerlink\" title=\"Step 6\"></a>Step 6</h3><p>项目评审</p>\n<h3 id=\"Step-7\"><a href=\"#Step-7\" class=\"headerlink\" title=\"Step 7\"></a>Step 7</h3><p>写代码</p>\n<h2 id=\"产出文档\"><a href=\"#产出文档\" class=\"headerlink\" title=\"产出文档\"></a>产出文档</h2><p>项目评审前，需要产出一份文档，让参会的人对设计进行评审（你总不能空手去吧），文档应该体现项目中的各种设计和考虑。</p>\n<h3 id=\"1-业务\"><a href=\"#1-业务\" class=\"headerlink\" title=\"1. 业务\"></a>1. 业务</h3><p>这个项目的背景是什么、项目的目标是什么、项目有哪些约束</p>\n<h3 id=\"2-系统设计计划\"><a href=\"#2-系统设计计划\" class=\"headerlink\" title=\"2. 系统设计计划\"></a>2. 系统设计计划</h3><p>一期打算实现哪些功能，二期打算增加哪些功能，三期打算实现哪些功能等等</p>\n<p>针对每一期，描述这期要实现的功能点</p>\n<h3 id=\"3-设计及考虑\"><a href=\"#3-设计及考虑\" class=\"headerlink\" title=\"3. 设计及考虑\"></a>3. 设计及考虑</h3><p>设计包括数据格式、调用形式、技术选型等等<br>考虑包括对并发、异常处理、安全等问题的考虑和解决方案等</p>\n<h2 id=\"评审\"><a href=\"#评审\" class=\"headerlink\" title=\"评审\"></a>评审</h2><p>参与评审的人员要准备一份清单（checklist），该清单包括对功能性和非功能性的要求，参会人员应针对每一项对设计者进行提问，如果设计者没有考虑到这个问题，或者设计不能满足需求，那么需要将问题记录下来，在会后进行完善，之后根据情况决定是否进行下一次评审。</p>\n<p>清单可以去网上找，设计的时候也可以对着清单看有没有遗漏。比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">- 功能点</div><div class=\"line\">  - A 功能</div><div class=\"line\">  - B 功能</div><div class=\"line\">- 非功能点</div><div class=\"line\">  - 扩展性</div><div class=\"line\">  - 性能</div><div class=\"line\">  - 维护</div><div class=\"line\">  - 可用性</div><div class=\"line\">  - 易用性</div><div class=\"line\">等等</div></pre></td></tr></table></figure>\n<h2 id=\"计划\"><a href=\"#计划\" class=\"headerlink\" title=\"计划\"></a>计划</h2><p>不仅在写代码的时候要对功能实现的时间有计划，在设计的时候，也要有计划。</p>\n<p>计划根据产出文档的步骤进行设定，比如 <code>今天下午-小名、小红-讨论 1.业务 和 2.系统设计计划</code></p>"},{"title":"React-router 按需加载","date":"2016-10-12T03:33:57.000Z","_content":"\nReact Router 是一个非常出色的路由解决方案，同时也非常容易上手。但是当网站规模越来越大的时候，首先出现的问题是 Javascript 文件变得巨大，这导致首页渲染的时间让人难以忍受。实际上程序应当只加载当前渲染页所需的 JavaScript，也就是大家说的“代码分拆\" — 将所有的代码分拆成多个小包，在用户浏览过程中按需加载。\n\n<!-- more -->\n\n官方示例在 [这里](https://github.com/ReactTraining/react-router/tree/master/examples/huge-apps)。\n\n所得到的效果是：\n\n以前是这样（23333，我真不是故意的。。）\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/react-router-dynamic/01.png)\n\n现在是这样：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/react-router-dynamic/02.png)\n\n实际上就是将一个大 javascript 文件拆分成了若干个 chunk file。\n\n下面是改造过程\n\n## Webpack 配置\n\n首先在 `webpack.config.js` 的 `output` 内加上 `chunkFilename`\n\n```javascript\noutput: {\n    path: path.join(__dirname, '/../dist/assets'),\n    filename: 'app.js',\n    publicPath: defaultSettings.publicPath,\n    // 添加 chunkFilename\n    chunkFilename: '[name].[chunkhash:5].chunk.js',\n},\n```\n\n`name` 是在代码里为创建的 chunk 指定的名字，如果代码中没指定则 webpack 默认分配 id 作为 name。\n\n`chunkhash` 是文件的 hash 码，这里只使用前五位。\n\n## 添加首页\n\n以前你的路由大概应该是这样的：（作为需要按需加载的大型应用，路由肯定是相当复杂，这里只列举部分路由举例）\n\n```jsx\nReactDOM.render(\n  (\n    <Router history={browserHistory}>\n      {/* 主页 */}\n      <Route path=\"/\" component={App}>\n        {/* 默认 */}\n        <IndexRoute component={HomePage} />\n\n        {/* baidu */}\n        <Route path=\"/baidu\" component={BaiduPage}>\n          <Route path=\"result\" component={BaiduResultPage} />\n          <Route path=\"frequency\" component={BaiduFrequencyPage} />\n        </Route>\n\n        {/* 404 */}\n        <Route path='/404' component={NotFoundPage} />\n        \n        {/* 其他重定向到 404 */}\n        <Redirect from='*' to='/404' />\n      </Route>\n    </Router>\n  ), document.getElementById('app')\n);\n```\n\n按需加载之后，我们需要让路由动态加载组件，需要将 `component` 换成 `getComponent`。首先将路由拆出来（因为路由庞大之后全部写在一起会很难看），创建一个根路由 rootRoute：\n\n```jsx\nconst rootRoute = {\n  path: '/',\n  indexRoute: {\n    getComponent(nextState, cb) {\n      require.ensure([], (require) => {\n        cb(null, require('components/layer/HomePage'))\n      }, 'HomePage')\n    },\n  },\n  getComponent(nextState, cb) {\n    require.ensure([], (require) => {\n      cb(null, require('components/Main'))\n    }, 'Main')\n  },\n  childRoutes: [\n    require('./routes/baidu'),\n    require('./routes/404'),\n    require('./routes/redirect')\n  ]\n}\n\nReactDOM.render(\n  (\n    <Router\n      history={browserHistory}\n      routes={rootRoute}\n      />\n  ), document.getElementById('app')\n);\n```\n\nhistory 不变，在 Router 中添加 routes 属性，将创建的路由传递进去。\n\n这里有四个属性：\n\n### path\n\n将匹配的路由，也就是以前的 path。\n\n### getComponent\n\n对应于以前的 component 属性，但是这个方法是异步的，也就是当路由匹配时，才会调用这个方法。\n\n这里面有个 **require.ensure** 方法\n\n```javascript\nrequire.ensure(dependencies, callback, chunkName)\n```\n\n这是 webpack 提供的方法，这也是按需加载的核心方法。第一个参数是依赖，第二个是回调函数，第三个就是上面提到的 chunkName，用来指定这个 chunk file 的 name。\n\n如果需要返回多个子组件，则使用 `getComponents` 方法，将多个组件作为一个对象的属性通过 `cb` 返回出去即可。这个在官方示例也有，但是我们这里并不需要，而且根组件是不能返回多个子组件的，所以使用 `getComponent`。\n\n### indexRoute\n\n用来设置主页，对应于以前的 `<IndexRoute>`。\n\n注意这里的 indexRoute 写法， **这是个对象，在对象里面使用 getComponent**。\n\n### childRoutes\n\n这里面放置的就是子路由的配置，对应于以前的子路由们。我们将以前的 `/baidu`、`/404` 和 `*` 都拆了出来，接下来将分别为他们创建路由配置。\n\n## 路由控制\n\n上面的`childRoutes` 里面，我们 require 了三个子路由，在目录下创建 `routes` 目录，将这三个路由放置进去。\n\n```\nroutes/\n├── 404\n│   └── index.js\n├── baidu\n│   ├── index.js\n│   └── routes\n│       ├── frequency\n│       │   └── index.js\n│       └── result\n│           └── index.js\n└── redirect\n    └── index.js\n```\n\n和 rootRoute 类似，里面的每个 index.js 都是一个路由对象：\n\n### /404/index.js\n\n```javascript\nmodule.exports = {\n  path: '404',\n\n  getComponent(nextState, cb) {\n    require.ensure([], (require) => {\n      cb(null, require('components/layer/NotFoundPage'))\n    }, 'NotFoundPage')\n  }\n}\n\n```\n\n### /baidu/index.js\n\n```javascript\nmodule.exports = {\n  path: 'baidu',\n\n  getChildRoutes(partialNextState, cb) {\n    require.ensure([], (require) => {\n      cb(null, [\n        require('./routes/result'),\n        require('./routes/frequency')\n      ])\n    })\n  },\n\n  getComponent(nextState, cb) {\n    require.ensure([], (require) => {\n      cb(null, require('components/layer/BaiduPage'))\n    }, 'BaiduPage')\n  }\n}\n\n```\n\n### /baidu/routes/frequency/index.js\n\n```javascript\nmodule.exports = {\n  path: 'frequency',\n\n  getComponent(nextState, cb) {\n    require.ensure([], (require) => {\n      cb(null, require('components/layer/BaiduFrequencyPage'))\n    }, 'BaiduFrequencyPage')\n  }\n}\n\n```\n\n举这几个例子应该就差不多了，其他都是一样的，稍微有点特别的是 redirect。\n\n## 设置 Redirect\n\n之前我们在根路由下是这么设置重定向的：\n\n```jsx\n<Router history={browserHistory}>\n      <Route path=\"/\" component={App}>\n        {/* home */}\n        <IndexRoute component={HomePage} />\n\n        <Route path=\"/baidu\" component={BaiduPage}>\n          <Route path=\"result\" component={BaiduResultPage} />\n          <Route path=\"frequency\" component={BaiduFrequencyPage} />\n        </Route>\n\n        <Route path='/404' component={NotFoundPage} />\n        {/* 如果都不匹配，重定向到 404 */}\n        <Redirect from='*' to='/404' />\n      </Route>\n    </Router>\n```\n\n当改写之后，我们需要把这个重定向的路由单独拆出来，也就是  `*` 这个路由，我们上面已经为他创建了一个 `redirect` 目录。这里使用到 onEnter 方法，然后在这个方法里改变路由状态，调到另外的路由，实现 redirect ：\n\n### /redirect/index.js\n\n```javascript\nmodule.exports = {\n  path: '*',\n  onEnter: (_, replaceState) => replaceState(null, \"/404\")\n}\n```\n\n## The root route must render a single element\n\n跟着官方示例和上面码出来之后，可能页面并没有渲染出来，而是报 **The root route must render a single element** 这个异常，这是因为 `module.exports` 和 ES6 里的 `export default` 有区别。\n\n如果你是使用 es6 的写法，也就是你的组件都是通过 `export default` 导出的，那么在 `getComponent` 方法里面需要加入 `.default`。\n\n```javascript\ngetComponent(nextState, cb) {\n    require.ensure([], (require) => {\n      // 在后面加 .default\n      cb(null, require('components/layer/ReportPage')).default\n    }, 'ReportPage')\n}\n```\n\n如果你是使用 CommonJS 的写法，也就是通过 `module.exports` 导出的，那就无须加 `.default` 了。","source":"_posts/react-router-dynamic.md","raw":"---\ntitle: React-router 按需加载\ndate: 2016-10-12 11:33:57\ntags: [总结, react]\n---\n\nReact Router 是一个非常出色的路由解决方案，同时也非常容易上手。但是当网站规模越来越大的时候，首先出现的问题是 Javascript 文件变得巨大，这导致首页渲染的时间让人难以忍受。实际上程序应当只加载当前渲染页所需的 JavaScript，也就是大家说的“代码分拆\" — 将所有的代码分拆成多个小包，在用户浏览过程中按需加载。\n\n<!-- more -->\n\n官方示例在 [这里](https://github.com/ReactTraining/react-router/tree/master/examples/huge-apps)。\n\n所得到的效果是：\n\n以前是这样（23333，我真不是故意的。。）\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/react-router-dynamic/01.png)\n\n现在是这样：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/react-router-dynamic/02.png)\n\n实际上就是将一个大 javascript 文件拆分成了若干个 chunk file。\n\n下面是改造过程\n\n## Webpack 配置\n\n首先在 `webpack.config.js` 的 `output` 内加上 `chunkFilename`\n\n```javascript\noutput: {\n    path: path.join(__dirname, '/../dist/assets'),\n    filename: 'app.js',\n    publicPath: defaultSettings.publicPath,\n    // 添加 chunkFilename\n    chunkFilename: '[name].[chunkhash:5].chunk.js',\n},\n```\n\n`name` 是在代码里为创建的 chunk 指定的名字，如果代码中没指定则 webpack 默认分配 id 作为 name。\n\n`chunkhash` 是文件的 hash 码，这里只使用前五位。\n\n## 添加首页\n\n以前你的路由大概应该是这样的：（作为需要按需加载的大型应用，路由肯定是相当复杂，这里只列举部分路由举例）\n\n```jsx\nReactDOM.render(\n  (\n    <Router history={browserHistory}>\n      {/* 主页 */}\n      <Route path=\"/\" component={App}>\n        {/* 默认 */}\n        <IndexRoute component={HomePage} />\n\n        {/* baidu */}\n        <Route path=\"/baidu\" component={BaiduPage}>\n          <Route path=\"result\" component={BaiduResultPage} />\n          <Route path=\"frequency\" component={BaiduFrequencyPage} />\n        </Route>\n\n        {/* 404 */}\n        <Route path='/404' component={NotFoundPage} />\n        \n        {/* 其他重定向到 404 */}\n        <Redirect from='*' to='/404' />\n      </Route>\n    </Router>\n  ), document.getElementById('app')\n);\n```\n\n按需加载之后，我们需要让路由动态加载组件，需要将 `component` 换成 `getComponent`。首先将路由拆出来（因为路由庞大之后全部写在一起会很难看），创建一个根路由 rootRoute：\n\n```jsx\nconst rootRoute = {\n  path: '/',\n  indexRoute: {\n    getComponent(nextState, cb) {\n      require.ensure([], (require) => {\n        cb(null, require('components/layer/HomePage'))\n      }, 'HomePage')\n    },\n  },\n  getComponent(nextState, cb) {\n    require.ensure([], (require) => {\n      cb(null, require('components/Main'))\n    }, 'Main')\n  },\n  childRoutes: [\n    require('./routes/baidu'),\n    require('./routes/404'),\n    require('./routes/redirect')\n  ]\n}\n\nReactDOM.render(\n  (\n    <Router\n      history={browserHistory}\n      routes={rootRoute}\n      />\n  ), document.getElementById('app')\n);\n```\n\nhistory 不变，在 Router 中添加 routes 属性，将创建的路由传递进去。\n\n这里有四个属性：\n\n### path\n\n将匹配的路由，也就是以前的 path。\n\n### getComponent\n\n对应于以前的 component 属性，但是这个方法是异步的，也就是当路由匹配时，才会调用这个方法。\n\n这里面有个 **require.ensure** 方法\n\n```javascript\nrequire.ensure(dependencies, callback, chunkName)\n```\n\n这是 webpack 提供的方法，这也是按需加载的核心方法。第一个参数是依赖，第二个是回调函数，第三个就是上面提到的 chunkName，用来指定这个 chunk file 的 name。\n\n如果需要返回多个子组件，则使用 `getComponents` 方法，将多个组件作为一个对象的属性通过 `cb` 返回出去即可。这个在官方示例也有，但是我们这里并不需要，而且根组件是不能返回多个子组件的，所以使用 `getComponent`。\n\n### indexRoute\n\n用来设置主页，对应于以前的 `<IndexRoute>`。\n\n注意这里的 indexRoute 写法， **这是个对象，在对象里面使用 getComponent**。\n\n### childRoutes\n\n这里面放置的就是子路由的配置，对应于以前的子路由们。我们将以前的 `/baidu`、`/404` 和 `*` 都拆了出来，接下来将分别为他们创建路由配置。\n\n## 路由控制\n\n上面的`childRoutes` 里面，我们 require 了三个子路由，在目录下创建 `routes` 目录，将这三个路由放置进去。\n\n```\nroutes/\n├── 404\n│   └── index.js\n├── baidu\n│   ├── index.js\n│   └── routes\n│       ├── frequency\n│       │   └── index.js\n│       └── result\n│           └── index.js\n└── redirect\n    └── index.js\n```\n\n和 rootRoute 类似，里面的每个 index.js 都是一个路由对象：\n\n### /404/index.js\n\n```javascript\nmodule.exports = {\n  path: '404',\n\n  getComponent(nextState, cb) {\n    require.ensure([], (require) => {\n      cb(null, require('components/layer/NotFoundPage'))\n    }, 'NotFoundPage')\n  }\n}\n\n```\n\n### /baidu/index.js\n\n```javascript\nmodule.exports = {\n  path: 'baidu',\n\n  getChildRoutes(partialNextState, cb) {\n    require.ensure([], (require) => {\n      cb(null, [\n        require('./routes/result'),\n        require('./routes/frequency')\n      ])\n    })\n  },\n\n  getComponent(nextState, cb) {\n    require.ensure([], (require) => {\n      cb(null, require('components/layer/BaiduPage'))\n    }, 'BaiduPage')\n  }\n}\n\n```\n\n### /baidu/routes/frequency/index.js\n\n```javascript\nmodule.exports = {\n  path: 'frequency',\n\n  getComponent(nextState, cb) {\n    require.ensure([], (require) => {\n      cb(null, require('components/layer/BaiduFrequencyPage'))\n    }, 'BaiduFrequencyPage')\n  }\n}\n\n```\n\n举这几个例子应该就差不多了，其他都是一样的，稍微有点特别的是 redirect。\n\n## 设置 Redirect\n\n之前我们在根路由下是这么设置重定向的：\n\n```jsx\n<Router history={browserHistory}>\n      <Route path=\"/\" component={App}>\n        {/* home */}\n        <IndexRoute component={HomePage} />\n\n        <Route path=\"/baidu\" component={BaiduPage}>\n          <Route path=\"result\" component={BaiduResultPage} />\n          <Route path=\"frequency\" component={BaiduFrequencyPage} />\n        </Route>\n\n        <Route path='/404' component={NotFoundPage} />\n        {/* 如果都不匹配，重定向到 404 */}\n        <Redirect from='*' to='/404' />\n      </Route>\n    </Router>\n```\n\n当改写之后，我们需要把这个重定向的路由单独拆出来，也就是  `*` 这个路由，我们上面已经为他创建了一个 `redirect` 目录。这里使用到 onEnter 方法，然后在这个方法里改变路由状态，调到另外的路由，实现 redirect ：\n\n### /redirect/index.js\n\n```javascript\nmodule.exports = {\n  path: '*',\n  onEnter: (_, replaceState) => replaceState(null, \"/404\")\n}\n```\n\n## The root route must render a single element\n\n跟着官方示例和上面码出来之后，可能页面并没有渲染出来，而是报 **The root route must render a single element** 这个异常，这是因为 `module.exports` 和 ES6 里的 `export default` 有区别。\n\n如果你是使用 es6 的写法，也就是你的组件都是通过 `export default` 导出的，那么在 `getComponent` 方法里面需要加入 `.default`。\n\n```javascript\ngetComponent(nextState, cb) {\n    require.ensure([], (require) => {\n      // 在后面加 .default\n      cb(null, require('components/layer/ReportPage')).default\n    }, 'ReportPage')\n}\n```\n\n如果你是使用 CommonJS 的写法，也就是通过 `module.exports` 导出的，那就无须加 `.default` 了。","slug":"react-router-dynamic","published":1,"updated":"2017-03-17T13:40:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcwx002in927scste4vb","content":"<p>React Router 是一个非常出色的路由解决方案，同时也非常容易上手。但是当网站规模越来越大的时候，首先出现的问题是 Javascript 文件变得巨大，这导致首页渲染的时间让人难以忍受。实际上程序应当只加载当前渲染页所需的 JavaScript，也就是大家说的“代码分拆” — 将所有的代码分拆成多个小包，在用户浏览过程中按需加载。</p>\n<a id=\"more\"></a>\n<p>官方示例在 <a href=\"https://github.com/ReactTraining/react-router/tree/master/examples/huge-apps\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n<p>所得到的效果是：</p>\n<p>以前是这样（23333，我真不是故意的。。）</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/react-router-dynamic/01.png\" alt=\"\"></p>\n<p>现在是这样：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/react-router-dynamic/02.png\" alt=\"\"></p>\n<p>实际上就是将一个大 javascript 文件拆分成了若干个 chunk file。</p>\n<p>下面是改造过程</p>\n<h2 id=\"Webpack-配置\"><a href=\"#Webpack-配置\" class=\"headerlink\" title=\"Webpack 配置\"></a>Webpack 配置</h2><p>首先在 <code>webpack.config.js</code> 的 <code>output</code> 内加上 <code>chunkFilename</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">output: &#123;</div><div class=\"line\">    <span class=\"attr\">path</span>: path.join(__dirname, <span class=\"string\">'/../dist/assets'</span>),</div><div class=\"line\">    <span class=\"attr\">filename</span>: <span class=\"string\">'app.js'</span>,</div><div class=\"line\">    <span class=\"attr\">publicPath</span>: defaultSettings.publicPath,</div><div class=\"line\">    <span class=\"comment\">// 添加 chunkFilename</span></div><div class=\"line\">    chunkFilename: <span class=\"string\">'[name].[chunkhash:5].chunk.js'</span>,</div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure>\n<p><code>name</code> 是在代码里为创建的 chunk 指定的名字，如果代码中没指定则 webpack 默认分配 id 作为 name。</p>\n<p><code>chunkhash</code> 是文件的 hash 码，这里只使用前五位。</p>\n<h2 id=\"添加首页\"><a href=\"#添加首页\" class=\"headerlink\" title=\"添加首页\"></a>添加首页</h2><p>以前你的路由大概应该是这样的：（作为需要按需加载的大型应用，路由肯定是相当复杂，这里只列举部分路由举例）</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  (</div><div class=\"line\">    &lt;Router history=&#123;browserHistory&#125;&gt;</div><div class=\"line\">      &#123;/* 主页 */&#125;</div><div class=\"line\">      &lt;Route path=\"/\" component=&#123;App&#125;&gt;</div><div class=\"line\">        &#123;/* 默认 */&#125;</div><div class=\"line\">        &lt;IndexRoute component=&#123;HomePage&#125; /&gt;</div><div class=\"line\"></div><div class=\"line\">        &#123;/* baidu */&#125;</div><div class=\"line\">        &lt;Route path=\"/baidu\" component=&#123;BaiduPage&#125;&gt;</div><div class=\"line\">          &lt;Route path=\"result\" component=&#123;BaiduResultPage&#125; /&gt;</div><div class=\"line\">          &lt;Route path=\"frequency\" component=&#123;BaiduFrequencyPage&#125; /&gt;</div><div class=\"line\">        &lt;/Route&gt;</div><div class=\"line\"></div><div class=\"line\">        &#123;/* 404 */&#125;</div><div class=\"line\">        &lt;Route path='/404' component=&#123;NotFoundPage&#125; /&gt;</div><div class=\"line\">        </div><div class=\"line\">        &#123;/* 其他重定向到 404 */&#125;</div><div class=\"line\">        &lt;Redirect from='*' to='/404' /&gt;</div><div class=\"line\">      &lt;/Route&gt;</div><div class=\"line\">    &lt;/Router&gt;</div><div class=\"line\">  ), document.getElementById('app')</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n<p>按需加载之后，我们需要让路由动态加载组件，需要将 <code>component</code> 换成 <code>getComponent</code>。首先将路由拆出来（因为路由庞大之后全部写在一起会很难看），创建一个根路由 rootRoute：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> rootRoute = &#123;</div><div class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">'/'</span>,</div><div class=\"line\">  <span class=\"attr\">indexRoute</span>: &#123;</div><div class=\"line\">    getComponent(nextState, cb) &#123;</div><div class=\"line\">      <span class=\"built_in\">require</span>.ensure([], (<span class=\"built_in\">require</span>) =&gt; &#123;</div><div class=\"line\">        cb(<span class=\"literal\">null</span>, <span class=\"built_in\">require</span>(<span class=\"string\">'components/layer/HomePage'</span>))</div><div class=\"line\">      &#125;, <span class=\"string\">'HomePage'</span>)</div><div class=\"line\">    &#125;,</div><div class=\"line\">  &#125;,</div><div class=\"line\">  getComponent(nextState, cb) &#123;</div><div class=\"line\">    <span class=\"built_in\">require</span>.ensure([], (<span class=\"built_in\">require</span>) =&gt; &#123;</div><div class=\"line\">      cb(<span class=\"literal\">null</span>, <span class=\"built_in\">require</span>(<span class=\"string\">'components/Main'</span>))</div><div class=\"line\">    &#125;, <span class=\"string\">'Main'</span>)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">childRoutes</span>: [</div><div class=\"line\">    <span class=\"built_in\">require</span>(<span class=\"string\">'./routes/baidu'</span>),</div><div class=\"line\">    <span class=\"built_in\">require</span>(<span class=\"string\">'./routes/404'</span>),</div><div class=\"line\">    <span class=\"built_in\">require</span>(<span class=\"string\">'./routes/redirect'</span>)</div><div class=\"line\">  ]</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  (</div><div class=\"line\">    &lt;Router</div><div class=\"line\">      history=&#123;browserHistory&#125;</div><div class=\"line\">      routes=&#123;rootRoute&#125;</div><div class=\"line\">      /&gt;</div><div class=\"line\">  ), document.getElementById('app')</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n<p>history 不变，在 Router 中添加 routes 属性，将创建的路由传递进去。</p>\n<p>这里有四个属性：</p>\n<h3 id=\"path\"><a href=\"#path\" class=\"headerlink\" title=\"path\"></a>path</h3><p>将匹配的路由，也就是以前的 path。</p>\n<h3 id=\"getComponent\"><a href=\"#getComponent\" class=\"headerlink\" title=\"getComponent\"></a>getComponent</h3><p>对应于以前的 component 属性，但是这个方法是异步的，也就是当路由匹配时，才会调用这个方法。</p>\n<p>这里面有个 <strong>require.ensure</strong> 方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">require</span>.ensure(dependencies, callback, chunkName)</div></pre></td></tr></table></figure>\n<p>这是 webpack 提供的方法，这也是按需加载的核心方法。第一个参数是依赖，第二个是回调函数，第三个就是上面提到的 chunkName，用来指定这个 chunk file 的 name。</p>\n<p>如果需要返回多个子组件，则使用 <code>getComponents</code> 方法，将多个组件作为一个对象的属性通过 <code>cb</code> 返回出去即可。这个在官方示例也有，但是我们这里并不需要，而且根组件是不能返回多个子组件的，所以使用 <code>getComponent</code>。</p>\n<h3 id=\"indexRoute\"><a href=\"#indexRoute\" class=\"headerlink\" title=\"indexRoute\"></a>indexRoute</h3><p>用来设置主页，对应于以前的 <code>&lt;IndexRoute&gt;</code>。</p>\n<p>注意这里的 indexRoute 写法， <strong>这是个对象，在对象里面使用 getComponent</strong>。</p>\n<h3 id=\"childRoutes\"><a href=\"#childRoutes\" class=\"headerlink\" title=\"childRoutes\"></a>childRoutes</h3><p>这里面放置的就是子路由的配置，对应于以前的子路由们。我们将以前的 <code>/baidu</code>、<code>/404</code> 和 <code>*</code> 都拆了出来，接下来将分别为他们创建路由配置。</p>\n<h2 id=\"路由控制\"><a href=\"#路由控制\" class=\"headerlink\" title=\"路由控制\"></a>路由控制</h2><p>上面的<code>childRoutes</code> 里面，我们 require 了三个子路由，在目录下创建 <code>routes</code> 目录，将这三个路由放置进去。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">routes/</div><div class=\"line\">├── 404</div><div class=\"line\">│   └── index.js</div><div class=\"line\">├── baidu</div><div class=\"line\">│   ├── index.js</div><div class=\"line\">│   └── routes</div><div class=\"line\">│       ├── frequency</div><div class=\"line\">│       │   └── index.js</div><div class=\"line\">│       └── result</div><div class=\"line\">│           └── index.js</div><div class=\"line\">└── redirect</div><div class=\"line\">    └── index.js</div></pre></td></tr></table></figure>\n<p>和 rootRoute 类似，里面的每个 index.js 都是一个路由对象：</p>\n<h3 id=\"404-index-js\"><a href=\"#404-index-js\" class=\"headerlink\" title=\"/404/index.js\"></a>/404/index.js</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">'404'</span>,</div><div class=\"line\"></div><div class=\"line\">  getComponent(nextState, cb) &#123;</div><div class=\"line\">    <span class=\"built_in\">require</span>.ensure([], (<span class=\"built_in\">require</span>) =&gt; &#123;</div><div class=\"line\">      cb(<span class=\"literal\">null</span>, <span class=\"built_in\">require</span>(<span class=\"string\">'components/layer/NotFoundPage'</span>))</div><div class=\"line\">    &#125;, <span class=\"string\">'NotFoundPage'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"baidu-index-js\"><a href=\"#baidu-index-js\" class=\"headerlink\" title=\"/baidu/index.js\"></a>/baidu/index.js</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">'baidu'</span>,</div><div class=\"line\"></div><div class=\"line\">  getChildRoutes(partialNextState, cb) &#123;</div><div class=\"line\">    <span class=\"built_in\">require</span>.ensure([], (<span class=\"built_in\">require</span>) =&gt; &#123;</div><div class=\"line\">      cb(<span class=\"literal\">null</span>, [</div><div class=\"line\">        <span class=\"built_in\">require</span>(<span class=\"string\">'./routes/result'</span>),</div><div class=\"line\">        <span class=\"built_in\">require</span>(<span class=\"string\">'./routes/frequency'</span>)</div><div class=\"line\">      ])</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  getComponent(nextState, cb) &#123;</div><div class=\"line\">    <span class=\"built_in\">require</span>.ensure([], (<span class=\"built_in\">require</span>) =&gt; &#123;</div><div class=\"line\">      cb(<span class=\"literal\">null</span>, <span class=\"built_in\">require</span>(<span class=\"string\">'components/layer/BaiduPage'</span>))</div><div class=\"line\">    &#125;, <span class=\"string\">'BaiduPage'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"baidu-routes-frequency-index-js\"><a href=\"#baidu-routes-frequency-index-js\" class=\"headerlink\" title=\"/baidu/routes/frequency/index.js\"></a>/baidu/routes/frequency/index.js</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">'frequency'</span>,</div><div class=\"line\"></div><div class=\"line\">  getComponent(nextState, cb) &#123;</div><div class=\"line\">    <span class=\"built_in\">require</span>.ensure([], (<span class=\"built_in\">require</span>) =&gt; &#123;</div><div class=\"line\">      cb(<span class=\"literal\">null</span>, <span class=\"built_in\">require</span>(<span class=\"string\">'components/layer/BaiduFrequencyPage'</span>))</div><div class=\"line\">    &#125;, <span class=\"string\">'BaiduFrequencyPage'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>举这几个例子应该就差不多了，其他都是一样的，稍微有点特别的是 redirect。</p>\n<h2 id=\"设置-Redirect\"><a href=\"#设置-Redirect\" class=\"headerlink\" title=\"设置 Redirect\"></a>设置 Redirect</h2><p>之前我们在根路由下是这么设置重定向的：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Router history=&#123;browserHistory&#125;&gt;</div><div class=\"line\">      &lt;Route path=\"/\" component=&#123;App&#125;&gt;</div><div class=\"line\">        &#123;/* home */&#125;</div><div class=\"line\">        &lt;IndexRoute component=&#123;HomePage&#125; /&gt;</div><div class=\"line\"></div><div class=\"line\">        &lt;Route path=\"/baidu\" component=&#123;BaiduPage&#125;&gt;</div><div class=\"line\">          &lt;Route path=\"result\" component=&#123;BaiduResultPage&#125; /&gt;</div><div class=\"line\">          &lt;Route path=\"frequency\" component=&#123;BaiduFrequencyPage&#125; /&gt;</div><div class=\"line\">        &lt;/Route&gt;</div><div class=\"line\"></div><div class=\"line\">        &lt;Route path='/404' component=&#123;NotFoundPage&#125; /&gt;</div><div class=\"line\">        &#123;/* 如果都不匹配，重定向到 404 */&#125;</div><div class=\"line\">        &lt;Redirect from='*' to='/404' /&gt;</div><div class=\"line\">      &lt;/Route&gt;</div><div class=\"line\">    &lt;/Router&gt;</div></pre></td></tr></table></figure>\n<p>当改写之后，我们需要把这个重定向的路由单独拆出来，也就是  <code>*</code> 这个路由，我们上面已经为他创建了一个 <code>redirect</code> 目录。这里使用到 onEnter 方法，然后在这个方法里改变路由状态，调到另外的路由，实现 redirect ：</p>\n<h3 id=\"redirect-index-js\"><a href=\"#redirect-index-js\" class=\"headerlink\" title=\"/redirect/index.js\"></a>/redirect/index.js</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">'*'</span>,</div><div class=\"line\">  <span class=\"attr\">onEnter</span>: <span class=\"function\">(<span class=\"params\">_, replaceState</span>) =&gt;</span> replaceState(<span class=\"literal\">null</span>, <span class=\"string\">\"/404\"</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"The-root-route-must-render-a-single-element\"><a href=\"#The-root-route-must-render-a-single-element\" class=\"headerlink\" title=\"The root route must render a single element\"></a>The root route must render a single element</h2><p>跟着官方示例和上面码出来之后，可能页面并没有渲染出来，而是报 <strong>The root route must render a single element</strong> 这个异常，这是因为 <code>module.exports</code> 和 ES6 里的 <code>export default</code> 有区别。</p>\n<p>如果你是使用 es6 的写法，也就是你的组件都是通过 <code>export default</code> 导出的，那么在 <code>getComponent</code> 方法里面需要加入 <code>.default</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">getComponent(nextState, cb) &#123;</div><div class=\"line\">    <span class=\"built_in\">require</span>.ensure([], (<span class=\"built_in\">require</span>) =&gt; &#123;</div><div class=\"line\">      <span class=\"comment\">// 在后面加 .default</span></div><div class=\"line\">      cb(<span class=\"literal\">null</span>, <span class=\"built_in\">require</span>(<span class=\"string\">'components/layer/ReportPage'</span>)).default</div><div class=\"line\">    &#125;, <span class=\"string\">'ReportPage'</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果你是使用 CommonJS 的写法，也就是通过 <code>module.exports</code> 导出的，那就无须加 <code>.default</code> 了。</p>\n","excerpt":"<p>React Router 是一个非常出色的路由解决方案，同时也非常容易上手。但是当网站规模越来越大的时候，首先出现的问题是 Javascript 文件变得巨大，这导致首页渲染的时间让人难以忍受。实际上程序应当只加载当前渲染页所需的 JavaScript，也就是大家说的“代码分拆” — 将所有的代码分拆成多个小包，在用户浏览过程中按需加载。</p>","more":"<p>官方示例在 <a href=\"https://github.com/ReactTraining/react-router/tree/master/examples/huge-apps\">这里</a>。</p>\n<p>所得到的效果是：</p>\n<p>以前是这样（23333，我真不是故意的。。）</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/react-router-dynamic/01.png\" alt=\"\"></p>\n<p>现在是这样：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/react-router-dynamic/02.png\" alt=\"\"></p>\n<p>实际上就是将一个大 javascript 文件拆分成了若干个 chunk file。</p>\n<p>下面是改造过程</p>\n<h2 id=\"Webpack-配置\"><a href=\"#Webpack-配置\" class=\"headerlink\" title=\"Webpack 配置\"></a>Webpack 配置</h2><p>首先在 <code>webpack.config.js</code> 的 <code>output</code> 内加上 <code>chunkFilename</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">output: &#123;</div><div class=\"line\">    <span class=\"attr\">path</span>: path.join(__dirname, <span class=\"string\">'/../dist/assets'</span>),</div><div class=\"line\">    <span class=\"attr\">filename</span>: <span class=\"string\">'app.js'</span>,</div><div class=\"line\">    <span class=\"attr\">publicPath</span>: defaultSettings.publicPath,</div><div class=\"line\">    <span class=\"comment\">// 添加 chunkFilename</span></div><div class=\"line\">    chunkFilename: <span class=\"string\">'[name].[chunkhash:5].chunk.js'</span>,</div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure>\n<p><code>name</code> 是在代码里为创建的 chunk 指定的名字，如果代码中没指定则 webpack 默认分配 id 作为 name。</p>\n<p><code>chunkhash</code> 是文件的 hash 码，这里只使用前五位。</p>\n<h2 id=\"添加首页\"><a href=\"#添加首页\" class=\"headerlink\" title=\"添加首页\"></a>添加首页</h2><p>以前你的路由大概应该是这样的：（作为需要按需加载的大型应用，路由肯定是相当复杂，这里只列举部分路由举例）</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  (</div><div class=\"line\">    &lt;Router history=&#123;browserHistory&#125;&gt;</div><div class=\"line\">      &#123;/* 主页 */&#125;</div><div class=\"line\">      &lt;Route path=\"/\" component=&#123;App&#125;&gt;</div><div class=\"line\">        &#123;/* 默认 */&#125;</div><div class=\"line\">        &lt;IndexRoute component=&#123;HomePage&#125; /&gt;</div><div class=\"line\"></div><div class=\"line\">        &#123;/* baidu */&#125;</div><div class=\"line\">        &lt;Route path=\"/baidu\" component=&#123;BaiduPage&#125;&gt;</div><div class=\"line\">          &lt;Route path=\"result\" component=&#123;BaiduResultPage&#125; /&gt;</div><div class=\"line\">          &lt;Route path=\"frequency\" component=&#123;BaiduFrequencyPage&#125; /&gt;</div><div class=\"line\">        &lt;/Route&gt;</div><div class=\"line\"></div><div class=\"line\">        &#123;/* 404 */&#125;</div><div class=\"line\">        &lt;Route path='/404' component=&#123;NotFoundPage&#125; /&gt;</div><div class=\"line\">        </div><div class=\"line\">        &#123;/* 其他重定向到 404 */&#125;</div><div class=\"line\">        &lt;Redirect from='*' to='/404' /&gt;</div><div class=\"line\">      &lt;/Route&gt;</div><div class=\"line\">    &lt;/Router&gt;</div><div class=\"line\">  ), document.getElementById('app')</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n<p>按需加载之后，我们需要让路由动态加载组件，需要将 <code>component</code> 换成 <code>getComponent</code>。首先将路由拆出来（因为路由庞大之后全部写在一起会很难看），创建一个根路由 rootRoute：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> rootRoute = &#123;</div><div class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">'/'</span>,</div><div class=\"line\">  <span class=\"attr\">indexRoute</span>: &#123;</div><div class=\"line\">    getComponent(nextState, cb) &#123;</div><div class=\"line\">      <span class=\"built_in\">require</span>.ensure([], (<span class=\"built_in\">require</span>) =&gt; &#123;</div><div class=\"line\">        cb(<span class=\"literal\">null</span>, <span class=\"built_in\">require</span>(<span class=\"string\">'components/layer/HomePage'</span>))</div><div class=\"line\">      &#125;, <span class=\"string\">'HomePage'</span>)</div><div class=\"line\">    &#125;,</div><div class=\"line\">  &#125;,</div><div class=\"line\">  getComponent(nextState, cb) &#123;</div><div class=\"line\">    <span class=\"built_in\">require</span>.ensure([], (<span class=\"built_in\">require</span>) =&gt; &#123;</div><div class=\"line\">      cb(<span class=\"literal\">null</span>, <span class=\"built_in\">require</span>(<span class=\"string\">'components/Main'</span>))</div><div class=\"line\">    &#125;, <span class=\"string\">'Main'</span>)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">childRoutes</span>: [</div><div class=\"line\">    <span class=\"built_in\">require</span>(<span class=\"string\">'./routes/baidu'</span>),</div><div class=\"line\">    <span class=\"built_in\">require</span>(<span class=\"string\">'./routes/404'</span>),</div><div class=\"line\">    <span class=\"built_in\">require</span>(<span class=\"string\">'./routes/redirect'</span>)</div><div class=\"line\">  ]</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  (</div><div class=\"line\">    &lt;Router</div><div class=\"line\">      history=&#123;browserHistory&#125;</div><div class=\"line\">      routes=&#123;rootRoute&#125;</div><div class=\"line\">      /&gt;</div><div class=\"line\">  ), document.getElementById('app')</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n<p>history 不变，在 Router 中添加 routes 属性，将创建的路由传递进去。</p>\n<p>这里有四个属性：</p>\n<h3 id=\"path\"><a href=\"#path\" class=\"headerlink\" title=\"path\"></a>path</h3><p>将匹配的路由，也就是以前的 path。</p>\n<h3 id=\"getComponent\"><a href=\"#getComponent\" class=\"headerlink\" title=\"getComponent\"></a>getComponent</h3><p>对应于以前的 component 属性，但是这个方法是异步的，也就是当路由匹配时，才会调用这个方法。</p>\n<p>这里面有个 <strong>require.ensure</strong> 方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">require</span>.ensure(dependencies, callback, chunkName)</div></pre></td></tr></table></figure>\n<p>这是 webpack 提供的方法，这也是按需加载的核心方法。第一个参数是依赖，第二个是回调函数，第三个就是上面提到的 chunkName，用来指定这个 chunk file 的 name。</p>\n<p>如果需要返回多个子组件，则使用 <code>getComponents</code> 方法，将多个组件作为一个对象的属性通过 <code>cb</code> 返回出去即可。这个在官方示例也有，但是我们这里并不需要，而且根组件是不能返回多个子组件的，所以使用 <code>getComponent</code>。</p>\n<h3 id=\"indexRoute\"><a href=\"#indexRoute\" class=\"headerlink\" title=\"indexRoute\"></a>indexRoute</h3><p>用来设置主页，对应于以前的 <code>&lt;IndexRoute&gt;</code>。</p>\n<p>注意这里的 indexRoute 写法， <strong>这是个对象，在对象里面使用 getComponent</strong>。</p>\n<h3 id=\"childRoutes\"><a href=\"#childRoutes\" class=\"headerlink\" title=\"childRoutes\"></a>childRoutes</h3><p>这里面放置的就是子路由的配置，对应于以前的子路由们。我们将以前的 <code>/baidu</code>、<code>/404</code> 和 <code>*</code> 都拆了出来，接下来将分别为他们创建路由配置。</p>\n<h2 id=\"路由控制\"><a href=\"#路由控制\" class=\"headerlink\" title=\"路由控制\"></a>路由控制</h2><p>上面的<code>childRoutes</code> 里面，我们 require 了三个子路由，在目录下创建 <code>routes</code> 目录，将这三个路由放置进去。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">routes/</div><div class=\"line\">├── 404</div><div class=\"line\">│   └── index.js</div><div class=\"line\">├── baidu</div><div class=\"line\">│   ├── index.js</div><div class=\"line\">│   └── routes</div><div class=\"line\">│       ├── frequency</div><div class=\"line\">│       │   └── index.js</div><div class=\"line\">│       └── result</div><div class=\"line\">│           └── index.js</div><div class=\"line\">└── redirect</div><div class=\"line\">    └── index.js</div></pre></td></tr></table></figure>\n<p>和 rootRoute 类似，里面的每个 index.js 都是一个路由对象：</p>\n<h3 id=\"404-index-js\"><a href=\"#404-index-js\" class=\"headerlink\" title=\"/404/index.js\"></a>/404/index.js</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">'404'</span>,</div><div class=\"line\"></div><div class=\"line\">  getComponent(nextState, cb) &#123;</div><div class=\"line\">    <span class=\"built_in\">require</span>.ensure([], (<span class=\"built_in\">require</span>) =&gt; &#123;</div><div class=\"line\">      cb(<span class=\"literal\">null</span>, <span class=\"built_in\">require</span>(<span class=\"string\">'components/layer/NotFoundPage'</span>))</div><div class=\"line\">    &#125;, <span class=\"string\">'NotFoundPage'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"baidu-index-js\"><a href=\"#baidu-index-js\" class=\"headerlink\" title=\"/baidu/index.js\"></a>/baidu/index.js</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">'baidu'</span>,</div><div class=\"line\"></div><div class=\"line\">  getChildRoutes(partialNextState, cb) &#123;</div><div class=\"line\">    <span class=\"built_in\">require</span>.ensure([], (<span class=\"built_in\">require</span>) =&gt; &#123;</div><div class=\"line\">      cb(<span class=\"literal\">null</span>, [</div><div class=\"line\">        <span class=\"built_in\">require</span>(<span class=\"string\">'./routes/result'</span>),</div><div class=\"line\">        <span class=\"built_in\">require</span>(<span class=\"string\">'./routes/frequency'</span>)</div><div class=\"line\">      ])</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  getComponent(nextState, cb) &#123;</div><div class=\"line\">    <span class=\"built_in\">require</span>.ensure([], (<span class=\"built_in\">require</span>) =&gt; &#123;</div><div class=\"line\">      cb(<span class=\"literal\">null</span>, <span class=\"built_in\">require</span>(<span class=\"string\">'components/layer/BaiduPage'</span>))</div><div class=\"line\">    &#125;, <span class=\"string\">'BaiduPage'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"baidu-routes-frequency-index-js\"><a href=\"#baidu-routes-frequency-index-js\" class=\"headerlink\" title=\"/baidu/routes/frequency/index.js\"></a>/baidu/routes/frequency/index.js</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">'frequency'</span>,</div><div class=\"line\"></div><div class=\"line\">  getComponent(nextState, cb) &#123;</div><div class=\"line\">    <span class=\"built_in\">require</span>.ensure([], (<span class=\"built_in\">require</span>) =&gt; &#123;</div><div class=\"line\">      cb(<span class=\"literal\">null</span>, <span class=\"built_in\">require</span>(<span class=\"string\">'components/layer/BaiduFrequencyPage'</span>))</div><div class=\"line\">    &#125;, <span class=\"string\">'BaiduFrequencyPage'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>举这几个例子应该就差不多了，其他都是一样的，稍微有点特别的是 redirect。</p>\n<h2 id=\"设置-Redirect\"><a href=\"#设置-Redirect\" class=\"headerlink\" title=\"设置 Redirect\"></a>设置 Redirect</h2><p>之前我们在根路由下是这么设置重定向的：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Router history=&#123;browserHistory&#125;&gt;</div><div class=\"line\">      &lt;Route path=\"/\" component=&#123;App&#125;&gt;</div><div class=\"line\">        &#123;/* home */&#125;</div><div class=\"line\">        &lt;IndexRoute component=&#123;HomePage&#125; /&gt;</div><div class=\"line\"></div><div class=\"line\">        &lt;Route path=\"/baidu\" component=&#123;BaiduPage&#125;&gt;</div><div class=\"line\">          &lt;Route path=\"result\" component=&#123;BaiduResultPage&#125; /&gt;</div><div class=\"line\">          &lt;Route path=\"frequency\" component=&#123;BaiduFrequencyPage&#125; /&gt;</div><div class=\"line\">        &lt;/Route&gt;</div><div class=\"line\"></div><div class=\"line\">        &lt;Route path='/404' component=&#123;NotFoundPage&#125; /&gt;</div><div class=\"line\">        &#123;/* 如果都不匹配，重定向到 404 */&#125;</div><div class=\"line\">        &lt;Redirect from='*' to='/404' /&gt;</div><div class=\"line\">      &lt;/Route&gt;</div><div class=\"line\">    &lt;/Router&gt;</div></pre></td></tr></table></figure>\n<p>当改写之后，我们需要把这个重定向的路由单独拆出来，也就是  <code>*</code> 这个路由，我们上面已经为他创建了一个 <code>redirect</code> 目录。这里使用到 onEnter 方法，然后在这个方法里改变路由状态，调到另外的路由，实现 redirect ：</p>\n<h3 id=\"redirect-index-js\"><a href=\"#redirect-index-js\" class=\"headerlink\" title=\"/redirect/index.js\"></a>/redirect/index.js</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">'*'</span>,</div><div class=\"line\">  <span class=\"attr\">onEnter</span>: <span class=\"function\">(<span class=\"params\">_, replaceState</span>) =&gt;</span> replaceState(<span class=\"literal\">null</span>, <span class=\"string\">\"/404\"</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"The-root-route-must-render-a-single-element\"><a href=\"#The-root-route-must-render-a-single-element\" class=\"headerlink\" title=\"The root route must render a single element\"></a>The root route must render a single element</h2><p>跟着官方示例和上面码出来之后，可能页面并没有渲染出来，而是报 <strong>The root route must render a single element</strong> 这个异常，这是因为 <code>module.exports</code> 和 ES6 里的 <code>export default</code> 有区别。</p>\n<p>如果你是使用 es6 的写法，也就是你的组件都是通过 <code>export default</code> 导出的，那么在 <code>getComponent</code> 方法里面需要加入 <code>.default</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">getComponent(nextState, cb) &#123;</div><div class=\"line\">    <span class=\"built_in\">require</span>.ensure([], (<span class=\"built_in\">require</span>) =&gt; &#123;</div><div class=\"line\">      <span class=\"comment\">// 在后面加 .default</span></div><div class=\"line\">      cb(<span class=\"literal\">null</span>, <span class=\"built_in\">require</span>(<span class=\"string\">'components/layer/ReportPage'</span>)).default</div><div class=\"line\">    &#125;, <span class=\"string\">'ReportPage'</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果你是使用 CommonJS 的写法，也就是通过 <code>module.exports</code> 导出的，那就无须加 <code>.default</code> 了。</p>"},{"title":"红黑树","date":"2016-08-07T15:10:57.000Z","_content":"\n红黑树是二叉搜索树的一种，同时也是一种平衡搜索树，在红黑树中，没有一条路径会比其他路径长出 2 倍，因此它是近似平衡的。\n\n<!-- more -->\n\n红黑树中的每个结点都有一个颜色，颜色可以是黑色或者红色，红黑树根据结点的颜色对树进行约束，从而保持树的平衡。\n\n一颗红黑树是满足下面红黑性质的二叉搜索树：\n\n1. 每个结点要么是红色，要么是黑色\n2. 根结点是黑色的\n3. 每个叶结点是黑色的\n4. 如果一个结点是红色，则它的两个子结点都是黑色的\n5. 对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点\n\n由性质 2 和 4 可知，红黑树中最短的路径是结点全部为黑色的路径，最长的路径是红黑相间的路径，所以在红黑树中，不会出现一条路径比其他路径长 2 倍。\n\n相比于以前使用 null 来表示边界，在红黑树中，我们引入哨兵 `nil` 来处理边界条件。哨兵和普通结点拥有相同属性，但作为叶子结点的哨兵根据性质 3，它的颜色应该是黑色的。\n\n如下就是一颗红黑树：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/red-black-tree.png)\n\n## 旋转\n\n红黑树和二叉搜索树很类似，但因为引入了红黑性质，所以在对红黑树进行插入和删除等操作的时候，很可能破坏红黑性质，这时候需要对树进行调整，改变一些结点的位置。\n\n旋转是调整树结构的一种操作，分为左旋和右旋。如下\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/rotate.png)\n\n在旋转中，只有指针会改变，其他属性都保持不变。\n\n```javascript\nleftRotate(node) {\n  let rNode = node.right;\n  node.right = rNode.left;\n  if(rNode.left != this.nil) {\n    rNode.left.parent = node;\n  }\n\n  rNode.parent = node.parent;\n  rNode.left = node;\n  node.parent = rNode;\n\n  if(rNode.parent == this.nil) {\n    this.root = rNode;\n  } else {\n    if(rNode.key < rNode.parent.key) {\n      rNode.parent.left = rNode;\n    } else {\n      rNode.parent.right = rNode;\n    }\n  }\n}\n\nrightRotate(node) {\n  let lNode = node.left;\n  node.left = lNode.right;\n  if(lNode.right != this.nil) {\n    lNode.right.parent = node;\n  }\n\n  lNode.parent = node.parent;\n  lNode.right = node;\n  node.parent = lNode;\n\n  if(lNode.parent == this.nil) {\n    this.root = lNode;\n  } else {\n    if(lNode.key < lNode.parent.key) {\n      lNode.parent.left = lNode;\n    } else {\n      lNode.parent.right = lNode;\n    }\n  }\n}\n```\n\n## 插入\n\n将新结点插入到红黑树中时，如果新结点是黑色，则势必会破坏性质 5，而红色可能一条性质也不会破坏，所以我们选择红色为新结点的默认颜色。\n\n插入之前我们需要先找到要插入的位置，这里和二叉搜索树是一样的。\n\n```javascript\nclass TreeNode {\n  constructor() {\n    this.parent = null;\n    this.left = null;\n    this.right = null;\n    this.key = 'nil';\n    this.color = 'black';\n  }\n\n  toString() {\n    return this.key + ',' + this.color;\n  }\n}\n\nclass RedBlackTree {\n\n  constructor() {\n    this.nil = new TreeNode();\n    this.root = this.nil;\n  }\n\n  insert(key) {\n    let curNode = this.root;\n    let parent = this.nil;\n    // 找到要插入的位置\n    while(curNode != this.nil) {\n      parent = curNode;\n      if(key < curNode.key) {\n        curNode = curNode.left;\n      } else {\n        curNode = curNode.right;\n      }\n    }\n\n    let node = new TreeNode();\n    node.key = key;\n    node.parent = parent;\n    node.left = this.nil;\n    node.right = this.nil;\n\n    if(parent == this.nil) {\n      // 如果树中没有结点，插入结点为根结点\n      node.color = 'black';\n      this.root = node;\n    } else {\n      // 插入到正确的地方\n      node.color = 'red';\n      if(node.key < parent.key) {\n        parent.left = node;\n      } else {\n        parent.right = node;\n      }\n      // 调整树的结构\n      this.insertFix(node);\n    }\n  }\n}\n```\n\n`insertFix` 方法的作用是在插入结点后调整树的结构，在有新的红色结点插入到树中后，有哪些性质可能被破坏呢？\n\n- 性质 1 显然不会被破坏。\n\n- 如果插入元素是根结点时，会破坏性质 2。\n\n- 性质 3 不会被破坏，因为叶子结点始终是哨兵。\n\n- 如果插入元素的父结点是红色，那么性质 4 会被破坏。\n\n- 性质 5 不会被破坏，因为插入的结点是红色，不会影响路径中黑色结点的个数。\n\n所以在调整树的结构时，我们只需关注性质 2 和 4。\n\n### 情况一\n\n如果插入结点的父结点是黑色结点，那么性质 12345 全部继续成立，不需要调整树的结构。\n\n### 情况二\n\n如果插入结点的父结点是红色结点。\n\n因为插入之前这课树是一颗红黑树，那么插入结点的父结点的父结点（图中的 B 结点）必定是黑色（否则违反性质 4）。如下图，R 表示红色，B 表示黑色：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/01.png)\n\n但不确定 C 是什么颜色。\n\n#### a) C 是红色\n\n因为 D 和 B 的颜色起了冲突，必定需要改变其中一个结点的颜色，如果改变 D 的颜色，会破坏性质 5，而如果改变 B 的颜色，为了维持性质 5，我们可以选择将 A 和 C 的颜色也改变，即：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/02.png)\n\n这个时候性质 5 不会被破坏，但因为 A 的颜色变了，可能会与 A 的父结点颜色冲突，所以我们需要把 A 看作新插入结点，重新进行判断。\n\n#### b) C 是黑色或者 C 是 nil\n\n如果 C 是黑色，我们仍然改变 A 和 B 的颜色，但是为了保证性质 5 成立，所以可以对 A 和 B 进行右旋：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/03.png)\n\n当 D 是 B 的右子树时，先将 B 和 D 左旋，然后变成上面这种情况，再对 A、B 进行右旋。\n\n以上情况二是假设 D 和 B 是 A 的左子树，当 D 和 B 是 A 的右子树时，需要把方向换一下，原理是相同的。\n\n```Javascript\nclass RedBlackTree {\n\n  constructor() {\n    //...\n  }\n\n  insert(key) {\n    //...\n  }\n\n  insertFix(node) {\n    while(node.parent.color == 'red') {\n      if(node.parent == node.parent.parent.left) {\n        let uncle = node.parent.parent.right;\n        if(uncle.color == 'red') {\n          // 叔结点是红色\n          node.parent.color = 'black';\n          uncle.color = 'black';\n          node.parent.parent.color = 'red';\n          node = node.parent.parent;\n        } else {\n          // 旋转\n          if(node == node.parent.right) {\n            node = node.parent;\n            this.leftRotate(node);\n          }\n          node.parent.color = 'black';\n          node.parent.parent.color = 'red';\n          this.rightRotate(node.parent.parent); \n        }\n      } else {\n        let uncle = node.parent.parent.left;\n        if(uncle.color == 'red') {\n          // 叔结点是红色\n          node.parent.color = 'black';\n          uncle.color = 'black';\n          node.parent.parent.color = 'red';\n          node = node.parent.parent;\n        } else {\n          if(node == node.parent.left) {\n            node = node.parent;\n            this.rightRotate(node);\n          }\n          node.parent.color = 'black';\n          node.parent.parent.color = 'red';\n          this.leftRotate(node.parent.parent);\n        }\n      }\n    }\n    this.root.color = 'black';\n  }\n\n  leftRotate(node) {\n    //...\n  }\n\n  rightRotate(node) {\n    //...\n  }\n}\n```","source":"_posts/red-black-tree.md","raw":"---\ntitle: 红黑树\ndate: 2016-08-07 23:10:57\ntags: [数据结构]\n---\n\n红黑树是二叉搜索树的一种，同时也是一种平衡搜索树，在红黑树中，没有一条路径会比其他路径长出 2 倍，因此它是近似平衡的。\n\n<!-- more -->\n\n红黑树中的每个结点都有一个颜色，颜色可以是黑色或者红色，红黑树根据结点的颜色对树进行约束，从而保持树的平衡。\n\n一颗红黑树是满足下面红黑性质的二叉搜索树：\n\n1. 每个结点要么是红色，要么是黑色\n2. 根结点是黑色的\n3. 每个叶结点是黑色的\n4. 如果一个结点是红色，则它的两个子结点都是黑色的\n5. 对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点\n\n由性质 2 和 4 可知，红黑树中最短的路径是结点全部为黑色的路径，最长的路径是红黑相间的路径，所以在红黑树中，不会出现一条路径比其他路径长 2 倍。\n\n相比于以前使用 null 来表示边界，在红黑树中，我们引入哨兵 `nil` 来处理边界条件。哨兵和普通结点拥有相同属性，但作为叶子结点的哨兵根据性质 3，它的颜色应该是黑色的。\n\n如下就是一颗红黑树：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/red-black-tree.png)\n\n## 旋转\n\n红黑树和二叉搜索树很类似，但因为引入了红黑性质，所以在对红黑树进行插入和删除等操作的时候，很可能破坏红黑性质，这时候需要对树进行调整，改变一些结点的位置。\n\n旋转是调整树结构的一种操作，分为左旋和右旋。如下\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/rotate.png)\n\n在旋转中，只有指针会改变，其他属性都保持不变。\n\n```javascript\nleftRotate(node) {\n  let rNode = node.right;\n  node.right = rNode.left;\n  if(rNode.left != this.nil) {\n    rNode.left.parent = node;\n  }\n\n  rNode.parent = node.parent;\n  rNode.left = node;\n  node.parent = rNode;\n\n  if(rNode.parent == this.nil) {\n    this.root = rNode;\n  } else {\n    if(rNode.key < rNode.parent.key) {\n      rNode.parent.left = rNode;\n    } else {\n      rNode.parent.right = rNode;\n    }\n  }\n}\n\nrightRotate(node) {\n  let lNode = node.left;\n  node.left = lNode.right;\n  if(lNode.right != this.nil) {\n    lNode.right.parent = node;\n  }\n\n  lNode.parent = node.parent;\n  lNode.right = node;\n  node.parent = lNode;\n\n  if(lNode.parent == this.nil) {\n    this.root = lNode;\n  } else {\n    if(lNode.key < lNode.parent.key) {\n      lNode.parent.left = lNode;\n    } else {\n      lNode.parent.right = lNode;\n    }\n  }\n}\n```\n\n## 插入\n\n将新结点插入到红黑树中时，如果新结点是黑色，则势必会破坏性质 5，而红色可能一条性质也不会破坏，所以我们选择红色为新结点的默认颜色。\n\n插入之前我们需要先找到要插入的位置，这里和二叉搜索树是一样的。\n\n```javascript\nclass TreeNode {\n  constructor() {\n    this.parent = null;\n    this.left = null;\n    this.right = null;\n    this.key = 'nil';\n    this.color = 'black';\n  }\n\n  toString() {\n    return this.key + ',' + this.color;\n  }\n}\n\nclass RedBlackTree {\n\n  constructor() {\n    this.nil = new TreeNode();\n    this.root = this.nil;\n  }\n\n  insert(key) {\n    let curNode = this.root;\n    let parent = this.nil;\n    // 找到要插入的位置\n    while(curNode != this.nil) {\n      parent = curNode;\n      if(key < curNode.key) {\n        curNode = curNode.left;\n      } else {\n        curNode = curNode.right;\n      }\n    }\n\n    let node = new TreeNode();\n    node.key = key;\n    node.parent = parent;\n    node.left = this.nil;\n    node.right = this.nil;\n\n    if(parent == this.nil) {\n      // 如果树中没有结点，插入结点为根结点\n      node.color = 'black';\n      this.root = node;\n    } else {\n      // 插入到正确的地方\n      node.color = 'red';\n      if(node.key < parent.key) {\n        parent.left = node;\n      } else {\n        parent.right = node;\n      }\n      // 调整树的结构\n      this.insertFix(node);\n    }\n  }\n}\n```\n\n`insertFix` 方法的作用是在插入结点后调整树的结构，在有新的红色结点插入到树中后，有哪些性质可能被破坏呢？\n\n- 性质 1 显然不会被破坏。\n\n- 如果插入元素是根结点时，会破坏性质 2。\n\n- 性质 3 不会被破坏，因为叶子结点始终是哨兵。\n\n- 如果插入元素的父结点是红色，那么性质 4 会被破坏。\n\n- 性质 5 不会被破坏，因为插入的结点是红色，不会影响路径中黑色结点的个数。\n\n所以在调整树的结构时，我们只需关注性质 2 和 4。\n\n### 情况一\n\n如果插入结点的父结点是黑色结点，那么性质 12345 全部继续成立，不需要调整树的结构。\n\n### 情况二\n\n如果插入结点的父结点是红色结点。\n\n因为插入之前这课树是一颗红黑树，那么插入结点的父结点的父结点（图中的 B 结点）必定是黑色（否则违反性质 4）。如下图，R 表示红色，B 表示黑色：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/01.png)\n\n但不确定 C 是什么颜色。\n\n#### a) C 是红色\n\n因为 D 和 B 的颜色起了冲突，必定需要改变其中一个结点的颜色，如果改变 D 的颜色，会破坏性质 5，而如果改变 B 的颜色，为了维持性质 5，我们可以选择将 A 和 C 的颜色也改变，即：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/02.png)\n\n这个时候性质 5 不会被破坏，但因为 A 的颜色变了，可能会与 A 的父结点颜色冲突，所以我们需要把 A 看作新插入结点，重新进行判断。\n\n#### b) C 是黑色或者 C 是 nil\n\n如果 C 是黑色，我们仍然改变 A 和 B 的颜色，但是为了保证性质 5 成立，所以可以对 A 和 B 进行右旋：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/03.png)\n\n当 D 是 B 的右子树时，先将 B 和 D 左旋，然后变成上面这种情况，再对 A、B 进行右旋。\n\n以上情况二是假设 D 和 B 是 A 的左子树，当 D 和 B 是 A 的右子树时，需要把方向换一下，原理是相同的。\n\n```Javascript\nclass RedBlackTree {\n\n  constructor() {\n    //...\n  }\n\n  insert(key) {\n    //...\n  }\n\n  insertFix(node) {\n    while(node.parent.color == 'red') {\n      if(node.parent == node.parent.parent.left) {\n        let uncle = node.parent.parent.right;\n        if(uncle.color == 'red') {\n          // 叔结点是红色\n          node.parent.color = 'black';\n          uncle.color = 'black';\n          node.parent.parent.color = 'red';\n          node = node.parent.parent;\n        } else {\n          // 旋转\n          if(node == node.parent.right) {\n            node = node.parent;\n            this.leftRotate(node);\n          }\n          node.parent.color = 'black';\n          node.parent.parent.color = 'red';\n          this.rightRotate(node.parent.parent); \n        }\n      } else {\n        let uncle = node.parent.parent.left;\n        if(uncle.color == 'red') {\n          // 叔结点是红色\n          node.parent.color = 'black';\n          uncle.color = 'black';\n          node.parent.parent.color = 'red';\n          node = node.parent.parent;\n        } else {\n          if(node == node.parent.left) {\n            node = node.parent;\n            this.rightRotate(node);\n          }\n          node.parent.color = 'black';\n          node.parent.parent.color = 'red';\n          this.leftRotate(node.parent.parent);\n        }\n      }\n    }\n    this.root.color = 'black';\n  }\n\n  leftRotate(node) {\n    //...\n  }\n\n  rightRotate(node) {\n    //...\n  }\n}\n```","slug":"red-black-tree","published":1,"updated":"2017-03-17T13:40:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcwy002kn927a7d44nrm","content":"<p>红黑树是二叉搜索树的一种，同时也是一种平衡搜索树，在红黑树中，没有一条路径会比其他路径长出 2 倍，因此它是近似平衡的。</p>\n<a id=\"more\"></a>\n<p>红黑树中的每个结点都有一个颜色，颜色可以是黑色或者红色，红黑树根据结点的颜色对树进行约束，从而保持树的平衡。</p>\n<p>一颗红黑树是满足下面红黑性质的二叉搜索树：</p>\n<ol>\n<li>每个结点要么是红色，要么是黑色</li>\n<li>根结点是黑色的</li>\n<li>每个叶结点是黑色的</li>\n<li>如果一个结点是红色，则它的两个子结点都是黑色的</li>\n<li>对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点</li>\n</ol>\n<p>由性质 2 和 4 可知，红黑树中最短的路径是结点全部为黑色的路径，最长的路径是红黑相间的路径，所以在红黑树中，不会出现一条路径比其他路径长 2 倍。</p>\n<p>相比于以前使用 null 来表示边界，在红黑树中，我们引入哨兵 <code>nil</code> 来处理边界条件。哨兵和普通结点拥有相同属性，但作为叶子结点的哨兵根据性质 3，它的颜色应该是黑色的。</p>\n<p>如下就是一颗红黑树：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/red-black-tree.png\" alt=\"\"></p>\n<h2 id=\"旋转\"><a href=\"#旋转\" class=\"headerlink\" title=\"旋转\"></a>旋转</h2><p>红黑树和二叉搜索树很类似，但因为引入了红黑性质，所以在对红黑树进行插入和删除等操作的时候，很可能破坏红黑性质，这时候需要对树进行调整，改变一些结点的位置。</p>\n<p>旋转是调整树结构的一种操作，分为左旋和右旋。如下</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/rotate.png\" alt=\"\"></p>\n<p>在旋转中，只有指针会改变，其他属性都保持不变。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">leftRotate(node) &#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> rNode = node.right;</div><div class=\"line\">  node.right = rNode.left;</div><div class=\"line\">  <span class=\"keyword\">if</span>(rNode.left != <span class=\"keyword\">this</span>.nil) &#123;</div><div class=\"line\">    rNode.left.parent = node;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  rNode.parent = node.parent;</div><div class=\"line\">  rNode.left = node;</div><div class=\"line\">  node.parent = rNode;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(rNode.parent == <span class=\"keyword\">this</span>.nil) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.root = rNode;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(rNode.key &lt; rNode.parent.key) &#123;</div><div class=\"line\">      rNode.parent.left = rNode;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      rNode.parent.right = rNode;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">rightRotate(node) &#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> lNode = node.left;</div><div class=\"line\">  node.left = lNode.right;</div><div class=\"line\">  <span class=\"keyword\">if</span>(lNode.right != <span class=\"keyword\">this</span>.nil) &#123;</div><div class=\"line\">    lNode.right.parent = node;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  lNode.parent = node.parent;</div><div class=\"line\">  lNode.right = node;</div><div class=\"line\">  node.parent = lNode;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(lNode.parent == <span class=\"keyword\">this</span>.nil) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.root = lNode;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(lNode.key &lt; lNode.parent.key) &#123;</div><div class=\"line\">      lNode.parent.left = lNode;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      lNode.parent.right = lNode;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h2><p>将新结点插入到红黑树中时，如果新结点是黑色，则势必会破坏性质 5，而红色可能一条性质也不会破坏，所以我们选择红色为新结点的默认颜色。</p>\n<p>插入之前我们需要先找到要插入的位置，这里和二叉搜索树是一样的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.parent = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.left = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.right = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.key = <span class=\"string\">'nil'</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.key + <span class=\"string\">','</span> + <span class=\"keyword\">this</span>.color;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedBlackTree</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.nil = <span class=\"keyword\">new</span> TreeNode();</div><div class=\"line\">    <span class=\"keyword\">this</span>.root = <span class=\"keyword\">this</span>.nil;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  insert(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.root;</div><div class=\"line\">    <span class=\"keyword\">let</span> parent = <span class=\"keyword\">this</span>.nil;</div><div class=\"line\">    <span class=\"comment\">// 找到要插入的位置</span></div><div class=\"line\">    <span class=\"keyword\">while</span>(curNode != <span class=\"keyword\">this</span>.nil) &#123;</div><div class=\"line\">      parent = curNode;</div><div class=\"line\">      <span class=\"keyword\">if</span>(key &lt; curNode.key) &#123;</div><div class=\"line\">        curNode = curNode.left;</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        curNode = curNode.right;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">let</span> node = <span class=\"keyword\">new</span> TreeNode();</div><div class=\"line\">    node.key = key;</div><div class=\"line\">    node.parent = parent;</div><div class=\"line\">    node.left = <span class=\"keyword\">this</span>.nil;</div><div class=\"line\">    node.right = <span class=\"keyword\">this</span>.nil;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(parent == <span class=\"keyword\">this</span>.nil) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果树中没有结点，插入结点为根结点</span></div><div class=\"line\">      node.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">      <span class=\"keyword\">this</span>.root = node;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 插入到正确的地方</span></div><div class=\"line\">      node.color = <span class=\"string\">'red'</span>;</div><div class=\"line\">      <span class=\"keyword\">if</span>(node.key &lt; parent.key) &#123;</div><div class=\"line\">        parent.left = node;</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        parent.right = node;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">// 调整树的结构</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.insertFix(node);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>insertFix</code> 方法的作用是在插入结点后调整树的结构，在有新的红色结点插入到树中后，有哪些性质可能被破坏呢？</p>\n<ul>\n<li><p>性质 1 显然不会被破坏。</p>\n</li>\n<li><p>如果插入元素是根结点时，会破坏性质 2。</p>\n</li>\n<li><p>性质 3 不会被破坏，因为叶子结点始终是哨兵。</p>\n</li>\n<li><p>如果插入元素的父结点是红色，那么性质 4 会被破坏。</p>\n</li>\n<li><p>性质 5 不会被破坏，因为插入的结点是红色，不会影响路径中黑色结点的个数。</p>\n</li>\n</ul>\n<p>所以在调整树的结构时，我们只需关注性质 2 和 4。</p>\n<h3 id=\"情况一\"><a href=\"#情况一\" class=\"headerlink\" title=\"情况一\"></a>情况一</h3><p>如果插入结点的父结点是黑色结点，那么性质 12345 全部继续成立，不需要调整树的结构。</p>\n<h3 id=\"情况二\"><a href=\"#情况二\" class=\"headerlink\" title=\"情况二\"></a>情况二</h3><p>如果插入结点的父结点是红色结点。</p>\n<p>因为插入之前这课树是一颗红黑树，那么插入结点的父结点的父结点（图中的 B 结点）必定是黑色（否则违反性质 4）。如下图，R 表示红色，B 表示黑色：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/01.png\" alt=\"\"></p>\n<p>但不确定 C 是什么颜色。</p>\n<h4 id=\"a-C-是红色\"><a href=\"#a-C-是红色\" class=\"headerlink\" title=\"a) C 是红色\"></a>a) C 是红色</h4><p>因为 D 和 B 的颜色起了冲突，必定需要改变其中一个结点的颜色，如果改变 D 的颜色，会破坏性质 5，而如果改变 B 的颜色，为了维持性质 5，我们可以选择将 A 和 C 的颜色也改变，即：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/02.png\" alt=\"\"></p>\n<p>这个时候性质 5 不会被破坏，但因为 A 的颜色变了，可能会与 A 的父结点颜色冲突，所以我们需要把 A 看作新插入结点，重新进行判断。</p>\n<h4 id=\"b-C-是黑色或者-C-是-nil\"><a href=\"#b-C-是黑色或者-C-是-nil\" class=\"headerlink\" title=\"b) C 是黑色或者 C 是 nil\"></a>b) C 是黑色或者 C 是 nil</h4><p>如果 C 是黑色，我们仍然改变 A 和 B 的颜色，但是为了保证性质 5 成立，所以可以对 A 和 B 进行右旋：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/03.png\" alt=\"\"></p>\n<p>当 D 是 B 的右子树时，先将 B 和 D 左旋，然后变成上面这种情况，再对 A、B 进行右旋。</p>\n<p>以上情况二是假设 D 和 B 是 A 的左子树，当 D 和 B 是 A 的右子树时，需要把方向换一下，原理是相同的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedBlackTree</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  insert(key) &#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  insertFix(node) &#123;</div><div class=\"line\">    <span class=\"keyword\">while</span>(node.parent.color == <span class=\"string\">'red'</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(node.parent == node.parent.parent.left) &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> uncle = node.parent.parent.right;</div><div class=\"line\">        <span class=\"keyword\">if</span>(uncle.color == <span class=\"string\">'red'</span>) &#123;</div><div class=\"line\">          <span class=\"comment\">// 叔结点是红色</span></div><div class=\"line\">          node.parent.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">          uncle.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">          node.parent.parent.color = <span class=\"string\">'red'</span>;</div><div class=\"line\">          node = node.parent.parent;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          <span class=\"comment\">// 旋转</span></div><div class=\"line\">          <span class=\"keyword\">if</span>(node == node.parent.right) &#123;</div><div class=\"line\">            node = node.parent;</div><div class=\"line\">            <span class=\"keyword\">this</span>.leftRotate(node);</div><div class=\"line\">          &#125;</div><div class=\"line\">          node.parent.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">          node.parent.parent.color = <span class=\"string\">'red'</span>;</div><div class=\"line\">          <span class=\"keyword\">this</span>.rightRotate(node.parent.parent); </div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> uncle = node.parent.parent.left;</div><div class=\"line\">        <span class=\"keyword\">if</span>(uncle.color == <span class=\"string\">'red'</span>) &#123;</div><div class=\"line\">          <span class=\"comment\">// 叔结点是红色</span></div><div class=\"line\">          node.parent.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">          uncle.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">          node.parent.parent.color = <span class=\"string\">'red'</span>;</div><div class=\"line\">          node = node.parent.parent;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          <span class=\"keyword\">if</span>(node == node.parent.left) &#123;</div><div class=\"line\">            node = node.parent;</div><div class=\"line\">            <span class=\"keyword\">this</span>.rightRotate(node);</div><div class=\"line\">          &#125;</div><div class=\"line\">          node.parent.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">          node.parent.parent.color = <span class=\"string\">'red'</span>;</div><div class=\"line\">          <span class=\"keyword\">this</span>.leftRotate(node.parent.parent);</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.root.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  leftRotate(node) &#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  rightRotate(node) &#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","excerpt":"<p>红黑树是二叉搜索树的一种，同时也是一种平衡搜索树，在红黑树中，没有一条路径会比其他路径长出 2 倍，因此它是近似平衡的。</p>","more":"<p>红黑树中的每个结点都有一个颜色，颜色可以是黑色或者红色，红黑树根据结点的颜色对树进行约束，从而保持树的平衡。</p>\n<p>一颗红黑树是满足下面红黑性质的二叉搜索树：</p>\n<ol>\n<li>每个结点要么是红色，要么是黑色</li>\n<li>根结点是黑色的</li>\n<li>每个叶结点是黑色的</li>\n<li>如果一个结点是红色，则它的两个子结点都是黑色的</li>\n<li>对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点</li>\n</ol>\n<p>由性质 2 和 4 可知，红黑树中最短的路径是结点全部为黑色的路径，最长的路径是红黑相间的路径，所以在红黑树中，不会出现一条路径比其他路径长 2 倍。</p>\n<p>相比于以前使用 null 来表示边界，在红黑树中，我们引入哨兵 <code>nil</code> 来处理边界条件。哨兵和普通结点拥有相同属性，但作为叶子结点的哨兵根据性质 3，它的颜色应该是黑色的。</p>\n<p>如下就是一颗红黑树：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/red-black-tree.png\" alt=\"\"></p>\n<h2 id=\"旋转\"><a href=\"#旋转\" class=\"headerlink\" title=\"旋转\"></a>旋转</h2><p>红黑树和二叉搜索树很类似，但因为引入了红黑性质，所以在对红黑树进行插入和删除等操作的时候，很可能破坏红黑性质，这时候需要对树进行调整，改变一些结点的位置。</p>\n<p>旋转是调整树结构的一种操作，分为左旋和右旋。如下</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/rotate.png\" alt=\"\"></p>\n<p>在旋转中，只有指针会改变，其他属性都保持不变。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">leftRotate(node) &#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> rNode = node.right;</div><div class=\"line\">  node.right = rNode.left;</div><div class=\"line\">  <span class=\"keyword\">if</span>(rNode.left != <span class=\"keyword\">this</span>.nil) &#123;</div><div class=\"line\">    rNode.left.parent = node;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  rNode.parent = node.parent;</div><div class=\"line\">  rNode.left = node;</div><div class=\"line\">  node.parent = rNode;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(rNode.parent == <span class=\"keyword\">this</span>.nil) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.root = rNode;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(rNode.key &lt; rNode.parent.key) &#123;</div><div class=\"line\">      rNode.parent.left = rNode;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      rNode.parent.right = rNode;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">rightRotate(node) &#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> lNode = node.left;</div><div class=\"line\">  node.left = lNode.right;</div><div class=\"line\">  <span class=\"keyword\">if</span>(lNode.right != <span class=\"keyword\">this</span>.nil) &#123;</div><div class=\"line\">    lNode.right.parent = node;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  lNode.parent = node.parent;</div><div class=\"line\">  lNode.right = node;</div><div class=\"line\">  node.parent = lNode;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(lNode.parent == <span class=\"keyword\">this</span>.nil) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.root = lNode;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(lNode.key &lt; lNode.parent.key) &#123;</div><div class=\"line\">      lNode.parent.left = lNode;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      lNode.parent.right = lNode;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h2><p>将新结点插入到红黑树中时，如果新结点是黑色，则势必会破坏性质 5，而红色可能一条性质也不会破坏，所以我们选择红色为新结点的默认颜色。</p>\n<p>插入之前我们需要先找到要插入的位置，这里和二叉搜索树是一样的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.parent = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.left = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.right = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.key = <span class=\"string\">'nil'</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.key + <span class=\"string\">','</span> + <span class=\"keyword\">this</span>.color;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedBlackTree</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.nil = <span class=\"keyword\">new</span> TreeNode();</div><div class=\"line\">    <span class=\"keyword\">this</span>.root = <span class=\"keyword\">this</span>.nil;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  insert(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.root;</div><div class=\"line\">    <span class=\"keyword\">let</span> parent = <span class=\"keyword\">this</span>.nil;</div><div class=\"line\">    <span class=\"comment\">// 找到要插入的位置</span></div><div class=\"line\">    <span class=\"keyword\">while</span>(curNode != <span class=\"keyword\">this</span>.nil) &#123;</div><div class=\"line\">      parent = curNode;</div><div class=\"line\">      <span class=\"keyword\">if</span>(key &lt; curNode.key) &#123;</div><div class=\"line\">        curNode = curNode.left;</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        curNode = curNode.right;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">let</span> node = <span class=\"keyword\">new</span> TreeNode();</div><div class=\"line\">    node.key = key;</div><div class=\"line\">    node.parent = parent;</div><div class=\"line\">    node.left = <span class=\"keyword\">this</span>.nil;</div><div class=\"line\">    node.right = <span class=\"keyword\">this</span>.nil;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(parent == <span class=\"keyword\">this</span>.nil) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果树中没有结点，插入结点为根结点</span></div><div class=\"line\">      node.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">      <span class=\"keyword\">this</span>.root = node;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 插入到正确的地方</span></div><div class=\"line\">      node.color = <span class=\"string\">'red'</span>;</div><div class=\"line\">      <span class=\"keyword\">if</span>(node.key &lt; parent.key) &#123;</div><div class=\"line\">        parent.left = node;</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        parent.right = node;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">// 调整树的结构</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.insertFix(node);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>insertFix</code> 方法的作用是在插入结点后调整树的结构，在有新的红色结点插入到树中后，有哪些性质可能被破坏呢？</p>\n<ul>\n<li><p>性质 1 显然不会被破坏。</p>\n</li>\n<li><p>如果插入元素是根结点时，会破坏性质 2。</p>\n</li>\n<li><p>性质 3 不会被破坏，因为叶子结点始终是哨兵。</p>\n</li>\n<li><p>如果插入元素的父结点是红色，那么性质 4 会被破坏。</p>\n</li>\n<li><p>性质 5 不会被破坏，因为插入的结点是红色，不会影响路径中黑色结点的个数。</p>\n</li>\n</ul>\n<p>所以在调整树的结构时，我们只需关注性质 2 和 4。</p>\n<h3 id=\"情况一\"><a href=\"#情况一\" class=\"headerlink\" title=\"情况一\"></a>情况一</h3><p>如果插入结点的父结点是黑色结点，那么性质 12345 全部继续成立，不需要调整树的结构。</p>\n<h3 id=\"情况二\"><a href=\"#情况二\" class=\"headerlink\" title=\"情况二\"></a>情况二</h3><p>如果插入结点的父结点是红色结点。</p>\n<p>因为插入之前这课树是一颗红黑树，那么插入结点的父结点的父结点（图中的 B 结点）必定是黑色（否则违反性质 4）。如下图，R 表示红色，B 表示黑色：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/01.png\" alt=\"\"></p>\n<p>但不确定 C 是什么颜色。</p>\n<h4 id=\"a-C-是红色\"><a href=\"#a-C-是红色\" class=\"headerlink\" title=\"a) C 是红色\"></a>a) C 是红色</h4><p>因为 D 和 B 的颜色起了冲突，必定需要改变其中一个结点的颜色，如果改变 D 的颜色，会破坏性质 5，而如果改变 B 的颜色，为了维持性质 5，我们可以选择将 A 和 C 的颜色也改变，即：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/02.png\" alt=\"\"></p>\n<p>这个时候性质 5 不会被破坏，但因为 A 的颜色变了，可能会与 A 的父结点颜色冲突，所以我们需要把 A 看作新插入结点，重新进行判断。</p>\n<h4 id=\"b-C-是黑色或者-C-是-nil\"><a href=\"#b-C-是黑色或者-C-是-nil\" class=\"headerlink\" title=\"b) C 是黑色或者 C 是 nil\"></a>b) C 是黑色或者 C 是 nil</h4><p>如果 C 是黑色，我们仍然改变 A 和 B 的颜色，但是为了保证性质 5 成立，所以可以对 A 和 B 进行右旋：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/03.png\" alt=\"\"></p>\n<p>当 D 是 B 的右子树时，先将 B 和 D 左旋，然后变成上面这种情况，再对 A、B 进行右旋。</p>\n<p>以上情况二是假设 D 和 B 是 A 的左子树，当 D 和 B 是 A 的右子树时，需要把方向换一下，原理是相同的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedBlackTree</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  insert(key) &#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  insertFix(node) &#123;</div><div class=\"line\">    <span class=\"keyword\">while</span>(node.parent.color == <span class=\"string\">'red'</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(node.parent == node.parent.parent.left) &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> uncle = node.parent.parent.right;</div><div class=\"line\">        <span class=\"keyword\">if</span>(uncle.color == <span class=\"string\">'red'</span>) &#123;</div><div class=\"line\">          <span class=\"comment\">// 叔结点是红色</span></div><div class=\"line\">          node.parent.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">          uncle.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">          node.parent.parent.color = <span class=\"string\">'red'</span>;</div><div class=\"line\">          node = node.parent.parent;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          <span class=\"comment\">// 旋转</span></div><div class=\"line\">          <span class=\"keyword\">if</span>(node == node.parent.right) &#123;</div><div class=\"line\">            node = node.parent;</div><div class=\"line\">            <span class=\"keyword\">this</span>.leftRotate(node);</div><div class=\"line\">          &#125;</div><div class=\"line\">          node.parent.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">          node.parent.parent.color = <span class=\"string\">'red'</span>;</div><div class=\"line\">          <span class=\"keyword\">this</span>.rightRotate(node.parent.parent); </div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> uncle = node.parent.parent.left;</div><div class=\"line\">        <span class=\"keyword\">if</span>(uncle.color == <span class=\"string\">'red'</span>) &#123;</div><div class=\"line\">          <span class=\"comment\">// 叔结点是红色</span></div><div class=\"line\">          node.parent.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">          uncle.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">          node.parent.parent.color = <span class=\"string\">'red'</span>;</div><div class=\"line\">          node = node.parent.parent;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          <span class=\"keyword\">if</span>(node == node.parent.left) &#123;</div><div class=\"line\">            node = node.parent;</div><div class=\"line\">            <span class=\"keyword\">this</span>.rightRotate(node);</div><div class=\"line\">          &#125;</div><div class=\"line\">          node.parent.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">          node.parent.parent.color = <span class=\"string\">'red'</span>;</div><div class=\"line\">          <span class=\"keyword\">this</span>.leftRotate(node.parent.parent);</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.root.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  leftRotate(node) &#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  rightRotate(node) &#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"Javascript 中的线程与进程","date":"2016-08-26T23:43:34.000Z","_content":"\n写 javascript 写久了，就会对 javascript 的异步写法习以为常，反而不会好奇为什么在 javascript 里可以异步执行一个任务，是因为 javascript 是多线程吗？\n\n实际上，javascript 从来都是单线程的。目前 javascript 有两个主要的运行环境，一个是浏览器，一个是 nodejs，下面分别从这两个方面对这个问题进行解释。\n\n<!-- more -->\n\n## 浏览器\n\njavascript 的设计初衷，是为了解决一些简单的网页互动，也就是操作 DOM 元素。而如果采用多线程，那么大家都知道，多线程是可能会造成竞争资源的，很可能多个线程同时操作一个 DOM 元素，造成不必要的麻烦，所以 javascript 从诞生开始就选择了单线程执行。\n\n然而在前端开发中，会经常用到 `setTimeout` 这个函数，我们可以规定让一段逻辑在指定时间后执行：\n\n```javascript\nsetTimeout(function() {\n  console.log('timeout done');\n}, 3000);\n\nconsole.log('main task')\n```\n\n上面这段代码会先输出 `main task`，然后在 3 秒之后输出 `timeout done`。就好像 setTimeout 开启了一个新线程一样，实际上并不是这样。\n\n### Event loop\n\n实际上， JavaScript 运行时包含了一个待处理的消息队列，每一个消息都与一个函数相关联。同时有一个事件循环不停地在轮询这个队列，当队列不为空时，就从队列中取出一个消息进行处理。它的实现大概如此：\n\n```javascript\nwhile(queue.waitForMessage()){\n  queue.processNextMessage();\n}\n```\n\n所以，上面的例子调用 [setTimeout](https://developer.mozilla.org/en-US/docs/window.setTimeout) 函数会在一个时间段过去后在队列中添加一个消息，实际上没有创建一个新的线程，当时间到达时，如果在队列中它的前面还有其他消息没有处理，那么它也要先等前面的执行完才执行。所谓的异步执行，实际上是在主线程空闲的时候执行，可以看如下代码：\n\n```javascript\nvar startTime = new Date();\n\n// 第一个异步任务\nsetTimeout(function() {\n    console.log('task 1 start.');\n    while(true) {\n        var curTime = new Date();\n        if(curTime - startTime > 5000) {\n            break;\n        }\n    }\n    console.log('task 1 done.')\n}, 100);\n\n// 第二个异步任务\nsetTimeout(function() {\n    console.log('task 2 start.');\n}, 500);\n\nconsole.log('main');\n```\n\n程序第一个输出 `main`，这个毋庸置疑，但是第一个异步任务会执行 5 秒，而我们设置了第二个异步任务在 500 毫秒后执行，如果是多线程，`task 2 start` 会在 `task 1 done` 之前输出，然而结果是等 `task 1 done` 输出后才会输出 `task 2 done`。因为到 500 ms 时，task 2 被插入到消息队列中，然而此时task 1 还没有执行完，所以 task 2 紧接着 task 1 执行。示意图如下：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/thread-in-javascript/01.png)\n\n### webworker\n\n但是 javascript 能不能支持多线程呢，答案是可以的，在 HTML 5 规范中，新增了webworker 用来进行计算量大的操作，避免阻塞主线程，不过在webworker 创建的线程中，是不能操作 DOM 元素的，当 webworker 中的计算完成时可以通过事件与主线程进行通信。\n\n## Nodejs\n\n说完了浏览器端，现在说回 nodejs，nodejs 只是 javascript 的一个运行环境，实际上并不改变 javascript 是单线程执行的本质，但是 nodejs 可以提供一些方式来进行多线程和多进程开发。\n\n### 多线程\n\n#### [tagg](https://github.com/xk/node-threads-a-gogo)\n\nJorge Chamorro Bieling是 `tagg(Threads a gogo for Node.js)` 包的作者，他硬是利用 `phread` 库和C语言让Node.js支持了多线程的开发\n\n### libuvd\n\n`libuv` 是一个跨平台的异步I/O库，它主要用于Node.js的开发，同时他也被 `Mozilla's Rust language`,  `Luvit`, `Julia`,  `pyuv`等使用。它主要包括了 `Event loops` 事件循环， `Filesystem` 文件系统， `Networking` 网络支持，`Threads` 线程，`Processes` 进程，`Utilities` 其他工具。\n\n\n\n### 多进程\n\n#### child_process\n\n可以启动一个 nodejs 文件，将它作为 worker 进程，实现多进程解决主进程阻塞的问题。\n\n#### cluster\n\n`cluster`可以用来让Node.js充分利用多核cpu的性能，同时也可以让Node.js程序更加健壮，官网上的`cluster`示例已经告诉我们如何重新启动一个因为异常而奔溃的子进程。\n\n\n\n## 参考\n\n1. [Node.js的线程和进程](https://github.com/DoubleSpout/threadAndPackage/blob/master/chapter.7.thread_and_process.md)\n2. [Node.js 探秘：初识单线程的 Node.js](http://taobaofed.org/blog/2015/10/29/deep-into-node-1/)\n3. [细说JavaScript单线程的一些事](https://segmentfault.com/a/1190000004276027)\n4. [并发模型与Event Loop](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoo)","source":"_posts/thread-in-javascript.md","raw":"---\ntitle: Javascript 中的线程与进程\ndate: 2016-08-27 07:43:34\ntags: [总结, javascript]\n---\n\n写 javascript 写久了，就会对 javascript 的异步写法习以为常，反而不会好奇为什么在 javascript 里可以异步执行一个任务，是因为 javascript 是多线程吗？\n\n实际上，javascript 从来都是单线程的。目前 javascript 有两个主要的运行环境，一个是浏览器，一个是 nodejs，下面分别从这两个方面对这个问题进行解释。\n\n<!-- more -->\n\n## 浏览器\n\njavascript 的设计初衷，是为了解决一些简单的网页互动，也就是操作 DOM 元素。而如果采用多线程，那么大家都知道，多线程是可能会造成竞争资源的，很可能多个线程同时操作一个 DOM 元素，造成不必要的麻烦，所以 javascript 从诞生开始就选择了单线程执行。\n\n然而在前端开发中，会经常用到 `setTimeout` 这个函数，我们可以规定让一段逻辑在指定时间后执行：\n\n```javascript\nsetTimeout(function() {\n  console.log('timeout done');\n}, 3000);\n\nconsole.log('main task')\n```\n\n上面这段代码会先输出 `main task`，然后在 3 秒之后输出 `timeout done`。就好像 setTimeout 开启了一个新线程一样，实际上并不是这样。\n\n### Event loop\n\n实际上， JavaScript 运行时包含了一个待处理的消息队列，每一个消息都与一个函数相关联。同时有一个事件循环不停地在轮询这个队列，当队列不为空时，就从队列中取出一个消息进行处理。它的实现大概如此：\n\n```javascript\nwhile(queue.waitForMessage()){\n  queue.processNextMessage();\n}\n```\n\n所以，上面的例子调用 [setTimeout](https://developer.mozilla.org/en-US/docs/window.setTimeout) 函数会在一个时间段过去后在队列中添加一个消息，实际上没有创建一个新的线程，当时间到达时，如果在队列中它的前面还有其他消息没有处理，那么它也要先等前面的执行完才执行。所谓的异步执行，实际上是在主线程空闲的时候执行，可以看如下代码：\n\n```javascript\nvar startTime = new Date();\n\n// 第一个异步任务\nsetTimeout(function() {\n    console.log('task 1 start.');\n    while(true) {\n        var curTime = new Date();\n        if(curTime - startTime > 5000) {\n            break;\n        }\n    }\n    console.log('task 1 done.')\n}, 100);\n\n// 第二个异步任务\nsetTimeout(function() {\n    console.log('task 2 start.');\n}, 500);\n\nconsole.log('main');\n```\n\n程序第一个输出 `main`，这个毋庸置疑，但是第一个异步任务会执行 5 秒，而我们设置了第二个异步任务在 500 毫秒后执行，如果是多线程，`task 2 start` 会在 `task 1 done` 之前输出，然而结果是等 `task 1 done` 输出后才会输出 `task 2 done`。因为到 500 ms 时，task 2 被插入到消息队列中，然而此时task 1 还没有执行完，所以 task 2 紧接着 task 1 执行。示意图如下：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/thread-in-javascript/01.png)\n\n### webworker\n\n但是 javascript 能不能支持多线程呢，答案是可以的，在 HTML 5 规范中，新增了webworker 用来进行计算量大的操作，避免阻塞主线程，不过在webworker 创建的线程中，是不能操作 DOM 元素的，当 webworker 中的计算完成时可以通过事件与主线程进行通信。\n\n## Nodejs\n\n说完了浏览器端，现在说回 nodejs，nodejs 只是 javascript 的一个运行环境，实际上并不改变 javascript 是单线程执行的本质，但是 nodejs 可以提供一些方式来进行多线程和多进程开发。\n\n### 多线程\n\n#### [tagg](https://github.com/xk/node-threads-a-gogo)\n\nJorge Chamorro Bieling是 `tagg(Threads a gogo for Node.js)` 包的作者，他硬是利用 `phread` 库和C语言让Node.js支持了多线程的开发\n\n### libuvd\n\n`libuv` 是一个跨平台的异步I/O库，它主要用于Node.js的开发，同时他也被 `Mozilla's Rust language`,  `Luvit`, `Julia`,  `pyuv`等使用。它主要包括了 `Event loops` 事件循环， `Filesystem` 文件系统， `Networking` 网络支持，`Threads` 线程，`Processes` 进程，`Utilities` 其他工具。\n\n\n\n### 多进程\n\n#### child_process\n\n可以启动一个 nodejs 文件，将它作为 worker 进程，实现多进程解决主进程阻塞的问题。\n\n#### cluster\n\n`cluster`可以用来让Node.js充分利用多核cpu的性能，同时也可以让Node.js程序更加健壮，官网上的`cluster`示例已经告诉我们如何重新启动一个因为异常而奔溃的子进程。\n\n\n\n## 参考\n\n1. [Node.js的线程和进程](https://github.com/DoubleSpout/threadAndPackage/blob/master/chapter.7.thread_and_process.md)\n2. [Node.js 探秘：初识单线程的 Node.js](http://taobaofed.org/blog/2015/10/29/deep-into-node-1/)\n3. [细说JavaScript单线程的一些事](https://segmentfault.com/a/1190000004276027)\n4. [并发模型与Event Loop](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoo)","slug":"thread-in-javascript","published":1,"updated":"2017-03-17T13:41:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcx0002nn927woxiw2f5","content":"<p>写 javascript 写久了，就会对 javascript 的异步写法习以为常，反而不会好奇为什么在 javascript 里可以异步执行一个任务，是因为 javascript 是多线程吗？</p>\n<p>实际上，javascript 从来都是单线程的。目前 javascript 有两个主要的运行环境，一个是浏览器，一个是 nodejs，下面分别从这两个方面对这个问题进行解释。</p>\n<a id=\"more\"></a>\n<h2 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h2><p>javascript 的设计初衷，是为了解决一些简单的网页互动，也就是操作 DOM 元素。而如果采用多线程，那么大家都知道，多线程是可能会造成竞争资源的，很可能多个线程同时操作一个 DOM 元素，造成不必要的麻烦，所以 javascript 从诞生开始就选择了单线程执行。</p>\n<p>然而在前端开发中，会经常用到 <code>setTimeout</code> 这个函数，我们可以规定让一段逻辑在指定时间后执行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'timeout done'</span>);</div><div class=\"line\">&#125;, <span class=\"number\">3000</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'main task'</span>)</div></pre></td></tr></table></figure>\n<p>上面这段代码会先输出 <code>main task</code>，然后在 3 秒之后输出 <code>timeout done</code>。就好像 setTimeout 开启了一个新线程一样，实际上并不是这样。</p>\n<h3 id=\"Event-loop\"><a href=\"#Event-loop\" class=\"headerlink\" title=\"Event loop\"></a>Event loop</h3><p>实际上， JavaScript 运行时包含了一个待处理的消息队列，每一个消息都与一个函数相关联。同时有一个事件循环不停地在轮询这个队列，当队列不为空时，就从队列中取出一个消息进行处理。它的实现大概如此：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span>(queue.waitForMessage())&#123;</div><div class=\"line\">  queue.processNextMessage();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>所以，上面的例子调用 <a href=\"https://developer.mozilla.org/en-US/docs/window.setTimeout\" target=\"_blank\" rel=\"external\">setTimeout</a> 函数会在一个时间段过去后在队列中添加一个消息，实际上没有创建一个新的线程，当时间到达时，如果在队列中它的前面还有其他消息没有处理，那么它也要先等前面的执行完才执行。所谓的异步执行，实际上是在主线程空闲的时候执行，可以看如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> startTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 第一个异步任务</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'task 1 start.'</span>);</div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> curTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\">        <span class=\"keyword\">if</span>(curTime - startTime &gt; <span class=\"number\">5000</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'task 1 done.'</span>)</div><div class=\"line\">&#125;, <span class=\"number\">100</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 第二个异步任务</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'task 2 start.'</span>);</div><div class=\"line\">&#125;, <span class=\"number\">500</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'main'</span>);</div></pre></td></tr></table></figure>\n<p>程序第一个输出 <code>main</code>，这个毋庸置疑，但是第一个异步任务会执行 5 秒，而我们设置了第二个异步任务在 500 毫秒后执行，如果是多线程，<code>task 2 start</code> 会在 <code>task 1 done</code> 之前输出，然而结果是等 <code>task 1 done</code> 输出后才会输出 <code>task 2 done</code>。因为到 500 ms 时，task 2 被插入到消息队列中，然而此时task 1 还没有执行完，所以 task 2 紧接着 task 1 执行。示意图如下：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/thread-in-javascript/01.png\" alt=\"\"></p>\n<h3 id=\"webworker\"><a href=\"#webworker\" class=\"headerlink\" title=\"webworker\"></a>webworker</h3><p>但是 javascript 能不能支持多线程呢，答案是可以的，在 HTML 5 规范中，新增了webworker 用来进行计算量大的操作，避免阻塞主线程，不过在webworker 创建的线程中，是不能操作 DOM 元素的，当 webworker 中的计算完成时可以通过事件与主线程进行通信。</p>\n<h2 id=\"Nodejs\"><a href=\"#Nodejs\" class=\"headerlink\" title=\"Nodejs\"></a>Nodejs</h2><p>说完了浏览器端，现在说回 nodejs，nodejs 只是 javascript 的一个运行环境，实际上并不改变 javascript 是单线程执行的本质，但是 nodejs 可以提供一些方式来进行多线程和多进程开发。</p>\n<h3 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h3><h4 id=\"tagg\"><a href=\"#tagg\" class=\"headerlink\" title=\"tagg\"></a><a href=\"https://github.com/xk/node-threads-a-gogo\" target=\"_blank\" rel=\"external\">tagg</a></h4><p>Jorge Chamorro Bieling是 <code>tagg(Threads a gogo for Node.js)</code> 包的作者，他硬是利用 <code>phread</code> 库和C语言让Node.js支持了多线程的开发</p>\n<h3 id=\"libuvd\"><a href=\"#libuvd\" class=\"headerlink\" title=\"libuvd\"></a>libuvd</h3><p><code>libuv</code> 是一个跨平台的异步I/O库，它主要用于Node.js的开发，同时他也被 <code>Mozilla&#39;s Rust language</code>,  <code>Luvit</code>, <code>Julia</code>,  <code>pyuv</code>等使用。它主要包括了 <code>Event loops</code> 事件循环， <code>Filesystem</code> 文件系统， <code>Networking</code> 网络支持，<code>Threads</code> 线程，<code>Processes</code> 进程，<code>Utilities</code> 其他工具。</p>\n<h3 id=\"多进程\"><a href=\"#多进程\" class=\"headerlink\" title=\"多进程\"></a>多进程</h3><h4 id=\"child-process\"><a href=\"#child-process\" class=\"headerlink\" title=\"child_process\"></a>child_process</h4><p>可以启动一个 nodejs 文件，将它作为 worker 进程，实现多进程解决主进程阻塞的问题。</p>\n<h4 id=\"cluster\"><a href=\"#cluster\" class=\"headerlink\" title=\"cluster\"></a>cluster</h4><p><code>cluster</code>可以用来让Node.js充分利用多核cpu的性能，同时也可以让Node.js程序更加健壮，官网上的<code>cluster</code>示例已经告诉我们如何重新启动一个因为异常而奔溃的子进程。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://github.com/DoubleSpout/threadAndPackage/blob/master/chapter.7.thread_and_process.md\" target=\"_blank\" rel=\"external\">Node.js的线程和进程</a></li>\n<li><a href=\"http://taobaofed.org/blog/2015/10/29/deep-into-node-1/\" target=\"_blank\" rel=\"external\">Node.js 探秘：初识单线程的 Node.js</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000004276027\" target=\"_blank\" rel=\"external\">细说JavaScript单线程的一些事</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoo\" target=\"_blank\" rel=\"external\">并发模型与Event Loop</a></li>\n</ol>\n","excerpt":"<p>写 javascript 写久了，就会对 javascript 的异步写法习以为常，反而不会好奇为什么在 javascript 里可以异步执行一个任务，是因为 javascript 是多线程吗？</p>\n<p>实际上，javascript 从来都是单线程的。目前 javascript 有两个主要的运行环境，一个是浏览器，一个是 nodejs，下面分别从这两个方面对这个问题进行解释。</p>","more":"<h2 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h2><p>javascript 的设计初衷，是为了解决一些简单的网页互动，也就是操作 DOM 元素。而如果采用多线程，那么大家都知道，多线程是可能会造成竞争资源的，很可能多个线程同时操作一个 DOM 元素，造成不必要的麻烦，所以 javascript 从诞生开始就选择了单线程执行。</p>\n<p>然而在前端开发中，会经常用到 <code>setTimeout</code> 这个函数，我们可以规定让一段逻辑在指定时间后执行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'timeout done'</span>);</div><div class=\"line\">&#125;, <span class=\"number\">3000</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'main task'</span>)</div></pre></td></tr></table></figure>\n<p>上面这段代码会先输出 <code>main task</code>，然后在 3 秒之后输出 <code>timeout done</code>。就好像 setTimeout 开启了一个新线程一样，实际上并不是这样。</p>\n<h3 id=\"Event-loop\"><a href=\"#Event-loop\" class=\"headerlink\" title=\"Event loop\"></a>Event loop</h3><p>实际上， JavaScript 运行时包含了一个待处理的消息队列，每一个消息都与一个函数相关联。同时有一个事件循环不停地在轮询这个队列，当队列不为空时，就从队列中取出一个消息进行处理。它的实现大概如此：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span>(queue.waitForMessage())&#123;</div><div class=\"line\">  queue.processNextMessage();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>所以，上面的例子调用 <a href=\"https://developer.mozilla.org/en-US/docs/window.setTimeout\">setTimeout</a> 函数会在一个时间段过去后在队列中添加一个消息，实际上没有创建一个新的线程，当时间到达时，如果在队列中它的前面还有其他消息没有处理，那么它也要先等前面的执行完才执行。所谓的异步执行，实际上是在主线程空闲的时候执行，可以看如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> startTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 第一个异步任务</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'task 1 start.'</span>);</div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> curTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\">        <span class=\"keyword\">if</span>(curTime - startTime &gt; <span class=\"number\">5000</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'task 1 done.'</span>)</div><div class=\"line\">&#125;, <span class=\"number\">100</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 第二个异步任务</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'task 2 start.'</span>);</div><div class=\"line\">&#125;, <span class=\"number\">500</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'main'</span>);</div></pre></td></tr></table></figure>\n<p>程序第一个输出 <code>main</code>，这个毋庸置疑，但是第一个异步任务会执行 5 秒，而我们设置了第二个异步任务在 500 毫秒后执行，如果是多线程，<code>task 2 start</code> 会在 <code>task 1 done</code> 之前输出，然而结果是等 <code>task 1 done</code> 输出后才会输出 <code>task 2 done</code>。因为到 500 ms 时，task 2 被插入到消息队列中，然而此时task 1 还没有执行完，所以 task 2 紧接着 task 1 执行。示意图如下：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/thread-in-javascript/01.png\" alt=\"\"></p>\n<h3 id=\"webworker\"><a href=\"#webworker\" class=\"headerlink\" title=\"webworker\"></a>webworker</h3><p>但是 javascript 能不能支持多线程呢，答案是可以的，在 HTML 5 规范中，新增了webworker 用来进行计算量大的操作，避免阻塞主线程，不过在webworker 创建的线程中，是不能操作 DOM 元素的，当 webworker 中的计算完成时可以通过事件与主线程进行通信。</p>\n<h2 id=\"Nodejs\"><a href=\"#Nodejs\" class=\"headerlink\" title=\"Nodejs\"></a>Nodejs</h2><p>说完了浏览器端，现在说回 nodejs，nodejs 只是 javascript 的一个运行环境，实际上并不改变 javascript 是单线程执行的本质，但是 nodejs 可以提供一些方式来进行多线程和多进程开发。</p>\n<h3 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h3><h4 id=\"tagg\"><a href=\"#tagg\" class=\"headerlink\" title=\"tagg\"></a><a href=\"https://github.com/xk/node-threads-a-gogo\">tagg</a></h4><p>Jorge Chamorro Bieling是 <code>tagg(Threads a gogo for Node.js)</code> 包的作者，他硬是利用 <code>phread</code> 库和C语言让Node.js支持了多线程的开发</p>\n<h3 id=\"libuvd\"><a href=\"#libuvd\" class=\"headerlink\" title=\"libuvd\"></a>libuvd</h3><p><code>libuv</code> 是一个跨平台的异步I/O库，它主要用于Node.js的开发，同时他也被 <code>Mozilla&#39;s Rust language</code>,  <code>Luvit</code>, <code>Julia</code>,  <code>pyuv</code>等使用。它主要包括了 <code>Event loops</code> 事件循环， <code>Filesystem</code> 文件系统， <code>Networking</code> 网络支持，<code>Threads</code> 线程，<code>Processes</code> 进程，<code>Utilities</code> 其他工具。</p>\n<h3 id=\"多进程\"><a href=\"#多进程\" class=\"headerlink\" title=\"多进程\"></a>多进程</h3><h4 id=\"child-process\"><a href=\"#child-process\" class=\"headerlink\" title=\"child_process\"></a>child_process</h4><p>可以启动一个 nodejs 文件，将它作为 worker 进程，实现多进程解决主进程阻塞的问题。</p>\n<h4 id=\"cluster\"><a href=\"#cluster\" class=\"headerlink\" title=\"cluster\"></a>cluster</h4><p><code>cluster</code>可以用来让Node.js充分利用多核cpu的性能，同时也可以让Node.js程序更加健壮，官网上的<code>cluster</code>示例已经告诉我们如何重新启动一个因为异常而奔溃的子进程。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://github.com/DoubleSpout/threadAndPackage/blob/master/chapter.7.thread_and_process.md\">Node.js的线程和进程</a></li>\n<li><a href=\"http://taobaofed.org/blog/2015/10/29/deep-into-node-1/\">Node.js 探秘：初识单线程的 Node.js</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000004276027\">细说JavaScript单线程的一些事</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoo\">并发模型与Event Loop</a></li>\n</ol>"},{"title":"集中趋势和离散趋势","date":"2017-01-21T14:52:45.000Z","_content":"\n给定一组数据，可以使用 *平均数、中位数、众数* 等来判断这组数据的 **集中趋势**，使用 *方差、标准差* 等来判断 **离散趋势**。\n\n<!--more-->\n\n## 总体和样本\n\n如果要测量全中国所有男性的平均身高，显然是不可能一个一个去测量的，而是从中随机抽取一定数量的人，来测量这些人的平均身高，用以估计全中国男性的平均身高。\n\n在这个例子里面，全中国的男性称为总体，抽样出来的男性称为样本。\n\n> 每当你试图描述一组分数时，统计学都能为你提供解决方案。有时你想描述的总体全都摆在眼前，这时完成该任务的方法称作 **描述性统计**。更常见的情形是，你只能看到样本，但仍想描述整个组。这种概括性方法称作 **推断性统计**。\n\n## 集中趋势\n\n一组数据的集中趋势可以通过平均数、中位数或者众数来观察。\n\n### 中位数\n\n中位数指将一组数据排序之后，处在最中间的那个数。如果总数为奇数，则直接取到最中间的数；如果总数是偶数，取最中间的两个数值的平均数作为中位数.\n\n> 1, 1, 2, 3, 4, 5, 12 的中位数为 3\n\n### 众数\n\n众数指在一组数据中出现最多次数的数。如果所有数出现次数相等，则该组数据没有众数；如果出现次数最多的数有多个，则这多个数都是该组数据的众数。\n\n> 1, 1, 2, 3, 4, 5, 12 的众数为 1\n\n### 平均数\n\n这里说的平均数指 **算术平均数**。\n\n设有总体个数为 $N$，另有样本个数 $n$。\n\n如果能够得到总体的全部数据，自然就能得到总体平均数，此时，将 **总体均值** 记为 $\\mu$。\n\n$$\n\\mu = \\frac{\\sum_{i=1}^Nx_i}{N}\n$$\n\n如果只能得到样本的数据，可以通过样本计算出 **样本均值**，记为 $\\overline{X}$。\n\n$$\n\\overline{X} = \\frac{\\sum_{i=1}^nx_i}{n}\n$$\n\n其实就是 $N$ 和 $n$ 的区别。\n\n> 1, 1, 2, 3, 4, 5, 12 的平均数为 $\\frac{1 + 1 + 2 + 3 + 4 + 5 + 12}7 = 4$\n\n## 离散趋势\n\n一组数据的离散趋势可以通过方差、标准差来观察。\n\n### 方差\n\n设有总体个数为 $N$，另有样本个数 $n$。\n\n如果能得到总体的全部数据，自然就能得到总体的均值 $\\mu$，即可得到总体的方差。此时，将 **总体方差** 记为 $\\sigma^2$。\n\n$$\n\\sigma^2 = \\frac{\\sum_{i=1}^N(x_i - \\mu)^2}{N}\n$$\n\n如果只能得到样本数据，将 **样本方差** 记为 $s^2$。此时，样本方差的 **无偏估计** 为：\n\n$$\ns^2 = \\frac{\\sum_{i=1}^n(x_i - \\overline{X})^2}{n - 1}\n$$\n\n对比总体方差的计算方式，样本方差的计算有两个疑问：\n\n- 为什么不是除以 n\n- 为什么除以的是 n - 1\n\n#### 为什么不是除以 n\n\n计算样本方差时，我们只知道样本的数据，所以只能求出样本的均值 $\\overline{X}$，而得不到总体均值 $\\mu$，假设此时计算公式和总体方差类似，被除数是 n：\n\n$$\ns^2 = \\frac{\\sum_{i=1}^n(x_i - \\overline{X})^2}{n}\n$$\n\n那么：\n\n$$\n\\begin{align}\ns^2 & = \\frac1n\\sum\\_{i=1}^n(x\\_i - \\overline{X})^2 \\\\\\\n& = \\frac1n\\sum\\_{i=1}^n[(x\\_i - \\mu) + (\\mu - \\overline{X})]^2 \\\\\\\n& = \\frac1n\\sum\\_{i=1}^n(x\\_i - \\mu)^2 + \\frac2n\\sum\\_{i=1}^n(x\\_i - \\mu)(\\mu - \\overline{X}) + \\frac1n\\sum\\_{i=1}^n(\\mu - \\overline{X})^2 \\\\\\\n& = \\frac1n\\sum\\_{i=1}^n(x\\_i - \\mu)^2 + 2(\\overline{X} - \\mu)(\\mu - \\overline{X}) + (\\mu - \\overline{X})^2 \\\\\\\n& = \\frac1n\\sum\\_{i=1}^n(x\\_i - \\mu)^2 - (\\mu - \\overline{X})^2\n\\end{align}\n$$\n\n可以看到，当 $\\overline{X}$ 不等于 $\\mu$ 时，这样得到的方差是小于实际的方差的，所以为了减少误差，必须要把样本方差放大一点，也就是在分母上除以比 n 小的数。这样得到的方差称为 **样本方差的无偏估计** 或 **无偏样本方差**\n\n#### 为什么除以的是 n - 1\n\n至于为什么除以的是 n - 1，而不是 n - 2、n - 3 之类的，这个涉及到具体的数学证明，在此先不做探讨。有一种理解是 n - 1 为自由度，也就是当均值确定时，只要前 n - 1 个数确定了，那么最后一个数也就确定了，也就是说只有 n - 1 个数是自由的，这里的自由度是 n - 1。\n\n**所以，如果已知总体均值 $\\mu$，使用 $\\mu$ 代替 $\\overline{X}$，就无须将 n 换成 n - 1 了。**\n\n### 标准差\n\n标准差为方差的平方根。\n\n总体标准差记为 $\\sigma$\n\n$$\n\\sigma = \\sqrt{\\sigma^2} = \\sqrt{\\frac{\\sum\\_{i=1}^N(x\\_i - \\mu)^2}{N}}\n$$\n\n样本标准差记为 $s$\n\n$$\ns = \\sqrt{s^2} = \\sqrt{\\frac{\\sum_{i=1}^n(x_i - \\overline{X})^2}{n - 1}}\n$$\n\n#### 为什么要引入标准差\n\n一方面，相比于方差，标准差的单位更友好：方差的计算里面因为使用了平方，所以单位也是是原数据单位的平方；而平方根的单位和原数据单位保持一致。\n\n另一方面，在某些场景下，标准差更容易观察数据，比如正态分布等。\n","source":"_posts/statistics-tendency.md","raw":"---\ntitle: 集中趋势和离散趋势\ndate: 2017-01-21 22:52:45\ntags: [统计学]\n---\n\n给定一组数据，可以使用 *平均数、中位数、众数* 等来判断这组数据的 **集中趋势**，使用 *方差、标准差* 等来判断 **离散趋势**。\n\n<!--more-->\n\n## 总体和样本\n\n如果要测量全中国所有男性的平均身高，显然是不可能一个一个去测量的，而是从中随机抽取一定数量的人，来测量这些人的平均身高，用以估计全中国男性的平均身高。\n\n在这个例子里面，全中国的男性称为总体，抽样出来的男性称为样本。\n\n> 每当你试图描述一组分数时，统计学都能为你提供解决方案。有时你想描述的总体全都摆在眼前，这时完成该任务的方法称作 **描述性统计**。更常见的情形是，你只能看到样本，但仍想描述整个组。这种概括性方法称作 **推断性统计**。\n\n## 集中趋势\n\n一组数据的集中趋势可以通过平均数、中位数或者众数来观察。\n\n### 中位数\n\n中位数指将一组数据排序之后，处在最中间的那个数。如果总数为奇数，则直接取到最中间的数；如果总数是偶数，取最中间的两个数值的平均数作为中位数.\n\n> 1, 1, 2, 3, 4, 5, 12 的中位数为 3\n\n### 众数\n\n众数指在一组数据中出现最多次数的数。如果所有数出现次数相等，则该组数据没有众数；如果出现次数最多的数有多个，则这多个数都是该组数据的众数。\n\n> 1, 1, 2, 3, 4, 5, 12 的众数为 1\n\n### 平均数\n\n这里说的平均数指 **算术平均数**。\n\n设有总体个数为 $N$，另有样本个数 $n$。\n\n如果能够得到总体的全部数据，自然就能得到总体平均数，此时，将 **总体均值** 记为 $\\mu$。\n\n$$\n\\mu = \\frac{\\sum_{i=1}^Nx_i}{N}\n$$\n\n如果只能得到样本的数据，可以通过样本计算出 **样本均值**，记为 $\\overline{X}$。\n\n$$\n\\overline{X} = \\frac{\\sum_{i=1}^nx_i}{n}\n$$\n\n其实就是 $N$ 和 $n$ 的区别。\n\n> 1, 1, 2, 3, 4, 5, 12 的平均数为 $\\frac{1 + 1 + 2 + 3 + 4 + 5 + 12}7 = 4$\n\n## 离散趋势\n\n一组数据的离散趋势可以通过方差、标准差来观察。\n\n### 方差\n\n设有总体个数为 $N$，另有样本个数 $n$。\n\n如果能得到总体的全部数据，自然就能得到总体的均值 $\\mu$，即可得到总体的方差。此时，将 **总体方差** 记为 $\\sigma^2$。\n\n$$\n\\sigma^2 = \\frac{\\sum_{i=1}^N(x_i - \\mu)^2}{N}\n$$\n\n如果只能得到样本数据，将 **样本方差** 记为 $s^2$。此时，样本方差的 **无偏估计** 为：\n\n$$\ns^2 = \\frac{\\sum_{i=1}^n(x_i - \\overline{X})^2}{n - 1}\n$$\n\n对比总体方差的计算方式，样本方差的计算有两个疑问：\n\n- 为什么不是除以 n\n- 为什么除以的是 n - 1\n\n#### 为什么不是除以 n\n\n计算样本方差时，我们只知道样本的数据，所以只能求出样本的均值 $\\overline{X}$，而得不到总体均值 $\\mu$，假设此时计算公式和总体方差类似，被除数是 n：\n\n$$\ns^2 = \\frac{\\sum_{i=1}^n(x_i - \\overline{X})^2}{n}\n$$\n\n那么：\n\n$$\n\\begin{align}\ns^2 & = \\frac1n\\sum\\_{i=1}^n(x\\_i - \\overline{X})^2 \\\\\\\n& = \\frac1n\\sum\\_{i=1}^n[(x\\_i - \\mu) + (\\mu - \\overline{X})]^2 \\\\\\\n& = \\frac1n\\sum\\_{i=1}^n(x\\_i - \\mu)^2 + \\frac2n\\sum\\_{i=1}^n(x\\_i - \\mu)(\\mu - \\overline{X}) + \\frac1n\\sum\\_{i=1}^n(\\mu - \\overline{X})^2 \\\\\\\n& = \\frac1n\\sum\\_{i=1}^n(x\\_i - \\mu)^2 + 2(\\overline{X} - \\mu)(\\mu - \\overline{X}) + (\\mu - \\overline{X})^2 \\\\\\\n& = \\frac1n\\sum\\_{i=1}^n(x\\_i - \\mu)^2 - (\\mu - \\overline{X})^2\n\\end{align}\n$$\n\n可以看到，当 $\\overline{X}$ 不等于 $\\mu$ 时，这样得到的方差是小于实际的方差的，所以为了减少误差，必须要把样本方差放大一点，也就是在分母上除以比 n 小的数。这样得到的方差称为 **样本方差的无偏估计** 或 **无偏样本方差**\n\n#### 为什么除以的是 n - 1\n\n至于为什么除以的是 n - 1，而不是 n - 2、n - 3 之类的，这个涉及到具体的数学证明，在此先不做探讨。有一种理解是 n - 1 为自由度，也就是当均值确定时，只要前 n - 1 个数确定了，那么最后一个数也就确定了，也就是说只有 n - 1 个数是自由的，这里的自由度是 n - 1。\n\n**所以，如果已知总体均值 $\\mu$，使用 $\\mu$ 代替 $\\overline{X}$，就无须将 n 换成 n - 1 了。**\n\n### 标准差\n\n标准差为方差的平方根。\n\n总体标准差记为 $\\sigma$\n\n$$\n\\sigma = \\sqrt{\\sigma^2} = \\sqrt{\\frac{\\sum\\_{i=1}^N(x\\_i - \\mu)^2}{N}}\n$$\n\n样本标准差记为 $s$\n\n$$\ns = \\sqrt{s^2} = \\sqrt{\\frac{\\sum_{i=1}^n(x_i - \\overline{X})^2}{n - 1}}\n$$\n\n#### 为什么要引入标准差\n\n一方面，相比于方差，标准差的单位更友好：方差的计算里面因为使用了平方，所以单位也是是原数据单位的平方；而平方根的单位和原数据单位保持一致。\n\n另一方面，在某些场景下，标准差更容易观察数据，比如正态分布等。\n","slug":"statistics-tendency","published":1,"updated":"2017-01-23T02:48:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcx2002pn927ov4umfon","content":"<p>给定一组数据，可以使用 <em>平均数、中位数、众数</em> 等来判断这组数据的 <strong>集中趋势</strong>，使用 <em>方差、标准差</em> 等来判断 <strong>离散趋势</strong>。</p>\n<a id=\"more\"></a>\n<h2 id=\"总体和样本\"><a href=\"#总体和样本\" class=\"headerlink\" title=\"总体和样本\"></a>总体和样本</h2><p>如果要测量全中国所有男性的平均身高，显然是不可能一个一个去测量的，而是从中随机抽取一定数量的人，来测量这些人的平均身高，用以估计全中国男性的平均身高。</p>\n<p>在这个例子里面，全中国的男性称为总体，抽样出来的男性称为样本。</p>\n<blockquote>\n<p>每当你试图描述一组分数时，统计学都能为你提供解决方案。有时你想描述的总体全都摆在眼前，这时完成该任务的方法称作 <strong>描述性统计</strong>。更常见的情形是，你只能看到样本，但仍想描述整个组。这种概括性方法称作 <strong>推断性统计</strong>。</p>\n</blockquote>\n<h2 id=\"集中趋势\"><a href=\"#集中趋势\" class=\"headerlink\" title=\"集中趋势\"></a>集中趋势</h2><p>一组数据的集中趋势可以通过平均数、中位数或者众数来观察。</p>\n<h3 id=\"中位数\"><a href=\"#中位数\" class=\"headerlink\" title=\"中位数\"></a>中位数</h3><p>中位数指将一组数据排序之后，处在最中间的那个数。如果总数为奇数，则直接取到最中间的数；如果总数是偶数，取最中间的两个数值的平均数作为中位数.</p>\n<blockquote>\n<p>1, 1, 2, 3, 4, 5, 12 的中位数为 3</p>\n</blockquote>\n<h3 id=\"众数\"><a href=\"#众数\" class=\"headerlink\" title=\"众数\"></a>众数</h3><p>众数指在一组数据中出现最多次数的数。如果所有数出现次数相等，则该组数据没有众数；如果出现次数最多的数有多个，则这多个数都是该组数据的众数。</p>\n<blockquote>\n<p>1, 1, 2, 3, 4, 5, 12 的众数为 1</p>\n</blockquote>\n<h3 id=\"平均数\"><a href=\"#平均数\" class=\"headerlink\" title=\"平均数\"></a>平均数</h3><p>这里说的平均数指 <strong>算术平均数</strong>。</p>\n<p>设有总体个数为 $N$，另有样本个数 $n$。</p>\n<p>如果能够得到总体的全部数据，自然就能得到总体平均数，此时，将 <strong>总体均值</strong> 记为 $\\mu$。</p>\n<p>$$<br>\\mu = \\frac{\\sum_{i=1}^Nx_i}{N}<br>$$</p>\n<p>如果只能得到样本的数据，可以通过样本计算出 <strong>样本均值</strong>，记为 $\\overline{X}$。</p>\n<p>$$<br>\\overline{X} = \\frac{\\sum_{i=1}^nx_i}{n}<br>$$</p>\n<p>其实就是 $N$ 和 $n$ 的区别。</p>\n<blockquote>\n<p>1, 1, 2, 3, 4, 5, 12 的平均数为 $\\frac{1 + 1 + 2 + 3 + 4 + 5 + 12}7 = 4$</p>\n</blockquote>\n<h2 id=\"离散趋势\"><a href=\"#离散趋势\" class=\"headerlink\" title=\"离散趋势\"></a>离散趋势</h2><p>一组数据的离散趋势可以通过方差、标准差来观察。</p>\n<h3 id=\"方差\"><a href=\"#方差\" class=\"headerlink\" title=\"方差\"></a>方差</h3><p>设有总体个数为 $N$，另有样本个数 $n$。</p>\n<p>如果能得到总体的全部数据，自然就能得到总体的均值 $\\mu$，即可得到总体的方差。此时，将 <strong>总体方差</strong> 记为 $\\sigma^2$。</p>\n<p>$$<br>\\sigma^2 = \\frac{\\sum_{i=1}^N(x_i - \\mu)^2}{N}<br>$$</p>\n<p>如果只能得到样本数据，将 <strong>样本方差</strong> 记为 $s^2$。此时，样本方差的 <strong>无偏估计</strong> 为：</p>\n<p>$$<br>s^2 = \\frac{\\sum_{i=1}^n(x_i - \\overline{X})^2}{n - 1}<br>$$</p>\n<p>对比总体方差的计算方式，样本方差的计算有两个疑问：</p>\n<ul>\n<li>为什么不是除以 n</li>\n<li>为什么除以的是 n - 1</li>\n</ul>\n<h4 id=\"为什么不是除以-n\"><a href=\"#为什么不是除以-n\" class=\"headerlink\" title=\"为什么不是除以 n\"></a>为什么不是除以 n</h4><p>计算样本方差时，我们只知道样本的数据，所以只能求出样本的均值 $\\overline{X}$，而得不到总体均值 $\\mu$，假设此时计算公式和总体方差类似，被除数是 n：</p>\n<p>$$<br>s^2 = \\frac{\\sum_{i=1}^n(x_i - \\overline{X})^2}{n}<br>$$</p>\n<p>那么：</p>\n<p>$$<br>\\begin{align}<br>s^2 &amp; = \\frac1n\\sum_{i=1}^n(x_i - \\overline{X})^2 \\\\<br>&amp; = \\frac1n\\sum_{i=1}^n[(x_i - \\mu) + (\\mu - \\overline{X})]^2 \\\\<br>&amp; = \\frac1n\\sum_{i=1}^n(x_i - \\mu)^2 + \\frac2n\\sum_{i=1}^n(x_i - \\mu)(\\mu - \\overline{X}) + \\frac1n\\sum_{i=1}^n(\\mu - \\overline{X})^2 \\\\<br>&amp; = \\frac1n\\sum_{i=1}^n(x_i - \\mu)^2 + 2(\\overline{X} - \\mu)(\\mu - \\overline{X}) + (\\mu - \\overline{X})^2 \\\\<br>&amp; = \\frac1n\\sum_{i=1}^n(x_i - \\mu)^2 - (\\mu - \\overline{X})^2<br>\\end{align}<br>$$</p>\n<p>可以看到，当 $\\overline{X}$ 不等于 $\\mu$ 时，这样得到的方差是小于实际的方差的，所以为了减少误差，必须要把样本方差放大一点，也就是在分母上除以比 n 小的数。这样得到的方差称为 <strong>样本方差的无偏估计</strong> 或 <strong>无偏样本方差</strong></p>\n<h4 id=\"为什么除以的是-n-1\"><a href=\"#为什么除以的是-n-1\" class=\"headerlink\" title=\"为什么除以的是 n - 1\"></a>为什么除以的是 n - 1</h4><p>至于为什么除以的是 n - 1，而不是 n - 2、n - 3 之类的，这个涉及到具体的数学证明，在此先不做探讨。有一种理解是 n - 1 为自由度，也就是当均值确定时，只要前 n - 1 个数确定了，那么最后一个数也就确定了，也就是说只有 n - 1 个数是自由的，这里的自由度是 n - 1。</p>\n<p><strong>所以，如果已知总体均值 $\\mu$，使用 $\\mu$ 代替 $\\overline{X}$，就无须将 n 换成 n - 1 了。</strong></p>\n<h3 id=\"标准差\"><a href=\"#标准差\" class=\"headerlink\" title=\"标准差\"></a>标准差</h3><p>标准差为方差的平方根。</p>\n<p>总体标准差记为 $\\sigma$</p>\n<p>$$<br>\\sigma = \\sqrt{\\sigma^2} = \\sqrt{\\frac{\\sum_{i=1}^N(x_i - \\mu)^2}{N}}<br>$$</p>\n<p>样本标准差记为 $s$</p>\n<p>$$<br>s = \\sqrt{s^2} = \\sqrt{\\frac{\\sum_{i=1}^n(x_i - \\overline{X})^2}{n - 1}}<br>$$</p>\n<h4 id=\"为什么要引入标准差\"><a href=\"#为什么要引入标准差\" class=\"headerlink\" title=\"为什么要引入标准差\"></a>为什么要引入标准差</h4><p>一方面，相比于方差，标准差的单位更友好：方差的计算里面因为使用了平方，所以单位也是是原数据单位的平方；而平方根的单位和原数据单位保持一致。</p>\n<p>另一方面，在某些场景下，标准差更容易观察数据，比如正态分布等。</p>\n","excerpt":"<p>给定一组数据，可以使用 <em>平均数、中位数、众数</em> 等来判断这组数据的 <strong>集中趋势</strong>，使用 <em>方差、标准差</em> 等来判断 <strong>离散趋势</strong>。</p>","more":"<h2 id=\"总体和样本\"><a href=\"#总体和样本\" class=\"headerlink\" title=\"总体和样本\"></a>总体和样本</h2><p>如果要测量全中国所有男性的平均身高，显然是不可能一个一个去测量的，而是从中随机抽取一定数量的人，来测量这些人的平均身高，用以估计全中国男性的平均身高。</p>\n<p>在这个例子里面，全中国的男性称为总体，抽样出来的男性称为样本。</p>\n<blockquote>\n<p>每当你试图描述一组分数时，统计学都能为你提供解决方案。有时你想描述的总体全都摆在眼前，这时完成该任务的方法称作 <strong>描述性统计</strong>。更常见的情形是，你只能看到样本，但仍想描述整个组。这种概括性方法称作 <strong>推断性统计</strong>。</p>\n</blockquote>\n<h2 id=\"集中趋势\"><a href=\"#集中趋势\" class=\"headerlink\" title=\"集中趋势\"></a>集中趋势</h2><p>一组数据的集中趋势可以通过平均数、中位数或者众数来观察。</p>\n<h3 id=\"中位数\"><a href=\"#中位数\" class=\"headerlink\" title=\"中位数\"></a>中位数</h3><p>中位数指将一组数据排序之后，处在最中间的那个数。如果总数为奇数，则直接取到最中间的数；如果总数是偶数，取最中间的两个数值的平均数作为中位数.</p>\n<blockquote>\n<p>1, 1, 2, 3, 4, 5, 12 的中位数为 3</p>\n</blockquote>\n<h3 id=\"众数\"><a href=\"#众数\" class=\"headerlink\" title=\"众数\"></a>众数</h3><p>众数指在一组数据中出现最多次数的数。如果所有数出现次数相等，则该组数据没有众数；如果出现次数最多的数有多个，则这多个数都是该组数据的众数。</p>\n<blockquote>\n<p>1, 1, 2, 3, 4, 5, 12 的众数为 1</p>\n</blockquote>\n<h3 id=\"平均数\"><a href=\"#平均数\" class=\"headerlink\" title=\"平均数\"></a>平均数</h3><p>这里说的平均数指 <strong>算术平均数</strong>。</p>\n<p>设有总体个数为 $N$，另有样本个数 $n$。</p>\n<p>如果能够得到总体的全部数据，自然就能得到总体平均数，此时，将 <strong>总体均值</strong> 记为 $\\mu$。</p>\n<p>$$<br>\\mu = \\frac{\\sum_{i=1}^Nx_i}{N}<br>$$</p>\n<p>如果只能得到样本的数据，可以通过样本计算出 <strong>样本均值</strong>，记为 $\\overline{X}$。</p>\n<p>$$<br>\\overline{X} = \\frac{\\sum_{i=1}^nx_i}{n}<br>$$</p>\n<p>其实就是 $N$ 和 $n$ 的区别。</p>\n<blockquote>\n<p>1, 1, 2, 3, 4, 5, 12 的平均数为 $\\frac{1 + 1 + 2 + 3 + 4 + 5 + 12}7 = 4$</p>\n</blockquote>\n<h2 id=\"离散趋势\"><a href=\"#离散趋势\" class=\"headerlink\" title=\"离散趋势\"></a>离散趋势</h2><p>一组数据的离散趋势可以通过方差、标准差来观察。</p>\n<h3 id=\"方差\"><a href=\"#方差\" class=\"headerlink\" title=\"方差\"></a>方差</h3><p>设有总体个数为 $N$，另有样本个数 $n$。</p>\n<p>如果能得到总体的全部数据，自然就能得到总体的均值 $\\mu$，即可得到总体的方差。此时，将 <strong>总体方差</strong> 记为 $\\sigma^2$。</p>\n<p>$$<br>\\sigma^2 = \\frac{\\sum_{i=1}^N(x_i - \\mu)^2}{N}<br>$$</p>\n<p>如果只能得到样本数据，将 <strong>样本方差</strong> 记为 $s^2$。此时，样本方差的 <strong>无偏估计</strong> 为：</p>\n<p>$$<br>s^2 = \\frac{\\sum_{i=1}^n(x_i - \\overline{X})^2}{n - 1}<br>$$</p>\n<p>对比总体方差的计算方式，样本方差的计算有两个疑问：</p>\n<ul>\n<li>为什么不是除以 n</li>\n<li>为什么除以的是 n - 1</li>\n</ul>\n<h4 id=\"为什么不是除以-n\"><a href=\"#为什么不是除以-n\" class=\"headerlink\" title=\"为什么不是除以 n\"></a>为什么不是除以 n</h4><p>计算样本方差时，我们只知道样本的数据，所以只能求出样本的均值 $\\overline{X}$，而得不到总体均值 $\\mu$，假设此时计算公式和总体方差类似，被除数是 n：</p>\n<p>$$<br>s^2 = \\frac{\\sum_{i=1}^n(x_i - \\overline{X})^2}{n}<br>$$</p>\n<p>那么：</p>\n<p>$$<br>\\begin{align}<br>s^2 &amp; = \\frac1n\\sum_{i=1}^n(x_i - \\overline{X})^2 \\\\<br>&amp; = \\frac1n\\sum_{i=1}^n[(x_i - \\mu) + (\\mu - \\overline{X})]^2 \\\\<br>&amp; = \\frac1n\\sum_{i=1}^n(x_i - \\mu)^2 + \\frac2n\\sum_{i=1}^n(x_i - \\mu)(\\mu - \\overline{X}) + \\frac1n\\sum_{i=1}^n(\\mu - \\overline{X})^2 \\\\<br>&amp; = \\frac1n\\sum_{i=1}^n(x_i - \\mu)^2 + 2(\\overline{X} - \\mu)(\\mu - \\overline{X}) + (\\mu - \\overline{X})^2 \\\\<br>&amp; = \\frac1n\\sum_{i=1}^n(x_i - \\mu)^2 - (\\mu - \\overline{X})^2<br>\\end{align}<br>$$</p>\n<p>可以看到，当 $\\overline{X}$ 不等于 $\\mu$ 时，这样得到的方差是小于实际的方差的，所以为了减少误差，必须要把样本方差放大一点，也就是在分母上除以比 n 小的数。这样得到的方差称为 <strong>样本方差的无偏估计</strong> 或 <strong>无偏样本方差</strong></p>\n<h4 id=\"为什么除以的是-n-1\"><a href=\"#为什么除以的是-n-1\" class=\"headerlink\" title=\"为什么除以的是 n - 1\"></a>为什么除以的是 n - 1</h4><p>至于为什么除以的是 n - 1，而不是 n - 2、n - 3 之类的，这个涉及到具体的数学证明，在此先不做探讨。有一种理解是 n - 1 为自由度，也就是当均值确定时，只要前 n - 1 个数确定了，那么最后一个数也就确定了，也就是说只有 n - 1 个数是自由的，这里的自由度是 n - 1。</p>\n<p><strong>所以，如果已知总体均值 $\\mu$，使用 $\\mu$ 代替 $\\overline{X}$，就无须将 n 换成 n - 1 了。</strong></p>\n<h3 id=\"标准差\"><a href=\"#标准差\" class=\"headerlink\" title=\"标准差\"></a>标准差</h3><p>标准差为方差的平方根。</p>\n<p>总体标准差记为 $\\sigma$</p>\n<p>$$<br>\\sigma = \\sqrt{\\sigma^2} = \\sqrt{\\frac{\\sum_{i=1}^N(x_i - \\mu)^2}{N}}<br>$$</p>\n<p>样本标准差记为 $s$</p>\n<p>$$<br>s = \\sqrt{s^2} = \\sqrt{\\frac{\\sum_{i=1}^n(x_i - \\overline{X})^2}{n - 1}}<br>$$</p>\n<h4 id=\"为什么要引入标准差\"><a href=\"#为什么要引入标准差\" class=\"headerlink\" title=\"为什么要引入标准差\"></a>为什么要引入标准差</h4><p>一方面，相比于方差，标准差的单位更友好：方差的计算里面因为使用了平方，所以单位也是是原数据单位的平方；而平方根的单位和原数据单位保持一致。</p>\n<p>另一方面，在某些场景下，标准差更容易观察数据，比如正态分布等。</p>"},{"title":"Run \"sh -c node-gyp rebuild\" error","date":"2016-10-26T03:43:34.000Z","_content":"\nnpm 安装包的时候，出现 `Run \"sh -c node-gyp rebuild\" error` 异常，这是因为需要 C++ 11 的编译环境，使用 `gcc -v` 命令查看一下机器上 gcc 的版本，发现是 4.4.7，将其升级至 4.8.0 之后即可。\n\n<!-- more -->\n\n## 升级 gcc\n\n### 1.下载源码包\n\n```bash\nwget http: //ftp.gnu.org/gnu/gcc/gcc-4.8.0/gcc-4.8.0.tar.bz2\ntar -jxvf  gcc-4.8.0.tar.bz2\n```\n\n### 2.下载编译所需依赖库\n\n```bash\ncd gcc-4.8.0\n./contrib/download_prerequisites\n```\n\n\n### 3.建立编译输出目录\n\n```bash\ncd ..\nmkdir gcc-build-4.8.0\n```\n\n### 4.进入此目录，执行以下命令，生成makefile文件\n\n```bash\ncd  gcc-build-4.8.0\n../gcc-4.8.0/configure --enable-checking=release --enable-languages=c,c++ --disable-multilib\n```\n\n### 5.编译\n\n```bash\nmake -j4\n```\n*j 后面的是核心数，编译速度会比较快*\n\n### 6.安装\n\n```bash\nsudo make install\n```\n\n## 问题\n### 内存不足\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/update-gcc/update-gcc-01.png)\n出现这个问题是因为内存不足，释放内存之后重试一下","source":"_posts/update-gcc.md","raw":"---\ntitle: Run \"sh -c node-gyp rebuild\" error\ndate: 2016-10-26 11:43:34\ntags: [总结]\n---\n\nnpm 安装包的时候，出现 `Run \"sh -c node-gyp rebuild\" error` 异常，这是因为需要 C++ 11 的编译环境，使用 `gcc -v` 命令查看一下机器上 gcc 的版本，发现是 4.4.7，将其升级至 4.8.0 之后即可。\n\n<!-- more -->\n\n## 升级 gcc\n\n### 1.下载源码包\n\n```bash\nwget http: //ftp.gnu.org/gnu/gcc/gcc-4.8.0/gcc-4.8.0.tar.bz2\ntar -jxvf  gcc-4.8.0.tar.bz2\n```\n\n### 2.下载编译所需依赖库\n\n```bash\ncd gcc-4.8.0\n./contrib/download_prerequisites\n```\n\n\n### 3.建立编译输出目录\n\n```bash\ncd ..\nmkdir gcc-build-4.8.0\n```\n\n### 4.进入此目录，执行以下命令，生成makefile文件\n\n```bash\ncd  gcc-build-4.8.0\n../gcc-4.8.0/configure --enable-checking=release --enable-languages=c,c++ --disable-multilib\n```\n\n### 5.编译\n\n```bash\nmake -j4\n```\n*j 后面的是核心数，编译速度会比较快*\n\n### 6.安装\n\n```bash\nsudo make install\n```\n\n## 问题\n### 内存不足\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/update-gcc/update-gcc-01.png)\n出现这个问题是因为内存不足，释放内存之后重试一下","slug":"update-gcc","published":1,"updated":"2016-10-26T03:38:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcx4002sn927prd9o185","content":"<p>npm 安装包的时候，出现 <code>Run &quot;sh -c node-gyp rebuild&quot; error</code> 异常，这是因为需要 C++ 11 的编译环境，使用 <code>gcc -v</code> 命令查看一下机器上 gcc 的版本，发现是 4.4.7，将其升级至 4.8.0 之后即可。</p>\n<a id=\"more\"></a>\n<h2 id=\"升级-gcc\"><a href=\"#升级-gcc\" class=\"headerlink\" title=\"升级 gcc\"></a>升级 gcc</h2><h3 id=\"1-下载源码包\"><a href=\"#1-下载源码包\" class=\"headerlink\" title=\"1.下载源码包\"></a>1.下载源码包</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http: //ftp.gnu.org/gnu/gcc/gcc-4.8.0/gcc-4.8.0.tar.bz2</div><div class=\"line\">tar -jxvf  gcc-4.8.0.tar.bz2</div></pre></td></tr></table></figure>\n<h3 id=\"2-下载编译所需依赖库\"><a href=\"#2-下载编译所需依赖库\" class=\"headerlink\" title=\"2.下载编译所需依赖库\"></a>2.下载编译所需依赖库</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cd</span> gcc-4.8.0</div><div class=\"line\">./contrib/download_prerequisites</div></pre></td></tr></table></figure>\n<h3 id=\"3-建立编译输出目录\"><a href=\"#3-建立编译输出目录\" class=\"headerlink\" title=\"3.建立编译输出目录\"></a>3.建立编译输出目录</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cd</span> ..</div><div class=\"line\">mkdir gcc-build-4.8.0</div></pre></td></tr></table></figure>\n<h3 id=\"4-进入此目录，执行以下命令，生成makefile文件\"><a href=\"#4-进入此目录，执行以下命令，生成makefile文件\" class=\"headerlink\" title=\"4.进入此目录，执行以下命令，生成makefile文件\"></a>4.进入此目录，执行以下命令，生成makefile文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cd</span>  gcc-build-4.8.0</div><div class=\"line\">../gcc-4.8.0/configure --enable-checking=release --enable-languages=c,c++ --disable-multilib</div></pre></td></tr></table></figure>\n<h3 id=\"5-编译\"><a href=\"#5-编译\" class=\"headerlink\" title=\"5.编译\"></a>5.编译</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">make -j4</div></pre></td></tr></table></figure>\n<p><em>j 后面的是核心数，编译速度会比较快</em></p>\n<h3 id=\"6-安装\"><a href=\"#6-安装\" class=\"headerlink\" title=\"6.安装\"></a>6.安装</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo make install</div></pre></td></tr></table></figure>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><h3 id=\"内存不足\"><a href=\"#内存不足\" class=\"headerlink\" title=\"内存不足\"></a>内存不足</h3><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/update-gcc/update-gcc-01.png\" alt=\"\"><br>出现这个问题是因为内存不足，释放内存之后重试一下</p>\n","excerpt":"<p>npm 安装包的时候，出现 <code>Run &quot;sh -c node-gyp rebuild&quot; error</code> 异常，这是因为需要 C++ 11 的编译环境，使用 <code>gcc -v</code> 命令查看一下机器上 gcc 的版本，发现是 4.4.7，将其升级至 4.8.0 之后即可。</p>","more":"<h2 id=\"升级-gcc\"><a href=\"#升级-gcc\" class=\"headerlink\" title=\"升级 gcc\"></a>升级 gcc</h2><h3 id=\"1-下载源码包\"><a href=\"#1-下载源码包\" class=\"headerlink\" title=\"1.下载源码包\"></a>1.下载源码包</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http: //ftp.gnu.org/gnu/gcc/gcc-4.8.0/gcc-4.8.0.tar.bz2</div><div class=\"line\">tar -jxvf  gcc-4.8.0.tar.bz2</div></pre></td></tr></table></figure>\n<h3 id=\"2-下载编译所需依赖库\"><a href=\"#2-下载编译所需依赖库\" class=\"headerlink\" title=\"2.下载编译所需依赖库\"></a>2.下载编译所需依赖库</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cd</span> gcc-4.8.0</div><div class=\"line\">./contrib/download_prerequisites</div></pre></td></tr></table></figure>\n<h3 id=\"3-建立编译输出目录\"><a href=\"#3-建立编译输出目录\" class=\"headerlink\" title=\"3.建立编译输出目录\"></a>3.建立编译输出目录</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cd</span> ..</div><div class=\"line\">mkdir gcc-build-4.8.0</div></pre></td></tr></table></figure>\n<h3 id=\"4-进入此目录，执行以下命令，生成makefile文件\"><a href=\"#4-进入此目录，执行以下命令，生成makefile文件\" class=\"headerlink\" title=\"4.进入此目录，执行以下命令，生成makefile文件\"></a>4.进入此目录，执行以下命令，生成makefile文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cd</span>  gcc-build-4.8.0</div><div class=\"line\">../gcc-4.8.0/configure --enable-checking=release --enable-languages=c,c++ --disable-multilib</div></pre></td></tr></table></figure>\n<h3 id=\"5-编译\"><a href=\"#5-编译\" class=\"headerlink\" title=\"5.编译\"></a>5.编译</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">make -j4</div></pre></td></tr></table></figure>\n<p><em>j 后面的是核心数，编译速度会比较快</em></p>\n<h3 id=\"6-安装\"><a href=\"#6-安装\" class=\"headerlink\" title=\"6.安装\"></a>6.安装</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo make install</div></pre></td></tr></table></figure>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><h3 id=\"内存不足\"><a href=\"#内存不足\" class=\"headerlink\" title=\"内存不足\"></a>内存不足</h3><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/update-gcc/update-gcc-01.png\" alt=\"\"><br>出现这个问题是因为内存不足，释放内存之后重试一下</p>"},{"title":"使用 svg 让线条动起来","date":"2016-06-28T12:43:19.000Z","_content":"[百度echarts3官网](http://echarts.baidu.com/index.html) 上有一个非常好看的绘制 logo 的效果，通过 svg 就能实现：\n![绘制logo](http://7xo08n.com1.z0.glb.clouddn.com/blog%2Fuse-svg-draw-line/02.gif)\n\n与此类似的还有绘制签名的过程：\n![绘制签名](http://7xo08n.com1.z0.glb.clouddn.com/blog/use-svg-draw-line/01.gif)\n\n其实原理很简单，只要充分发挥想象力，加上好看的设计，就能完成很多意想不到的效果了。\n\n<!-- more -->\n\n## 准备 svg\n首先要准备绘制的路径，SVG里用 path 来定义路径\n```html\n<svg width=\"580\" height=\"400\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"m149,123c0,1 -1.496231,3.907784 -2,8c-0.122177,0.992508 -2.206802,4.812653 -4,7c-2.285873,2.78833 -3.49295,5.234009 -6,10\" id=\"svg_27\" fill-opacity=\"null\" stroke-opacity=\"null\" stroke-width=\"1.5\" stroke=\"#000\" fill=\"none\"/>\n</svg>\n```\n网上可以找到很多在线的或客户端可以用来生成 svg，比如写这个 demo 用到的是 [这个在线编辑svg的网站](http://www.yyyweb.com/ctools/demo.php)。\n\n## 主要属性\n有了一段 path 之后，我们就可以开始让它动起来了，这里涉及到两个属性：\n- stroke-dasharray\n- stroke-dashoffset\n\n`stroke-dasharray` 可以让线条变成虚线，第一个值设置每段虚线的长度，第二个值设置虚线之间的间隔，如：\n\n原线条：\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/use-svg-draw-line/03.png)\n\n设置 `stroke-dasharray: 20 5` 之后：\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/use-svg-draw-line/04.png)\n\n`stroke-dashoffset` 用来设置虚线的偏移量\n\n## 原理\n可以想到，如果我们设置每段虚线的长度和虚线之间的间隔都大于整条路径的长度，那么虽然看起来没有变化，但实际上整个路径显示出来的只是一小段虚线。\n\n接着我们设置 `stroke-dashoffset` 让这条虚线偏移一个路径的长度，此时路径就不可见了，因为已经虚线已经偏移出路径了，而虚线间的空隙是大于一个路径长的。\n\n最后我们通过动画让 `stroke-dashoffset` 缓慢变为 0，这时就有绘制的效果了。\n\n代码示例：\n```javascript\nvar path = document.querySelector('path');\n// 获取路径的长度\nvar length = path.getTotalLength();\n// 设置起始点\npath.style.strokeDasharray = `${length} ${length}`;\npath.style.strokeDashoffset = length;\n// 获取一个区域，获取相关的样式，让浏览器寻找一个起始点。\npath.getBoundingClientRect();\n// 定义动作\npath.style.transition = 'stroke-dashoffset 2s ease-in-out';\n// 开始绘制\npath.style.strokeDashoffset = '0';\n```\n\n当要绘制签名这种有很多线条的图形时，只需要给每一段都设置好时间，通过 `transition` 的 `delay` 来控制开始时间即可。\n\n当要绘制本文一开始出现的闭合图形时，可以通过改变 `stroke-dasharray` 中的长度和间隔来控制。\n","source":"_posts/use-svg-to-draw-line.md","raw":"---\ntitle: 使用 svg 让线条动起来\ndate: 2016-06-28 20:43:19\ntags: [总结, svg]\n---\n[百度echarts3官网](http://echarts.baidu.com/index.html) 上有一个非常好看的绘制 logo 的效果，通过 svg 就能实现：\n![绘制logo](http://7xo08n.com1.z0.glb.clouddn.com/blog%2Fuse-svg-draw-line/02.gif)\n\n与此类似的还有绘制签名的过程：\n![绘制签名](http://7xo08n.com1.z0.glb.clouddn.com/blog/use-svg-draw-line/01.gif)\n\n其实原理很简单，只要充分发挥想象力，加上好看的设计，就能完成很多意想不到的效果了。\n\n<!-- more -->\n\n## 准备 svg\n首先要准备绘制的路径，SVG里用 path 来定义路径\n```html\n<svg width=\"580\" height=\"400\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"m149,123c0,1 -1.496231,3.907784 -2,8c-0.122177,0.992508 -2.206802,4.812653 -4,7c-2.285873,2.78833 -3.49295,5.234009 -6,10\" id=\"svg_27\" fill-opacity=\"null\" stroke-opacity=\"null\" stroke-width=\"1.5\" stroke=\"#000\" fill=\"none\"/>\n</svg>\n```\n网上可以找到很多在线的或客户端可以用来生成 svg，比如写这个 demo 用到的是 [这个在线编辑svg的网站](http://www.yyyweb.com/ctools/demo.php)。\n\n## 主要属性\n有了一段 path 之后，我们就可以开始让它动起来了，这里涉及到两个属性：\n- stroke-dasharray\n- stroke-dashoffset\n\n`stroke-dasharray` 可以让线条变成虚线，第一个值设置每段虚线的长度，第二个值设置虚线之间的间隔，如：\n\n原线条：\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/use-svg-draw-line/03.png)\n\n设置 `stroke-dasharray: 20 5` 之后：\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/use-svg-draw-line/04.png)\n\n`stroke-dashoffset` 用来设置虚线的偏移量\n\n## 原理\n可以想到，如果我们设置每段虚线的长度和虚线之间的间隔都大于整条路径的长度，那么虽然看起来没有变化，但实际上整个路径显示出来的只是一小段虚线。\n\n接着我们设置 `stroke-dashoffset` 让这条虚线偏移一个路径的长度，此时路径就不可见了，因为已经虚线已经偏移出路径了，而虚线间的空隙是大于一个路径长的。\n\n最后我们通过动画让 `stroke-dashoffset` 缓慢变为 0，这时就有绘制的效果了。\n\n代码示例：\n```javascript\nvar path = document.querySelector('path');\n// 获取路径的长度\nvar length = path.getTotalLength();\n// 设置起始点\npath.style.strokeDasharray = `${length} ${length}`;\npath.style.strokeDashoffset = length;\n// 获取一个区域，获取相关的样式，让浏览器寻找一个起始点。\npath.getBoundingClientRect();\n// 定义动作\npath.style.transition = 'stroke-dashoffset 2s ease-in-out';\n// 开始绘制\npath.style.strokeDashoffset = '0';\n```\n\n当要绘制签名这种有很多线条的图形时，只需要给每一段都设置好时间，通过 `transition` 的 `delay` 来控制开始时间即可。\n\n当要绘制本文一开始出现的闭合图形时，可以通过改变 `stroke-dasharray` 中的长度和间隔来控制。\n","slug":"use-svg-to-draw-line","published":1,"updated":"2017-03-17T13:41:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2navcx6002un927pzu584uv","content":"<p><a href=\"http://echarts.baidu.com/index.html\" target=\"_blank\" rel=\"external\">百度echarts3官网</a> 上有一个非常好看的绘制 logo 的效果，通过 svg 就能实现：<br><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog%2Fuse-svg-draw-line/02.gif\" alt=\"绘制logo\"></p>\n<p>与此类似的还有绘制签名的过程：<br><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/use-svg-draw-line/01.gif\" alt=\"绘制签名\"></p>\n<p>其实原理很简单，只要充分发挥想象力，加上好看的设计，就能完成很多意想不到的效果了。</p>\n<a id=\"more\"></a>\n<h2 id=\"准备-svg\"><a href=\"#准备-svg\" class=\"headerlink\" title=\"准备 svg\"></a>准备 svg</h2><p>首先要准备绘制的路径，SVG里用 path 来定义路径<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span> <span class=\"attr\">width</span>=<span class=\"string\">\"580\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"400\"</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.w3.org/2000/svg\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">d</span>=<span class=\"string\">\"m149,123c0,1 -1.496231,3.907784 -2,8c-0.122177,0.992508 -2.206802,4.812653 -4,7c-2.285873,2.78833 -3.49295,5.234009 -6,10\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"svg_27\"</span> <span class=\"attr\">fill-opacity</span>=<span class=\"string\">\"null\"</span> <span class=\"attr\">stroke-opacity</span>=<span class=\"string\">\"null\"</span> <span class=\"attr\">stroke-width</span>=<span class=\"string\">\"1.5\"</span> <span class=\"attr\">stroke</span>=<span class=\"string\">\"#000\"</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"none\"</span>/&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>网上可以找到很多在线的或客户端可以用来生成 svg，比如写这个 demo 用到的是 <a href=\"http://www.yyyweb.com/ctools/demo.php\" target=\"_blank\" rel=\"external\">这个在线编辑svg的网站</a>。</p>\n<h2 id=\"主要属性\"><a href=\"#主要属性\" class=\"headerlink\" title=\"主要属性\"></a>主要属性</h2><p>有了一段 path 之后，我们就可以开始让它动起来了，这里涉及到两个属性：</p>\n<ul>\n<li>stroke-dasharray</li>\n<li>stroke-dashoffset</li>\n</ul>\n<p><code>stroke-dasharray</code> 可以让线条变成虚线，第一个值设置每段虚线的长度，第二个值设置虚线之间的间隔，如：</p>\n<p>原线条：<br><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/use-svg-draw-line/03.png\" alt=\"\"></p>\n<p>设置 <code>stroke-dasharray: 20 5</code> 之后：<br><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/use-svg-draw-line/04.png\" alt=\"\"></p>\n<p><code>stroke-dashoffset</code> 用来设置虚线的偏移量</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>可以想到，如果我们设置每段虚线的长度和虚线之间的间隔都大于整条路径的长度，那么虽然看起来没有变化，但实际上整个路径显示出来的只是一小段虚线。</p>\n<p>接着我们设置 <code>stroke-dashoffset</code> 让这条虚线偏移一个路径的长度，此时路径就不可见了，因为已经虚线已经偏移出路径了，而虚线间的空隙是大于一个路径长的。</p>\n<p>最后我们通过动画让 <code>stroke-dashoffset</code> 缓慢变为 0，这时就有绘制的效果了。</p>\n<p>代码示例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'path'</span>);</div><div class=\"line\"><span class=\"comment\">// 获取路径的长度</span></div><div class=\"line\"><span class=\"keyword\">var</span> length = path.getTotalLength();</div><div class=\"line\"><span class=\"comment\">// 设置起始点</span></div><div class=\"line\">path.style.strokeDasharray = <span class=\"string\">`<span class=\"subst\">$&#123;length&#125;</span> <span class=\"subst\">$&#123;length&#125;</span>`</span>;</div><div class=\"line\">path.style.strokeDashoffset = length;</div><div class=\"line\"><span class=\"comment\">// 获取一个区域，获取相关的样式，让浏览器寻找一个起始点。</span></div><div class=\"line\">path.getBoundingClientRect();</div><div class=\"line\"><span class=\"comment\">// 定义动作</span></div><div class=\"line\">path.style.transition = <span class=\"string\">'stroke-dashoffset 2s ease-in-out'</span>;</div><div class=\"line\"><span class=\"comment\">// 开始绘制</span></div><div class=\"line\">path.style.strokeDashoffset = <span class=\"string\">'0'</span>;</div></pre></td></tr></table></figure></p>\n<p>当要绘制签名这种有很多线条的图形时，只需要给每一段都设置好时间，通过 <code>transition</code> 的 <code>delay</code> 来控制开始时间即可。</p>\n<p>当要绘制本文一开始出现的闭合图形时，可以通过改变 <code>stroke-dasharray</code> 中的长度和间隔来控制。</p>\n","excerpt":"<p><a href=\"http://echarts.baidu.com/index.html\">百度echarts3官网</a> 上有一个非常好看的绘制 logo 的效果，通过 svg 就能实现：<br><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog%2Fuse-svg-draw-line/02.gif\" alt=\"绘制logo\"></p>\n<p>与此类似的还有绘制签名的过程：<br><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/use-svg-draw-line/01.gif\" alt=\"绘制签名\"></p>\n<p>其实原理很简单，只要充分发挥想象力，加上好看的设计，就能完成很多意想不到的效果了。</p>","more":"<h2 id=\"准备-svg\"><a href=\"#准备-svg\" class=\"headerlink\" title=\"准备 svg\"></a>准备 svg</h2><p>首先要准备绘制的路径，SVG里用 path 来定义路径<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span> <span class=\"attr\">width</span>=<span class=\"string\">\"580\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"400\"</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.w3.org/2000/svg\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">d</span>=<span class=\"string\">\"m149,123c0,1 -1.496231,3.907784 -2,8c-0.122177,0.992508 -2.206802,4.812653 -4,7c-2.285873,2.78833 -3.49295,5.234009 -6,10\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"svg_27\"</span> <span class=\"attr\">fill-opacity</span>=<span class=\"string\">\"null\"</span> <span class=\"attr\">stroke-opacity</span>=<span class=\"string\">\"null\"</span> <span class=\"attr\">stroke-width</span>=<span class=\"string\">\"1.5\"</span> <span class=\"attr\">stroke</span>=<span class=\"string\">\"#000\"</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"none\"</span>/&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>网上可以找到很多在线的或客户端可以用来生成 svg，比如写这个 demo 用到的是 <a href=\"http://www.yyyweb.com/ctools/demo.php\">这个在线编辑svg的网站</a>。</p>\n<h2 id=\"主要属性\"><a href=\"#主要属性\" class=\"headerlink\" title=\"主要属性\"></a>主要属性</h2><p>有了一段 path 之后，我们就可以开始让它动起来了，这里涉及到两个属性：</p>\n<ul>\n<li>stroke-dasharray</li>\n<li>stroke-dashoffset</li>\n</ul>\n<p><code>stroke-dasharray</code> 可以让线条变成虚线，第一个值设置每段虚线的长度，第二个值设置虚线之间的间隔，如：</p>\n<p>原线条：<br><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/use-svg-draw-line/03.png\" alt=\"\"></p>\n<p>设置 <code>stroke-dasharray: 20 5</code> 之后：<br><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/use-svg-draw-line/04.png\" alt=\"\"></p>\n<p><code>stroke-dashoffset</code> 用来设置虚线的偏移量</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>可以想到，如果我们设置每段虚线的长度和虚线之间的间隔都大于整条路径的长度，那么虽然看起来没有变化，但实际上整个路径显示出来的只是一小段虚线。</p>\n<p>接着我们设置 <code>stroke-dashoffset</code> 让这条虚线偏移一个路径的长度，此时路径就不可见了，因为已经虚线已经偏移出路径了，而虚线间的空隙是大于一个路径长的。</p>\n<p>最后我们通过动画让 <code>stroke-dashoffset</code> 缓慢变为 0，这时就有绘制的效果了。</p>\n<p>代码示例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'path'</span>);</div><div class=\"line\"><span class=\"comment\">// 获取路径的长度</span></div><div class=\"line\"><span class=\"keyword\">var</span> length = path.getTotalLength();</div><div class=\"line\"><span class=\"comment\">// 设置起始点</span></div><div class=\"line\">path.style.strokeDasharray = <span class=\"string\">`<span class=\"subst\">$&#123;length&#125;</span> <span class=\"subst\">$&#123;length&#125;</span>`</span>;</div><div class=\"line\">path.style.strokeDashoffset = length;</div><div class=\"line\"><span class=\"comment\">// 获取一个区域，获取相关的样式，让浏览器寻找一个起始点。</span></div><div class=\"line\">path.getBoundingClientRect();</div><div class=\"line\"><span class=\"comment\">// 定义动作</span></div><div class=\"line\">path.style.transition = <span class=\"string\">'stroke-dashoffset 2s ease-in-out'</span>;</div><div class=\"line\"><span class=\"comment\">// 开始绘制</span></div><div class=\"line\">path.style.strokeDashoffset = <span class=\"string\">'0'</span>;</div></pre></td></tr></table></figure></p>\n<p>当要绘制签名这种有很多线条的图形时，只需要给每一段都设置好时间，通过 <code>transition</code> 的 <code>delay</code> 来控制开始时间即可。</p>\n<p>当要绘制本文一开始出现的闭合图形时，可以通过改变 <code>stroke-dasharray</code> 中的长度和间隔来控制。</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj2navcu90001n927k6biviyc","tag_id":"cj2navcup0005n927gmzi2f3d","_id":"cj2navcux000an927u616ixi8"},{"post_id":"cj2navcui0003n92755xnou01","tag_id":"cj2navcuw0009n927z7g9x62g","_id":"cj2navcv8000in927cuqr5sbj"},{"post_id":"cj2navcui0003n92755xnou01","tag_id":"cj2navcv2000dn927tky8kg24","_id":"cj2navcva000kn927od8b5jbm"},{"post_id":"cj2navcv8000jn927my3hb8jf","tag_id":"cj2navcup0005n927gmzi2f3d","_id":"cj2navcvd000nn9271ail8vks"},{"post_id":"cj2navcur0006n927z7i5mtwy","tag_id":"cj2navcuw0009n927z7g9x62g","_id":"cj2navcvh000rn927gkv2msj5"},{"post_id":"cj2navcur0006n927z7i5mtwy","tag_id":"cj2navcv2000dn927tky8kg24","_id":"cj2navcvj000tn927xjxblvdt"},{"post_id":"cj2navcut0007n927kpzd7p3f","tag_id":"cj2navcuw0009n927z7g9x62g","_id":"cj2navcvp000zn927ale1m368"},{"post_id":"cj2navcut0007n927kpzd7p3f","tag_id":"cj2navcv2000dn927tky8kg24","_id":"cj2navcvq0011n9275eggf1xy"},{"post_id":"cj2navcvp0010n9274iv0kky7","tag_id":"cj2navcup0005n927gmzi2f3d","_id":"cj2navcvs0014n927sz6hvw9j"},{"post_id":"cj2navcuv0008n927rvcl2055","tag_id":"cj2navcuw0009n927z7g9x62g","_id":"cj2navcvw0018n927k5youpoe"},{"post_id":"cj2navcuv0008n927rvcl2055","tag_id":"cj2navcv2000dn927tky8kg24","_id":"cj2navcvx001an927nd9hon0l"},{"post_id":"cj2navcvv0017n927i3ipa2h6","tag_id":"cj2navcvu0016n927le15sgc2","_id":"cj2navcvy001dn927suapi8io"},{"post_id":"cj2navcuy000bn9278b88mo0h","tag_id":"cj2navcvu0016n927le15sgc2","_id":"cj2navcw1001fn927ktlgvt37"},{"post_id":"cj2navcv0000cn927rppfubx9","tag_id":"cj2navcuw0009n927z7g9x62g","_id":"cj2navcw3001in927fs7bsvf1"},{"post_id":"cj2navcv0000cn927rppfubx9","tag_id":"cj2navcv2000dn927tky8kg24","_id":"cj2navcw5001kn927gim7hfrt"},{"post_id":"cj2navcw0001en927vunshvd9","tag_id":"cj2navcup0005n927gmzi2f3d","_id":"cj2navcw7001nn927zyp6vtx1"},{"post_id":"cj2navcw2001hn9273zf7o024","tag_id":"cj2navcv2000dn927tky8kg24","_id":"cj2navcwb001pn927lggwl4f1"},{"post_id":"cj2navcw3001jn927r1mzkwyg","tag_id":"cj2navcup0005n927gmzi2f3d","_id":"cj2navcwd001sn9278poaxkm6"},{"post_id":"cj2navcv2000en927y7q9itiu","tag_id":"cj2navcw1001gn9274umbf1sa","_id":"cj2navcwf001un927ibpceuyn"},{"post_id":"cj2navcw5001ln927prno9jl6","tag_id":"cj2navcw1001gn9274umbf1sa","_id":"cj2navcwh001xn927bdot8l94"},{"post_id":"cj2navcv3000fn927fkmn7ypn","tag_id":"cj2navcw6001mn9275cthnxh8","_id":"cj2navcwk001zn927qcpuyz41"},{"post_id":"cj2navcwc001qn927iqnsku4v","tag_id":"cj2navcup0005n927gmzi2f3d","_id":"cj2navcwm0021n927ono54dnd"},{"post_id":"cj2navcwe001tn9279c3qlchr","tag_id":"cj2navcwd001rn9278tyuujbt","_id":"cj2navcwo0024n9273r5on3h4"},{"post_id":"cj2navcv7000hn927wjp9qtd8","tag_id":"cj2navcwd001rn9278tyuujbt","_id":"cj2navcwp0026n927axqx2w3b"},{"post_id":"cj2navcwi001yn927bgh8iv8m","tag_id":"cj2navcw1001gn9274umbf1sa","_id":"cj2navcwr0029n927zhmdtf98"},{"post_id":"cj2navcvb000mn927qekvwmql","tag_id":"cj2navcwh001wn927flxhdhdw","_id":"cj2navcwt002bn927sek5b285"},{"post_id":"cj2navcwm0023n927hjygjztg","tag_id":"cj2navcwd001rn9278tyuujbt","_id":"cj2navcwv002en927ctxtrr06"},{"post_id":"cj2navcvd000on927jig79d6m","tag_id":"cj2navcw1001gn9274umbf1sa","_id":"cj2navcww002gn927h29wun2d"},{"post_id":"cj2navcwo0025n927t3c3vn08","tag_id":"cj2navcwd001rn9278tyuujbt","_id":"cj2navcwy002jn9274x4slqle"},{"post_id":"cj2navcwq0028n927bwz5ygrv","tag_id":"cj2navcwd001rn9278tyuujbt","_id":"cj2navcwz002ln927m9cofm0d"},{"post_id":"cj2navcvf000qn927r614pjth","tag_id":"cj2navcvu0016n927le15sgc2","_id":"cj2navcx2002on927zyy1ic20"},{"post_id":"cj2navcws002an927v4o41a0g","tag_id":"cj2navcwh001wn927flxhdhdw","_id":"cj2navcx4002qn927uhls3qvo"},{"post_id":"cj2navcvh000sn927bsoh14p0","tag_id":"cj2navcw1001gn9274umbf1sa","_id":"cj2navcx6002tn9277n336ogd"},{"post_id":"cj2navcwv002fn927g22d3uvp","tag_id":"cj2navcup0005n927gmzi2f3d","_id":"cj2navcx8002vn927smsc3271"},{"post_id":"cj2navcvk000vn9276xm80dji","tag_id":"cj2navcwd001rn9278tyuujbt","_id":"cj2navcx8002xn927mnqejyjz"},{"post_id":"cj2navcwy002kn927a7d44nrm","tag_id":"cj2navcw6001mn9275cthnxh8","_id":"cj2navcx8002yn927nk96rjdv"},{"post_id":"cj2navcvm000wn927n7w5e10j","tag_id":"cj2navcw1001gn9274umbf1sa","_id":"cj2navcx90030n927uk8pdrjo"},{"post_id":"cj2navcx2002pn927ov4umfon","tag_id":"cj2navcw1001gn9274umbf1sa","_id":"cj2navcx90031n927g7zpl1i1"},{"post_id":"cj2navcx4002sn927prd9o185","tag_id":"cj2navcup0005n927gmzi2f3d","_id":"cj2navcxa0033n927nph44hrw"},{"post_id":"cj2navcvo000yn927mqeubzhr","tag_id":"cj2navcx4002rn927uqdi42ug","_id":"cj2navcxa0034n927fugu2xkr"},{"post_id":"cj2navcvr0013n927xb3fsd11","tag_id":"cj2navcw6001mn9275cthnxh8","_id":"cj2navcxb0036n927jwu60u2h"},{"post_id":"cj2navcvt0015n927f46l8fj7","tag_id":"cj2navcw6001mn9275cthnxh8","_id":"cj2navcxb0037n9279wbh1nx7"},{"post_id":"cj2navcvw0019n9278fqqsaa0","tag_id":"cj2navcwd001rn9278tyuujbt","_id":"cj2navcxb0039n927h98dj1lx"},{"post_id":"cj2navcvx001cn927konigf91","tag_id":"cj2navcwh001wn927flxhdhdw","_id":"cj2navcxc003bn92792n313no"},{"post_id":"cj2navcvx001cn927konigf91","tag_id":"cj2navcxb0038n927zbp5mlhi","_id":"cj2navcxc003cn9278v5wrl19"},{"post_id":"cj2navcw8001on927qud2ugep","tag_id":"cj2navcup0005n927gmzi2f3d","_id":"cj2navcxc003en9279m0ic09h"},{"post_id":"cj2navcw8001on927qud2ugep","tag_id":"cj2navcxc003an927pbwg9fk9","_id":"cj2navcxc003fn927z4gz29r0"},{"post_id":"cj2navcwf001vn927di2ikjj8","tag_id":"cj2navcup0005n927gmzi2f3d","_id":"cj2navcxd003hn927gay2ibv4"},{"post_id":"cj2navcwf001vn927di2ikjj8","tag_id":"cj2navcxc003dn9272e0p9tex","_id":"cj2navcxd003in927ahz11ra1"},{"post_id":"cj2navcwl0020n9277bxk7dj7","tag_id":"cj2navcxc003gn927gb4qjeuu","_id":"cj2navcxd003kn927yg29m5cd"},{"post_id":"cj2navcwu002dn9275nvxqz4b","tag_id":"cj2navcxd003jn927c2nu83g8","_id":"cj2navcxe003mn927m1tosc9l"},{"post_id":"cj2navcwx002in927scste4vb","tag_id":"cj2navcup0005n927gmzi2f3d","_id":"cj2navcxg003on9273tnnikb0"},{"post_id":"cj2navcwx002in927scste4vb","tag_id":"cj2navcxd003ln927axx74rd5","_id":"cj2navcxg003pn927b5nxagxe"},{"post_id":"cj2navcx0002nn927woxiw2f5","tag_id":"cj2navcup0005n927gmzi2f3d","_id":"cj2navcxh003rn92746s575vu"},{"post_id":"cj2navcx0002nn927woxiw2f5","tag_id":"cj2navcx4002rn927uqdi42ug","_id":"cj2navcxi003sn927paflcq6k"},{"post_id":"cj2navcx6002un927pzu584uv","tag_id":"cj2navcup0005n927gmzi2f3d","_id":"cj2navcxi003tn927ajf60dte"},{"post_id":"cj2navcx6002un927pzu584uv","tag_id":"cj2navcxg003qn92789y7td1a","_id":"cj2navcxi003un9276gypvm13"}],"Tag":[{"name":"总结","_id":"cj2navcup0005n927gmzi2f3d"},{"name":"读书笔记","_id":"cj2navcuw0009n927z7g9x62g"},{"name":"算法","_id":"cj2navcv2000dn927tky8kg24"},{"name":"密码技术","_id":"cj2navcvu0016n927le15sgc2"},{"name":"统计学","_id":"cj2navcw1001gn9274umbf1sa"},{"name":"数据结构","_id":"cj2navcw6001mn9275cthnxh8"},{"name":"单变量微积分","_id":"cj2navcwd001rn9278tyuujbt"},{"name":"nodejs","_id":"cj2navcwh001wn927flxhdhdw"},{"name":"javascript","_id":"cj2navcx4002rn927uqdi42ug"},{"name":"express","_id":"cj2navcxb0038n927zbp5mlhi"},{"name":"hexo","_id":"cj2navcxc003an927pbwg9fk9"},{"name":"kafka","_id":"cj2navcxc003dn9272e0p9tex"},{"name":"自然语言处理 读书笔记","_id":"cj2navcxc003gn927gb4qjeuu"},{"name":"nginx","_id":"cj2navcxd003jn927c2nu83g8"},{"name":"react","_id":"cj2navcxd003ln927axx74rd5"},{"name":"svg","_id":"cj2navcxg003qn92789y7td1a"}]}}
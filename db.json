{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/next/source/404.html","path":"404.html","modified":1,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","path":"vendors/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","path":"vendors/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/images/aoliao.png","path":"images/aoliao.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"ca4676214e2f3f6bcb8b587ab85416a7eb090157","modified":1472256196000},{"_id":"themes/next/.gitignore","hash":"efec790f5b7a0256763e1cc08f12c4f0aff509f6","modified":1472256196000},{"_id":"themes/next/.javascript_ignore","hash":"d619ee13031908cd72666e4ff652d2ea3483b1c3","modified":1472256196000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1472256196000},{"_id":"themes/next/.bowerrc","hash":"80e096fdc1cf912ee85dd9f7e6e77fd40cf60f10","modified":1472256196000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1472256196000},{"_id":"themes/next/_config.yml","hash":"023330374343d3a5f6ca89aa4d9ba4723d03968e","modified":1472256196000},{"_id":"themes/next/bower.json","hash":"f89c6700a11d81e067cc97273ca6bf96cb88c8f9","modified":1472256196000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1472256196000},{"_id":"themes/next/gulpfile.coffee","hash":"26e5b1b945704c8bc78b928feede895c4c111c95","modified":1472256196000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1472256196000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1472256196000},{"_id":"themes/next/package.json","hash":"63e9c0f1dd9e5d7f51b4ae383981ef939a2ed45d","modified":1472256196000},{"_id":"source/_posts/Introduction-to-Algorithms-2.md","hash":"8cb7986852c87c2a704e471f01bc2da3a40e3930","modified":1472256196000},{"_id":"source/_posts/Introduction-to-Algorithms-4.md","hash":"6a68ece0d50e047521d42d3bbdbaa60ef628315e","modified":1472256196000},{"_id":"source/_posts/Introduction-to-Algorithms-6.md","hash":"7f29e70a4644cd6f608f8e242694e10a64ef9fc8","modified":1472256196000},{"_id":"source/_posts/Introduction-to-Algorithms-7.md","hash":"5c44332270d086540489a26d84abc066e9243b91","modified":1472256196000},{"_id":"source/_posts/Introduction-to-Algorithms-8.md","hash":"6eb469d2a064727292ee37eabe788fd12c86c17e","modified":1472256196000},{"_id":"source/_posts/binary-search-tree.md","hash":"9cac687d94dfd471256a6bc23788d00483850837","modified":1472256196000},{"_id":"source/_posts/calculate-24-game.md","hash":"adabf611bbba91c093de44ca682094b85a2fcc89","modified":1472256196000},{"_id":"source/_posts/currying.md","hash":"685dd6af4d56d80f3bc60a65abd665dea28ad72b","modified":1472256196000},{"_id":"source/_posts/data-capture.md","hash":"314cbd727308fda5f7b3623f150129217486ad86","modified":1472256196000},{"_id":"source/_posts/data-structures-2.md","hash":"79d43dd17d4d4bdde6d328fa3b6199c6586a1ba3","modified":1472256196000},{"_id":"source/_posts/data-structures.md","hash":"df2e7386117b6016b247dd63b4ab6a17fc5dc8b3","modified":1472256196000},{"_id":"source/_posts/five-in-a-row-game.md","hash":"b26b3af25fb8f744567c3f88b1ea90b6d751b7b6","modified":1472256196000},{"_id":"source/_posts/git.md","hash":"0deddc6054a5a0892d8588b520b74c341d590c83","modified":1472257017000},{"_id":"source/_posts/natural-language-processing-1.md","hash":"00e92c9acbe5857167c809e82a8d992a3774cbb7","modified":1472256196000},{"_id":"source/_posts/red-black-tree.md","hash":"75766078eb43b8deab2671082e2050bb13b622b5","modified":1472256196000},{"_id":"source/_posts/thread-in-javascript.md","hash":"a992e6c7cd3eb7e5571c0590dc09c20c0abce13b","modified":1472257017000},{"_id":"source/_posts/use-svg-to-draw-line.md","hash":"8adf7895b78d2de3a39d7d649ca06870a75d3608","modified":1472256196000},{"_id":"source/categories/index.md","hash":"febd887e2f4b7d531a03f6125152ec36416aacd7","modified":1472256196000},{"_id":"source/tags/index.md","hash":"3365be6aa2194cf67a2505b305458372491a2c54","modified":1472256196000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1472256196000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1472256196000},{"_id":"themes/next/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1472256196000},{"_id":"themes/next/languages/en.yml","hash":"f03799cbdb5a33064ead080bcac4baca1f6bc5f9","modified":1472256196000},{"_id":"themes/next/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1472256196000},{"_id":"themes/next/languages/id.yml","hash":"147c01e41b931085ad14250fa900c2249dcbbdd7","modified":1472256196000},{"_id":"themes/next/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1472256196000},{"_id":"themes/next/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1472256196000},{"_id":"themes/next/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1472256196000},{"_id":"themes/next/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1472256196000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"bea452bc49aed171a210d09bd6cddc4e846ea8ab","modified":1472256196000},{"_id":"themes/next/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1472256196000},{"_id":"themes/next/languages/zh-tw.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1472256196000},{"_id":"themes/next/layout/_layout.swig","hash":"74157f6cfd679ea11febec632542793f37c5e5d4","modified":1472256196000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1472256196000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1472256196000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1472256196000},{"_id":"themes/next/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1472256196000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1472256196000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1472256196000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1472256196000},{"_id":"themes/next/source/404.html","hash":"3f0cfb0b8a15eec015e87738cbeffc2f205ce70e","modified":1472256196000},{"_id":"themes/next/test/.jshintrc","hash":"096ed6df627373edd820f24d46b8baf528dee61d","modified":1472256196000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1472256196000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1472256196000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472256196000},{"_id":"themes/next/layout/_macro/post.swig","hash":"1ca03011bed92614832b1343b65be92183957dc5","modified":1472256196000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"b883289054ee54a374caad5d4883591beb94bd8b","modified":1472256196000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1472256196000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"0ce71d8322ea7dea82d9371fa2fe13949aa870e3","modified":1472256196000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"b73f9443bee2d3ea383aad52e49ffca8aa97dcc2","modified":1472256196000},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b0c495b8154ef8b2d2cb0a554e164ff22cdc962","modified":1472256196000},{"_id":"themes/next/layout/_partials/header.swig","hash":"963a765dc00e6ac43cfc53ffaf5725eb854cf95e","modified":1472256196000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1472256196000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"85327c2174d09c6d69c9033592e6c8f7eb7ac3ba","modified":1472256196000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1472256196000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1472256196000},{"_id":"themes/next/layout/_partials/search.swig","hash":"011b9d6c9f0a2f4654908ea20b9391f9b7981271","modified":1472256196000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"82d060fe055d6e423bbc9199f82dfe5c68e74779","modified":1472256196000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1472256196000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1472256196000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1472256196000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1472256196000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1472256196000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1472256196000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1472256196000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1472256196000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1472256196000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1472256196000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1472256196000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1472256196000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1472256196000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1472256196000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1472256196000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1472256196000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1472256196000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1472256196000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1472256196000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1472256196000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472256196000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472256196000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472256196000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472256196000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472256196000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472256196000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472256196000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1472256196000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1472256196000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1472256196000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1472256196000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"c07f7b2f264e5215b8ed42d67e8cef2477558364","modified":1472256196000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"7ca5cb4daa58b3504e17f3e02975e794bc634658","modified":1472256196000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1472256196000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1472256196000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1472256196000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1472256196000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1472256196000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1472256196000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"1561bd0c107d725252c6d746e9ac177fc18f93bf","modified":1472256196000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"5bafc33f57508d1d04a9930165240f6e9efa8d6d","modified":1472256196000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1472256196000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1472256196000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1472256196000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1472256196000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1472256196000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1472256196000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"3ead77befa064d6327dc7afd0a5af7be59a5f196","modified":1472256196000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"17624186f7a1f28daddea258d044f8e03b2f4bea","modified":1472256196000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1472256196000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1472256196000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1472256196000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1472256196000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1472256196000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1472256196000},{"_id":"themes/next/source/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1472256196000},{"_id":"themes/next/source/vendors/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1472256196000},{"_id":"themes/next/source/vendors/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1472256196000},{"_id":"themes/next/source/vendors/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1472256196000},{"_id":"themes/next/source/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1472256196000},{"_id":"themes/next/source/vendors/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1472256196000},{"_id":"themes/next/source/vendors/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1472256196000},{"_id":"themes/next/source/vendors/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1472256196000},{"_id":"themes/next/source/vendors/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1472256196000},{"_id":"themes/next/source/vendors/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1472256196000},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1472256196000},{"_id":"themes/next/source/vendors/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1472256196000},{"_id":"themes/next/source/vendors/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1472256196000},{"_id":"themes/next/source/vendors/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1472256196000},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1472256196000},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1472256196000},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1472256196000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1472256196000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1472256196000},{"_id":"themes/next/source/vendors/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1472256196000},{"_id":"themes/next/source/vendors/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1472256196000},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1472256196000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1472256196000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1472256196000},{"_id":"themes/next/source/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1472256196000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1472256196000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1472256196000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"f9c6ee91c2a615edd8ca26edcc8a66b71883c238","modified":1472256196000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1472256196000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1472256196000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1472256196000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"bff3b18f56175c53f3bc6d733166c4d998e08732","modified":1472256196000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"8c7af79407d223486fba72b8150fe045a553bf70","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6ed60cc621bac096c0ed7534fa25b1a52dc571d4","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"8d7cecde4933900c7df2db9d0a98f5f82f88dc93","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1472256196000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1472256196000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1472256196000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1472256196000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1472256196000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1472256196000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1472256196000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1472256196000},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1472256196000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1472256196000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1472256196000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1472256196000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1472256196000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1472256196000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1472256196000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1472256196000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1472256196000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1472256196000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1472256196000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1472256196000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1472256196000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1472256196000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1472256196000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1472256196000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1472256196000},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1472256196000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1472256196000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1472256196000},{"_id":"themes/next/source/vendors/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1472256196000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4da051c7f3924fa2db1e73c55b2baf1c2c150255","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"90f8f9706cd7fe829cf06e9959a65fd3f8b994fa","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d543d1377c1f61b70e3adb6da0eb12797552e5f2","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"795d94561888d31cb7a6ff4a125596809ea69b7d","modified":1472256196000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"3afc459442c132c480d1d832f1a872f1070bb048","modified":1472256196000},{"_id":"themes/next/source/images/aoliao.png","hash":"4cf2a2757bcf9b20a36af91d43835198ba6c3cba","modified":1472256196000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1472256196000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1472256196000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1472256196000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1472256196000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1472256196000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1472256196000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1472256196000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1472256196000},{"_id":"public/CNAME","hash":"ca4676214e2f3f6bcb8b587ab85416a7eb090157","modified":1472258937396},{"_id":"public/categories/index.html","hash":"335691fede22284a8249f741210317f047dadf23","modified":1472258937417},{"_id":"public/tags/index.html","hash":"5fb4ec5da057dfabe6631ffb56b5c65a7cdd9806","modified":1472258937417},{"_id":"public/2016/08/15/git/index.html","hash":"560ef5361d79dcc89c1e5f939fed8172d85783d4","modified":1472258937417},{"_id":"public/archives/page/2/index.html","hash":"bd36a3d24c18b3bfa70aba13aa83b9fc615278da","modified":1472258937417},{"_id":"public/archives/2016/page/2/index.html","hash":"e5ceb65c2d425865e0bcb19728d157af7cca3f89","modified":1472258937417},{"_id":"public/archives/2016/06/index.html","hash":"f4a28351f7234741309653fe14bee3db30a2e7e1","modified":1472258937417},{"_id":"public/archives/2016/07/index.html","hash":"e3d3d181957c2d3a3dcad5e53e47599db5a32171","modified":1472258937418},{"_id":"public/archives/2016/08/index.html","hash":"e08fef2aabbed0d632686b461932fe8bec45c87d","modified":1472258937418},{"_id":"public/tags/读书笔记/index.html","hash":"a1dfabdbaacba358bd2100c903ea70560c130b78","modified":1472258937418},{"_id":"public/tags/算法/index.html","hash":"c214e329e88e5a99709facf6c0054bf4ce1e25ec","modified":1472258937418},{"_id":"public/tags/每周总结/index.html","hash":"ff4ad78e2c099f48786508f7608af94e5882b6da","modified":1472258937419},{"_id":"public/tags/每周总结/page/2/index.html","hash":"b97a9aeab38317159eec7aeb9c5eb7a41d7e8ade","modified":1472258937419},{"_id":"public/tags/数据结构/index.html","hash":"e28d19a351df1bca442105915d31b3154417da6c","modified":1472258937419},{"_id":"public/tags/javascript/index.html","hash":"7492c8fb29d5732975f55a29e8ac52b9a2e66422","modified":1472258937419},{"_id":"public/tags/git/index.html","hash":"c53b6e066477463050728c37f9cb0a011db02353","modified":1472258937419},{"_id":"public/tags/自然语言处理-读书笔记/index.html","hash":"18ad95f20ab9f764698b5923ec43c3cf33e00957","modified":1472258937419},{"_id":"public/tags/svg/index.html","hash":"b6b13cc9daae2e37ee76e486a564c28b6cf69470","modified":1472258937419},{"_id":"public/2016/08/27/thread-in-javascript/index.html","hash":"3f176ee4c9e97e00ba402f26328e776da41935a4","modified":1472258937420},{"_id":"public/2016/08/12/data-capture/index.html","hash":"0ec117b9d7401ff72a026f7609fc61bc9cf94bf9","modified":1472258937420},{"_id":"public/2016/08/07/red-black-tree/index.html","hash":"00fe760bfb9510013fb740468a9138cbb56f6254","modified":1472258937420},{"_id":"public/2016/08/07/binary-search-tree/index.html","hash":"df246278c02f03bb297a58960e89c081e0b4bab4","modified":1472258937420},{"_id":"public/2016/07/31/five-in-a-row-game/index.html","hash":"fb345106e50c45f116a477474f8ad73fa65dd55f","modified":1472258937420},{"_id":"public/2016/07/26/data-structures-2/index.html","hash":"62f9cae5126d4aed878cae1c8928cceeb6988ba0","modified":1472258937420},{"_id":"public/2016/07/24/data-structures/index.html","hash":"f0e391b8bca52d639610dd03aae2b12e3114dd5e","modified":1472258937420},{"_id":"public/2016/07/19/calculate-24-game/index.html","hash":"d9489d0d5bd464d8e11742752bed68a2df6536c6","modified":1472258937420},{"_id":"public/2016/07/10/natural-language-processing-1/index.html","hash":"0ad9194099723a5966d14adb72a8d32c86e32dbb","modified":1472258937420},{"_id":"public/2016/07/09/Introduction-to-Algorithms-8/index.html","hash":"b1ce1079bb6bae09a7c7a89b8d053bd3fe67c1b0","modified":1472258937420},{"_id":"public/2016/07/07/Introduction-to-Algorithms-7/index.html","hash":"ac702b8fd601858d95ff37aee0e80a37150a19b2","modified":1472258937420},{"_id":"public/2016/07/04/currying/index.html","hash":"5cfe987dbf03ce04672f8d765872e4ad7eda4dbe","modified":1472258937420},{"_id":"public/2016/07/03/Introduction-to-Algorithms-6/index.html","hash":"1095ce31fff08da1400551555bfdbfb35df1c072","modified":1472258937420},{"_id":"public/2016/06/29/Introduction-to-Algorithms-4/index.html","hash":"eb5abea58d00a9364307b4d286e39ef496563022","modified":1472258937421},{"_id":"public/2016/06/28/use-svg-to-draw-line/index.html","hash":"ffbc7f912c52472f37dd139bd8417b9c7352460a","modified":1472258937421},{"_id":"public/2016/06/27/Introduction-to-Algorithms-2/index.html","hash":"0631f76168437b806a79742fd91b904ba9534f63","modified":1472258937421},{"_id":"public/index.html","hash":"988ac333d384705b62f4dba1a197634be3116bc3","modified":1472258937421},{"_id":"public/page/2/index.html","hash":"b664f17be4e28394ce55756789bafe81f5980dbe","modified":1472258937421},{"_id":"public/archives/index.html","hash":"4fcd536b1e0848b43f5486d6f5c516509aefe6c9","modified":1472258937421},{"_id":"public/archives/2016/index.html","hash":"60009fd0484bc6e2428647dc999326d72e9e0eda","modified":1472258937421},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1472258937438},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1472258937439},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1472258937439},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1472258937439},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1472258937439},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1472258937439},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1472258937439},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1472258937440},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1472258937440},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1472258937440},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1472258937440},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1472258937440},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1472258937440},{"_id":"public/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1472258937440},{"_id":"public/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1472258937440},{"_id":"public/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1472258937440},{"_id":"public/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1472258937440},{"_id":"public/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1472258937440},{"_id":"public/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1472258937440},{"_id":"public/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1472258937440},{"_id":"public/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1472258937440},{"_id":"public/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1472258937440},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1472258937440},{"_id":"public/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1472258937440},{"_id":"public/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1472258938184},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1472258938186},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1472258938187},{"_id":"public/404.html","hash":"3f0cfb0b8a15eec015e87738cbeffc2f205ce70e","modified":1472258938194},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1472258938194},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1472258938194},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1472258938194},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1472258938194},{"_id":"public/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1472258938194},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1472258938194},{"_id":"public/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1472258938194},{"_id":"public/vendors/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1472258938194},{"_id":"public/vendors/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1472258938194},{"_id":"public/vendors/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1472258938194},{"_id":"public/vendors/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1472258938194},{"_id":"public/vendors/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1472258938194},{"_id":"public/vendors/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1472258938194},{"_id":"public/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1472258938194},{"_id":"public/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1472258938194},{"_id":"public/vendors/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1472258938194},{"_id":"public/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1472258938194},{"_id":"public/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1472258938194},{"_id":"public/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1472258938195},{"_id":"public/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1472258938195},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1472258938195},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1472258938195},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1472258938195},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1472258938195},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1472258938195},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1472258938195},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1472258938195},{"_id":"public/css/main.css","hash":"fd0196bfdf49c5fd9be36680410ff2238d3153de","modified":1472258938195},{"_id":"public/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1472258938195},{"_id":"public/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1472258938195},{"_id":"public/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1472258938195},{"_id":"public/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1472258938195},{"_id":"public/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1472258938195},{"_id":"public/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1472258938195},{"_id":"public/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1472258938195},{"_id":"public/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1472258938195},{"_id":"public/vendors/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1472258938195},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1472258938195},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1472258938200},{"_id":"public/images/aoliao.png","hash":"4cf2a2757bcf9b20a36af91d43835198ba6c3cba","modified":1472258938201}],"Category":[],"Data":[],"Page":[{"title":"分类","date":"2016-06-29T06:43:40.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2016-06-29 14:43:40\ntype: \"categories\"\n---\n","updated":"2016-08-27T00:03:16.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ciscgyh5y0023gq276ua5dcrw","content":"","excerpt":"","more":""},{"title":"标签","date":"2016-06-29T06:41:28.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2016-06-29 14:41:28\ntype: \"tags\"\n---\n","updated":"2016-08-27T00:03:16.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ciscgyh600024gq27m0xvfq2o","content":"","excerpt":"","more":""}],"Post":[{"title":"《算法导论》第二章：算法基础","date":"2016-06-26T18:47:19.000Z","_content":"这一章考察求解了排序问题中的**插入排序**算法，并引用算法设计中的**分治法**来开发**归并排序**的算法。\n\n<!-- more -->\n\n## 插入排序\n\n插入排序的工作方式就像许多人排序一手扑克牌。开始时手中一张牌都没有，然后我们每起一次牌，都会将它与手中的牌作比较，从左到右（或者从右到左）来找到这张牌的正确位置，一直到起到最后一张。这个算法的关键之处就在于**你拿在手上的牌始终都是已经排好序的**。\n\n### 伪代码\nINSERTATION-SORT(A)\n```\nfor j = 2 to A.length\n  key = A[j]\n  // Insert A[j] into the sorted sequence A[1..j-1]\n  i = j - 1\n  while i > 0 and A[i] > key\n    A[i + 1] = A[i]\n    i = i - 1\n  A[i + 1] = key\n```\n*（伪代码的数组下标从1开始）*\n\n`for` 循环对应每一次起牌，`key` 代表起上的新牌，`while` 循环表示将新牌和手上的牌从右到左比较，直到找到比新牌小的牌的位置，最后将新牌放到这张牌的后面。\n\n### Javascript 实现\n```javascript\nfunction insertion_sort(arr) {\n  for(var i = 1; i < arr.length; i++) {\n    var key = arr[i];\n    var j = i - 1;\n\n    while(j >= 0 && arr[j] > key) {\n      arr[j + 1] = arr[j];\n      j--;\n    }\n    arr[j + 1] = key;\n  }\n  console.log(arr)\n}\n\nvar a = [3, 1, 4, 5, 7, 2, 11, 13, 0, 9];\ninsertion_sort(a); //[0, 1, 2, 3, 4, 5, 7, 9, 11, 13]\n```\n\n### 插入排序算法的分析\n在最好情况，也就是输入数组本身已经从小到大排序了，该算法运行时间为\n```\nT(n) = an + b\n```\n是** n 的线性函数**\n\n在最坏的情况，也就是输入数组完全按倒序排列，每一次起到新的牌，都需与手中所有的牌作比较。运行时间为\n```\nT(n) = an² + bn + c\n```\n是** n 的二次函数**\n\n我们记插入排序具有最坏情况运行时间 `θ(n²)`\n\n## 归并排序\n\n### 分治法\n归并排序在结构上是递归的，完全遵循分治模式，典型地符合分治法的思想：**将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。**\n\n### 伪代码\n归并排序将原数组拆分成两个序列，再将每个序列继续拆分成两个序列，直到拆成长度为 1，然后递归开始回升，两两序列合并为排序好的新序列，一直到合并成为新数组。\n\n归并排序的关键就在于合并两个已经排序好的序列，我们通过调用 `MERGE(A, p, q, r)` 来完成合并，其中 A 是数组，p, q, r 是数组的下标，且 p ≤ q ≤ r。该过程假设 A[p..q] 和 A[q + 1..r] 都已经排好序，也就是这个方法用于合并两个已排好序的序列。\n\nMERGE(A, p, q, r)\n```\nn1 = q - p + 1\nn2 = r - q\nlet L[1..n1 + 1] and R[1..n2 + 1] be new arrays\nfor i = 1 to n1\n  L[i] = A[p + i - 1]\nfor j = 1 to n2\n  R[j] = A[q + j]\nL[n1 + 1] = ∞\nL[n2 + 1] = ∞\ni = 1\nj = 1\nfor k = p to r\n  if L[i] <= R[j]\n    A[k] = L[i]\n    i = i + 1\n  else\n    A[k] = R[j]\n    j = j + 1\n```\n代码中在每个序列的最后插入了一个**哨兵**，用于简化代码，避免判断是否有堆为空（因为最后一个下标 ++ 完会越界）\n\n该方法只要执行 n 次，即能将两个序列合并为新序列。\n\n现在 MERGE 方法就能作为归并排序算法中的一个子程序，接下来需要对数组进行拆分。这个方法排序数组 A[p..r] 中的元素，如果 p ≥ r, 则该子数组最多有一个元素，所以已经排好序，否则，将 A[p..r] 分成 A[p..q] 和 A[q + 1..r]。\n\nMERGE-SORT(A, p, r)\n```\nif p < r\n  q = 「(p + r) / 2」\n  MERGE-SORT(A, p, q)\n  MERGE-SORT(A, q + 1, r)\n  MERGE(A, p, q, r)\n```\n\n### Javascript 实现\n```javascript\nfunction merge(arr, p, q, r) {\n  var n1 = q - p + 1;\n  var n2 = r - q;\n  var L = [], R = [];\n  for(var i = 0; i < n1; i++) {\n    L[i] = arr[p + i];\n  }\n\n  for(var j = 0; j < n2; j++) {\n    R[j] = arr[q + 1 + j];\n  }\n\n  // 合并\n  i = 0, j = 0;\n\n  for(var k = p; k <= r; k++) {\n    if(j >= n2 || L[i] <= R[j]) {\n      arr[k] = L[i];  \n      i++;\n    } else if(i >= n1 || L[i] > R[j]) {\n      arr[k] = R[j];\n      j++;\n    }\n  }\n}\n\nfunction merge_sort(arr, p, r) {\n  if(p < r) {\n    var q = Math.floor((p + r) / 2);\n    merge_sort(arr, p, q);\n    merge_sort(arr, q + 1, r);  \n    merge(arr, p, q, r);\n  }\n\n}\n\nvar arr = [3, 2, 6, 3, 11, 10, 17, 0, 1, 9];\nmerge_sort(arr, 0, a.length - 1)\nconsole.log(arr); // [0, 1, 2, 3, 3, 6, 9, 10, 11, 17]\n```\n\n### 归并排序算法的分析\n归并排序是将数组递归拆解再合并，可以将问题分解为一颗递归树，运行时间为 `θ(nlgn)`\n","source":"_posts/Introduction-to-Algorithms-2.md","raw":"---\ntitle: 《算法导论》第二章：算法基础\ndate: 2016-06-27 02:47:19\ntags: [读书笔记, 算法]\n---\n这一章考察求解了排序问题中的**插入排序**算法，并引用算法设计中的**分治法**来开发**归并排序**的算法。\n\n<!-- more -->\n\n## 插入排序\n\n插入排序的工作方式就像许多人排序一手扑克牌。开始时手中一张牌都没有，然后我们每起一次牌，都会将它与手中的牌作比较，从左到右（或者从右到左）来找到这张牌的正确位置，一直到起到最后一张。这个算法的关键之处就在于**你拿在手上的牌始终都是已经排好序的**。\n\n### 伪代码\nINSERTATION-SORT(A)\n```\nfor j = 2 to A.length\n  key = A[j]\n  // Insert A[j] into the sorted sequence A[1..j-1]\n  i = j - 1\n  while i > 0 and A[i] > key\n    A[i + 1] = A[i]\n    i = i - 1\n  A[i + 1] = key\n```\n*（伪代码的数组下标从1开始）*\n\n`for` 循环对应每一次起牌，`key` 代表起上的新牌，`while` 循环表示将新牌和手上的牌从右到左比较，直到找到比新牌小的牌的位置，最后将新牌放到这张牌的后面。\n\n### Javascript 实现\n```javascript\nfunction insertion_sort(arr) {\n  for(var i = 1; i < arr.length; i++) {\n    var key = arr[i];\n    var j = i - 1;\n\n    while(j >= 0 && arr[j] > key) {\n      arr[j + 1] = arr[j];\n      j--;\n    }\n    arr[j + 1] = key;\n  }\n  console.log(arr)\n}\n\nvar a = [3, 1, 4, 5, 7, 2, 11, 13, 0, 9];\ninsertion_sort(a); //[0, 1, 2, 3, 4, 5, 7, 9, 11, 13]\n```\n\n### 插入排序算法的分析\n在最好情况，也就是输入数组本身已经从小到大排序了，该算法运行时间为\n```\nT(n) = an + b\n```\n是** n 的线性函数**\n\n在最坏的情况，也就是输入数组完全按倒序排列，每一次起到新的牌，都需与手中所有的牌作比较。运行时间为\n```\nT(n) = an² + bn + c\n```\n是** n 的二次函数**\n\n我们记插入排序具有最坏情况运行时间 `θ(n²)`\n\n## 归并排序\n\n### 分治法\n归并排序在结构上是递归的，完全遵循分治模式，典型地符合分治法的思想：**将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。**\n\n### 伪代码\n归并排序将原数组拆分成两个序列，再将每个序列继续拆分成两个序列，直到拆成长度为 1，然后递归开始回升，两两序列合并为排序好的新序列，一直到合并成为新数组。\n\n归并排序的关键就在于合并两个已经排序好的序列，我们通过调用 `MERGE(A, p, q, r)` 来完成合并，其中 A 是数组，p, q, r 是数组的下标，且 p ≤ q ≤ r。该过程假设 A[p..q] 和 A[q + 1..r] 都已经排好序，也就是这个方法用于合并两个已排好序的序列。\n\nMERGE(A, p, q, r)\n```\nn1 = q - p + 1\nn2 = r - q\nlet L[1..n1 + 1] and R[1..n2 + 1] be new arrays\nfor i = 1 to n1\n  L[i] = A[p + i - 1]\nfor j = 1 to n2\n  R[j] = A[q + j]\nL[n1 + 1] = ∞\nL[n2 + 1] = ∞\ni = 1\nj = 1\nfor k = p to r\n  if L[i] <= R[j]\n    A[k] = L[i]\n    i = i + 1\n  else\n    A[k] = R[j]\n    j = j + 1\n```\n代码中在每个序列的最后插入了一个**哨兵**，用于简化代码，避免判断是否有堆为空（因为最后一个下标 ++ 完会越界）\n\n该方法只要执行 n 次，即能将两个序列合并为新序列。\n\n现在 MERGE 方法就能作为归并排序算法中的一个子程序，接下来需要对数组进行拆分。这个方法排序数组 A[p..r] 中的元素，如果 p ≥ r, 则该子数组最多有一个元素，所以已经排好序，否则，将 A[p..r] 分成 A[p..q] 和 A[q + 1..r]。\n\nMERGE-SORT(A, p, r)\n```\nif p < r\n  q = 「(p + r) / 2」\n  MERGE-SORT(A, p, q)\n  MERGE-SORT(A, q + 1, r)\n  MERGE(A, p, q, r)\n```\n\n### Javascript 实现\n```javascript\nfunction merge(arr, p, q, r) {\n  var n1 = q - p + 1;\n  var n2 = r - q;\n  var L = [], R = [];\n  for(var i = 0; i < n1; i++) {\n    L[i] = arr[p + i];\n  }\n\n  for(var j = 0; j < n2; j++) {\n    R[j] = arr[q + 1 + j];\n  }\n\n  // 合并\n  i = 0, j = 0;\n\n  for(var k = p; k <= r; k++) {\n    if(j >= n2 || L[i] <= R[j]) {\n      arr[k] = L[i];  \n      i++;\n    } else if(i >= n1 || L[i] > R[j]) {\n      arr[k] = R[j];\n      j++;\n    }\n  }\n}\n\nfunction merge_sort(arr, p, r) {\n  if(p < r) {\n    var q = Math.floor((p + r) / 2);\n    merge_sort(arr, p, q);\n    merge_sort(arr, q + 1, r);  \n    merge(arr, p, q, r);\n  }\n\n}\n\nvar arr = [3, 2, 6, 3, 11, 10, 17, 0, 1, 9];\nmerge_sort(arr, 0, a.length - 1)\nconsole.log(arr); // [0, 1, 2, 3, 3, 6, 9, 10, 11, 17]\n```\n\n### 归并排序算法的分析\n归并排序是将数组递归拆解再合并，可以将问题分解为一颗递归树，运行时间为 `θ(nlgn)`\n","slug":"Introduction-to-Algorithms-2","published":1,"updated":"2016-08-27T00:03:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscgyh0n0000gq27h845c0jm","content":"<p>这一章考察求解了排序问题中的<strong>插入排序</strong>算法，并引用算法设计中的<strong>分治法</strong>来开发<strong>归并排序</strong>的算法。</p>\n<a id=\"more\"></a>\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p>插入排序的工作方式就像许多人排序一手扑克牌。开始时手中一张牌都没有，然后我们每起一次牌，都会将它与手中的牌作比较，从左到右（或者从右到左）来找到这张牌的正确位置，一直到起到最后一张。这个算法的关键之处就在于<strong>你拿在手上的牌始终都是已经排好序的</strong>。</p>\n<h3 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h3><p>INSERTATION-SORT(A)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">for j = 2 to A.length</div><div class=\"line\">  key = A[j]</div><div class=\"line\">  // Insert A[j] into the sorted sequence A[1..j-1]</div><div class=\"line\">  i = j - 1</div><div class=\"line\">  while i &gt; 0 and A[i] &gt; key</div><div class=\"line\">    A[i + 1] = A[i]</div><div class=\"line\">    i = i - 1</div><div class=\"line\">  A[i + 1] = key</div></pre></td></tr></table></figure></p>\n<p><em>（伪代码的数组下标从1开始）</em></p>\n<p><code>for</code> 循环对应每一次起牌，<code>key</code> 代表起上的新牌，<code>while</code> 循环表示将新牌和手上的牌从右到左比较，直到找到比新牌小的牌的位置，最后将新牌放到这张牌的后面。</p>\n<h3 id=\"Javascript-实现\"><a href=\"#Javascript-实现\" class=\"headerlink\" title=\"Javascript 实现\"></a>Javascript 实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertion_sort</span>(<span class=\"params\">arr</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; arr.length; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> key = arr[i];</div><div class=\"line\">    <span class=\"keyword\">var</span> j = i - <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(j &gt;= <span class=\"number\">0</span> &amp;&amp; arr[j] &gt; key) &#123;</div><div class=\"line\">      arr[j + <span class=\"number\">1</span>] = arr[j];</div><div class=\"line\">      j--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    arr[j + <span class=\"number\">1</span>] = key;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(arr)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>, <span class=\"number\">0</span>, <span class=\"number\">9</span>];</div><div class=\"line\">insertion_sort(a); <span class=\"comment\">//[0, 1, 2, 3, 4, 5, 7, 9, 11, 13]</span></div></pre></td></tr></table></figure>\n<h3 id=\"插入排序算法的分析\"><a href=\"#插入排序算法的分析\" class=\"headerlink\" title=\"插入排序算法的分析\"></a>插入排序算法的分析</h3><p>在最好情况，也就是输入数组本身已经从小到大排序了，该算法运行时间为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">T(n) = an + b</div></pre></td></tr></table></figure></p>\n<p>是<strong> n 的线性函数</strong></p>\n<p>在最坏的情况，也就是输入数组完全按倒序排列，每一次起到新的牌，都需与手中所有的牌作比较。运行时间为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">T(n) = an² + bn + c</div></pre></td></tr></table></figure></p>\n<p>是<strong> n 的二次函数</strong></p>\n<p>我们记插入排序具有最坏情况运行时间 <code>θ(n²)</code></p>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><h3 id=\"分治法\"><a href=\"#分治法\" class=\"headerlink\" title=\"分治法\"></a>分治法</h3><p>归并排序在结构上是递归的，完全遵循分治模式，典型地符合分治法的思想：<strong>将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。</strong></p>\n<h3 id=\"伪代码-1\"><a href=\"#伪代码-1\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h3><p>归并排序将原数组拆分成两个序列，再将每个序列继续拆分成两个序列，直到拆成长度为 1，然后递归开始回升，两两序列合并为排序好的新序列，一直到合并成为新数组。</p>\n<p>归并排序的关键就在于合并两个已经排序好的序列，我们通过调用 <code>MERGE(A, p, q, r)</code> 来完成合并，其中 A 是数组，p, q, r 是数组的下标，且 p ≤ q ≤ r。该过程假设 A[p..q] 和 A[q + 1..r] 都已经排好序，也就是这个方法用于合并两个已排好序的序列。</p>\n<p>MERGE(A, p, q, r)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">n1 = q - p + 1</div><div class=\"line\">n2 = r - q</div><div class=\"line\">let L[1..n1 + 1] and R[1..n2 + 1] be new arrays</div><div class=\"line\">for i = 1 to n1</div><div class=\"line\">  L[i] = A[p + i - 1]</div><div class=\"line\">for j = 1 to n2</div><div class=\"line\">  R[j] = A[q + j]</div><div class=\"line\">L[n1 + 1] = ∞</div><div class=\"line\">L[n2 + 1] = ∞</div><div class=\"line\">i = 1</div><div class=\"line\">j = 1</div><div class=\"line\">for k = p to r</div><div class=\"line\">  if L[i] &lt;= R[j]</div><div class=\"line\">    A[k] = L[i]</div><div class=\"line\">    i = i + 1</div><div class=\"line\">  else</div><div class=\"line\">    A[k] = R[j]</div><div class=\"line\">    j = j + 1</div></pre></td></tr></table></figure></p>\n<p>代码中在每个序列的最后插入了一个<strong>哨兵</strong>，用于简化代码，避免判断是否有堆为空（因为最后一个下标 ++ 完会越界）</p>\n<p>该方法只要执行 n 次，即能将两个序列合并为新序列。</p>\n<p>现在 MERGE 方法就能作为归并排序算法中的一个子程序，接下来需要对数组进行拆分。这个方法排序数组 A[p..r] 中的元素，如果 p ≥ r, 则该子数组最多有一个元素，所以已经排好序，否则，将 A[p..r] 分成 A[p..q] 和 A[q + 1..r]。</p>\n<p>MERGE-SORT(A, p, r)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">if p &lt; r</div><div class=\"line\">  q = 「(p + r) / 2」</div><div class=\"line\">  MERGE-SORT(A, p, q)</div><div class=\"line\">  MERGE-SORT(A, q + 1, r)</div><div class=\"line\">  MERGE(A, p, q, r)</div></pre></td></tr></table></figure></p>\n<h3 id=\"Javascript-实现-1\"><a href=\"#Javascript-实现-1\" class=\"headerlink\" title=\"Javascript 实现\"></a>Javascript 实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge</span>(<span class=\"params\">arr, p, q, r</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> n1 = q - p + <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> n2 = r - q;</div><div class=\"line\">  <span class=\"keyword\">var</span> L = [], R = [];</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; n1; i++) &#123;</div><div class=\"line\">    L[i] = arr[p + i];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; n2; j++) &#123;</div><div class=\"line\">    R[j] = arr[q + <span class=\"number\">1</span> + j];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 合并</span></div><div class=\"line\">  i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> k = p; k &lt;= r; k++) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(j &gt;= n2 || L[i] &lt;= R[j]) &#123;</div><div class=\"line\">      arr[k] = L[i];  </div><div class=\"line\">      i++;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(i &gt;= n1 || L[i] &gt; R[j]) &#123;</div><div class=\"line\">      arr[k] = R[j];</div><div class=\"line\">      j++;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge_sort</span>(<span class=\"params\">arr, p, r</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(p &lt; r) &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> q = <span class=\"built_in\">Math</span>.floor((p + r) / <span class=\"number\">2</span>);</div><div class=\"line\">    merge_sort(arr, p, q);</div><div class=\"line\">    merge_sort(arr, q + <span class=\"number\">1</span>, r);  </div><div class=\"line\">    merge(arr, p, q, r);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span>, <span class=\"number\">11</span>, <span class=\"number\">10</span>, <span class=\"number\">17</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>];</div><div class=\"line\">merge_sort(arr, <span class=\"number\">0</span>, a.length - <span class=\"number\">1</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [0, 1, 2, 3, 3, 6, 9, 10, 11, 17]</span></div></pre></td></tr></table></figure>\n<h3 id=\"归并排序算法的分析\"><a href=\"#归并排序算法的分析\" class=\"headerlink\" title=\"归并排序算法的分析\"></a>归并排序算法的分析</h3><p>归并排序是将数组递归拆解再合并，可以将问题分解为一颗递归树，运行时间为 <code>θ(nlgn)</code></p>\n","excerpt":"<p>这一章考察求解了排序问题中的<strong>插入排序</strong>算法，并引用算法设计中的<strong>分治法</strong>来开发<strong>归并排序</strong>的算法。</p>","more":"<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p>插入排序的工作方式就像许多人排序一手扑克牌。开始时手中一张牌都没有，然后我们每起一次牌，都会将它与手中的牌作比较，从左到右（或者从右到左）来找到这张牌的正确位置，一直到起到最后一张。这个算法的关键之处就在于<strong>你拿在手上的牌始终都是已经排好序的</strong>。</p>\n<h3 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h3><p>INSERTATION-SORT(A)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">for j = 2 to A.length</div><div class=\"line\">  key = A[j]</div><div class=\"line\">  // Insert A[j] into the sorted sequence A[1..j-1]</div><div class=\"line\">  i = j - 1</div><div class=\"line\">  while i &gt; 0 and A[i] &gt; key</div><div class=\"line\">    A[i + 1] = A[i]</div><div class=\"line\">    i = i - 1</div><div class=\"line\">  A[i + 1] = key</div></pre></td></tr></table></figure></p>\n<p><em>（伪代码的数组下标从1开始）</em></p>\n<p><code>for</code> 循环对应每一次起牌，<code>key</code> 代表起上的新牌，<code>while</code> 循环表示将新牌和手上的牌从右到左比较，直到找到比新牌小的牌的位置，最后将新牌放到这张牌的后面。</p>\n<h3 id=\"Javascript-实现\"><a href=\"#Javascript-实现\" class=\"headerlink\" title=\"Javascript 实现\"></a>Javascript 实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertion_sort</span>(<span class=\"params\">arr</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; arr.length; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> key = arr[i];</div><div class=\"line\">    <span class=\"keyword\">var</span> j = i - <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(j &gt;= <span class=\"number\">0</span> &amp;&amp; arr[j] &gt; key) &#123;</div><div class=\"line\">      arr[j + <span class=\"number\">1</span>] = arr[j];</div><div class=\"line\">      j--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    arr[j + <span class=\"number\">1</span>] = key;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(arr)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>, <span class=\"number\">0</span>, <span class=\"number\">9</span>];</div><div class=\"line\">insertion_sort(a); <span class=\"comment\">//[0, 1, 2, 3, 4, 5, 7, 9, 11, 13]</span></div></pre></td></tr></table></figure>\n<h3 id=\"插入排序算法的分析\"><a href=\"#插入排序算法的分析\" class=\"headerlink\" title=\"插入排序算法的分析\"></a>插入排序算法的分析</h3><p>在最好情况，也就是输入数组本身已经从小到大排序了，该算法运行时间为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">T(n) = an + b</div></pre></td></tr></table></figure></p>\n<p>是<strong> n 的线性函数</strong></p>\n<p>在最坏的情况，也就是输入数组完全按倒序排列，每一次起到新的牌，都需与手中所有的牌作比较。运行时间为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">T(n) = an² + bn + c</div></pre></td></tr></table></figure></p>\n<p>是<strong> n 的二次函数</strong></p>\n<p>我们记插入排序具有最坏情况运行时间 <code>θ(n²)</code></p>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><h3 id=\"分治法\"><a href=\"#分治法\" class=\"headerlink\" title=\"分治法\"></a>分治法</h3><p>归并排序在结构上是递归的，完全遵循分治模式，典型地符合分治法的思想：<strong>将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。</strong></p>\n<h3 id=\"伪代码-1\"><a href=\"#伪代码-1\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h3><p>归并排序将原数组拆分成两个序列，再将每个序列继续拆分成两个序列，直到拆成长度为 1，然后递归开始回升，两两序列合并为排序好的新序列，一直到合并成为新数组。</p>\n<p>归并排序的关键就在于合并两个已经排序好的序列，我们通过调用 <code>MERGE(A, p, q, r)</code> 来完成合并，其中 A 是数组，p, q, r 是数组的下标，且 p ≤ q ≤ r。该过程假设 A[p..q] 和 A[q + 1..r] 都已经排好序，也就是这个方法用于合并两个已排好序的序列。</p>\n<p>MERGE(A, p, q, r)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">n1 = q - p + 1</div><div class=\"line\">n2 = r - q</div><div class=\"line\">let L[1..n1 + 1] and R[1..n2 + 1] be new arrays</div><div class=\"line\">for i = 1 to n1</div><div class=\"line\">  L[i] = A[p + i - 1]</div><div class=\"line\">for j = 1 to n2</div><div class=\"line\">  R[j] = A[q + j]</div><div class=\"line\">L[n1 + 1] = ∞</div><div class=\"line\">L[n2 + 1] = ∞</div><div class=\"line\">i = 1</div><div class=\"line\">j = 1</div><div class=\"line\">for k = p to r</div><div class=\"line\">  if L[i] &lt;= R[j]</div><div class=\"line\">    A[k] = L[i]</div><div class=\"line\">    i = i + 1</div><div class=\"line\">  else</div><div class=\"line\">    A[k] = R[j]</div><div class=\"line\">    j = j + 1</div></pre></td></tr></table></figure></p>\n<p>代码中在每个序列的最后插入了一个<strong>哨兵</strong>，用于简化代码，避免判断是否有堆为空（因为最后一个下标 ++ 完会越界）</p>\n<p>该方法只要执行 n 次，即能将两个序列合并为新序列。</p>\n<p>现在 MERGE 方法就能作为归并排序算法中的一个子程序，接下来需要对数组进行拆分。这个方法排序数组 A[p..r] 中的元素，如果 p ≥ r, 则该子数组最多有一个元素，所以已经排好序，否则，将 A[p..r] 分成 A[p..q] 和 A[q + 1..r]。</p>\n<p>MERGE-SORT(A, p, r)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">if p &lt; r</div><div class=\"line\">  q = 「(p + r) / 2」</div><div class=\"line\">  MERGE-SORT(A, p, q)</div><div class=\"line\">  MERGE-SORT(A, q + 1, r)</div><div class=\"line\">  MERGE(A, p, q, r)</div></pre></td></tr></table></figure></p>\n<h3 id=\"Javascript-实现-1\"><a href=\"#Javascript-实现-1\" class=\"headerlink\" title=\"Javascript 实现\"></a>Javascript 实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge</span>(<span class=\"params\">arr, p, q, r</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> n1 = q - p + <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> n2 = r - q;</div><div class=\"line\">  <span class=\"keyword\">var</span> L = [], R = [];</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; n1; i++) &#123;</div><div class=\"line\">    L[i] = arr[p + i];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; n2; j++) &#123;</div><div class=\"line\">    R[j] = arr[q + <span class=\"number\">1</span> + j];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 合并</span></div><div class=\"line\">  i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> k = p; k &lt;= r; k++) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(j &gt;= n2 || L[i] &lt;= R[j]) &#123;</div><div class=\"line\">      arr[k] = L[i];  </div><div class=\"line\">      i++;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(i &gt;= n1 || L[i] &gt; R[j]) &#123;</div><div class=\"line\">      arr[k] = R[j];</div><div class=\"line\">      j++;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge_sort</span>(<span class=\"params\">arr, p, r</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(p &lt; r) &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> q = <span class=\"built_in\">Math</span>.floor((p + r) / <span class=\"number\">2</span>);</div><div class=\"line\">    merge_sort(arr, p, q);</div><div class=\"line\">    merge_sort(arr, q + <span class=\"number\">1</span>, r);  </div><div class=\"line\">    merge(arr, p, q, r);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span>, <span class=\"number\">11</span>, <span class=\"number\">10</span>, <span class=\"number\">17</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>];</div><div class=\"line\">merge_sort(arr, <span class=\"number\">0</span>, a.length - <span class=\"number\">1</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [0, 1, 2, 3, 3, 6, 9, 10, 11, 17]</span></div></pre></td></tr></table></figure>\n<h3 id=\"归并排序算法的分析\"><a href=\"#归并排序算法的分析\" class=\"headerlink\" title=\"归并排序算法的分析\"></a>归并排序算法的分析</h3><p>归并排序是将数组递归拆解再合并，可以将问题分解为一颗递归树，运行时间为 <code>θ(nlgn)</code></p>"},{"title":"《算法导论》第四章：分治策略","date":"2016-06-29T14:59:14.000Z","_content":"在第二章的归并排序中已经使用了分治策略。在分治策略中，我们递归地求解一个问题，在每层递归中应用如下三个步骤：\n\n- **分解**步骤将问题划分为一些子问题，子问题的形式于原问题一样，只是规模更小。\n- **解决**步骤递归地求解出子问题。如果子问题的规模足够小，则停止递归，直接求解。\n- **合并**步骤将子问题的解组合成原问题的解。\n\n当问题足够大，需要递归求解时，我们称之为**递归情况**。当子问题变得足够小，不需要递归时，我们说递归已经“触底”，进入了**基本情况**。\n\n<!-- more -->\n\n## 最大子数组问题\n假设有以下数组：`[13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7]`，我们的目的是从中寻找一个连续子数组，使得数组元素之和是所有子数组中最大的。我们称这样的连续子数组为**最大子数组**。\n\n### 暴力求解方法\n我们当然可以通过暴力方法来求解：简单尝试所有可能的子数组，从中找出最大子数组。`n` 个元素一共有 `1 + 2 + 3 + ... + n` 个子数组，也就是这种方法的运行时间为 `Ω(n²)`。\n\n### 分治策略的求解方法\n假定我们要寻求子数组 A[low .. high] 的最大子数组，如果使用分治策略，这意味着我们需要把数组拆分成两个规模尽量相等的子数组，找到子数组的中点位置，假设为 `mid`，然后考虑求解两个子数组 A[low .. mid] 和 B[mid + 1 .. high。\n\n此时，A[low .. high] 的任何连续子数组 A[i .. j] 所处的位置必然是以下三种情况之一：\n\n- 完全位于子数组 A[low .. mid] 中，因此 low <= i <= j <= mid。\n- 完全位于子数组 A[mid + 1 .. high] 中，因此 mid <= i <= j <= high。\n- 跨越了中点，因此 low <= i <= mid < j <= high。\n\n所以，A[low .. high] 的最大子数组也必定是这三种情况之一，我们只需要找出这三种情况的最大值。我们可以递归地求解 A[low .. mid] 和 A[mid + 1 .. high] 的最大子数组，因为这两个子问题仍是最大子数组问题。接着寻找跨越中点的最大子数组，然后在三种情况中选取和最大者。\n\n要找出跨越中点的子数组很容易，因为它必定跨越中点，所以它一定由 A[i .. mid] 和 A[mid + 1 .. j] 组成，我们只需要找出两边最大的子数组，然后将其合并即可。\n\n过程 FIND-MAX-CROSSING-SUBARRAY 接收数组 A 和下标 low、mid 和 high 为输入，返回一个下标元组划定跨越中点的最大子数组的边界，并返回最大子数组的和。\n\nFIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)\n```\nleft-sum = -∞\nsum = 0\nfor i = mid downto low\n  sum = sum + A[i]\n  if sum > left-sum\n    left-sum = sum\n    max-left = i\nright-sum = -∞\nsum = 0\nfor j = mid + 1 to high\n  sum = sum + A[j]\n  if sum > right-sum\n    right-sum = sum\n    max-right = j\nreturn (max-left, max-right, left-sum + right-sum)\n```\n\n有了 FIND-MAX-CROSSING-SUBARRAY， 我们即可设计求解最大子数组问题的分治算法的伪代码了：\n\nFIND-MAXIMUM-SUBARRAY(A, low, high)\n```\nif high == low\n  return (low, high, A[low])\nelse\n  mid = [(low + high) / 2]\n  (left-low, left-high, left-sum) = FIND-MAXIMUM-SUBARRAY(A, low, mid)\n  (right-low, right-high, right-sum) = FIND-MAXIMUM-SUBARRAY(A, mid + 1, high)\n  (cross-low, cross-high, cross-sum) = FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)\n  if left-sum >= right-sum and left-sum >= cross-sum\n    return (left-low, left-high, left-sum)\n  else right-sum >= left-sum and right-sum >= cross-sum\n    return (right-low, right-high, right-sum)\n  else\n    return (cross-low, cross-high, cross-sum)\n```\n\n要理解为什么通过递归就能求出左子数组和右子数组的最大值，关键在于想明白**递归之后子数组问题会合并**。\n\n### Javascript 实现\n```javascript\nfunction findMaxCrossingSubarray(arr, low, mid, high) {\n  var leftIndex = 0, rightIndex = 0;\n  // left\n  var leftMax = -999;\n  var leftSum = 0;\n  for(var i = mid; i >= low; i--) {\n    leftSum += arr[i];\n    if(leftSum > leftMax) {\n      leftMax = leftSum;\n      leftIndex = i;\n    }\n  }\n\n  // right\n  var rightMax = -999;\n  var rightSum = 0;\n  for(var j = mid + 1; j <= high; j++) {\n    rightSum += arr[j];\n    if(rightSum > rightMax) {\n      rightMax = rightSum;\n      rightIndex = j;\n    }\n  }\n\n  return {\n    leftIndex: leftIndex,\n    rightIndex: rightIndex,\n    max: leftMax + rightMax\n  }\n}\n\nfunction findMaximumSubarray(arr, low, high) {\n  if(low == high) {\n    return {\n      leftIndex: low,\n      high: high,\n      max: arr[low]\n    }\n  } else {\n    var mid = Math.floor((low + high) / 2);\n    var left = findMaximumSubarray(arr, low, mid);\n    var right = findMaximumSubarray(arr, mid + 1, high);\n    var cross = findMaxCrossingSubarray(arr, low, mid, high);\n    if(left.max >= right.max && left.max >= cross.max) {\n      return left;\n    } else if (right.max >= left.max && right.max >= cross.max) {\n      return right;\n    } else {\n      return cross;\n    }\n  }\n}\n\nvar arr = [13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7];\nvar maxSubarray = findMaximumSubarray(arr, 0, arr.length - 1);\n/**\n * leftIndex: 7\n * max: 43\n * rightIndex: 10\n */\nconsole.log(maxSubarray);\n```\n\n### 分治算法分析\n和归并排序一样，FIND-MAXIMUM-SUBARRAY 的运行时间\n```\nT(n) = ⊙(1)              若 n = 1\nT(n) = 2T(n / 2) + ⊙(n)  若 n > 1\n```\n解为 `T(n) = ⊙(nlgn)`\n\n*最大子数组问题实际上还存在一个线性时间的算法，并未使用分治方法*\n","source":"_posts/Introduction-to-Algorithms-4.md","raw":"---\ntitle: 《算法导论》第四章：分治策略\ndate: 2016-06-29 22:59:14\ntags: [读书笔记, 算法]\n---\n在第二章的归并排序中已经使用了分治策略。在分治策略中，我们递归地求解一个问题，在每层递归中应用如下三个步骤：\n\n- **分解**步骤将问题划分为一些子问题，子问题的形式于原问题一样，只是规模更小。\n- **解决**步骤递归地求解出子问题。如果子问题的规模足够小，则停止递归，直接求解。\n- **合并**步骤将子问题的解组合成原问题的解。\n\n当问题足够大，需要递归求解时，我们称之为**递归情况**。当子问题变得足够小，不需要递归时，我们说递归已经“触底”，进入了**基本情况**。\n\n<!-- more -->\n\n## 最大子数组问题\n假设有以下数组：`[13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7]`，我们的目的是从中寻找一个连续子数组，使得数组元素之和是所有子数组中最大的。我们称这样的连续子数组为**最大子数组**。\n\n### 暴力求解方法\n我们当然可以通过暴力方法来求解：简单尝试所有可能的子数组，从中找出最大子数组。`n` 个元素一共有 `1 + 2 + 3 + ... + n` 个子数组，也就是这种方法的运行时间为 `Ω(n²)`。\n\n### 分治策略的求解方法\n假定我们要寻求子数组 A[low .. high] 的最大子数组，如果使用分治策略，这意味着我们需要把数组拆分成两个规模尽量相等的子数组，找到子数组的中点位置，假设为 `mid`，然后考虑求解两个子数组 A[low .. mid] 和 B[mid + 1 .. high。\n\n此时，A[low .. high] 的任何连续子数组 A[i .. j] 所处的位置必然是以下三种情况之一：\n\n- 完全位于子数组 A[low .. mid] 中，因此 low <= i <= j <= mid。\n- 完全位于子数组 A[mid + 1 .. high] 中，因此 mid <= i <= j <= high。\n- 跨越了中点，因此 low <= i <= mid < j <= high。\n\n所以，A[low .. high] 的最大子数组也必定是这三种情况之一，我们只需要找出这三种情况的最大值。我们可以递归地求解 A[low .. mid] 和 A[mid + 1 .. high] 的最大子数组，因为这两个子问题仍是最大子数组问题。接着寻找跨越中点的最大子数组，然后在三种情况中选取和最大者。\n\n要找出跨越中点的子数组很容易，因为它必定跨越中点，所以它一定由 A[i .. mid] 和 A[mid + 1 .. j] 组成，我们只需要找出两边最大的子数组，然后将其合并即可。\n\n过程 FIND-MAX-CROSSING-SUBARRAY 接收数组 A 和下标 low、mid 和 high 为输入，返回一个下标元组划定跨越中点的最大子数组的边界，并返回最大子数组的和。\n\nFIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)\n```\nleft-sum = -∞\nsum = 0\nfor i = mid downto low\n  sum = sum + A[i]\n  if sum > left-sum\n    left-sum = sum\n    max-left = i\nright-sum = -∞\nsum = 0\nfor j = mid + 1 to high\n  sum = sum + A[j]\n  if sum > right-sum\n    right-sum = sum\n    max-right = j\nreturn (max-left, max-right, left-sum + right-sum)\n```\n\n有了 FIND-MAX-CROSSING-SUBARRAY， 我们即可设计求解最大子数组问题的分治算法的伪代码了：\n\nFIND-MAXIMUM-SUBARRAY(A, low, high)\n```\nif high == low\n  return (low, high, A[low])\nelse\n  mid = [(low + high) / 2]\n  (left-low, left-high, left-sum) = FIND-MAXIMUM-SUBARRAY(A, low, mid)\n  (right-low, right-high, right-sum) = FIND-MAXIMUM-SUBARRAY(A, mid + 1, high)\n  (cross-low, cross-high, cross-sum) = FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)\n  if left-sum >= right-sum and left-sum >= cross-sum\n    return (left-low, left-high, left-sum)\n  else right-sum >= left-sum and right-sum >= cross-sum\n    return (right-low, right-high, right-sum)\n  else\n    return (cross-low, cross-high, cross-sum)\n```\n\n要理解为什么通过递归就能求出左子数组和右子数组的最大值，关键在于想明白**递归之后子数组问题会合并**。\n\n### Javascript 实现\n```javascript\nfunction findMaxCrossingSubarray(arr, low, mid, high) {\n  var leftIndex = 0, rightIndex = 0;\n  // left\n  var leftMax = -999;\n  var leftSum = 0;\n  for(var i = mid; i >= low; i--) {\n    leftSum += arr[i];\n    if(leftSum > leftMax) {\n      leftMax = leftSum;\n      leftIndex = i;\n    }\n  }\n\n  // right\n  var rightMax = -999;\n  var rightSum = 0;\n  for(var j = mid + 1; j <= high; j++) {\n    rightSum += arr[j];\n    if(rightSum > rightMax) {\n      rightMax = rightSum;\n      rightIndex = j;\n    }\n  }\n\n  return {\n    leftIndex: leftIndex,\n    rightIndex: rightIndex,\n    max: leftMax + rightMax\n  }\n}\n\nfunction findMaximumSubarray(arr, low, high) {\n  if(low == high) {\n    return {\n      leftIndex: low,\n      high: high,\n      max: arr[low]\n    }\n  } else {\n    var mid = Math.floor((low + high) / 2);\n    var left = findMaximumSubarray(arr, low, mid);\n    var right = findMaximumSubarray(arr, mid + 1, high);\n    var cross = findMaxCrossingSubarray(arr, low, mid, high);\n    if(left.max >= right.max && left.max >= cross.max) {\n      return left;\n    } else if (right.max >= left.max && right.max >= cross.max) {\n      return right;\n    } else {\n      return cross;\n    }\n  }\n}\n\nvar arr = [13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7];\nvar maxSubarray = findMaximumSubarray(arr, 0, arr.length - 1);\n/**\n * leftIndex: 7\n * max: 43\n * rightIndex: 10\n */\nconsole.log(maxSubarray);\n```\n\n### 分治算法分析\n和归并排序一样，FIND-MAXIMUM-SUBARRAY 的运行时间\n```\nT(n) = ⊙(1)              若 n = 1\nT(n) = 2T(n / 2) + ⊙(n)  若 n > 1\n```\n解为 `T(n) = ⊙(nlgn)`\n\n*最大子数组问题实际上还存在一个线性时间的算法，并未使用分治方法*\n","slug":"Introduction-to-Algorithms-4","published":1,"updated":"2016-08-27T00:03:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscgyh0s0001gq2703h7otky","content":"<p>在第二章的归并排序中已经使用了分治策略。在分治策略中，我们递归地求解一个问题，在每层递归中应用如下三个步骤：</p>\n<ul>\n<li><strong>分解</strong>步骤将问题划分为一些子问题，子问题的形式于原问题一样，只是规模更小。</li>\n<li><strong>解决</strong>步骤递归地求解出子问题。如果子问题的规模足够小，则停止递归，直接求解。</li>\n<li><strong>合并</strong>步骤将子问题的解组合成原问题的解。</li>\n</ul>\n<p>当问题足够大，需要递归求解时，我们称之为<strong>递归情况</strong>。当子问题变得足够小，不需要递归时，我们说递归已经“触底”，进入了<strong>基本情况</strong>。</p>\n<a id=\"more\"></a>\n<h2 id=\"最大子数组问题\"><a href=\"#最大子数组问题\" class=\"headerlink\" title=\"最大子数组问题\"></a>最大子数组问题</h2><p>假设有以下数组：<code>[13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7]</code>，我们的目的是从中寻找一个连续子数组，使得数组元素之和是所有子数组中最大的。我们称这样的连续子数组为<strong>最大子数组</strong>。</p>\n<h3 id=\"暴力求解方法\"><a href=\"#暴力求解方法\" class=\"headerlink\" title=\"暴力求解方法\"></a>暴力求解方法</h3><p>我们当然可以通过暴力方法来求解：简单尝试所有可能的子数组，从中找出最大子数组。<code>n</code> 个元素一共有 <code>1 + 2 + 3 + ... + n</code> 个子数组，也就是这种方法的运行时间为 <code>Ω(n²)</code>。</p>\n<h3 id=\"分治策略的求解方法\"><a href=\"#分治策略的求解方法\" class=\"headerlink\" title=\"分治策略的求解方法\"></a>分治策略的求解方法</h3><p>假定我们要寻求子数组 A[low .. high] 的最大子数组，如果使用分治策略，这意味着我们需要把数组拆分成两个规模尽量相等的子数组，找到子数组的中点位置，假设为 <code>mid</code>，然后考虑求解两个子数组 A[low .. mid] 和 B[mid + 1 .. high。</p>\n<p>此时，A[low .. high] 的任何连续子数组 A[i .. j] 所处的位置必然是以下三种情况之一：</p>\n<ul>\n<li>完全位于子数组 A[low .. mid] 中，因此 low &lt;= i &lt;= j &lt;= mid。</li>\n<li>完全位于子数组 A[mid + 1 .. high] 中，因此 mid &lt;= i &lt;= j &lt;= high。</li>\n<li>跨越了中点，因此 low &lt;= i &lt;= mid &lt; j &lt;= high。</li>\n</ul>\n<p>所以，A[low .. high] 的最大子数组也必定是这三种情况之一，我们只需要找出这三种情况的最大值。我们可以递归地求解 A[low .. mid] 和 A[mid + 1 .. high] 的最大子数组，因为这两个子问题仍是最大子数组问题。接着寻找跨越中点的最大子数组，然后在三种情况中选取和最大者。</p>\n<p>要找出跨越中点的子数组很容易，因为它必定跨越中点，所以它一定由 A[i .. mid] 和 A[mid + 1 .. j] 组成，我们只需要找出两边最大的子数组，然后将其合并即可。</p>\n<p>过程 FIND-MAX-CROSSING-SUBARRAY 接收数组 A 和下标 low、mid 和 high 为输入，返回一个下标元组划定跨越中点的最大子数组的边界，并返回最大子数组的和。</p>\n<p>FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">left-sum = -∞</div><div class=\"line\">sum = 0</div><div class=\"line\">for i = mid downto low</div><div class=\"line\">  sum = sum + A[i]</div><div class=\"line\">  if sum &gt; left-sum</div><div class=\"line\">    left-sum = sum</div><div class=\"line\">    max-left = i</div><div class=\"line\">right-sum = -∞</div><div class=\"line\">sum = 0</div><div class=\"line\">for j = mid + 1 to high</div><div class=\"line\">  sum = sum + A[j]</div><div class=\"line\">  if sum &gt; right-sum</div><div class=\"line\">    right-sum = sum</div><div class=\"line\">    max-right = j</div><div class=\"line\">return (max-left, max-right, left-sum + right-sum)</div></pre></td></tr></table></figure></p>\n<p>有了 FIND-MAX-CROSSING-SUBARRAY， 我们即可设计求解最大子数组问题的分治算法的伪代码了：</p>\n<p>FIND-MAXIMUM-SUBARRAY(A, low, high)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">if high == low</div><div class=\"line\">  return (low, high, A[low])</div><div class=\"line\">else</div><div class=\"line\">  mid = [(low + high) / 2]</div><div class=\"line\">  (left-low, left-high, left-sum) = FIND-MAXIMUM-SUBARRAY(A, low, mid)</div><div class=\"line\">  (right-low, right-high, right-sum) = FIND-MAXIMUM-SUBARRAY(A, mid + 1, high)</div><div class=\"line\">  (cross-low, cross-high, cross-sum) = FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)</div><div class=\"line\">  if left-sum &gt;= right-sum and left-sum &gt;= cross-sum</div><div class=\"line\">    return (left-low, left-high, left-sum)</div><div class=\"line\">  else right-sum &gt;= left-sum and right-sum &gt;= cross-sum</div><div class=\"line\">    return (right-low, right-high, right-sum)</div><div class=\"line\">  else</div><div class=\"line\">    return (cross-low, cross-high, cross-sum)</div></pre></td></tr></table></figure></p>\n<p>要理解为什么通过递归就能求出左子数组和右子数组的最大值，关键在于想明白<strong>递归之后子数组问题会合并</strong>。</p>\n<h3 id=\"Javascript-实现\"><a href=\"#Javascript-实现\" class=\"headerlink\" title=\"Javascript 实现\"></a>Javascript 实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findMaxCrossingSubarray</span>(<span class=\"params\">arr, low, mid, high</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> leftIndex = <span class=\"number\">0</span>, rightIndex = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"comment\">// left</span></div><div class=\"line\">  <span class=\"keyword\">var</span> leftMax = <span class=\"number\">-999</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> leftSum = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = mid; i &gt;= low; i--) &#123;</div><div class=\"line\">    leftSum += arr[i];</div><div class=\"line\">    <span class=\"keyword\">if</span>(leftSum &gt; leftMax) &#123;</div><div class=\"line\">      leftMax = leftSum;</div><div class=\"line\">      leftIndex = i;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// right</span></div><div class=\"line\">  <span class=\"keyword\">var</span> rightMax = <span class=\"number\">-999</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> rightSum = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = mid + <span class=\"number\">1</span>; j &lt;= high; j++) &#123;</div><div class=\"line\">    rightSum += arr[j];</div><div class=\"line\">    <span class=\"keyword\">if</span>(rightSum &gt; rightMax) &#123;</div><div class=\"line\">      rightMax = rightSum;</div><div class=\"line\">      rightIndex = j;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    leftIndex: leftIndex,</div><div class=\"line\">    rightIndex: rightIndex,</div><div class=\"line\">    max: leftMax + rightMax</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findMaximumSubarray</span>(<span class=\"params\">arr, low, high</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(low == high) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      leftIndex: low,</div><div class=\"line\">      high: high,</div><div class=\"line\">      max: arr[low]</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> mid = <span class=\"built_in\">Math</span>.floor((low + high) / <span class=\"number\">2</span>);</div><div class=\"line\">    <span class=\"keyword\">var</span> left = findMaximumSubarray(arr, low, mid);</div><div class=\"line\">    <span class=\"keyword\">var</span> right = findMaximumSubarray(arr, mid + <span class=\"number\">1</span>, high);</div><div class=\"line\">    <span class=\"keyword\">var</span> cross = findMaxCrossingSubarray(arr, low, mid, high);</div><div class=\"line\">    <span class=\"keyword\">if</span>(left.max &gt;= right.max &amp;&amp; left.max &gt;= cross.max) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> left;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (right.max &gt;= left.max &amp;&amp; right.max &gt;= cross.max) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> right;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> cross;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">13</span>, <span class=\"number\">-3</span>, <span class=\"number\">-25</span>, <span class=\"number\">20</span>, <span class=\"number\">-3</span>, <span class=\"number\">-16</span>, <span class=\"number\">-23</span>, <span class=\"number\">18</span>, <span class=\"number\">20</span>, <span class=\"number\">-7</span>, <span class=\"number\">12</span>, <span class=\"number\">-5</span>, <span class=\"number\">-22</span>, <span class=\"number\">15</span>, <span class=\"number\">-4</span>, <span class=\"number\">7</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> maxSubarray = findMaximumSubarray(arr, <span class=\"number\">0</span>, arr.length - <span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * leftIndex: 7</div><div class=\"line\"> * max: 43</div><div class=\"line\"> * rightIndex: 10</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"built_in\">console</span>.log(maxSubarray);</div></pre></td></tr></table></figure>\n<h3 id=\"分治算法分析\"><a href=\"#分治算法分析\" class=\"headerlink\" title=\"分治算法分析\"></a>分治算法分析</h3><p>和归并排序一样，FIND-MAXIMUM-SUBARRAY 的运行时间<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">T(n) = ⊙(1)              若 n = 1</div><div class=\"line\">T(n) = 2T(n / 2) + ⊙(n)  若 n &gt; 1</div></pre></td></tr></table></figure></p>\n<p>解为 <code>T(n) = ⊙(nlgn)</code></p>\n<p><em>最大子数组问题实际上还存在一个线性时间的算法，并未使用分治方法</em></p>\n","excerpt":"<p>在第二章的归并排序中已经使用了分治策略。在分治策略中，我们递归地求解一个问题，在每层递归中应用如下三个步骤：</p>\n<ul>\n<li><strong>分解</strong>步骤将问题划分为一些子问题，子问题的形式于原问题一样，只是规模更小。</li>\n<li><strong>解决</strong>步骤递归地求解出子问题。如果子问题的规模足够小，则停止递归，直接求解。</li>\n<li><strong>合并</strong>步骤将子问题的解组合成原问题的解。</li>\n</ul>\n<p>当问题足够大，需要递归求解时，我们称之为<strong>递归情况</strong>。当子问题变得足够小，不需要递归时，我们说递归已经“触底”，进入了<strong>基本情况</strong>。</p>","more":"<h2 id=\"最大子数组问题\"><a href=\"#最大子数组问题\" class=\"headerlink\" title=\"最大子数组问题\"></a>最大子数组问题</h2><p>假设有以下数组：<code>[13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7]</code>，我们的目的是从中寻找一个连续子数组，使得数组元素之和是所有子数组中最大的。我们称这样的连续子数组为<strong>最大子数组</strong>。</p>\n<h3 id=\"暴力求解方法\"><a href=\"#暴力求解方法\" class=\"headerlink\" title=\"暴力求解方法\"></a>暴力求解方法</h3><p>我们当然可以通过暴力方法来求解：简单尝试所有可能的子数组，从中找出最大子数组。<code>n</code> 个元素一共有 <code>1 + 2 + 3 + ... + n</code> 个子数组，也就是这种方法的运行时间为 <code>Ω(n²)</code>。</p>\n<h3 id=\"分治策略的求解方法\"><a href=\"#分治策略的求解方法\" class=\"headerlink\" title=\"分治策略的求解方法\"></a>分治策略的求解方法</h3><p>假定我们要寻求子数组 A[low .. high] 的最大子数组，如果使用分治策略，这意味着我们需要把数组拆分成两个规模尽量相等的子数组，找到子数组的中点位置，假设为 <code>mid</code>，然后考虑求解两个子数组 A[low .. mid] 和 B[mid + 1 .. high。</p>\n<p>此时，A[low .. high] 的任何连续子数组 A[i .. j] 所处的位置必然是以下三种情况之一：</p>\n<ul>\n<li>完全位于子数组 A[low .. mid] 中，因此 low &lt;= i &lt;= j &lt;= mid。</li>\n<li>完全位于子数组 A[mid + 1 .. high] 中，因此 mid &lt;= i &lt;= j &lt;= high。</li>\n<li>跨越了中点，因此 low &lt;= i &lt;= mid &lt; j &lt;= high。</li>\n</ul>\n<p>所以，A[low .. high] 的最大子数组也必定是这三种情况之一，我们只需要找出这三种情况的最大值。我们可以递归地求解 A[low .. mid] 和 A[mid + 1 .. high] 的最大子数组，因为这两个子问题仍是最大子数组问题。接着寻找跨越中点的最大子数组，然后在三种情况中选取和最大者。</p>\n<p>要找出跨越中点的子数组很容易，因为它必定跨越中点，所以它一定由 A[i .. mid] 和 A[mid + 1 .. j] 组成，我们只需要找出两边最大的子数组，然后将其合并即可。</p>\n<p>过程 FIND-MAX-CROSSING-SUBARRAY 接收数组 A 和下标 low、mid 和 high 为输入，返回一个下标元组划定跨越中点的最大子数组的边界，并返回最大子数组的和。</p>\n<p>FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">left-sum = -∞</div><div class=\"line\">sum = 0</div><div class=\"line\">for i = mid downto low</div><div class=\"line\">  sum = sum + A[i]</div><div class=\"line\">  if sum &gt; left-sum</div><div class=\"line\">    left-sum = sum</div><div class=\"line\">    max-left = i</div><div class=\"line\">right-sum = -∞</div><div class=\"line\">sum = 0</div><div class=\"line\">for j = mid + 1 to high</div><div class=\"line\">  sum = sum + A[j]</div><div class=\"line\">  if sum &gt; right-sum</div><div class=\"line\">    right-sum = sum</div><div class=\"line\">    max-right = j</div><div class=\"line\">return (max-left, max-right, left-sum + right-sum)</div></pre></td></tr></table></figure></p>\n<p>有了 FIND-MAX-CROSSING-SUBARRAY， 我们即可设计求解最大子数组问题的分治算法的伪代码了：</p>\n<p>FIND-MAXIMUM-SUBARRAY(A, low, high)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">if high == low</div><div class=\"line\">  return (low, high, A[low])</div><div class=\"line\">else</div><div class=\"line\">  mid = [(low + high) / 2]</div><div class=\"line\">  (left-low, left-high, left-sum) = FIND-MAXIMUM-SUBARRAY(A, low, mid)</div><div class=\"line\">  (right-low, right-high, right-sum) = FIND-MAXIMUM-SUBARRAY(A, mid + 1, high)</div><div class=\"line\">  (cross-low, cross-high, cross-sum) = FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)</div><div class=\"line\">  if left-sum &gt;= right-sum and left-sum &gt;= cross-sum</div><div class=\"line\">    return (left-low, left-high, left-sum)</div><div class=\"line\">  else right-sum &gt;= left-sum and right-sum &gt;= cross-sum</div><div class=\"line\">    return (right-low, right-high, right-sum)</div><div class=\"line\">  else</div><div class=\"line\">    return (cross-low, cross-high, cross-sum)</div></pre></td></tr></table></figure></p>\n<p>要理解为什么通过递归就能求出左子数组和右子数组的最大值，关键在于想明白<strong>递归之后子数组问题会合并</strong>。</p>\n<h3 id=\"Javascript-实现\"><a href=\"#Javascript-实现\" class=\"headerlink\" title=\"Javascript 实现\"></a>Javascript 实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findMaxCrossingSubarray</span>(<span class=\"params\">arr, low, mid, high</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> leftIndex = <span class=\"number\">0</span>, rightIndex = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"comment\">// left</span></div><div class=\"line\">  <span class=\"keyword\">var</span> leftMax = <span class=\"number\">-999</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> leftSum = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = mid; i &gt;= low; i--) &#123;</div><div class=\"line\">    leftSum += arr[i];</div><div class=\"line\">    <span class=\"keyword\">if</span>(leftSum &gt; leftMax) &#123;</div><div class=\"line\">      leftMax = leftSum;</div><div class=\"line\">      leftIndex = i;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// right</span></div><div class=\"line\">  <span class=\"keyword\">var</span> rightMax = <span class=\"number\">-999</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> rightSum = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = mid + <span class=\"number\">1</span>; j &lt;= high; j++) &#123;</div><div class=\"line\">    rightSum += arr[j];</div><div class=\"line\">    <span class=\"keyword\">if</span>(rightSum &gt; rightMax) &#123;</div><div class=\"line\">      rightMax = rightSum;</div><div class=\"line\">      rightIndex = j;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    leftIndex: leftIndex,</div><div class=\"line\">    rightIndex: rightIndex,</div><div class=\"line\">    max: leftMax + rightMax</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findMaximumSubarray</span>(<span class=\"params\">arr, low, high</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(low == high) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      leftIndex: low,</div><div class=\"line\">      high: high,</div><div class=\"line\">      max: arr[low]</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> mid = <span class=\"built_in\">Math</span>.floor((low + high) / <span class=\"number\">2</span>);</div><div class=\"line\">    <span class=\"keyword\">var</span> left = findMaximumSubarray(arr, low, mid);</div><div class=\"line\">    <span class=\"keyword\">var</span> right = findMaximumSubarray(arr, mid + <span class=\"number\">1</span>, high);</div><div class=\"line\">    <span class=\"keyword\">var</span> cross = findMaxCrossingSubarray(arr, low, mid, high);</div><div class=\"line\">    <span class=\"keyword\">if</span>(left.max &gt;= right.max &amp;&amp; left.max &gt;= cross.max) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> left;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (right.max &gt;= left.max &amp;&amp; right.max &gt;= cross.max) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> right;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> cross;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">13</span>, <span class=\"number\">-3</span>, <span class=\"number\">-25</span>, <span class=\"number\">20</span>, <span class=\"number\">-3</span>, <span class=\"number\">-16</span>, <span class=\"number\">-23</span>, <span class=\"number\">18</span>, <span class=\"number\">20</span>, <span class=\"number\">-7</span>, <span class=\"number\">12</span>, <span class=\"number\">-5</span>, <span class=\"number\">-22</span>, <span class=\"number\">15</span>, <span class=\"number\">-4</span>, <span class=\"number\">7</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> maxSubarray = findMaximumSubarray(arr, <span class=\"number\">0</span>, arr.length - <span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * leftIndex: 7</div><div class=\"line\"> * max: 43</div><div class=\"line\"> * rightIndex: 10</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(maxSubarray);</div></pre></td></tr></table></figure>\n<h3 id=\"分治算法分析\"><a href=\"#分治算法分析\" class=\"headerlink\" title=\"分治算法分析\"></a>分治算法分析</h3><p>和归并排序一样，FIND-MAXIMUM-SUBARRAY 的运行时间<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">T(n) = ⊙(1)              若 n = 1</div><div class=\"line\">T(n) = 2T(n / 2) + ⊙(n)  若 n &gt; 1</div></pre></td></tr></table></figure></p>\n<p>解为 <code>T(n) = ⊙(nlgn)</code></p>\n<p><em>最大子数组问题实际上还存在一个线性时间的算法，并未使用分治方法</em></p>"},{"title":"《算法导论》第六章：堆排序","date":"2016-07-03T15:54:10.000Z","_content":"堆排序引入了另一种算法设计技巧：使用“堆”的数据结构来进行信息管理。堆不仅用在堆排序中，而且它也可以构造一种有效的优先队列。\n\n<!-- more -->\n\n## 堆排序\n如下图，（二叉）堆是一个数组，它可以被看成一个近似的完全二叉树：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-6/01.png)\n\n树的每一个节点，对应数组中的一个元素，除了最底层外，该树是完全充满的，而且是从左到右填充。\n\n我们给表示堆的数组 A 两个属性，`A.length` 和 `A.heap-size`\n\n- A.length: 数组元素的个数\n- A.heap-size: 表示有多少个堆元素存储在该数组中\n\n也就是说，A[1 .. A.length] 是整个数组，但只有 A[1 .. A.heap-size] 存放的是堆的有效元素。（0 <= A.heap-size <= A.length）\n\n树的根节点是 A[1], 这样给定一个节点下标 i， 那么它的父结点、左孩子、右孩子的下标为：\n\n```\n// 父节点下标\nPARENT(i)\n  return 向下取整(i / 2)\n\n// 左孩子下标\nLEFT(i)\n  return 2 * i\n\n// 右孩子下标\nRIGHT(i)\n  return 2 * i + 1\n```\n\n二叉堆可以分为两种形式：**最大堆** 和 **最小堆**。\n在最大堆中，**最大堆性质**是指除了根以外的所有结点 i 都要满足：\n```\nA[PARENT(i)] >= A[i]\n```\n也就是说，某个结点的值至多与其父结点一样大。堆的根节点保存的是堆的最大元素，而且在任一子树中，该子树所包含的所有结点都不大于该子树根结点的值。\n\n最小堆正好相反，**最小堆性质**是指除了根以外的所有结点 i 都有：\n```\nA[PARENT(i)] <= A[i]\n```\n\n在堆排序算法中，我们使用的是最大堆。\n\n### 构造最大堆\n\n#### step 1 维护最大堆性质\n\n要进行堆排序，首先要将数组构造成一颗最大堆。\n\nMAX-HEAPIFY 是用于维护最大堆性质的重要过程。它的输入为数组 A 和一个下标 i。在调用 MAX-HEAPIFY 时，我们假定**根结点为 LEFT(i) 和 RIGHT(i) 的二叉树都是最大堆**，当 A[i] 小于任一孩子时，则需要把 A[i] 和最大的孩子交换顺序。MAX-HEAPIFY 通过让 A[i] 的值在最大堆中“逐级下降”，从而使以下标为根结点的子树重新遵循最大堆的性质。\n\n*MAX-HEAPIFY(A, i) 伪代码*\n```\n// 左孩子下标\nl = LEFT(i)\n// 右孩子下标\nr = RIGHT(i)\n// 比较根结点和左孩子的大小\nif l <= A.heap-size and A[l] > A[i]\n  // 左孩子比根结点大\n  largest = l\nelse\n  largest = i\n// 比较根结点和右孩子的大小\nif r <= A.heap-size and A[r] > A[largest]\n  // 右孩子比左孩子和根结点都大\n  largest = r\n\nif largest != i\n  // 如果存在孩子比根结点大，让根结点和最大的孩子交换顺序\n  exchange A[i] with A[largest]\n  // 递归调用\n  MAX-HEAPIFY(A, largest)\n```\n\n#### step 2 构建最大堆\n\n利用 MAX-HEAPIFY，我们可以自底向上把大小为 n 的数组 A[1 .. n] 转换为最大堆，但实际上，子数组 a(N / 2 + 1 .. n) 中的元素都是树的叶子结点。每个叶子结点都可以看成只包含一个元素的堆。所以过程 MAX-HEAPIFY 只需对其他结点调用即可。\n\n*BUILD-MAX-HEAP(A) 伪代码*\n```\nA.heap-size = A.length\nfor i = 向下取整(A.length / 2) downto 1\n  MAX-HEAPIFY(A, i)\n```\n\n#### step 3 堆排序算法\n\n构建好最大堆之后，因为数组中最大元素总在根结点 A[1] 中，通过把根节点和 A[n] 进行互换，可以让该元素放在正确的位置，然后将结点 n 从堆中去掉（减少 A.heap-size 即可），在剩余结点中，继续维护最大堆的性质，不断重复这一过程，直到堆的大小降到 2。\n\n*HEAP-SORT(A) 伪代码*\n```\nBUILD-MAX-HEAP(A)\nfor(i = A.length downto 2)\n  // 将堆中最大的元素移动到正确的位置\n  exchange A[1] with A[i]\n  // 将刚才最大的元素剔除出堆\n  A.heap-size = A.heap-size - 1\n  // 维护最大堆性质\n  MAX-HEAPIFY(A, i)\n```\n\n### Javascript 实现\n```javascript\nfunction max_heapify(arr, i) {\n  var l = i * 2 + 1;\n  var r = i * 2 + 2;\n  var largest = i;\n\n  if(l < arr.heap_size && arr[l] > arr[i]) {\n    largest = l;\n  } else {\n    largest = i;\n  }\n\n  if(r < arr.heap_size && arr[r] > arr[largest]) {\n    largest = r;\n  }\n\n  if(largest != i) {\n    [arr[i], arr[largest]] = [arr[largest], arr[i]];\n    max_heapify(arr, largest);\n  }\n}\n\nfunction build_max_heap(arr) {\n  arr.heap_size = arr.length;\n  for(var i = Math.floor(arr.heap_size / 2) - 1; i >= 0; i--) {\n    max_heapify(arr, i);\n  }\n}\n\nfunction heap_sort(arr) {\n  build_max_heap(arr);\n  for(var i = arr.length - 1; i >= 1; i--) {\n    [arr[0], arr[i]] = [arr[i], arr[0]];\n    arr.heap_size = arr.heap_size - 1;\n    max_heapify(arr, 0);\n  }\n}\n\nvar arr = [16, 4, 10, 14, 7, 9, 3, 2, 8, 1];\nheap_sort(arr);\nconsole.log(arr); // [1, 2, 3, 4, 7, 8, 9, 10, 14, 16]\n```\n\n堆排序的时间复杂度是 `θ(nlgn)`。\n\n## 优先队列\n\n上面讲了使用堆实现堆排序算法，除此之外，堆还有一个常见的应用：作为高效的优先队列。\n\n和堆一样，优先队列也有两种形式：**最大优先队列**和**最小优先队列**。\n\n优先队列是一种用来维护由一组元素构成的集合 S 的数据结构，其中的每一个元素都有一个相关的值，称为**关键字**。\n\n一个最大优先队列支持以下操作：\n\n- INSERT(S, x): 把元素 x 插入集合 S 中。\n- MAXIMUM(S): 返回 S 中具有最大键字的元素。\n- EXTRACT-MAX(S): 去掉并返回 S 中的具有最大键字的元素。\n- INCREASE-KEY(S, x, k): 将元素 x 的关键字值增加到 k，这里假设 k 的值不小于 x 的原关键字值。\n\n最大优先队列的应用有很多，其中一个就是在共享计算机系统的作业调度。最大优先队列记录将要执行的各个作业以及它们之间的相对优先级。当一个作业完成或者被中断后，调度器调用 EXTRACT-MAX 从所有的等待作业中选出具有最高优先级的作业来执行。在任何时候，调度器可以调用 INSERT 把一个新作业加入到队列中来。\n\n相应地，**最小优先队列**支持的操作包括 `INSERT`、`MINIMUM`、`EXTRACT-MIN` 和 `DECREASE-KEY`。\n\n最小优先队列可以被用于基于事件驱动的模拟器。队列中保存要模拟的事件，每个事件都有一个发生时间作为其关键字。事件必须按照发生的时间顺序进行模拟，因为某一事件的模拟结果可能会触发对其他事件的模拟。在每一步，模拟程序调用 EXTRACT-MIN 来选择下一个要模拟的事件。当一个新事件产生时，模拟器通过调用 INSERT 将其插入最小优先级队列中。\n\n### MAXIMUM\n\n我们先讨论如何实现最大优先队列。首先，HEAP-MAXIMUM 可以实现 MAXIMUM 的操作。\n\n*HEAP-MAXIMUM(A)*\n```\n// 最大堆的根结点即最大优先队列中最大的关键字\nreturn A[1]\n```\n\n### EXTRACT-MAX\n\n过程 HEAP-EXTRACT-MAX 实现 EXTRACT-MAX 操作，它与 HEAPSORT 过程中的 `for` 循环体部分相似。\n\n*HEAP-EXTRACT-MAX(A)*\n```\nif A.heap-size < 1\n  error \"heap underflow\"\n// 堆的根结点即是最大值\nmax = A[1]\n// 将最后一个结点放到根结点\nA[1] = A[A.heap-size]\nA.heap-size = A.heap-size - 1\n// 维持最大堆性质\nMAX-HEAPIFY(A, 1)\n```\n\n### INCREASE-KEY\n\n过程 HEAP-INCREASE-KEY 实现 INCREASE-KEY 操作。当将元素 A[i] 的关键字更新为新值后，因为增大 A[i]坑内会让新的堆违反最大堆性质，所以在从当前结点到根结点的路径上，为新增的关键字寻找恰当的插入位置。当前元素会不断地与其父结点进行比较，如果当前元素的关键字较大，则当前元素与父结点进行交换。这一过程一直重复到当前元素的关键字小于其父结点为止。\n\n在优先队列中，我们更希望增加关键字的优先队列元素由对应的数组下标 i 来标识：\n\n*HEAP-INCREASE-KEY(A, i, key)*\n```\nif key < A[i]\n  error \"new key is smaller than current key\"\n// 替换对应的关键字\nA[i] = key\n// 为新增关键字寻找正确的位置\nwhile i > 1 and A[PARENT(i)] < A[i]\n  // 若新增关键字大于父结点值，交换它们\n  exchange A[i] and A[PARENT(i)]\n  i = PARENT(i)\n```\n\n### INSERT\n\n过程 MAX-HEAP-INSERT 实现 INSERT 操作。它的输入是要被插入到最大堆 A 中的新元素的关键字。MAX-HEAP-INSERT 首先通过增加一个关键字为 `-∞` 的叶结点来扩展最大堆，然后调用 HEAP-INCREASE-KEY 来将新结点设置为对应的关键字，同时保持最大堆的性质。\n\n*MAX-HEAP-INSERT(A, key)*\n```\n// 扩展最大堆\nA.heap-size = A.heap-size + 1\n// 给新结点赋值\nA[heap-size] = -∞\n// 将新结点的值替换成对应关键字\nHEAP-INCREASE-KEY(A, A.heap-size, key)\n```\n","source":"_posts/Introduction-to-Algorithms-6.md","raw":"---\ntitle: 《算法导论》第六章：堆排序\ndate: 2016-07-03 23:54:10\ntags: [读书笔记, 算法]\n---\n堆排序引入了另一种算法设计技巧：使用“堆”的数据结构来进行信息管理。堆不仅用在堆排序中，而且它也可以构造一种有效的优先队列。\n\n<!-- more -->\n\n## 堆排序\n如下图，（二叉）堆是一个数组，它可以被看成一个近似的完全二叉树：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-6/01.png)\n\n树的每一个节点，对应数组中的一个元素，除了最底层外，该树是完全充满的，而且是从左到右填充。\n\n我们给表示堆的数组 A 两个属性，`A.length` 和 `A.heap-size`\n\n- A.length: 数组元素的个数\n- A.heap-size: 表示有多少个堆元素存储在该数组中\n\n也就是说，A[1 .. A.length] 是整个数组，但只有 A[1 .. A.heap-size] 存放的是堆的有效元素。（0 <= A.heap-size <= A.length）\n\n树的根节点是 A[1], 这样给定一个节点下标 i， 那么它的父结点、左孩子、右孩子的下标为：\n\n```\n// 父节点下标\nPARENT(i)\n  return 向下取整(i / 2)\n\n// 左孩子下标\nLEFT(i)\n  return 2 * i\n\n// 右孩子下标\nRIGHT(i)\n  return 2 * i + 1\n```\n\n二叉堆可以分为两种形式：**最大堆** 和 **最小堆**。\n在最大堆中，**最大堆性质**是指除了根以外的所有结点 i 都要满足：\n```\nA[PARENT(i)] >= A[i]\n```\n也就是说，某个结点的值至多与其父结点一样大。堆的根节点保存的是堆的最大元素，而且在任一子树中，该子树所包含的所有结点都不大于该子树根结点的值。\n\n最小堆正好相反，**最小堆性质**是指除了根以外的所有结点 i 都有：\n```\nA[PARENT(i)] <= A[i]\n```\n\n在堆排序算法中，我们使用的是最大堆。\n\n### 构造最大堆\n\n#### step 1 维护最大堆性质\n\n要进行堆排序，首先要将数组构造成一颗最大堆。\n\nMAX-HEAPIFY 是用于维护最大堆性质的重要过程。它的输入为数组 A 和一个下标 i。在调用 MAX-HEAPIFY 时，我们假定**根结点为 LEFT(i) 和 RIGHT(i) 的二叉树都是最大堆**，当 A[i] 小于任一孩子时，则需要把 A[i] 和最大的孩子交换顺序。MAX-HEAPIFY 通过让 A[i] 的值在最大堆中“逐级下降”，从而使以下标为根结点的子树重新遵循最大堆的性质。\n\n*MAX-HEAPIFY(A, i) 伪代码*\n```\n// 左孩子下标\nl = LEFT(i)\n// 右孩子下标\nr = RIGHT(i)\n// 比较根结点和左孩子的大小\nif l <= A.heap-size and A[l] > A[i]\n  // 左孩子比根结点大\n  largest = l\nelse\n  largest = i\n// 比较根结点和右孩子的大小\nif r <= A.heap-size and A[r] > A[largest]\n  // 右孩子比左孩子和根结点都大\n  largest = r\n\nif largest != i\n  // 如果存在孩子比根结点大，让根结点和最大的孩子交换顺序\n  exchange A[i] with A[largest]\n  // 递归调用\n  MAX-HEAPIFY(A, largest)\n```\n\n#### step 2 构建最大堆\n\n利用 MAX-HEAPIFY，我们可以自底向上把大小为 n 的数组 A[1 .. n] 转换为最大堆，但实际上，子数组 a(N / 2 + 1 .. n) 中的元素都是树的叶子结点。每个叶子结点都可以看成只包含一个元素的堆。所以过程 MAX-HEAPIFY 只需对其他结点调用即可。\n\n*BUILD-MAX-HEAP(A) 伪代码*\n```\nA.heap-size = A.length\nfor i = 向下取整(A.length / 2) downto 1\n  MAX-HEAPIFY(A, i)\n```\n\n#### step 3 堆排序算法\n\n构建好最大堆之后，因为数组中最大元素总在根结点 A[1] 中，通过把根节点和 A[n] 进行互换，可以让该元素放在正确的位置，然后将结点 n 从堆中去掉（减少 A.heap-size 即可），在剩余结点中，继续维护最大堆的性质，不断重复这一过程，直到堆的大小降到 2。\n\n*HEAP-SORT(A) 伪代码*\n```\nBUILD-MAX-HEAP(A)\nfor(i = A.length downto 2)\n  // 将堆中最大的元素移动到正确的位置\n  exchange A[1] with A[i]\n  // 将刚才最大的元素剔除出堆\n  A.heap-size = A.heap-size - 1\n  // 维护最大堆性质\n  MAX-HEAPIFY(A, i)\n```\n\n### Javascript 实现\n```javascript\nfunction max_heapify(arr, i) {\n  var l = i * 2 + 1;\n  var r = i * 2 + 2;\n  var largest = i;\n\n  if(l < arr.heap_size && arr[l] > arr[i]) {\n    largest = l;\n  } else {\n    largest = i;\n  }\n\n  if(r < arr.heap_size && arr[r] > arr[largest]) {\n    largest = r;\n  }\n\n  if(largest != i) {\n    [arr[i], arr[largest]] = [arr[largest], arr[i]];\n    max_heapify(arr, largest);\n  }\n}\n\nfunction build_max_heap(arr) {\n  arr.heap_size = arr.length;\n  for(var i = Math.floor(arr.heap_size / 2) - 1; i >= 0; i--) {\n    max_heapify(arr, i);\n  }\n}\n\nfunction heap_sort(arr) {\n  build_max_heap(arr);\n  for(var i = arr.length - 1; i >= 1; i--) {\n    [arr[0], arr[i]] = [arr[i], arr[0]];\n    arr.heap_size = arr.heap_size - 1;\n    max_heapify(arr, 0);\n  }\n}\n\nvar arr = [16, 4, 10, 14, 7, 9, 3, 2, 8, 1];\nheap_sort(arr);\nconsole.log(arr); // [1, 2, 3, 4, 7, 8, 9, 10, 14, 16]\n```\n\n堆排序的时间复杂度是 `θ(nlgn)`。\n\n## 优先队列\n\n上面讲了使用堆实现堆排序算法，除此之外，堆还有一个常见的应用：作为高效的优先队列。\n\n和堆一样，优先队列也有两种形式：**最大优先队列**和**最小优先队列**。\n\n优先队列是一种用来维护由一组元素构成的集合 S 的数据结构，其中的每一个元素都有一个相关的值，称为**关键字**。\n\n一个最大优先队列支持以下操作：\n\n- INSERT(S, x): 把元素 x 插入集合 S 中。\n- MAXIMUM(S): 返回 S 中具有最大键字的元素。\n- EXTRACT-MAX(S): 去掉并返回 S 中的具有最大键字的元素。\n- INCREASE-KEY(S, x, k): 将元素 x 的关键字值增加到 k，这里假设 k 的值不小于 x 的原关键字值。\n\n最大优先队列的应用有很多，其中一个就是在共享计算机系统的作业调度。最大优先队列记录将要执行的各个作业以及它们之间的相对优先级。当一个作业完成或者被中断后，调度器调用 EXTRACT-MAX 从所有的等待作业中选出具有最高优先级的作业来执行。在任何时候，调度器可以调用 INSERT 把一个新作业加入到队列中来。\n\n相应地，**最小优先队列**支持的操作包括 `INSERT`、`MINIMUM`、`EXTRACT-MIN` 和 `DECREASE-KEY`。\n\n最小优先队列可以被用于基于事件驱动的模拟器。队列中保存要模拟的事件，每个事件都有一个发生时间作为其关键字。事件必须按照发生的时间顺序进行模拟，因为某一事件的模拟结果可能会触发对其他事件的模拟。在每一步，模拟程序调用 EXTRACT-MIN 来选择下一个要模拟的事件。当一个新事件产生时，模拟器通过调用 INSERT 将其插入最小优先级队列中。\n\n### MAXIMUM\n\n我们先讨论如何实现最大优先队列。首先，HEAP-MAXIMUM 可以实现 MAXIMUM 的操作。\n\n*HEAP-MAXIMUM(A)*\n```\n// 最大堆的根结点即最大优先队列中最大的关键字\nreturn A[1]\n```\n\n### EXTRACT-MAX\n\n过程 HEAP-EXTRACT-MAX 实现 EXTRACT-MAX 操作，它与 HEAPSORT 过程中的 `for` 循环体部分相似。\n\n*HEAP-EXTRACT-MAX(A)*\n```\nif A.heap-size < 1\n  error \"heap underflow\"\n// 堆的根结点即是最大值\nmax = A[1]\n// 将最后一个结点放到根结点\nA[1] = A[A.heap-size]\nA.heap-size = A.heap-size - 1\n// 维持最大堆性质\nMAX-HEAPIFY(A, 1)\n```\n\n### INCREASE-KEY\n\n过程 HEAP-INCREASE-KEY 实现 INCREASE-KEY 操作。当将元素 A[i] 的关键字更新为新值后，因为增大 A[i]坑内会让新的堆违反最大堆性质，所以在从当前结点到根结点的路径上，为新增的关键字寻找恰当的插入位置。当前元素会不断地与其父结点进行比较，如果当前元素的关键字较大，则当前元素与父结点进行交换。这一过程一直重复到当前元素的关键字小于其父结点为止。\n\n在优先队列中，我们更希望增加关键字的优先队列元素由对应的数组下标 i 来标识：\n\n*HEAP-INCREASE-KEY(A, i, key)*\n```\nif key < A[i]\n  error \"new key is smaller than current key\"\n// 替换对应的关键字\nA[i] = key\n// 为新增关键字寻找正确的位置\nwhile i > 1 and A[PARENT(i)] < A[i]\n  // 若新增关键字大于父结点值，交换它们\n  exchange A[i] and A[PARENT(i)]\n  i = PARENT(i)\n```\n\n### INSERT\n\n过程 MAX-HEAP-INSERT 实现 INSERT 操作。它的输入是要被插入到最大堆 A 中的新元素的关键字。MAX-HEAP-INSERT 首先通过增加一个关键字为 `-∞` 的叶结点来扩展最大堆，然后调用 HEAP-INCREASE-KEY 来将新结点设置为对应的关键字，同时保持最大堆的性质。\n\n*MAX-HEAP-INSERT(A, key)*\n```\n// 扩展最大堆\nA.heap-size = A.heap-size + 1\n// 给新结点赋值\nA[heap-size] = -∞\n// 将新结点的值替换成对应关键字\nHEAP-INCREASE-KEY(A, A.heap-size, key)\n```\n","slug":"Introduction-to-Algorithms-6","published":1,"updated":"2016-08-27T00:03:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscgyh100003gq27e95dlw4n","content":"<p>堆排序引入了另一种算法设计技巧：使用“堆”的数据结构来进行信息管理。堆不仅用在堆排序中，而且它也可以构造一种有效的优先队列。</p>\n<a id=\"more\"></a>\n<h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><p>如下图，（二叉）堆是一个数组，它可以被看成一个近似的完全二叉树：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-6/01.png\" alt=\"\"></p>\n<p>树的每一个节点，对应数组中的一个元素，除了最底层外，该树是完全充满的，而且是从左到右填充。</p>\n<p>我们给表示堆的数组 A 两个属性，<code>A.length</code> 和 <code>A.heap-size</code></p>\n<ul>\n<li>A.length: 数组元素的个数</li>\n<li>A.heap-size: 表示有多少个堆元素存储在该数组中</li>\n</ul>\n<p>也就是说，A[1 .. A.length] 是整个数组，但只有 A[1 .. A.heap-size] 存放的是堆的有效元素。（0 &lt;= A.heap-size &lt;= A.length）</p>\n<p>树的根节点是 A[1], 这样给定一个节点下标 i， 那么它的父结点、左孩子、右孩子的下标为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 父节点下标</div><div class=\"line\">PARENT(i)</div><div class=\"line\">  return 向下取整(i / 2)</div><div class=\"line\"></div><div class=\"line\">// 左孩子下标</div><div class=\"line\">LEFT(i)</div><div class=\"line\">  return 2 * i</div><div class=\"line\"></div><div class=\"line\">// 右孩子下标</div><div class=\"line\">RIGHT(i)</div><div class=\"line\">  return 2 * i + 1</div></pre></td></tr></table></figure>\n<p>二叉堆可以分为两种形式：<strong>最大堆</strong> 和 <strong>最小堆</strong>。<br>在最大堆中，<strong>最大堆性质</strong>是指除了根以外的所有结点 i 都要满足：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">A[PARENT(i)] &gt;= A[i]</div></pre></td></tr></table></figure></p>\n<p>也就是说，某个结点的值至多与其父结点一样大。堆的根节点保存的是堆的最大元素，而且在任一子树中，该子树所包含的所有结点都不大于该子树根结点的值。</p>\n<p>最小堆正好相反，<strong>最小堆性质</strong>是指除了根以外的所有结点 i 都有：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">A[PARENT(i)] &lt;= A[i]</div></pre></td></tr></table></figure></p>\n<p>在堆排序算法中，我们使用的是最大堆。</p>\n<h3 id=\"构造最大堆\"><a href=\"#构造最大堆\" class=\"headerlink\" title=\"构造最大堆\"></a>构造最大堆</h3><h4 id=\"step-1-维护最大堆性质\"><a href=\"#step-1-维护最大堆性质\" class=\"headerlink\" title=\"step 1 维护最大堆性质\"></a>step 1 维护最大堆性质</h4><p>要进行堆排序，首先要将数组构造成一颗最大堆。</p>\n<p>MAX-HEAPIFY 是用于维护最大堆性质的重要过程。它的输入为数组 A 和一个下标 i。在调用 MAX-HEAPIFY 时，我们假定<strong>根结点为 LEFT(i) 和 RIGHT(i) 的二叉树都是最大堆</strong>，当 A[i] 小于任一孩子时，则需要把 A[i] 和最大的孩子交换顺序。MAX-HEAPIFY 通过让 A[i] 的值在最大堆中“逐级下降”，从而使以下标为根结点的子树重新遵循最大堆的性质。</p>\n<p><em>MAX-HEAPIFY(A, i) 伪代码</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 左孩子下标</div><div class=\"line\">l = LEFT(i)</div><div class=\"line\">// 右孩子下标</div><div class=\"line\">r = RIGHT(i)</div><div class=\"line\">// 比较根结点和左孩子的大小</div><div class=\"line\">if l &lt;= A.heap-size and A[l] &gt; A[i]</div><div class=\"line\">  // 左孩子比根结点大</div><div class=\"line\">  largest = l</div><div class=\"line\">else</div><div class=\"line\">  largest = i</div><div class=\"line\">// 比较根结点和右孩子的大小</div><div class=\"line\">if r &lt;= A.heap-size and A[r] &gt; A[largest]</div><div class=\"line\">  // 右孩子比左孩子和根结点都大</div><div class=\"line\">  largest = r</div><div class=\"line\"></div><div class=\"line\">if largest != i</div><div class=\"line\">  // 如果存在孩子比根结点大，让根结点和最大的孩子交换顺序</div><div class=\"line\">  exchange A[i] with A[largest]</div><div class=\"line\">  // 递归调用</div><div class=\"line\">  MAX-HEAPIFY(A, largest)</div></pre></td></tr></table></figure></p>\n<h4 id=\"step-2-构建最大堆\"><a href=\"#step-2-构建最大堆\" class=\"headerlink\" title=\"step 2 构建最大堆\"></a>step 2 构建最大堆</h4><p>利用 MAX-HEAPIFY，我们可以自底向上把大小为 n 的数组 A[1 .. n] 转换为最大堆，但实际上，子数组 a(N / 2 + 1 .. n) 中的元素都是树的叶子结点。每个叶子结点都可以看成只包含一个元素的堆。所以过程 MAX-HEAPIFY 只需对其他结点调用即可。</p>\n<p><em>BUILD-MAX-HEAP(A) 伪代码</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">A.heap-size = A.length</div><div class=\"line\">for i = 向下取整(A.length / 2) downto 1</div><div class=\"line\">  MAX-HEAPIFY(A, i)</div></pre></td></tr></table></figure></p>\n<h4 id=\"step-3-堆排序算法\"><a href=\"#step-3-堆排序算法\" class=\"headerlink\" title=\"step 3 堆排序算法\"></a>step 3 堆排序算法</h4><p>构建好最大堆之后，因为数组中最大元素总在根结点 A[1] 中，通过把根节点和 A[n] 进行互换，可以让该元素放在正确的位置，然后将结点 n 从堆中去掉（减少 A.heap-size 即可），在剩余结点中，继续维护最大堆的性质，不断重复这一过程，直到堆的大小降到 2。</p>\n<p><em>HEAP-SORT(A) 伪代码</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">BUILD-MAX-HEAP(A)</div><div class=\"line\">for(i = A.length downto 2)</div><div class=\"line\">  // 将堆中最大的元素移动到正确的位置</div><div class=\"line\">  exchange A[1] with A[i]</div><div class=\"line\">  // 将刚才最大的元素剔除出堆</div><div class=\"line\">  A.heap-size = A.heap-size - 1</div><div class=\"line\">  // 维护最大堆性质</div><div class=\"line\">  MAX-HEAPIFY(A, i)</div></pre></td></tr></table></figure></p>\n<h3 id=\"Javascript-实现\"><a href=\"#Javascript-实现\" class=\"headerlink\" title=\"Javascript 实现\"></a>Javascript 实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">max_heapify</span>(<span class=\"params\">arr, i</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> l = i * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> r = i * <span class=\"number\">2</span> + <span class=\"number\">2</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> largest = i;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(l &lt; arr.heap_size &amp;&amp; arr[l] &gt; arr[i]) &#123;</div><div class=\"line\">    largest = l;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    largest = i;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(r &lt; arr.heap_size &amp;&amp; arr[r] &gt; arr[largest]) &#123;</div><div class=\"line\">    largest = r;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(largest != i) &#123;</div><div class=\"line\">    [arr[i], arr[largest]] = [arr[largest], arr[i]];</div><div class=\"line\">    max_heapify(arr, largest);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">build_max_heap</span>(<span class=\"params\">arr</span>) </span>&#123;</div><div class=\"line\">  arr.heap_size = arr.length;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"built_in\">Math</span>.floor(arr.heap_size / <span class=\"number\">2</span>) - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</div><div class=\"line\">    max_heapify(arr, i);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">heap_sort</span>(<span class=\"params\">arr</span>) </span>&#123;</div><div class=\"line\">  build_max_heap(arr);</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = arr.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">1</span>; i--) &#123;</div><div class=\"line\">    [arr[<span class=\"number\">0</span>], arr[i]] = [arr[i], arr[<span class=\"number\">0</span>]];</div><div class=\"line\">    arr.heap_size = arr.heap_size - <span class=\"number\">1</span>;</div><div class=\"line\">    max_heapify(arr, <span class=\"number\">0</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">16</span>, <span class=\"number\">4</span>, <span class=\"number\">10</span>, <span class=\"number\">14</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>, <span class=\"number\">1</span>];</div><div class=\"line\">heap_sort(arr);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [1, 2, 3, 4, 7, 8, 9, 10, 14, 16]</span></div></pre></td></tr></table></figure>\n<p>堆排序的时间复杂度是 <code>θ(nlgn)</code>。</p>\n<h2 id=\"优先队列\"><a href=\"#优先队列\" class=\"headerlink\" title=\"优先队列\"></a>优先队列</h2><p>上面讲了使用堆实现堆排序算法，除此之外，堆还有一个常见的应用：作为高效的优先队列。</p>\n<p>和堆一样，优先队列也有两种形式：<strong>最大优先队列</strong>和<strong>最小优先队列</strong>。</p>\n<p>优先队列是一种用来维护由一组元素构成的集合 S 的数据结构，其中的每一个元素都有一个相关的值，称为<strong>关键字</strong>。</p>\n<p>一个最大优先队列支持以下操作：</p>\n<ul>\n<li>INSERT(S, x): 把元素 x 插入集合 S 中。</li>\n<li>MAXIMUM(S): 返回 S 中具有最大键字的元素。</li>\n<li>EXTRACT-MAX(S): 去掉并返回 S 中的具有最大键字的元素。</li>\n<li>INCREASE-KEY(S, x, k): 将元素 x 的关键字值增加到 k，这里假设 k 的值不小于 x 的原关键字值。</li>\n</ul>\n<p>最大优先队列的应用有很多，其中一个就是在共享计算机系统的作业调度。最大优先队列记录将要执行的各个作业以及它们之间的相对优先级。当一个作业完成或者被中断后，调度器调用 EXTRACT-MAX 从所有的等待作业中选出具有最高优先级的作业来执行。在任何时候，调度器可以调用 INSERT 把一个新作业加入到队列中来。</p>\n<p>相应地，<strong>最小优先队列</strong>支持的操作包括 <code>INSERT</code>、<code>MINIMUM</code>、<code>EXTRACT-MIN</code> 和 <code>DECREASE-KEY</code>。</p>\n<p>最小优先队列可以被用于基于事件驱动的模拟器。队列中保存要模拟的事件，每个事件都有一个发生时间作为其关键字。事件必须按照发生的时间顺序进行模拟，因为某一事件的模拟结果可能会触发对其他事件的模拟。在每一步，模拟程序调用 EXTRACT-MIN 来选择下一个要模拟的事件。当一个新事件产生时，模拟器通过调用 INSERT 将其插入最小优先级队列中。</p>\n<h3 id=\"MAXIMUM\"><a href=\"#MAXIMUM\" class=\"headerlink\" title=\"MAXIMUM\"></a>MAXIMUM</h3><p>我们先讨论如何实现最大优先队列。首先，HEAP-MAXIMUM 可以实现 MAXIMUM 的操作。</p>\n<p><em>HEAP-MAXIMUM(A)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 最大堆的根结点即最大优先队列中最大的关键字</div><div class=\"line\">return A[1]</div></pre></td></tr></table></figure></p>\n<h3 id=\"EXTRACT-MAX\"><a href=\"#EXTRACT-MAX\" class=\"headerlink\" title=\"EXTRACT-MAX\"></a>EXTRACT-MAX</h3><p>过程 HEAP-EXTRACT-MAX 实现 EXTRACT-MAX 操作，它与 HEAPSORT 过程中的 <code>for</code> 循环体部分相似。</p>\n<p><em>HEAP-EXTRACT-MAX(A)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">if A.heap-size &lt; 1</div><div class=\"line\">  error &quot;heap underflow&quot;</div><div class=\"line\">// 堆的根结点即是最大值</div><div class=\"line\">max = A[1]</div><div class=\"line\">// 将最后一个结点放到根结点</div><div class=\"line\">A[1] = A[A.heap-size]</div><div class=\"line\">A.heap-size = A.heap-size - 1</div><div class=\"line\">// 维持最大堆性质</div><div class=\"line\">MAX-HEAPIFY(A, 1)</div></pre></td></tr></table></figure></p>\n<h3 id=\"INCREASE-KEY\"><a href=\"#INCREASE-KEY\" class=\"headerlink\" title=\"INCREASE-KEY\"></a>INCREASE-KEY</h3><p>过程 HEAP-INCREASE-KEY 实现 INCREASE-KEY 操作。当将元素 A[i] 的关键字更新为新值后，因为增大 A[i]坑内会让新的堆违反最大堆性质，所以在从当前结点到根结点的路径上，为新增的关键字寻找恰当的插入位置。当前元素会不断地与其父结点进行比较，如果当前元素的关键字较大，则当前元素与父结点进行交换。这一过程一直重复到当前元素的关键字小于其父结点为止。</p>\n<p>在优先队列中，我们更希望增加关键字的优先队列元素由对应的数组下标 i 来标识：</p>\n<p><em>HEAP-INCREASE-KEY(A, i, key)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">if key &lt; A[i]</div><div class=\"line\">  error &quot;new key is smaller than current key&quot;</div><div class=\"line\">// 替换对应的关键字</div><div class=\"line\">A[i] = key</div><div class=\"line\">// 为新增关键字寻找正确的位置</div><div class=\"line\">while i &gt; 1 and A[PARENT(i)] &lt; A[i]</div><div class=\"line\">  // 若新增关键字大于父结点值，交换它们</div><div class=\"line\">  exchange A[i] and A[PARENT(i)]</div><div class=\"line\">  i = PARENT(i)</div></pre></td></tr></table></figure></p>\n<h3 id=\"INSERT\"><a href=\"#INSERT\" class=\"headerlink\" title=\"INSERT\"></a>INSERT</h3><p>过程 MAX-HEAP-INSERT 实现 INSERT 操作。它的输入是要被插入到最大堆 A 中的新元素的关键字。MAX-HEAP-INSERT 首先通过增加一个关键字为 <code>-∞</code> 的叶结点来扩展最大堆，然后调用 HEAP-INCREASE-KEY 来将新结点设置为对应的关键字，同时保持最大堆的性质。</p>\n<p><em>MAX-HEAP-INSERT(A, key)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 扩展最大堆</div><div class=\"line\">A.heap-size = A.heap-size + 1</div><div class=\"line\">// 给新结点赋值</div><div class=\"line\">A[heap-size] = -∞</div><div class=\"line\">// 将新结点的值替换成对应关键字</div><div class=\"line\">HEAP-INCREASE-KEY(A, A.heap-size, key)</div></pre></td></tr></table></figure></p>\n","excerpt":"<p>堆排序引入了另一种算法设计技巧：使用“堆”的数据结构来进行信息管理。堆不仅用在堆排序中，而且它也可以构造一种有效的优先队列。</p>","more":"<h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><p>如下图，（二叉）堆是一个数组，它可以被看成一个近似的完全二叉树：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-6/01.png\" alt=\"\"></p>\n<p>树的每一个节点，对应数组中的一个元素，除了最底层外，该树是完全充满的，而且是从左到右填充。</p>\n<p>我们给表示堆的数组 A 两个属性，<code>A.length</code> 和 <code>A.heap-size</code></p>\n<ul>\n<li>A.length: 数组元素的个数</li>\n<li>A.heap-size: 表示有多少个堆元素存储在该数组中</li>\n</ul>\n<p>也就是说，A[1 .. A.length] 是整个数组，但只有 A[1 .. A.heap-size] 存放的是堆的有效元素。（0 &lt;= A.heap-size &lt;= A.length）</p>\n<p>树的根节点是 A[1], 这样给定一个节点下标 i， 那么它的父结点、左孩子、右孩子的下标为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 父节点下标</div><div class=\"line\">PARENT(i)</div><div class=\"line\">  return 向下取整(i / 2)</div><div class=\"line\"></div><div class=\"line\">// 左孩子下标</div><div class=\"line\">LEFT(i)</div><div class=\"line\">  return 2 * i</div><div class=\"line\"></div><div class=\"line\">// 右孩子下标</div><div class=\"line\">RIGHT(i)</div><div class=\"line\">  return 2 * i + 1</div></pre></td></tr></table></figure>\n<p>二叉堆可以分为两种形式：<strong>最大堆</strong> 和 <strong>最小堆</strong>。<br>在最大堆中，<strong>最大堆性质</strong>是指除了根以外的所有结点 i 都要满足：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">A[PARENT(i)] &gt;= A[i]</div></pre></td></tr></table></figure></p>\n<p>也就是说，某个结点的值至多与其父结点一样大。堆的根节点保存的是堆的最大元素，而且在任一子树中，该子树所包含的所有结点都不大于该子树根结点的值。</p>\n<p>最小堆正好相反，<strong>最小堆性质</strong>是指除了根以外的所有结点 i 都有：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">A[PARENT(i)] &lt;= A[i]</div></pre></td></tr></table></figure></p>\n<p>在堆排序算法中，我们使用的是最大堆。</p>\n<h3 id=\"构造最大堆\"><a href=\"#构造最大堆\" class=\"headerlink\" title=\"构造最大堆\"></a>构造最大堆</h3><h4 id=\"step-1-维护最大堆性质\"><a href=\"#step-1-维护最大堆性质\" class=\"headerlink\" title=\"step 1 维护最大堆性质\"></a>step 1 维护最大堆性质</h4><p>要进行堆排序，首先要将数组构造成一颗最大堆。</p>\n<p>MAX-HEAPIFY 是用于维护最大堆性质的重要过程。它的输入为数组 A 和一个下标 i。在调用 MAX-HEAPIFY 时，我们假定<strong>根结点为 LEFT(i) 和 RIGHT(i) 的二叉树都是最大堆</strong>，当 A[i] 小于任一孩子时，则需要把 A[i] 和最大的孩子交换顺序。MAX-HEAPIFY 通过让 A[i] 的值在最大堆中“逐级下降”，从而使以下标为根结点的子树重新遵循最大堆的性质。</p>\n<p><em>MAX-HEAPIFY(A, i) 伪代码</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 左孩子下标</div><div class=\"line\">l = LEFT(i)</div><div class=\"line\">// 右孩子下标</div><div class=\"line\">r = RIGHT(i)</div><div class=\"line\">// 比较根结点和左孩子的大小</div><div class=\"line\">if l &lt;= A.heap-size and A[l] &gt; A[i]</div><div class=\"line\">  // 左孩子比根结点大</div><div class=\"line\">  largest = l</div><div class=\"line\">else</div><div class=\"line\">  largest = i</div><div class=\"line\">// 比较根结点和右孩子的大小</div><div class=\"line\">if r &lt;= A.heap-size and A[r] &gt; A[largest]</div><div class=\"line\">  // 右孩子比左孩子和根结点都大</div><div class=\"line\">  largest = r</div><div class=\"line\"></div><div class=\"line\">if largest != i</div><div class=\"line\">  // 如果存在孩子比根结点大，让根结点和最大的孩子交换顺序</div><div class=\"line\">  exchange A[i] with A[largest]</div><div class=\"line\">  // 递归调用</div><div class=\"line\">  MAX-HEAPIFY(A, largest)</div></pre></td></tr></table></figure></p>\n<h4 id=\"step-2-构建最大堆\"><a href=\"#step-2-构建最大堆\" class=\"headerlink\" title=\"step 2 构建最大堆\"></a>step 2 构建最大堆</h4><p>利用 MAX-HEAPIFY，我们可以自底向上把大小为 n 的数组 A[1 .. n] 转换为最大堆，但实际上，子数组 a(N / 2 + 1 .. n) 中的元素都是树的叶子结点。每个叶子结点都可以看成只包含一个元素的堆。所以过程 MAX-HEAPIFY 只需对其他结点调用即可。</p>\n<p><em>BUILD-MAX-HEAP(A) 伪代码</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">A.heap-size = A.length</div><div class=\"line\">for i = 向下取整(A.length / 2) downto 1</div><div class=\"line\">  MAX-HEAPIFY(A, i)</div></pre></td></tr></table></figure></p>\n<h4 id=\"step-3-堆排序算法\"><a href=\"#step-3-堆排序算法\" class=\"headerlink\" title=\"step 3 堆排序算法\"></a>step 3 堆排序算法</h4><p>构建好最大堆之后，因为数组中最大元素总在根结点 A[1] 中，通过把根节点和 A[n] 进行互换，可以让该元素放在正确的位置，然后将结点 n 从堆中去掉（减少 A.heap-size 即可），在剩余结点中，继续维护最大堆的性质，不断重复这一过程，直到堆的大小降到 2。</p>\n<p><em>HEAP-SORT(A) 伪代码</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">BUILD-MAX-HEAP(A)</div><div class=\"line\">for(i = A.length downto 2)</div><div class=\"line\">  // 将堆中最大的元素移动到正确的位置</div><div class=\"line\">  exchange A[1] with A[i]</div><div class=\"line\">  // 将刚才最大的元素剔除出堆</div><div class=\"line\">  A.heap-size = A.heap-size - 1</div><div class=\"line\">  // 维护最大堆性质</div><div class=\"line\">  MAX-HEAPIFY(A, i)</div></pre></td></tr></table></figure></p>\n<h3 id=\"Javascript-实现\"><a href=\"#Javascript-实现\" class=\"headerlink\" title=\"Javascript 实现\"></a>Javascript 实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">max_heapify</span>(<span class=\"params\">arr, i</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> l = i * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> r = i * <span class=\"number\">2</span> + <span class=\"number\">2</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> largest = i;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(l &lt; arr.heap_size &amp;&amp; arr[l] &gt; arr[i]) &#123;</div><div class=\"line\">    largest = l;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    largest = i;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(r &lt; arr.heap_size &amp;&amp; arr[r] &gt; arr[largest]) &#123;</div><div class=\"line\">    largest = r;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(largest != i) &#123;</div><div class=\"line\">    [arr[i], arr[largest]] = [arr[largest], arr[i]];</div><div class=\"line\">    max_heapify(arr, largest);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">build_max_heap</span>(<span class=\"params\">arr</span>) </span>&#123;</div><div class=\"line\">  arr.heap_size = arr.length;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"built_in\">Math</span>.floor(arr.heap_size / <span class=\"number\">2</span>) - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</div><div class=\"line\">    max_heapify(arr, i);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">heap_sort</span>(<span class=\"params\">arr</span>) </span>&#123;</div><div class=\"line\">  build_max_heap(arr);</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = arr.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">1</span>; i--) &#123;</div><div class=\"line\">    [arr[<span class=\"number\">0</span>], arr[i]] = [arr[i], arr[<span class=\"number\">0</span>]];</div><div class=\"line\">    arr.heap_size = arr.heap_size - <span class=\"number\">1</span>;</div><div class=\"line\">    max_heapify(arr, <span class=\"number\">0</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">16</span>, <span class=\"number\">4</span>, <span class=\"number\">10</span>, <span class=\"number\">14</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>, <span class=\"number\">1</span>];</div><div class=\"line\">heap_sort(arr);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [1, 2, 3, 4, 7, 8, 9, 10, 14, 16]</span></div></pre></td></tr></table></figure>\n<p>堆排序的时间复杂度是 <code>θ(nlgn)</code>。</p>\n<h2 id=\"优先队列\"><a href=\"#优先队列\" class=\"headerlink\" title=\"优先队列\"></a>优先队列</h2><p>上面讲了使用堆实现堆排序算法，除此之外，堆还有一个常见的应用：作为高效的优先队列。</p>\n<p>和堆一样，优先队列也有两种形式：<strong>最大优先队列</strong>和<strong>最小优先队列</strong>。</p>\n<p>优先队列是一种用来维护由一组元素构成的集合 S 的数据结构，其中的每一个元素都有一个相关的值，称为<strong>关键字</strong>。</p>\n<p>一个最大优先队列支持以下操作：</p>\n<ul>\n<li>INSERT(S, x): 把元素 x 插入集合 S 中。</li>\n<li>MAXIMUM(S): 返回 S 中具有最大键字的元素。</li>\n<li>EXTRACT-MAX(S): 去掉并返回 S 中的具有最大键字的元素。</li>\n<li>INCREASE-KEY(S, x, k): 将元素 x 的关键字值增加到 k，这里假设 k 的值不小于 x 的原关键字值。</li>\n</ul>\n<p>最大优先队列的应用有很多，其中一个就是在共享计算机系统的作业调度。最大优先队列记录将要执行的各个作业以及它们之间的相对优先级。当一个作业完成或者被中断后，调度器调用 EXTRACT-MAX 从所有的等待作业中选出具有最高优先级的作业来执行。在任何时候，调度器可以调用 INSERT 把一个新作业加入到队列中来。</p>\n<p>相应地，<strong>最小优先队列</strong>支持的操作包括 <code>INSERT</code>、<code>MINIMUM</code>、<code>EXTRACT-MIN</code> 和 <code>DECREASE-KEY</code>。</p>\n<p>最小优先队列可以被用于基于事件驱动的模拟器。队列中保存要模拟的事件，每个事件都有一个发生时间作为其关键字。事件必须按照发生的时间顺序进行模拟，因为某一事件的模拟结果可能会触发对其他事件的模拟。在每一步，模拟程序调用 EXTRACT-MIN 来选择下一个要模拟的事件。当一个新事件产生时，模拟器通过调用 INSERT 将其插入最小优先级队列中。</p>\n<h3 id=\"MAXIMUM\"><a href=\"#MAXIMUM\" class=\"headerlink\" title=\"MAXIMUM\"></a>MAXIMUM</h3><p>我们先讨论如何实现最大优先队列。首先，HEAP-MAXIMUM 可以实现 MAXIMUM 的操作。</p>\n<p><em>HEAP-MAXIMUM(A)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 最大堆的根结点即最大优先队列中最大的关键字</div><div class=\"line\">return A[1]</div></pre></td></tr></table></figure></p>\n<h3 id=\"EXTRACT-MAX\"><a href=\"#EXTRACT-MAX\" class=\"headerlink\" title=\"EXTRACT-MAX\"></a>EXTRACT-MAX</h3><p>过程 HEAP-EXTRACT-MAX 实现 EXTRACT-MAX 操作，它与 HEAPSORT 过程中的 <code>for</code> 循环体部分相似。</p>\n<p><em>HEAP-EXTRACT-MAX(A)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">if A.heap-size &lt; 1</div><div class=\"line\">  error &quot;heap underflow&quot;</div><div class=\"line\">// 堆的根结点即是最大值</div><div class=\"line\">max = A[1]</div><div class=\"line\">// 将最后一个结点放到根结点</div><div class=\"line\">A[1] = A[A.heap-size]</div><div class=\"line\">A.heap-size = A.heap-size - 1</div><div class=\"line\">// 维持最大堆性质</div><div class=\"line\">MAX-HEAPIFY(A, 1)</div></pre></td></tr></table></figure></p>\n<h3 id=\"INCREASE-KEY\"><a href=\"#INCREASE-KEY\" class=\"headerlink\" title=\"INCREASE-KEY\"></a>INCREASE-KEY</h3><p>过程 HEAP-INCREASE-KEY 实现 INCREASE-KEY 操作。当将元素 A[i] 的关键字更新为新值后，因为增大 A[i]坑内会让新的堆违反最大堆性质，所以在从当前结点到根结点的路径上，为新增的关键字寻找恰当的插入位置。当前元素会不断地与其父结点进行比较，如果当前元素的关键字较大，则当前元素与父结点进行交换。这一过程一直重复到当前元素的关键字小于其父结点为止。</p>\n<p>在优先队列中，我们更希望增加关键字的优先队列元素由对应的数组下标 i 来标识：</p>\n<p><em>HEAP-INCREASE-KEY(A, i, key)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">if key &lt; A[i]</div><div class=\"line\">  error &quot;new key is smaller than current key&quot;</div><div class=\"line\">// 替换对应的关键字</div><div class=\"line\">A[i] = key</div><div class=\"line\">// 为新增关键字寻找正确的位置</div><div class=\"line\">while i &gt; 1 and A[PARENT(i)] &lt; A[i]</div><div class=\"line\">  // 若新增关键字大于父结点值，交换它们</div><div class=\"line\">  exchange A[i] and A[PARENT(i)]</div><div class=\"line\">  i = PARENT(i)</div></pre></td></tr></table></figure></p>\n<h3 id=\"INSERT\"><a href=\"#INSERT\" class=\"headerlink\" title=\"INSERT\"></a>INSERT</h3><p>过程 MAX-HEAP-INSERT 实现 INSERT 操作。它的输入是要被插入到最大堆 A 中的新元素的关键字。MAX-HEAP-INSERT 首先通过增加一个关键字为 <code>-∞</code> 的叶结点来扩展最大堆，然后调用 HEAP-INCREASE-KEY 来将新结点设置为对应的关键字，同时保持最大堆的性质。</p>\n<p><em>MAX-HEAP-INSERT(A, key)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 扩展最大堆</div><div class=\"line\">A.heap-size = A.heap-size + 1</div><div class=\"line\">// 给新结点赋值</div><div class=\"line\">A[heap-size] = -∞</div><div class=\"line\">// 将新结点的值替换成对应关键字</div><div class=\"line\">HEAP-INCREASE-KEY(A, A.heap-size, key)</div></pre></td></tr></table></figure></p>"},{"title":"《算法导论》第七章：快速排序","date":"2016-07-07T14:48:08.000Z","_content":"\n快速排序和归并排序一样，使用了分治思想。回顾一下归并排序，归并排序是将数组递归拆分，然后两两合并成已排序的数组，一直到合并成为新数组。\n\n快速排序的思想有点相似，但快速排序能够进行原址排序，而不用占用大量的额外空间。\n\n<!-- more -->\n\n对于数组 `A[p .. r]` 快速排序的三步分治过程如下：\n\n- 分解：数组 `A[p .. r]` 被划分为两个（可能为空）子数组 `A[p .. q - 1]` 和 `A[q + 1 .. r]`，使得 `A[p .. q - 1]` 中的每一个元素都小于等于 `A[q]`，而 `A[q]` 也小于等于 `A[q + 1 .. r]` 中的每个元素。其中，计算下标 q 也是划分过程的一部分。\n- 解决：通过递归调用快速排序，对子数组 `A[p .. q - 1]` 和 `A[q + 1 .. r]` 进行排序。\n- 合并：因为子数组都是原址排序的，所以不需要合并操作：数组 `A[p .. r]` 已经有序。\n\n核心就在于我们选出了一个主元（即 `A[q]`），将数组划分为了两个子数组，一边小于等于 `A[q]`，一边大于等于 `A[q]`，再分别对两个子数组执行相同操作，一直到不可拆分为止。\n\n伪代码：\n*QUICKSORT(A, p, r)*\n```\nif p < r\n  // 找到分界点 A[q] 的位置\n  q = PARTITION(A, p, r);\n  // 递归调用 A[q] 左边的数组\n  QUICKSORT(A, p, q - 1);\n  // 递归调用 A[q] 右边的数组\n  QUICKSORT(A, q + 1, r);\n```\n\n所以算法的关键步骤就是 `PARTITION` 过程，它实现对子数组 `A[p .. r]` 的原址重排。\n\n*PARTITION(A, p, r)*\n```\n// 数组的最后一个元素（主元）\nx = A[r]\n// i 是小元素数组的右界\ni = p - 1;\n// 遍历数组\nfor j = p to r - 1\n  if A[j] <= x\n    // 如果该元素比 x 小，小元素数组长度加 1\n    i = i + 1\n    // 将该元素挪到小元素数组范围里去\n    exchange A[i] with A[j]\n// 将主元放到大小数组中间\nexchange A[i + 1] with A[j]\n// 主元的位置\nreturn i + 1\n```\n\n快速排序算法的过程涉及到 4 个变量：`p`, `r`, `i`, `j`。将 `A[p .. r]` 数组划分为了四个部分。\n\n1. `p` 到 `i` 之间为第一部分，其值都不大于主元\n2. `i + 1` 到 `j - 1` 之间为第二部分，其值都不小于主元\n3. `j` 到 `r - 1` 之间是第三部分，其元素等待被分配\n4. `r` 处为主元（数组的最后一个元素）\n\n当循环开始时，`j` 从左往右对数组进行扫描，当发现有比主元小的元素时，将 `i` 往右移，并该元素放到 `i` 处，这样循环结束后，整个数组中，`p` 到 `i` 为不大于主元的元素，`i + 1` 到 `r - 1` 为不小于主元的元素，`r` 处为主元，最后我们将 `i + 1` 处的元素和主元交换位置，这样主元就位于了两部分之间。最后，我们对两个子数组进行同样的操作。\n\njavascript 实现\n```javascript\nfunction quickSort(arr, p, r) {\n  if(p < r) {\n    let q = partition(arr, p, r);\n    quickSort(arr, p, q - 1);\n    quickSort(arr, q + 1, r);\n  }\n}\n\nfunction partition(arr, p, r) {\n  let x = arr[r];\n  let i = p - 1;\n  for(var j = p; j < r; j++) {\n    if(arr[j] <= x) {\n      i++;\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n  }\n  [arr[i + 1], arr[r]] = [arr[r], arr[i + 1]];\n  return i + 1;\n}\n\nlet arr = [13, 19, 9, 5, 12, 8, 7, 4, 21, 2, 6, 11];\nquickSort(arr, 0, arr.length - 1);\nconsole.log(arr); // [2, 4, 5, 6, 7, 8, 9, 11, 12, 13, 19, 21]\n```\n","source":"_posts/Introduction-to-Algorithms-7.md","raw":"---\ntitle: 《算法导论》第七章：快速排序\ndate: 2016-07-07 22:48:08\ntags: [读书笔记, 算法]\n---\n\n快速排序和归并排序一样，使用了分治思想。回顾一下归并排序，归并排序是将数组递归拆分，然后两两合并成已排序的数组，一直到合并成为新数组。\n\n快速排序的思想有点相似，但快速排序能够进行原址排序，而不用占用大量的额外空间。\n\n<!-- more -->\n\n对于数组 `A[p .. r]` 快速排序的三步分治过程如下：\n\n- 分解：数组 `A[p .. r]` 被划分为两个（可能为空）子数组 `A[p .. q - 1]` 和 `A[q + 1 .. r]`，使得 `A[p .. q - 1]` 中的每一个元素都小于等于 `A[q]`，而 `A[q]` 也小于等于 `A[q + 1 .. r]` 中的每个元素。其中，计算下标 q 也是划分过程的一部分。\n- 解决：通过递归调用快速排序，对子数组 `A[p .. q - 1]` 和 `A[q + 1 .. r]` 进行排序。\n- 合并：因为子数组都是原址排序的，所以不需要合并操作：数组 `A[p .. r]` 已经有序。\n\n核心就在于我们选出了一个主元（即 `A[q]`），将数组划分为了两个子数组，一边小于等于 `A[q]`，一边大于等于 `A[q]`，再分别对两个子数组执行相同操作，一直到不可拆分为止。\n\n伪代码：\n*QUICKSORT(A, p, r)*\n```\nif p < r\n  // 找到分界点 A[q] 的位置\n  q = PARTITION(A, p, r);\n  // 递归调用 A[q] 左边的数组\n  QUICKSORT(A, p, q - 1);\n  // 递归调用 A[q] 右边的数组\n  QUICKSORT(A, q + 1, r);\n```\n\n所以算法的关键步骤就是 `PARTITION` 过程，它实现对子数组 `A[p .. r]` 的原址重排。\n\n*PARTITION(A, p, r)*\n```\n// 数组的最后一个元素（主元）\nx = A[r]\n// i 是小元素数组的右界\ni = p - 1;\n// 遍历数组\nfor j = p to r - 1\n  if A[j] <= x\n    // 如果该元素比 x 小，小元素数组长度加 1\n    i = i + 1\n    // 将该元素挪到小元素数组范围里去\n    exchange A[i] with A[j]\n// 将主元放到大小数组中间\nexchange A[i + 1] with A[j]\n// 主元的位置\nreturn i + 1\n```\n\n快速排序算法的过程涉及到 4 个变量：`p`, `r`, `i`, `j`。将 `A[p .. r]` 数组划分为了四个部分。\n\n1. `p` 到 `i` 之间为第一部分，其值都不大于主元\n2. `i + 1` 到 `j - 1` 之间为第二部分，其值都不小于主元\n3. `j` 到 `r - 1` 之间是第三部分，其元素等待被分配\n4. `r` 处为主元（数组的最后一个元素）\n\n当循环开始时，`j` 从左往右对数组进行扫描，当发现有比主元小的元素时，将 `i` 往右移，并该元素放到 `i` 处，这样循环结束后，整个数组中，`p` 到 `i` 为不大于主元的元素，`i + 1` 到 `r - 1` 为不小于主元的元素，`r` 处为主元，最后我们将 `i + 1` 处的元素和主元交换位置，这样主元就位于了两部分之间。最后，我们对两个子数组进行同样的操作。\n\njavascript 实现\n```javascript\nfunction quickSort(arr, p, r) {\n  if(p < r) {\n    let q = partition(arr, p, r);\n    quickSort(arr, p, q - 1);\n    quickSort(arr, q + 1, r);\n  }\n}\n\nfunction partition(arr, p, r) {\n  let x = arr[r];\n  let i = p - 1;\n  for(var j = p; j < r; j++) {\n    if(arr[j] <= x) {\n      i++;\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n  }\n  [arr[i + 1], arr[r]] = [arr[r], arr[i + 1]];\n  return i + 1;\n}\n\nlet arr = [13, 19, 9, 5, 12, 8, 7, 4, 21, 2, 6, 11];\nquickSort(arr, 0, arr.length - 1);\nconsole.log(arr); // [2, 4, 5, 6, 7, 8, 9, 11, 12, 13, 19, 21]\n```\n","slug":"Introduction-to-Algorithms-7","published":1,"updated":"2016-08-27T00:03:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscgyh110004gq27tzy1xdwr","content":"<p>快速排序和归并排序一样，使用了分治思想。回顾一下归并排序，归并排序是将数组递归拆分，然后两两合并成已排序的数组，一直到合并成为新数组。</p>\n<p>快速排序的思想有点相似，但快速排序能够进行原址排序，而不用占用大量的额外空间。</p>\n<a id=\"more\"></a>\n<p>对于数组 <code>A[p .. r]</code> 快速排序的三步分治过程如下：</p>\n<ul>\n<li>分解：数组 <code>A[p .. r]</code> 被划分为两个（可能为空）子数组 <code>A[p .. q - 1]</code> 和 <code>A[q + 1 .. r]</code>，使得 <code>A[p .. q - 1]</code> 中的每一个元素都小于等于 <code>A[q]</code>，而 <code>A[q]</code> 也小于等于 <code>A[q + 1 .. r]</code> 中的每个元素。其中，计算下标 q 也是划分过程的一部分。</li>\n<li>解决：通过递归调用快速排序，对子数组 <code>A[p .. q - 1]</code> 和 <code>A[q + 1 .. r]</code> 进行排序。</li>\n<li>合并：因为子数组都是原址排序的，所以不需要合并操作：数组 <code>A[p .. r]</code> 已经有序。</li>\n</ul>\n<p>核心就在于我们选出了一个主元（即 <code>A[q]</code>），将数组划分为了两个子数组，一边小于等于 <code>A[q]</code>，一边大于等于 <code>A[q]</code>，再分别对两个子数组执行相同操作，一直到不可拆分为止。</p>\n<p>伪代码：<br><em>QUICKSORT(A, p, r)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">if p &lt; r</div><div class=\"line\">  // 找到分界点 A[q] 的位置</div><div class=\"line\">  q = PARTITION(A, p, r);</div><div class=\"line\">  // 递归调用 A[q] 左边的数组</div><div class=\"line\">  QUICKSORT(A, p, q - 1);</div><div class=\"line\">  // 递归调用 A[q] 右边的数组</div><div class=\"line\">  QUICKSORT(A, q + 1, r);</div></pre></td></tr></table></figure></p>\n<p>所以算法的关键步骤就是 <code>PARTITION</code> 过程，它实现对子数组 <code>A[p .. r]</code> 的原址重排。</p>\n<p><em>PARTITION(A, p, r)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 数组的最后一个元素（主元）</div><div class=\"line\">x = A[r]</div><div class=\"line\">// i 是小元素数组的右界</div><div class=\"line\">i = p - 1;</div><div class=\"line\">// 遍历数组</div><div class=\"line\">for j = p to r - 1</div><div class=\"line\">  if A[j] &lt;= x</div><div class=\"line\">    // 如果该元素比 x 小，小元素数组长度加 1</div><div class=\"line\">    i = i + 1</div><div class=\"line\">    // 将该元素挪到小元素数组范围里去</div><div class=\"line\">    exchange A[i] with A[j]</div><div class=\"line\">// 将主元放到大小数组中间</div><div class=\"line\">exchange A[i + 1] with A[j]</div><div class=\"line\">// 主元的位置</div><div class=\"line\">return i + 1</div></pre></td></tr></table></figure></p>\n<p>快速排序算法的过程涉及到 4 个变量：<code>p</code>, <code>r</code>, <code>i</code>, <code>j</code>。将 <code>A[p .. r]</code> 数组划分为了四个部分。</p>\n<ol>\n<li><code>p</code> 到 <code>i</code> 之间为第一部分，其值都不大于主元</li>\n<li><code>i + 1</code> 到 <code>j - 1</code> 之间为第二部分，其值都不小于主元</li>\n<li><code>j</code> 到 <code>r - 1</code> 之间是第三部分，其元素等待被分配</li>\n<li><code>r</code> 处为主元（数组的最后一个元素）</li>\n</ol>\n<p>当循环开始时，<code>j</code> 从左往右对数组进行扫描，当发现有比主元小的元素时，将 <code>i</code> 往右移，并该元素放到 <code>i</code> 处，这样循环结束后，整个数组中，<code>p</code> 到 <code>i</code> 为不大于主元的元素，<code>i + 1</code> 到 <code>r - 1</code> 为不小于主元的元素，<code>r</code> 处为主元，最后我们将 <code>i + 1</code> 处的元素和主元交换位置，这样主元就位于了两部分之间。最后，我们对两个子数组进行同样的操作。</p>\n<p>javascript 实现<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quickSort</span>(<span class=\"params\">arr, p, r</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(p &lt; r) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> q = partition(arr, p, r);</div><div class=\"line\">    quickSort(arr, p, q - <span class=\"number\">1</span>);</div><div class=\"line\">    quickSort(arr, q + <span class=\"number\">1</span>, r);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">partition</span>(<span class=\"params\">arr, p, r</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> x = arr[r];</div><div class=\"line\">  <span class=\"keyword\">let</span> i = p - <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = p; j &lt; r; j++) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(arr[j] &lt;= x) &#123;</div><div class=\"line\">      i++;</div><div class=\"line\">      [arr[i], arr[j]] = [arr[j], arr[i]];</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  [arr[i + <span class=\"number\">1</span>], arr[r]] = [arr[r], arr[i + <span class=\"number\">1</span>]];</div><div class=\"line\">  <span class=\"keyword\">return</span> i + <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">13</span>, <span class=\"number\">19</span>, <span class=\"number\">9</span>, <span class=\"number\">5</span>, <span class=\"number\">12</span>, <span class=\"number\">8</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>, <span class=\"number\">21</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">11</span>];</div><div class=\"line\">quickSort(arr, <span class=\"number\">0</span>, arr.length - <span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [2, 4, 5, 6, 7, 8, 9, 11, 12, 13, 19, 21]</span></div></pre></td></tr></table></figure></p>\n","excerpt":"<p>快速排序和归并排序一样，使用了分治思想。回顾一下归并排序，归并排序是将数组递归拆分，然后两两合并成已排序的数组，一直到合并成为新数组。</p>\n<p>快速排序的思想有点相似，但快速排序能够进行原址排序，而不用占用大量的额外空间。</p>","more":"<p>对于数组 <code>A[p .. r]</code> 快速排序的三步分治过程如下：</p>\n<ul>\n<li>分解：数组 <code>A[p .. r]</code> 被划分为两个（可能为空）子数组 <code>A[p .. q - 1]</code> 和 <code>A[q + 1 .. r]</code>，使得 <code>A[p .. q - 1]</code> 中的每一个元素都小于等于 <code>A[q]</code>，而 <code>A[q]</code> 也小于等于 <code>A[q + 1 .. r]</code> 中的每个元素。其中，计算下标 q 也是划分过程的一部分。</li>\n<li>解决：通过递归调用快速排序，对子数组 <code>A[p .. q - 1]</code> 和 <code>A[q + 1 .. r]</code> 进行排序。</li>\n<li>合并：因为子数组都是原址排序的，所以不需要合并操作：数组 <code>A[p .. r]</code> 已经有序。</li>\n</ul>\n<p>核心就在于我们选出了一个主元（即 <code>A[q]</code>），将数组划分为了两个子数组，一边小于等于 <code>A[q]</code>，一边大于等于 <code>A[q]</code>，再分别对两个子数组执行相同操作，一直到不可拆分为止。</p>\n<p>伪代码：<br><em>QUICKSORT(A, p, r)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">if p &lt; r</div><div class=\"line\">  // 找到分界点 A[q] 的位置</div><div class=\"line\">  q = PARTITION(A, p, r);</div><div class=\"line\">  // 递归调用 A[q] 左边的数组</div><div class=\"line\">  QUICKSORT(A, p, q - 1);</div><div class=\"line\">  // 递归调用 A[q] 右边的数组</div><div class=\"line\">  QUICKSORT(A, q + 1, r);</div></pre></td></tr></table></figure></p>\n<p>所以算法的关键步骤就是 <code>PARTITION</code> 过程，它实现对子数组 <code>A[p .. r]</code> 的原址重排。</p>\n<p><em>PARTITION(A, p, r)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 数组的最后一个元素（主元）</div><div class=\"line\">x = A[r]</div><div class=\"line\">// i 是小元素数组的右界</div><div class=\"line\">i = p - 1;</div><div class=\"line\">// 遍历数组</div><div class=\"line\">for j = p to r - 1</div><div class=\"line\">  if A[j] &lt;= x</div><div class=\"line\">    // 如果该元素比 x 小，小元素数组长度加 1</div><div class=\"line\">    i = i + 1</div><div class=\"line\">    // 将该元素挪到小元素数组范围里去</div><div class=\"line\">    exchange A[i] with A[j]</div><div class=\"line\">// 将主元放到大小数组中间</div><div class=\"line\">exchange A[i + 1] with A[j]</div><div class=\"line\">// 主元的位置</div><div class=\"line\">return i + 1</div></pre></td></tr></table></figure></p>\n<p>快速排序算法的过程涉及到 4 个变量：<code>p</code>, <code>r</code>, <code>i</code>, <code>j</code>。将 <code>A[p .. r]</code> 数组划分为了四个部分。</p>\n<ol>\n<li><code>p</code> 到 <code>i</code> 之间为第一部分，其值都不大于主元</li>\n<li><code>i + 1</code> 到 <code>j - 1</code> 之间为第二部分，其值都不小于主元</li>\n<li><code>j</code> 到 <code>r - 1</code> 之间是第三部分，其元素等待被分配</li>\n<li><code>r</code> 处为主元（数组的最后一个元素）</li>\n</ol>\n<p>当循环开始时，<code>j</code> 从左往右对数组进行扫描，当发现有比主元小的元素时，将 <code>i</code> 往右移，并该元素放到 <code>i</code> 处，这样循环结束后，整个数组中，<code>p</code> 到 <code>i</code> 为不大于主元的元素，<code>i + 1</code> 到 <code>r - 1</code> 为不小于主元的元素，<code>r</code> 处为主元，最后我们将 <code>i + 1</code> 处的元素和主元交换位置，这样主元就位于了两部分之间。最后，我们对两个子数组进行同样的操作。</p>\n<p>javascript 实现<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quickSort</span>(<span class=\"params\">arr, p, r</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(p &lt; r) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> q = partition(arr, p, r);</div><div class=\"line\">    quickSort(arr, p, q - <span class=\"number\">1</span>);</div><div class=\"line\">    quickSort(arr, q + <span class=\"number\">1</span>, r);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">partition</span>(<span class=\"params\">arr, p, r</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> x = arr[r];</div><div class=\"line\">  <span class=\"keyword\">let</span> i = p - <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = p; j &lt; r; j++) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(arr[j] &lt;= x) &#123;</div><div class=\"line\">      i++;</div><div class=\"line\">      [arr[i], arr[j]] = [arr[j], arr[i]];</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  [arr[i + <span class=\"number\">1</span>], arr[r]] = [arr[r], arr[i + <span class=\"number\">1</span>]];</div><div class=\"line\">  <span class=\"keyword\">return</span> i + <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">13</span>, <span class=\"number\">19</span>, <span class=\"number\">9</span>, <span class=\"number\">5</span>, <span class=\"number\">12</span>, <span class=\"number\">8</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>, <span class=\"number\">21</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">11</span>];</div><div class=\"line\">quickSort(arr, <span class=\"number\">0</span>, arr.length - <span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [2, 4, 5, 6, 7, 8, 9, 11, 12, 13, 19, 21]</span></div></pre></td></tr></table></figure></p>"},{"title":"《算法导论》第八章：线性时间排序","date":"2016-07-09T13:59:26.000Z","_content":"\n在前面几章总共介绍了*插入排序、归并排序、堆排序和快速排序*，这些算法都有一个有趣的性质：**在排序的最终结果中，各元素的次序依赖于它们之间的比较**。我们把这类排序算法成为比较排序。\n\n接下来讨论三种线性时间复杂度的排序算法：计数排序、基数排序和桶排序，它们使用运算而不是比较来确定排序顺序。\n\n<!-- more -->\n\n## 排序顺序的下界\n在一个比较排序中，我们只使用元素间的比较来获得输入序列 `<a1, a2, ..., an>` 中的元素间次序的信息。也就是给定两个元素 `ai` 和 `aj`，我们执行比较操作来确定它们之间的相对次序。\n\n### 决策树模型\n比较排序可以被抽象为一颗决策树。\n\n决策树是一颗**完全二叉树**，它可以表示在给定输入规模情况下，某一特定排序算法对所有元素的比较操作。其中，控制、数据移动等其他操作都被忽略了。\n\n在决策树中，每个内部结点都以 `i : j` 标记，其中，`i` 和 `j` 满足 `1 <= i <= j <= n`，`n` 是输入序列中的元素个数。每个叶结点上都标注一个序列 `<π(1), π(2), ..., π(n)`。\n\n排序算法的执行对应于一条从树的根结点到叶结点的路径。每一个内部结点表示比较一次 `ai` 和 `aj`。\n\n每当到达一个叶结点的时候，代表排序算法已经确定了一个顺序。对于一个正确的比较排序算法来说，`n` 个元素的 `n!` 种可能的排列都应该出现在决策树的叶结点上。而且，每一个叶结点都必须是可以从根结点经由某条路径到达的，该路径对应于比较排序的一次实际执行过程（我们称这种叶结点为“可达的”）。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-8/01.png)\n\n如上图，这是一颗作用于三个元素的插入排序决策树。根节点表示第一个元素和第二个元素进行了比较，当第一个元素小于等于第二个元素时，进入根节点的左孩子，将第二个元素和第三个元素进行比较，以此类推。最后，如果第三个孩子小于第一个孩子小于第二个孩子，则排序结果是 `<3, 1, 2>`。\n\n### 最坏情况的下界\n\n对于一颗每个排列都是一个可达叶结点的决策树来说，树的高度完全可以被确定。考虑一颗高度为 `h`，具有 `l` 个可达叶结点的决策树，它对应一个对 `n` 个元素所做的比较排序。\n\n因为输入数据的 `n!` 种可能的排列都是叶结点，所以有 `n! <= l`。\n\n由于在一棵高度为 `h` 的二叉树中，叶结点的数目不多于 `2^h`，所以有 `l <= 2^h`。\n\n我们即得到 `n! <= l <= 2^h`。\n\n两边取对数，有\n\n> h >= lg(n!) = Ω(nlgn)\n\n我们即得到定理：*在最坏情况下，任何比较排序算法都需要做 Ω(nlgn) 次比较*\n\n## 计数排序\n\n上面说完比较排序的最坏下界，我们现在开始讨论线性时间复杂度的排序算法。\n\n**计数排序假设 `n` 个输入元素中的每一个都是在 `0` 到 `k` 区间内的一个整数，其中 `k` 为某个整数**。当 `k = O(n)` 时，排序的运行时间为 `Θ(n)`。\n\n### 思想\n\n计数排序的思想是：对每一个输入元素 `x`，确定小于 `x` 的元素个数。这样，当需要排序元素 `x` 时，只需把 `x` 直接放到它在输出数组中的位置了。\n\n比如如果有 `17` 个元素小于 `x`，则 `x` 应该被放到第十八个输出位置上。当有几个元素相同时，这一方案要略作修改，因为不能把它们放到同一个位置。\n\n### 伪代码\n\n在计数排序的算法中，假设输入是一个数组 `A[1 .. n]`，`A.length = n`。我们还需要两个数组：`B[1 .. n]` 存放输出数组， `C[0 .. k]` 存放个数信息。\n\n*COUNTING-SORT(A, B, k)*\n```\n// C 数组长度为输入数组的最大值\nlet C[0 .. k] be a new array\n// 将 C 数组的元素全部赋值为 0\nfor i = 0 to k\n  C[i] = 0\n// 遍历输入数组，并将 C 元素中对应的值个数加一\nfor j = 1 to A.length\n  C[A[j]] = C[A[j]] + 1\n// 此时 C 数组中存放的是下标在输入数组中的个数\n// C[i] now contains the number of elements equal to i\n// 遍历 C 数组，将个数转变为小于等于下标的个数\nfor i = 1 to k\n  C[i] = C[i] + C[i - 1]\n// C[i] now contains the number of elements less than or equal to i\n// 将输入数组中的元素放入输出数组中对应的位置\nfor j = A.length downto 1\n  B[C[A[j]]] = A[j]\n  C[A[j]] = C[A[j]] - 1\n```\n\n### 排序过程\n\n假设数组 `A` 元素为：`2, 5, 3, 0, 2, 3, 0, 3`\n\n1) 因为输入数组最大元素为 `5`，所以初始化 `C` 数组长度为 `5`。\n\n2) 遍历 `A` 数组，将 `C` 数组中下标为遍历到的元素大小的元素加 1。\n\n3) 步骤 2 结束后 `C` 数组元素为：`2, 0, 2, 3, 0, 1`，代表 `A` 数组中 `0` 个数为 `2`，'1' 个数为 `0`，以此类推。\n\n4) 遍历 `C` 数组，将元素大小置为当前元素大小加前一元素大小。\n\n5) 步骤 4 结束后，`C` 数组元素为：`2, 2, 4, 7, 7, 8`，代表 `A` 数组中小于等于 `0` 个数为 `2`，小于等于 '1' 个数为 `2`，小于等于 '2' 个数为 `4`，以此类推。\n\n6) 遍历 `A` 数组，利用 `C` 数组中的信息将元素放置到对应的位置，需要注意每放置完一个元素需要将对应的小于等于个数减一。\n\n计数排序的总时间代价是 `Θ(k + n)`，当 `k = O(n)` 时，我们一般采用计数排序，此时运行时间为 `Θ(n)`。\n\n计数排序的另一个重要性质是它是**稳定的**：具有相同大小的元素，在输入数组中先出现的，在输出数组中也位于前面。\n\n### javascript 实现\n```javascript\nunction countingSort(arr, k) {\n  var B = [], C = [0];\n  for(var i = 0; i < k; i++, C[i] = 0) {/*empty*/}\n\n  for(var i = 0; i < arr.length; i++) {\n    C[arr[i]] = C[arr[i]] + 1;\n  }\n\n  for(var i = 1; i < C.length; i++) {\n    C[i] = C[i] + C[i - 1];\n  }\n\n  for(var i = arr.length - 1; i >= 0; i--) {\n    // -1 是因为小于等于该元素的个数包括该元素\n    B[C[arr[i]] - 1] = arr[i];\n    C[arr[i]] = C[arr[i]] - 1;\n  }\n\n  return B;\n}\n\nvar arr = [2, 5, 3, 0, 2, 3, 0, 3];\ncountingSort(arr, 5); // [0, 0, 2, 2, 3, 3, 3, 5]\n```\n\n## 基数排序\n\n基数排序用于排序 `n` 个 `d` 位数，先按最低有效位进行排序，然后按次低有效位，直到对所有的 `d` 位数都进行了排序。\n\n基数排序的代码是非常直观的，假设 `n` 个 `d` 位的元素存放在数组 `A` 中，其中第 `1` 位是最低位，第 `d` 位是最高位。如果我们希望元素排序完之后顺序不会被改变，那么在排序有效位过程中需要使用一种稳定的排序算法。\n\n*RADIX-SORT(A, d)*\n```\nfor i = 1 to d\n  use a stable sort to sort array A on digit d\n```\n\n以 8 个 3 位数举例，排序过程如下：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-8/02.jpg)\n\n对于 `n` 个 `d` 位数，其中每一个数位有 k 个可能的取值。如果 `RADIX-SORT` 使用的稳定排序方法耗时 `Θ(n + k)`，那么它就可以在 `Θ(d(n + k))` 时间内将这些数排好序。\n\n## 桶排序\n\n桶排序假设输入数据服从均匀分布，平均情况下它的时间代价为 `O(n)`。\n\n桶排序将 `[0, 1)` 划分为 `n` 个相同大小的子区间，称为桶。然后，将 n 个输入数分别放到桶中，因为输入数据是均匀、独立地分布在 `[0, 1)` 上，所以一般不会出现很多数落在同一个桶中的情况。为了得到输出结果，我们先对每个桶中的数进行排序，然后遍历每个桶，按照次序把各个桶中的元素列出来即可。\n\n算法需要一个临时数组 `B[0 .. n-1]` 来存放链表（即桶），并假设存在一种用于维护这些链表的机制。\n\n### 排序过程\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-8/03.jpg)\n","source":"_posts/Introduction-to-Algorithms-8.md","raw":"---\ntitle: 《算法导论》第八章：线性时间排序\ndate: 2016-07-09 21:59:26\ntags: [读书笔记, 算法]\n---\n\n在前面几章总共介绍了*插入排序、归并排序、堆排序和快速排序*，这些算法都有一个有趣的性质：**在排序的最终结果中，各元素的次序依赖于它们之间的比较**。我们把这类排序算法成为比较排序。\n\n接下来讨论三种线性时间复杂度的排序算法：计数排序、基数排序和桶排序，它们使用运算而不是比较来确定排序顺序。\n\n<!-- more -->\n\n## 排序顺序的下界\n在一个比较排序中，我们只使用元素间的比较来获得输入序列 `<a1, a2, ..., an>` 中的元素间次序的信息。也就是给定两个元素 `ai` 和 `aj`，我们执行比较操作来确定它们之间的相对次序。\n\n### 决策树模型\n比较排序可以被抽象为一颗决策树。\n\n决策树是一颗**完全二叉树**，它可以表示在给定输入规模情况下，某一特定排序算法对所有元素的比较操作。其中，控制、数据移动等其他操作都被忽略了。\n\n在决策树中，每个内部结点都以 `i : j` 标记，其中，`i` 和 `j` 满足 `1 <= i <= j <= n`，`n` 是输入序列中的元素个数。每个叶结点上都标注一个序列 `<π(1), π(2), ..., π(n)`。\n\n排序算法的执行对应于一条从树的根结点到叶结点的路径。每一个内部结点表示比较一次 `ai` 和 `aj`。\n\n每当到达一个叶结点的时候，代表排序算法已经确定了一个顺序。对于一个正确的比较排序算法来说，`n` 个元素的 `n!` 种可能的排列都应该出现在决策树的叶结点上。而且，每一个叶结点都必须是可以从根结点经由某条路径到达的，该路径对应于比较排序的一次实际执行过程（我们称这种叶结点为“可达的”）。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-8/01.png)\n\n如上图，这是一颗作用于三个元素的插入排序决策树。根节点表示第一个元素和第二个元素进行了比较，当第一个元素小于等于第二个元素时，进入根节点的左孩子，将第二个元素和第三个元素进行比较，以此类推。最后，如果第三个孩子小于第一个孩子小于第二个孩子，则排序结果是 `<3, 1, 2>`。\n\n### 最坏情况的下界\n\n对于一颗每个排列都是一个可达叶结点的决策树来说，树的高度完全可以被确定。考虑一颗高度为 `h`，具有 `l` 个可达叶结点的决策树，它对应一个对 `n` 个元素所做的比较排序。\n\n因为输入数据的 `n!` 种可能的排列都是叶结点，所以有 `n! <= l`。\n\n由于在一棵高度为 `h` 的二叉树中，叶结点的数目不多于 `2^h`，所以有 `l <= 2^h`。\n\n我们即得到 `n! <= l <= 2^h`。\n\n两边取对数，有\n\n> h >= lg(n!) = Ω(nlgn)\n\n我们即得到定理：*在最坏情况下，任何比较排序算法都需要做 Ω(nlgn) 次比较*\n\n## 计数排序\n\n上面说完比较排序的最坏下界，我们现在开始讨论线性时间复杂度的排序算法。\n\n**计数排序假设 `n` 个输入元素中的每一个都是在 `0` 到 `k` 区间内的一个整数，其中 `k` 为某个整数**。当 `k = O(n)` 时，排序的运行时间为 `Θ(n)`。\n\n### 思想\n\n计数排序的思想是：对每一个输入元素 `x`，确定小于 `x` 的元素个数。这样，当需要排序元素 `x` 时，只需把 `x` 直接放到它在输出数组中的位置了。\n\n比如如果有 `17` 个元素小于 `x`，则 `x` 应该被放到第十八个输出位置上。当有几个元素相同时，这一方案要略作修改，因为不能把它们放到同一个位置。\n\n### 伪代码\n\n在计数排序的算法中，假设输入是一个数组 `A[1 .. n]`，`A.length = n`。我们还需要两个数组：`B[1 .. n]` 存放输出数组， `C[0 .. k]` 存放个数信息。\n\n*COUNTING-SORT(A, B, k)*\n```\n// C 数组长度为输入数组的最大值\nlet C[0 .. k] be a new array\n// 将 C 数组的元素全部赋值为 0\nfor i = 0 to k\n  C[i] = 0\n// 遍历输入数组，并将 C 元素中对应的值个数加一\nfor j = 1 to A.length\n  C[A[j]] = C[A[j]] + 1\n// 此时 C 数组中存放的是下标在输入数组中的个数\n// C[i] now contains the number of elements equal to i\n// 遍历 C 数组，将个数转变为小于等于下标的个数\nfor i = 1 to k\n  C[i] = C[i] + C[i - 1]\n// C[i] now contains the number of elements less than or equal to i\n// 将输入数组中的元素放入输出数组中对应的位置\nfor j = A.length downto 1\n  B[C[A[j]]] = A[j]\n  C[A[j]] = C[A[j]] - 1\n```\n\n### 排序过程\n\n假设数组 `A` 元素为：`2, 5, 3, 0, 2, 3, 0, 3`\n\n1) 因为输入数组最大元素为 `5`，所以初始化 `C` 数组长度为 `5`。\n\n2) 遍历 `A` 数组，将 `C` 数组中下标为遍历到的元素大小的元素加 1。\n\n3) 步骤 2 结束后 `C` 数组元素为：`2, 0, 2, 3, 0, 1`，代表 `A` 数组中 `0` 个数为 `2`，'1' 个数为 `0`，以此类推。\n\n4) 遍历 `C` 数组，将元素大小置为当前元素大小加前一元素大小。\n\n5) 步骤 4 结束后，`C` 数组元素为：`2, 2, 4, 7, 7, 8`，代表 `A` 数组中小于等于 `0` 个数为 `2`，小于等于 '1' 个数为 `2`，小于等于 '2' 个数为 `4`，以此类推。\n\n6) 遍历 `A` 数组，利用 `C` 数组中的信息将元素放置到对应的位置，需要注意每放置完一个元素需要将对应的小于等于个数减一。\n\n计数排序的总时间代价是 `Θ(k + n)`，当 `k = O(n)` 时，我们一般采用计数排序，此时运行时间为 `Θ(n)`。\n\n计数排序的另一个重要性质是它是**稳定的**：具有相同大小的元素，在输入数组中先出现的，在输出数组中也位于前面。\n\n### javascript 实现\n```javascript\nunction countingSort(arr, k) {\n  var B = [], C = [0];\n  for(var i = 0; i < k; i++, C[i] = 0) {/*empty*/}\n\n  for(var i = 0; i < arr.length; i++) {\n    C[arr[i]] = C[arr[i]] + 1;\n  }\n\n  for(var i = 1; i < C.length; i++) {\n    C[i] = C[i] + C[i - 1];\n  }\n\n  for(var i = arr.length - 1; i >= 0; i--) {\n    // -1 是因为小于等于该元素的个数包括该元素\n    B[C[arr[i]] - 1] = arr[i];\n    C[arr[i]] = C[arr[i]] - 1;\n  }\n\n  return B;\n}\n\nvar arr = [2, 5, 3, 0, 2, 3, 0, 3];\ncountingSort(arr, 5); // [0, 0, 2, 2, 3, 3, 3, 5]\n```\n\n## 基数排序\n\n基数排序用于排序 `n` 个 `d` 位数，先按最低有效位进行排序，然后按次低有效位，直到对所有的 `d` 位数都进行了排序。\n\n基数排序的代码是非常直观的，假设 `n` 个 `d` 位的元素存放在数组 `A` 中，其中第 `1` 位是最低位，第 `d` 位是最高位。如果我们希望元素排序完之后顺序不会被改变，那么在排序有效位过程中需要使用一种稳定的排序算法。\n\n*RADIX-SORT(A, d)*\n```\nfor i = 1 to d\n  use a stable sort to sort array A on digit d\n```\n\n以 8 个 3 位数举例，排序过程如下：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-8/02.jpg)\n\n对于 `n` 个 `d` 位数，其中每一个数位有 k 个可能的取值。如果 `RADIX-SORT` 使用的稳定排序方法耗时 `Θ(n + k)`，那么它就可以在 `Θ(d(n + k))` 时间内将这些数排好序。\n\n## 桶排序\n\n桶排序假设输入数据服从均匀分布，平均情况下它的时间代价为 `O(n)`。\n\n桶排序将 `[0, 1)` 划分为 `n` 个相同大小的子区间，称为桶。然后，将 n 个输入数分别放到桶中，因为输入数据是均匀、独立地分布在 `[0, 1)` 上，所以一般不会出现很多数落在同一个桶中的情况。为了得到输出结果，我们先对每个桶中的数进行排序，然后遍历每个桶，按照次序把各个桶中的元素列出来即可。\n\n算法需要一个临时数组 `B[0 .. n-1]` 来存放链表（即桶），并假设存在一种用于维护这些链表的机制。\n\n### 排序过程\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-8/03.jpg)\n","slug":"Introduction-to-Algorithms-8","published":1,"updated":"2016-08-27T00:03:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscgyh130006gq27xc3x6zz5","content":"<p>在前面几章总共介绍了<em>插入排序、归并排序、堆排序和快速排序</em>，这些算法都有一个有趣的性质：<strong>在排序的最终结果中，各元素的次序依赖于它们之间的比较</strong>。我们把这类排序算法成为比较排序。</p>\n<p>接下来讨论三种线性时间复杂度的排序算法：计数排序、基数排序和桶排序，它们使用运算而不是比较来确定排序顺序。</p>\n<a id=\"more\"></a>\n<h2 id=\"排序顺序的下界\"><a href=\"#排序顺序的下界\" class=\"headerlink\" title=\"排序顺序的下界\"></a>排序顺序的下界</h2><p>在一个比较排序中，我们只使用元素间的比较来获得输入序列 <code>&lt;a1, a2, ..., an&gt;</code> 中的元素间次序的信息。也就是给定两个元素 <code>ai</code> 和 <code>aj</code>，我们执行比较操作来确定它们之间的相对次序。</p>\n<h3 id=\"决策树模型\"><a href=\"#决策树模型\" class=\"headerlink\" title=\"决策树模型\"></a>决策树模型</h3><p>比较排序可以被抽象为一颗决策树。</p>\n<p>决策树是一颗<strong>完全二叉树</strong>，它可以表示在给定输入规模情况下，某一特定排序算法对所有元素的比较操作。其中，控制、数据移动等其他操作都被忽略了。</p>\n<p>在决策树中，每个内部结点都以 <code>i : j</code> 标记，其中，<code>i</code> 和 <code>j</code> 满足 <code>1 &lt;= i &lt;= j &lt;= n</code>，<code>n</code> 是输入序列中的元素个数。每个叶结点上都标注一个序列 <code>&lt;π(1), π(2), ..., π(n)</code>。</p>\n<p>排序算法的执行对应于一条从树的根结点到叶结点的路径。每一个内部结点表示比较一次 <code>ai</code> 和 <code>aj</code>。</p>\n<p>每当到达一个叶结点的时候，代表排序算法已经确定了一个顺序。对于一个正确的比较排序算法来说，<code>n</code> 个元素的 <code>n!</code> 种可能的排列都应该出现在决策树的叶结点上。而且，每一个叶结点都必须是可以从根结点经由某条路径到达的，该路径对应于比较排序的一次实际执行过程（我们称这种叶结点为“可达的”）。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-8/01.png\" alt=\"\"></p>\n<p>如上图，这是一颗作用于三个元素的插入排序决策树。根节点表示第一个元素和第二个元素进行了比较，当第一个元素小于等于第二个元素时，进入根节点的左孩子，将第二个元素和第三个元素进行比较，以此类推。最后，如果第三个孩子小于第一个孩子小于第二个孩子，则排序结果是 <code>&lt;3, 1, 2&gt;</code>。</p>\n<h3 id=\"最坏情况的下界\"><a href=\"#最坏情况的下界\" class=\"headerlink\" title=\"最坏情况的下界\"></a>最坏情况的下界</h3><p>对于一颗每个排列都是一个可达叶结点的决策树来说，树的高度完全可以被确定。考虑一颗高度为 <code>h</code>，具有 <code>l</code> 个可达叶结点的决策树，它对应一个对 <code>n</code> 个元素所做的比较排序。</p>\n<p>因为输入数据的 <code>n!</code> 种可能的排列都是叶结点，所以有 <code>n! &lt;= l</code>。</p>\n<p>由于在一棵高度为 <code>h</code> 的二叉树中，叶结点的数目不多于 <code>2^h</code>，所以有 <code>l &lt;= 2^h</code>。</p>\n<p>我们即得到 <code>n! &lt;= l &lt;= 2^h</code>。</p>\n<p>两边取对数，有</p>\n<blockquote>\n<p>h &gt;= lg(n!) = Ω(nlgn)</p>\n</blockquote>\n<p>我们即得到定理：<em>在最坏情况下，任何比较排序算法都需要做 Ω(nlgn) 次比较</em></p>\n<h2 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h2><p>上面说完比较排序的最坏下界，我们现在开始讨论线性时间复杂度的排序算法。</p>\n<p><strong>计数排序假设 <code>n</code> 个输入元素中的每一个都是在 <code>0</code> 到 <code>k</code> 区间内的一个整数，其中 <code>k</code> 为某个整数</strong>。当 <code>k = O(n)</code> 时，排序的运行时间为 <code>Θ(n)</code>。</p>\n<h3 id=\"思想\"><a href=\"#思想\" class=\"headerlink\" title=\"思想\"></a>思想</h3><p>计数排序的思想是：对每一个输入元素 <code>x</code>，确定小于 <code>x</code> 的元素个数。这样，当需要排序元素 <code>x</code> 时，只需把 <code>x</code> 直接放到它在输出数组中的位置了。</p>\n<p>比如如果有 <code>17</code> 个元素小于 <code>x</code>，则 <code>x</code> 应该被放到第十八个输出位置上。当有几个元素相同时，这一方案要略作修改，因为不能把它们放到同一个位置。</p>\n<h3 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h3><p>在计数排序的算法中，假设输入是一个数组 <code>A[1 .. n]</code>，<code>A.length = n</code>。我们还需要两个数组：<code>B[1 .. n]</code> 存放输出数组， <code>C[0 .. k]</code> 存放个数信息。</p>\n<p><em>COUNTING-SORT(A, B, k)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">// C 数组长度为输入数组的最大值</div><div class=\"line\">let C[0 .. k] be a new array</div><div class=\"line\">// 将 C 数组的元素全部赋值为 0</div><div class=\"line\">for i = 0 to k</div><div class=\"line\">  C[i] = 0</div><div class=\"line\">// 遍历输入数组，并将 C 元素中对应的值个数加一</div><div class=\"line\">for j = 1 to A.length</div><div class=\"line\">  C[A[j]] = C[A[j]] + 1</div><div class=\"line\">// 此时 C 数组中存放的是下标在输入数组中的个数</div><div class=\"line\">// C[i] now contains the number of elements equal to i</div><div class=\"line\">// 遍历 C 数组，将个数转变为小于等于下标的个数</div><div class=\"line\">for i = 1 to k</div><div class=\"line\">  C[i] = C[i] + C[i - 1]</div><div class=\"line\">// C[i] now contains the number of elements less than or equal to i</div><div class=\"line\">// 将输入数组中的元素放入输出数组中对应的位置</div><div class=\"line\">for j = A.length downto 1</div><div class=\"line\">  B[C[A[j]]] = A[j]</div><div class=\"line\">  C[A[j]] = C[A[j]] - 1</div></pre></td></tr></table></figure></p>\n<h3 id=\"排序过程\"><a href=\"#排序过程\" class=\"headerlink\" title=\"排序过程\"></a>排序过程</h3><p>假设数组 <code>A</code> 元素为：<code>2, 5, 3, 0, 2, 3, 0, 3</code></p>\n<p>1) 因为输入数组最大元素为 <code>5</code>，所以初始化 <code>C</code> 数组长度为 <code>5</code>。</p>\n<p>2) 遍历 <code>A</code> 数组，将 <code>C</code> 数组中下标为遍历到的元素大小的元素加 1。</p>\n<p>3) 步骤 2 结束后 <code>C</code> 数组元素为：<code>2, 0, 2, 3, 0, 1</code>，代表 <code>A</code> 数组中 <code>0</code> 个数为 <code>2</code>，’1’ 个数为 <code>0</code>，以此类推。</p>\n<p>4) 遍历 <code>C</code> 数组，将元素大小置为当前元素大小加前一元素大小。</p>\n<p>5) 步骤 4 结束后，<code>C</code> 数组元素为：<code>2, 2, 4, 7, 7, 8</code>，代表 <code>A</code> 数组中小于等于 <code>0</code> 个数为 <code>2</code>，小于等于 ‘1’ 个数为 <code>2</code>，小于等于 ‘2’ 个数为 <code>4</code>，以此类推。</p>\n<p>6) 遍历 <code>A</code> 数组，利用 <code>C</code> 数组中的信息将元素放置到对应的位置，需要注意每放置完一个元素需要将对应的小于等于个数减一。</p>\n<p>计数排序的总时间代价是 <code>Θ(k + n)</code>，当 <code>k = O(n)</code> 时，我们一般采用计数排序，此时运行时间为 <code>Θ(n)</code>。</p>\n<p>计数排序的另一个重要性质是它是<strong>稳定的</strong>：具有相同大小的元素，在输入数组中先出现的，在输出数组中也位于前面。</p>\n<h3 id=\"javascript-实现\"><a href=\"#javascript-实现\" class=\"headerlink\" title=\"javascript 实现\"></a>javascript 实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">unction countingSort(arr, k) &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> B = [], C = [<span class=\"number\">0</span>];</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; k; i++, C[i] = <span class=\"number\">0</span>) &#123;<span class=\"comment\">/*empty*/</span>&#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</div><div class=\"line\">    C[arr[i]] = C[arr[i]] + <span class=\"number\">1</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; C.length; i++) &#123;</div><div class=\"line\">    C[i] = C[i] + C[i - <span class=\"number\">1</span>];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = arr.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</div><div class=\"line\">    <span class=\"comment\">// -1 是因为小于等于该元素的个数包括该元素</span></div><div class=\"line\">    B[C[arr[i]] - <span class=\"number\">1</span>] = arr[i];</div><div class=\"line\">    C[arr[i]] = C[arr[i]] - <span class=\"number\">1</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> B;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>];</div><div class=\"line\">countingSort(arr, <span class=\"number\">5</span>); <span class=\"comment\">// [0, 0, 2, 2, 3, 3, 3, 5]</span></div></pre></td></tr></table></figure>\n<h2 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h2><p>基数排序用于排序 <code>n</code> 个 <code>d</code> 位数，先按最低有效位进行排序，然后按次低有效位，直到对所有的 <code>d</code> 位数都进行了排序。</p>\n<p>基数排序的代码是非常直观的，假设 <code>n</code> 个 <code>d</code> 位的元素存放在数组 <code>A</code> 中，其中第 <code>1</code> 位是最低位，第 <code>d</code> 位是最高位。如果我们希望元素排序完之后顺序不会被改变，那么在排序有效位过程中需要使用一种稳定的排序算法。</p>\n<p><em>RADIX-SORT(A, d)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">for i = 1 to d</div><div class=\"line\">  use a stable sort to sort array A on digit d</div></pre></td></tr></table></figure></p>\n<p>以 8 个 3 位数举例，排序过程如下：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-8/02.jpg\" alt=\"\"></p>\n<p>对于 <code>n</code> 个 <code>d</code> 位数，其中每一个数位有 k 个可能的取值。如果 <code>RADIX-SORT</code> 使用的稳定排序方法耗时 <code>Θ(n + k)</code>，那么它就可以在 <code>Θ(d(n + k))</code> 时间内将这些数排好序。</p>\n<h2 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h2><p>桶排序假设输入数据服从均匀分布，平均情况下它的时间代价为 <code>O(n)</code>。</p>\n<p>桶排序将 <code>[0, 1)</code> 划分为 <code>n</code> 个相同大小的子区间，称为桶。然后，将 n 个输入数分别放到桶中，因为输入数据是均匀、独立地分布在 <code>[0, 1)</code> 上，所以一般不会出现很多数落在同一个桶中的情况。为了得到输出结果，我们先对每个桶中的数进行排序，然后遍历每个桶，按照次序把各个桶中的元素列出来即可。</p>\n<p>算法需要一个临时数组 <code>B[0 .. n-1]</code> 来存放链表（即桶），并假设存在一种用于维护这些链表的机制。</p>\n<h3 id=\"排序过程-1\"><a href=\"#排序过程-1\" class=\"headerlink\" title=\"排序过程\"></a>排序过程</h3><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-8/03.jpg\" alt=\"\"></p>\n","excerpt":"<p>在前面几章总共介绍了<em>插入排序、归并排序、堆排序和快速排序</em>，这些算法都有一个有趣的性质：<strong>在排序的最终结果中，各元素的次序依赖于它们之间的比较</strong>。我们把这类排序算法成为比较排序。</p>\n<p>接下来讨论三种线性时间复杂度的排序算法：计数排序、基数排序和桶排序，它们使用运算而不是比较来确定排序顺序。</p>","more":"<h2 id=\"排序顺序的下界\"><a href=\"#排序顺序的下界\" class=\"headerlink\" title=\"排序顺序的下界\"></a>排序顺序的下界</h2><p>在一个比较排序中，我们只使用元素间的比较来获得输入序列 <code>&lt;a1, a2, ..., an&gt;</code> 中的元素间次序的信息。也就是给定两个元素 <code>ai</code> 和 <code>aj</code>，我们执行比较操作来确定它们之间的相对次序。</p>\n<h3 id=\"决策树模型\"><a href=\"#决策树模型\" class=\"headerlink\" title=\"决策树模型\"></a>决策树模型</h3><p>比较排序可以被抽象为一颗决策树。</p>\n<p>决策树是一颗<strong>完全二叉树</strong>，它可以表示在给定输入规模情况下，某一特定排序算法对所有元素的比较操作。其中，控制、数据移动等其他操作都被忽略了。</p>\n<p>在决策树中，每个内部结点都以 <code>i : j</code> 标记，其中，<code>i</code> 和 <code>j</code> 满足 <code>1 &lt;= i &lt;= j &lt;= n</code>，<code>n</code> 是输入序列中的元素个数。每个叶结点上都标注一个序列 <code>&lt;π(1), π(2), ..., π(n)</code>。</p>\n<p>排序算法的执行对应于一条从树的根结点到叶结点的路径。每一个内部结点表示比较一次 <code>ai</code> 和 <code>aj</code>。</p>\n<p>每当到达一个叶结点的时候，代表排序算法已经确定了一个顺序。对于一个正确的比较排序算法来说，<code>n</code> 个元素的 <code>n!</code> 种可能的排列都应该出现在决策树的叶结点上。而且，每一个叶结点都必须是可以从根结点经由某条路径到达的，该路径对应于比较排序的一次实际执行过程（我们称这种叶结点为“可达的”）。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-8/01.png\" alt=\"\"></p>\n<p>如上图，这是一颗作用于三个元素的插入排序决策树。根节点表示第一个元素和第二个元素进行了比较，当第一个元素小于等于第二个元素时，进入根节点的左孩子，将第二个元素和第三个元素进行比较，以此类推。最后，如果第三个孩子小于第一个孩子小于第二个孩子，则排序结果是 <code>&lt;3, 1, 2&gt;</code>。</p>\n<h3 id=\"最坏情况的下界\"><a href=\"#最坏情况的下界\" class=\"headerlink\" title=\"最坏情况的下界\"></a>最坏情况的下界</h3><p>对于一颗每个排列都是一个可达叶结点的决策树来说，树的高度完全可以被确定。考虑一颗高度为 <code>h</code>，具有 <code>l</code> 个可达叶结点的决策树，它对应一个对 <code>n</code> 个元素所做的比较排序。</p>\n<p>因为输入数据的 <code>n!</code> 种可能的排列都是叶结点，所以有 <code>n! &lt;= l</code>。</p>\n<p>由于在一棵高度为 <code>h</code> 的二叉树中，叶结点的数目不多于 <code>2^h</code>，所以有 <code>l &lt;= 2^h</code>。</p>\n<p>我们即得到 <code>n! &lt;= l &lt;= 2^h</code>。</p>\n<p>两边取对数，有</p>\n<blockquote>\n<p>h &gt;= lg(n!) = Ω(nlgn)</p>\n</blockquote>\n<p>我们即得到定理：<em>在最坏情况下，任何比较排序算法都需要做 Ω(nlgn) 次比较</em></p>\n<h2 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h2><p>上面说完比较排序的最坏下界，我们现在开始讨论线性时间复杂度的排序算法。</p>\n<p><strong>计数排序假设 <code>n</code> 个输入元素中的每一个都是在 <code>0</code> 到 <code>k</code> 区间内的一个整数，其中 <code>k</code> 为某个整数</strong>。当 <code>k = O(n)</code> 时，排序的运行时间为 <code>Θ(n)</code>。</p>\n<h3 id=\"思想\"><a href=\"#思想\" class=\"headerlink\" title=\"思想\"></a>思想</h3><p>计数排序的思想是：对每一个输入元素 <code>x</code>，确定小于 <code>x</code> 的元素个数。这样，当需要排序元素 <code>x</code> 时，只需把 <code>x</code> 直接放到它在输出数组中的位置了。</p>\n<p>比如如果有 <code>17</code> 个元素小于 <code>x</code>，则 <code>x</code> 应该被放到第十八个输出位置上。当有几个元素相同时，这一方案要略作修改，因为不能把它们放到同一个位置。</p>\n<h3 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h3><p>在计数排序的算法中，假设输入是一个数组 <code>A[1 .. n]</code>，<code>A.length = n</code>。我们还需要两个数组：<code>B[1 .. n]</code> 存放输出数组， <code>C[0 .. k]</code> 存放个数信息。</p>\n<p><em>COUNTING-SORT(A, B, k)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">// C 数组长度为输入数组的最大值</div><div class=\"line\">let C[0 .. k] be a new array</div><div class=\"line\">// 将 C 数组的元素全部赋值为 0</div><div class=\"line\">for i = 0 to k</div><div class=\"line\">  C[i] = 0</div><div class=\"line\">// 遍历输入数组，并将 C 元素中对应的值个数加一</div><div class=\"line\">for j = 1 to A.length</div><div class=\"line\">  C[A[j]] = C[A[j]] + 1</div><div class=\"line\">// 此时 C 数组中存放的是下标在输入数组中的个数</div><div class=\"line\">// C[i] now contains the number of elements equal to i</div><div class=\"line\">// 遍历 C 数组，将个数转变为小于等于下标的个数</div><div class=\"line\">for i = 1 to k</div><div class=\"line\">  C[i] = C[i] + C[i - 1]</div><div class=\"line\">// C[i] now contains the number of elements less than or equal to i</div><div class=\"line\">// 将输入数组中的元素放入输出数组中对应的位置</div><div class=\"line\">for j = A.length downto 1</div><div class=\"line\">  B[C[A[j]]] = A[j]</div><div class=\"line\">  C[A[j]] = C[A[j]] - 1</div></pre></td></tr></table></figure></p>\n<h3 id=\"排序过程\"><a href=\"#排序过程\" class=\"headerlink\" title=\"排序过程\"></a>排序过程</h3><p>假设数组 <code>A</code> 元素为：<code>2, 5, 3, 0, 2, 3, 0, 3</code></p>\n<p>1) 因为输入数组最大元素为 <code>5</code>，所以初始化 <code>C</code> 数组长度为 <code>5</code>。</p>\n<p>2) 遍历 <code>A</code> 数组，将 <code>C</code> 数组中下标为遍历到的元素大小的元素加 1。</p>\n<p>3) 步骤 2 结束后 <code>C</code> 数组元素为：<code>2, 0, 2, 3, 0, 1</code>，代表 <code>A</code> 数组中 <code>0</code> 个数为 <code>2</code>，’1’ 个数为 <code>0</code>，以此类推。</p>\n<p>4) 遍历 <code>C</code> 数组，将元素大小置为当前元素大小加前一元素大小。</p>\n<p>5) 步骤 4 结束后，<code>C</code> 数组元素为：<code>2, 2, 4, 7, 7, 8</code>，代表 <code>A</code> 数组中小于等于 <code>0</code> 个数为 <code>2</code>，小于等于 ‘1’ 个数为 <code>2</code>，小于等于 ‘2’ 个数为 <code>4</code>，以此类推。</p>\n<p>6) 遍历 <code>A</code> 数组，利用 <code>C</code> 数组中的信息将元素放置到对应的位置，需要注意每放置完一个元素需要将对应的小于等于个数减一。</p>\n<p>计数排序的总时间代价是 <code>Θ(k + n)</code>，当 <code>k = O(n)</code> 时，我们一般采用计数排序，此时运行时间为 <code>Θ(n)</code>。</p>\n<p>计数排序的另一个重要性质是它是<strong>稳定的</strong>：具有相同大小的元素，在输入数组中先出现的，在输出数组中也位于前面。</p>\n<h3 id=\"javascript-实现\"><a href=\"#javascript-实现\" class=\"headerlink\" title=\"javascript 实现\"></a>javascript 实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">unction countingSort(arr, k) &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> B = [], C = [<span class=\"number\">0</span>];</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; k; i++, C[i] = <span class=\"number\">0</span>) &#123;<span class=\"comment\">/*empty*/</span>&#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</div><div class=\"line\">    C[arr[i]] = C[arr[i]] + <span class=\"number\">1</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; C.length; i++) &#123;</div><div class=\"line\">    C[i] = C[i] + C[i - <span class=\"number\">1</span>];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = arr.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</div><div class=\"line\">    <span class=\"comment\">// -1 是因为小于等于该元素的个数包括该元素</span></div><div class=\"line\">    B[C[arr[i]] - <span class=\"number\">1</span>] = arr[i];</div><div class=\"line\">    C[arr[i]] = C[arr[i]] - <span class=\"number\">1</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> B;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>];</div><div class=\"line\">countingSort(arr, <span class=\"number\">5</span>); <span class=\"comment\">// [0, 0, 2, 2, 3, 3, 3, 5]</span></div></pre></td></tr></table></figure>\n<h2 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h2><p>基数排序用于排序 <code>n</code> 个 <code>d</code> 位数，先按最低有效位进行排序，然后按次低有效位，直到对所有的 <code>d</code> 位数都进行了排序。</p>\n<p>基数排序的代码是非常直观的，假设 <code>n</code> 个 <code>d</code> 位的元素存放在数组 <code>A</code> 中，其中第 <code>1</code> 位是最低位，第 <code>d</code> 位是最高位。如果我们希望元素排序完之后顺序不会被改变，那么在排序有效位过程中需要使用一种稳定的排序算法。</p>\n<p><em>RADIX-SORT(A, d)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">for i = 1 to d</div><div class=\"line\">  use a stable sort to sort array A on digit d</div></pre></td></tr></table></figure></p>\n<p>以 8 个 3 位数举例，排序过程如下：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-8/02.jpg\" alt=\"\"></p>\n<p>对于 <code>n</code> 个 <code>d</code> 位数，其中每一个数位有 k 个可能的取值。如果 <code>RADIX-SORT</code> 使用的稳定排序方法耗时 <code>Θ(n + k)</code>，那么它就可以在 <code>Θ(d(n + k))</code> 时间内将这些数排好序。</p>\n<h2 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h2><p>桶排序假设输入数据服从均匀分布，平均情况下它的时间代价为 <code>O(n)</code>。</p>\n<p>桶排序将 <code>[0, 1)</code> 划分为 <code>n</code> 个相同大小的子区间，称为桶。然后，将 n 个输入数分别放到桶中，因为输入数据是均匀、独立地分布在 <code>[0, 1)</code> 上，所以一般不会出现很多数落在同一个桶中的情况。为了得到输出结果，我们先对每个桶中的数进行排序，然后遍历每个桶，按照次序把各个桶中的元素列出来即可。</p>\n<p>算法需要一个临时数组 <code>B[0 .. n-1]</code> 来存放链表（即桶），并假设存在一种用于维护这些链表的机制。</p>\n<h3 id=\"排序过程-1\"><a href=\"#排序过程-1\" class=\"headerlink\" title=\"排序过程\"></a>排序过程</h3><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-8/03.jpg\" alt=\"\"></p>"},{"title":"二叉搜索树","date":"2016-08-07T03:36:57.000Z","_content":"\n二叉搜索树(BST)是二叉树的一种，但是它只允许在左侧结点存储比父结点小的值，在右侧结点存储比父结点大或等于的值。\n\n<!-- more -->\n\n## 二叉树的基本结构\n\n术语：\n\n- 深度：结点的深度取决于它的祖先结点的数量。\n- 高度：树的高度取决于所有结点深度的最大值。\n- 层：根结点在第 0 层，它的子结点在第 1 层，以此类推。\n\n```javascript\n// 结点类\nclass TreeNode {\n  constructor(key) {\n    this.key = key;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// 二叉树\nclass Tree {\n  constructor() {\n    this.root = null;\n  }\n}\n```\n\n## 构建 BST\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/insert.gif)\n\n上图直观地展示了一颗二叉搜索树构建的过程，每次插入结点时，从根结点开始比较结点间大小，然后将结点插入到正确的位置。\n\n```javascript\nclass BinarySearchTree {\n  constructor() {\n    this.root = null;\n  }\n\n  insert(key) {\n    let curNode = this.root;\n\n    if(curNode === null) {\n      this.root = new TreeNode(key);\n      return;\n    } else {\n      while(curNode !== null) {\n        if(key > curNode.key) {\n          if(curNode.right === null) {\n            curNode.right = new TreeNode(key);\n            return;\n          }\n          curNode = curNode.right;\n        } else if(key < curNode.key) {\n          if(curNode.left === null) {\n            curNode.left = new TreeNode(key);\n            return;\n          }\n          curNode = curNode.left;\n        }\n      }\n    }\n  }\n}\n```\n\n## 查找\n\n### 树的遍历\n\n访问树的结点有三种方法：中序、前序和后序。\n\n- 中序遍历是指先访问结点的左孩子，然后访问结点自己，最后访问结点的右孩子。对每个孩子而言，规则也是一样的。\n- 前序遍历是指先访问结点自己，然后访问结点的左孩子，最后访问结点的右孩子。\n- 后序遍历是指先访问结点的左孩子，然后访问结点的右孩子，最后访问结点自己。\n\n#### 中序遍历\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/inorder.png)\n\n```javascript\ninOrderTraverse(callback) {\n\n  traverse(this.root);\n\n  function traverse(node) {\n    if(node == null) {\n      return;\n    }\n    traverse(node.left);\n    callback(node);\n    traverse(node.right);\n  }\n}\n```\n\n#### 前序遍历\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/preorder.png)\n\n```javascript\npreOrderTraverse(callback) {\n\n  traverse(this.root);\n\n  function traverse(node) {\n    if(node == null) {\n      return;\n    }\n    callback(node);\n    traverse(node.left);\n    traverse(node.right);\n  }\n}\n```\n\n#### 后序遍历\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/postorder.png)\n\n```javascript\npostOrderTraverse(callback) {\n\n  traverse(this.root);\n\n  function traverse(node) {\n    if(node == null) {\n      return;\n    }\n    traverse(node.left);\n    traverse(node.right);\n    callback(node);\n  }\n}\n```\n\n### BST 的最小值和最大值\n\n因为二叉搜索树会把比结点小的存在结点左边，把比结点大的存在结点右边，所以对二叉搜索树而言，树中的最小值在树的最左结点，树的最大值在树的最右结点。\n\n#### 获取最小结点\n\n```javascript\nmin(node) {\n  let curNode = node || this.root;\n  if(curNode !== null) {\n    while(curNode && curNode.left !== null) {\n      curNode = curNode.left;\n    }\n    return curNode;\n  }\n  \n  return null;\n}\n```\n\n#### 获取最大结点\n\n```javascript\nmax(node) {\n  let curNode = node || this.root;\n  if(curNode !== null) {\n    while(curNode && curNode.right !== null) {\n      curNode = curNode.right;\n    }\n    return curNode;\n  }\n  \n  return null;\n}\n```\n\n### 搜素 BST 中的值\n\n在二叉搜索树中进行搜索，和插入时一样进行比较即可。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/search.gif)\n\n```javascript\nsearch(key) {\n  let curNode = this.root;\n  while(curNode !== null) {\n    if(key < curNode.key) {\n      curNode = curNode.left;\n    } else if (key > curNode.key) {\n      curNode = curNode.right;\n    } else {\n      return curNode;\n    }\n  }\n  return null;\n}\n```\n\n## 移除结点\n\n移除结点包含了几种不同的运行场景，根据不同的情况，我们需要在移除后进行一些操作。\n\n### 移除叶结点\n\n移除叶结点不会对树产生影响，所以直接移除即可：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/remove_0.png)\n\n### 移除只有一个孩子的结点\n\n因为该结点只有一个孩子，所以将该结点移除后，需要用孩子来填补该结点的位置：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/remove_1.png)\n\n### 移除有两个孩子的结点\n\n这种情况相对以上两种要复杂一点，移除这个结点，需要执行三个步骤：\n\n1. 找到该结点右子树的最小结点。\n2. 用该结点右子树的最小结点的键更新该结点的键。\n3. 移除该结点右子树的最小结点。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/remove_2.png)\n\n### 实现\n```javascript\nremove(key) {\n\n  let removeNode = (node, key) => {\n    if(node == null) {\n      return null;\n    }\n\n    if(key < node.key) {\n      node.left = removeNode(node.left, key);\n      return node;\n    } else if(key > node.key) {\n      node.right = removeNode(node.right, key);\n      return node;\n    } else {\n      if(node.left == null && node.right == null) {\n        node = null;\n        return null;\n      }\n\n      if(node.left == null) {\n        node = node.right;\n        return node;\n      }\n\n      if(node.right == null) {\n        node = node.left;\n        return node;\n      }\n\n      // 找到右子树的最小结点\n      let n = this.min(node.right);\n      // 将该结点的值替换掉\n      node.key = n.key;\n      // 移除右子树的最小结点\n      node.right = removeNode(node.right, n.key);\n\n      return node;\n    }\n  }\n\n  removeNode(this.root, key);\n}\n```","source":"_posts/binary-search-tree.md","raw":"---\ntitle: 二叉搜索树\ndate: 2016-08-07 11:36:57\ntags: [每周总结, 数据结构]\n---\n\n二叉搜索树(BST)是二叉树的一种，但是它只允许在左侧结点存储比父结点小的值，在右侧结点存储比父结点大或等于的值。\n\n<!-- more -->\n\n## 二叉树的基本结构\n\n术语：\n\n- 深度：结点的深度取决于它的祖先结点的数量。\n- 高度：树的高度取决于所有结点深度的最大值。\n- 层：根结点在第 0 层，它的子结点在第 1 层，以此类推。\n\n```javascript\n// 结点类\nclass TreeNode {\n  constructor(key) {\n    this.key = key;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// 二叉树\nclass Tree {\n  constructor() {\n    this.root = null;\n  }\n}\n```\n\n## 构建 BST\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/insert.gif)\n\n上图直观地展示了一颗二叉搜索树构建的过程，每次插入结点时，从根结点开始比较结点间大小，然后将结点插入到正确的位置。\n\n```javascript\nclass BinarySearchTree {\n  constructor() {\n    this.root = null;\n  }\n\n  insert(key) {\n    let curNode = this.root;\n\n    if(curNode === null) {\n      this.root = new TreeNode(key);\n      return;\n    } else {\n      while(curNode !== null) {\n        if(key > curNode.key) {\n          if(curNode.right === null) {\n            curNode.right = new TreeNode(key);\n            return;\n          }\n          curNode = curNode.right;\n        } else if(key < curNode.key) {\n          if(curNode.left === null) {\n            curNode.left = new TreeNode(key);\n            return;\n          }\n          curNode = curNode.left;\n        }\n      }\n    }\n  }\n}\n```\n\n## 查找\n\n### 树的遍历\n\n访问树的结点有三种方法：中序、前序和后序。\n\n- 中序遍历是指先访问结点的左孩子，然后访问结点自己，最后访问结点的右孩子。对每个孩子而言，规则也是一样的。\n- 前序遍历是指先访问结点自己，然后访问结点的左孩子，最后访问结点的右孩子。\n- 后序遍历是指先访问结点的左孩子，然后访问结点的右孩子，最后访问结点自己。\n\n#### 中序遍历\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/inorder.png)\n\n```javascript\ninOrderTraverse(callback) {\n\n  traverse(this.root);\n\n  function traverse(node) {\n    if(node == null) {\n      return;\n    }\n    traverse(node.left);\n    callback(node);\n    traverse(node.right);\n  }\n}\n```\n\n#### 前序遍历\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/preorder.png)\n\n```javascript\npreOrderTraverse(callback) {\n\n  traverse(this.root);\n\n  function traverse(node) {\n    if(node == null) {\n      return;\n    }\n    callback(node);\n    traverse(node.left);\n    traverse(node.right);\n  }\n}\n```\n\n#### 后序遍历\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/postorder.png)\n\n```javascript\npostOrderTraverse(callback) {\n\n  traverse(this.root);\n\n  function traverse(node) {\n    if(node == null) {\n      return;\n    }\n    traverse(node.left);\n    traverse(node.right);\n    callback(node);\n  }\n}\n```\n\n### BST 的最小值和最大值\n\n因为二叉搜索树会把比结点小的存在结点左边，把比结点大的存在结点右边，所以对二叉搜索树而言，树中的最小值在树的最左结点，树的最大值在树的最右结点。\n\n#### 获取最小结点\n\n```javascript\nmin(node) {\n  let curNode = node || this.root;\n  if(curNode !== null) {\n    while(curNode && curNode.left !== null) {\n      curNode = curNode.left;\n    }\n    return curNode;\n  }\n  \n  return null;\n}\n```\n\n#### 获取最大结点\n\n```javascript\nmax(node) {\n  let curNode = node || this.root;\n  if(curNode !== null) {\n    while(curNode && curNode.right !== null) {\n      curNode = curNode.right;\n    }\n    return curNode;\n  }\n  \n  return null;\n}\n```\n\n### 搜素 BST 中的值\n\n在二叉搜索树中进行搜索，和插入时一样进行比较即可。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/search.gif)\n\n```javascript\nsearch(key) {\n  let curNode = this.root;\n  while(curNode !== null) {\n    if(key < curNode.key) {\n      curNode = curNode.left;\n    } else if (key > curNode.key) {\n      curNode = curNode.right;\n    } else {\n      return curNode;\n    }\n  }\n  return null;\n}\n```\n\n## 移除结点\n\n移除结点包含了几种不同的运行场景，根据不同的情况，我们需要在移除后进行一些操作。\n\n### 移除叶结点\n\n移除叶结点不会对树产生影响，所以直接移除即可：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/remove_0.png)\n\n### 移除只有一个孩子的结点\n\n因为该结点只有一个孩子，所以将该结点移除后，需要用孩子来填补该结点的位置：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/remove_1.png)\n\n### 移除有两个孩子的结点\n\n这种情况相对以上两种要复杂一点，移除这个结点，需要执行三个步骤：\n\n1. 找到该结点右子树的最小结点。\n2. 用该结点右子树的最小结点的键更新该结点的键。\n3. 移除该结点右子树的最小结点。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/remove_2.png)\n\n### 实现\n```javascript\nremove(key) {\n\n  let removeNode = (node, key) => {\n    if(node == null) {\n      return null;\n    }\n\n    if(key < node.key) {\n      node.left = removeNode(node.left, key);\n      return node;\n    } else if(key > node.key) {\n      node.right = removeNode(node.right, key);\n      return node;\n    } else {\n      if(node.left == null && node.right == null) {\n        node = null;\n        return null;\n      }\n\n      if(node.left == null) {\n        node = node.right;\n        return node;\n      }\n\n      if(node.right == null) {\n        node = node.left;\n        return node;\n      }\n\n      // 找到右子树的最小结点\n      let n = this.min(node.right);\n      // 将该结点的值替换掉\n      node.key = n.key;\n      // 移除右子树的最小结点\n      node.right = removeNode(node.right, n.key);\n\n      return node;\n    }\n  }\n\n  removeNode(this.root, key);\n}\n```","slug":"binary-search-tree","published":1,"updated":"2016-08-27T00:03:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscgyh140007gq27zdeuvwdg","content":"<p>二叉搜索树(BST)是二叉树的一种，但是它只允许在左侧结点存储比父结点小的值，在右侧结点存储比父结点大或等于的值。</p>\n<a id=\"more\"></a>\n<h2 id=\"二叉树的基本结构\"><a href=\"#二叉树的基本结构\" class=\"headerlink\" title=\"二叉树的基本结构\"></a>二叉树的基本结构</h2><p>术语：</p>\n<ul>\n<li>深度：结点的深度取决于它的祖先结点的数量。</li>\n<li>高度：树的高度取决于所有结点深度的最大值。</li>\n<li>层：根结点在第 0 层，它的子结点在第 1 层，以此类推。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 结点类</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.key = key;</div><div class=\"line\">    <span class=\"keyword\">this</span>.left = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.right = <span class=\"literal\">null</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 二叉树</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tree</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.root = <span class=\"literal\">null</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"构建-BST\"><a href=\"#构建-BST\" class=\"headerlink\" title=\"构建 BST\"></a>构建 BST</h2><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/insert.gif\" alt=\"\"></p>\n<p>上图直观地展示了一颗二叉搜索树构建的过程，每次插入结点时，从根结点开始比较结点间大小，然后将结点插入到正确的位置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinarySearchTree</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.root = <span class=\"literal\">null</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  insert(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.root;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(curNode === <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.root = <span class=\"keyword\">new</span> TreeNode(key);</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">while</span>(curNode !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(key &gt; curNode.key) &#123;</div><div class=\"line\">          <span class=\"keyword\">if</span>(curNode.right === <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">            curNode.right = <span class=\"keyword\">new</span> TreeNode(key);</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">          &#125;</div><div class=\"line\">          curNode = curNode.right;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(key &lt; curNode.key) &#123;</div><div class=\"line\">          <span class=\"keyword\">if</span>(curNode.left === <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">            curNode.left = <span class=\"keyword\">new</span> TreeNode(key);</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">          &#125;</div><div class=\"line\">          curNode = curNode.left;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h2><h3 id=\"树的遍历\"><a href=\"#树的遍历\" class=\"headerlink\" title=\"树的遍历\"></a>树的遍历</h3><p>访问树的结点有三种方法：中序、前序和后序。</p>\n<ul>\n<li>中序遍历是指先访问结点的左孩子，然后访问结点自己，最后访问结点的右孩子。对每个孩子而言，规则也是一样的。</li>\n<li>前序遍历是指先访问结点自己，然后访问结点的左孩子，最后访问结点的右孩子。</li>\n<li>后序遍历是指先访问结点的左孩子，然后访问结点的右孩子，最后访问结点自己。</li>\n</ul>\n<h4 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h4><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/inorder.png\" alt=\"\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">inOrderTraverse(callback) &#123;</div><div class=\"line\"></div><div class=\"line\">  traverse(<span class=\"keyword\">this</span>.root);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">traverse</span>(<span class=\"params\">node</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(node == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    traverse(node.left);</div><div class=\"line\">    callback(node);</div><div class=\"line\">    traverse(node.right);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h4><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/preorder.png\" alt=\"\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">preOrderTraverse(callback) &#123;</div><div class=\"line\"></div><div class=\"line\">  traverse(<span class=\"keyword\">this</span>.root);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">traverse</span>(<span class=\"params\">node</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(node == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    callback(node);</div><div class=\"line\">    traverse(node.left);</div><div class=\"line\">    traverse(node.right);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h4><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/postorder.png\" alt=\"\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">postOrderTraverse(callback) &#123;</div><div class=\"line\"></div><div class=\"line\">  traverse(<span class=\"keyword\">this</span>.root);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">traverse</span>(<span class=\"params\">node</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(node == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    traverse(node.left);</div><div class=\"line\">    traverse(node.right);</div><div class=\"line\">    callback(node);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"BST-的最小值和最大值\"><a href=\"#BST-的最小值和最大值\" class=\"headerlink\" title=\"BST 的最小值和最大值\"></a>BST 的最小值和最大值</h3><p>因为二叉搜索树会把比结点小的存在结点左边，把比结点大的存在结点右边，所以对二叉搜索树而言，树中的最小值在树的最左结点，树的最大值在树的最右结点。</p>\n<h4 id=\"获取最小结点\"><a href=\"#获取最小结点\" class=\"headerlink\" title=\"获取最小结点\"></a>获取最小结点</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">min(node) &#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> curNode = node || <span class=\"keyword\">this</span>.root;</div><div class=\"line\">  <span class=\"keyword\">if</span>(curNode !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">while</span>(curNode &amp;&amp; curNode.left !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      curNode = curNode.left;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> curNode;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"获取最大结点\"><a href=\"#获取最大结点\" class=\"headerlink\" title=\"获取最大结点\"></a>获取最大结点</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">max(node) &#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> curNode = node || <span class=\"keyword\">this</span>.root;</div><div class=\"line\">  <span class=\"keyword\">if</span>(curNode !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">while</span>(curNode &amp;&amp; curNode.right !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      curNode = curNode.right;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> curNode;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"搜素-BST-中的值\"><a href=\"#搜素-BST-中的值\" class=\"headerlink\" title=\"搜素 BST 中的值\"></a>搜素 BST 中的值</h3><p>在二叉搜索树中进行搜索，和插入时一样进行比较即可。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/search.gif\" alt=\"\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">search(key) &#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.root;</div><div class=\"line\">  <span class=\"keyword\">while</span>(curNode !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(key &lt; curNode.key) &#123;</div><div class=\"line\">      curNode = curNode.left;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &gt; curNode.key) &#123;</div><div class=\"line\">      curNode = curNode.right;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> curNode;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"移除结点\"><a href=\"#移除结点\" class=\"headerlink\" title=\"移除结点\"></a>移除结点</h2><p>移除结点包含了几种不同的运行场景，根据不同的情况，我们需要在移除后进行一些操作。</p>\n<h3 id=\"移除叶结点\"><a href=\"#移除叶结点\" class=\"headerlink\" title=\"移除叶结点\"></a>移除叶结点</h3><p>移除叶结点不会对树产生影响，所以直接移除即可：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/remove_0.png\" alt=\"\"></p>\n<h3 id=\"移除只有一个孩子的结点\"><a href=\"#移除只有一个孩子的结点\" class=\"headerlink\" title=\"移除只有一个孩子的结点\"></a>移除只有一个孩子的结点</h3><p>因为该结点只有一个孩子，所以将该结点移除后，需要用孩子来填补该结点的位置：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/remove_1.png\" alt=\"\"></p>\n<h3 id=\"移除有两个孩子的结点\"><a href=\"#移除有两个孩子的结点\" class=\"headerlink\" title=\"移除有两个孩子的结点\"></a>移除有两个孩子的结点</h3><p>这种情况相对以上两种要复杂一点，移除这个结点，需要执行三个步骤：</p>\n<ol>\n<li>找到该结点右子树的最小结点。</li>\n<li>用该结点右子树的最小结点的键更新该结点的键。</li>\n<li>移除该结点右子树的最小结点。</li>\n</ol>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/remove_2.png\" alt=\"\"></p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">remove(key) &#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">let</span> removeNode = (node, key) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(node == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(key &lt; node.key) &#123;</div><div class=\"line\">      node.left = removeNode(node.left, key);</div><div class=\"line\">      <span class=\"keyword\">return</span> node;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(key &gt; node.key) &#123;</div><div class=\"line\">      node.right = removeNode(node.right, key);</div><div class=\"line\">      <span class=\"keyword\">return</span> node;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(node.left == <span class=\"literal\">null</span> &amp;&amp; node.right == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        node = <span class=\"literal\">null</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span>(node.left == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        node = node.right;</div><div class=\"line\">        <span class=\"keyword\">return</span> node;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span>(node.right == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        node = node.left;</div><div class=\"line\">        <span class=\"keyword\">return</span> node;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// 找到右子树的最小结点</span></div><div class=\"line\">      <span class=\"keyword\">let</span> n = <span class=\"keyword\">this</span>.min(node.right);</div><div class=\"line\">      <span class=\"comment\">// 将该结点的值替换掉</span></div><div class=\"line\">      node.key = n.key;</div><div class=\"line\">      <span class=\"comment\">// 移除右子树的最小结点</span></div><div class=\"line\">      node.right = removeNode(node.right, n.key);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">return</span> node;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  removeNode(<span class=\"keyword\">this</span>.root, key);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","excerpt":"<p>二叉搜索树(BST)是二叉树的一种，但是它只允许在左侧结点存储比父结点小的值，在右侧结点存储比父结点大或等于的值。</p>","more":"<h2 id=\"二叉树的基本结构\"><a href=\"#二叉树的基本结构\" class=\"headerlink\" title=\"二叉树的基本结构\"></a>二叉树的基本结构</h2><p>术语：</p>\n<ul>\n<li>深度：结点的深度取决于它的祖先结点的数量。</li>\n<li>高度：树的高度取决于所有结点深度的最大值。</li>\n<li>层：根结点在第 0 层，它的子结点在第 1 层，以此类推。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 结点类</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.key = key;</div><div class=\"line\">    <span class=\"keyword\">this</span>.left = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.right = <span class=\"literal\">null</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 二叉树</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tree</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.root = <span class=\"literal\">null</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"构建-BST\"><a href=\"#构建-BST\" class=\"headerlink\" title=\"构建 BST\"></a>构建 BST</h2><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/insert.gif\" alt=\"\"></p>\n<p>上图直观地展示了一颗二叉搜索树构建的过程，每次插入结点时，从根结点开始比较结点间大小，然后将结点插入到正确的位置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinarySearchTree</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.root = <span class=\"literal\">null</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  insert(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.root;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(curNode === <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.root = <span class=\"keyword\">new</span> TreeNode(key);</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">while</span>(curNode !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(key &gt; curNode.key) &#123;</div><div class=\"line\">          <span class=\"keyword\">if</span>(curNode.right === <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">            curNode.right = <span class=\"keyword\">new</span> TreeNode(key);</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">          &#125;</div><div class=\"line\">          curNode = curNode.right;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(key &lt; curNode.key) &#123;</div><div class=\"line\">          <span class=\"keyword\">if</span>(curNode.left === <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">            curNode.left = <span class=\"keyword\">new</span> TreeNode(key);</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">          &#125;</div><div class=\"line\">          curNode = curNode.left;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h2><h3 id=\"树的遍历\"><a href=\"#树的遍历\" class=\"headerlink\" title=\"树的遍历\"></a>树的遍历</h3><p>访问树的结点有三种方法：中序、前序和后序。</p>\n<ul>\n<li>中序遍历是指先访问结点的左孩子，然后访问结点自己，最后访问结点的右孩子。对每个孩子而言，规则也是一样的。</li>\n<li>前序遍历是指先访问结点自己，然后访问结点的左孩子，最后访问结点的右孩子。</li>\n<li>后序遍历是指先访问结点的左孩子，然后访问结点的右孩子，最后访问结点自己。</li>\n</ul>\n<h4 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h4><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/inorder.png\" alt=\"\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">inOrderTraverse(callback) &#123;</div><div class=\"line\"></div><div class=\"line\">  traverse(<span class=\"keyword\">this</span>.root);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">traverse</span>(<span class=\"params\">node</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(node == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    traverse(node.left);</div><div class=\"line\">    callback(node);</div><div class=\"line\">    traverse(node.right);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h4><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/preorder.png\" alt=\"\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">preOrderTraverse(callback) &#123;</div><div class=\"line\"></div><div class=\"line\">  traverse(<span class=\"keyword\">this</span>.root);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">traverse</span>(<span class=\"params\">node</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(node == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    callback(node);</div><div class=\"line\">    traverse(node.left);</div><div class=\"line\">    traverse(node.right);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h4><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/postorder.png\" alt=\"\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">postOrderTraverse(callback) &#123;</div><div class=\"line\"></div><div class=\"line\">  traverse(<span class=\"keyword\">this</span>.root);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">traverse</span>(<span class=\"params\">node</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(node == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    traverse(node.left);</div><div class=\"line\">    traverse(node.right);</div><div class=\"line\">    callback(node);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"BST-的最小值和最大值\"><a href=\"#BST-的最小值和最大值\" class=\"headerlink\" title=\"BST 的最小值和最大值\"></a>BST 的最小值和最大值</h3><p>因为二叉搜索树会把比结点小的存在结点左边，把比结点大的存在结点右边，所以对二叉搜索树而言，树中的最小值在树的最左结点，树的最大值在树的最右结点。</p>\n<h4 id=\"获取最小结点\"><a href=\"#获取最小结点\" class=\"headerlink\" title=\"获取最小结点\"></a>获取最小结点</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">min(node) &#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> curNode = node || <span class=\"keyword\">this</span>.root;</div><div class=\"line\">  <span class=\"keyword\">if</span>(curNode !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">while</span>(curNode &amp;&amp; curNode.left !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      curNode = curNode.left;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> curNode;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"获取最大结点\"><a href=\"#获取最大结点\" class=\"headerlink\" title=\"获取最大结点\"></a>获取最大结点</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">max(node) &#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> curNode = node || <span class=\"keyword\">this</span>.root;</div><div class=\"line\">  <span class=\"keyword\">if</span>(curNode !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">while</span>(curNode &amp;&amp; curNode.right !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      curNode = curNode.right;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> curNode;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"搜素-BST-中的值\"><a href=\"#搜素-BST-中的值\" class=\"headerlink\" title=\"搜素 BST 中的值\"></a>搜素 BST 中的值</h3><p>在二叉搜索树中进行搜索，和插入时一样进行比较即可。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/search.gif\" alt=\"\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">search(key) &#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.root;</div><div class=\"line\">  <span class=\"keyword\">while</span>(curNode !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(key &lt; curNode.key) &#123;</div><div class=\"line\">      curNode = curNode.left;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &gt; curNode.key) &#123;</div><div class=\"line\">      curNode = curNode.right;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> curNode;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"移除结点\"><a href=\"#移除结点\" class=\"headerlink\" title=\"移除结点\"></a>移除结点</h2><p>移除结点包含了几种不同的运行场景，根据不同的情况，我们需要在移除后进行一些操作。</p>\n<h3 id=\"移除叶结点\"><a href=\"#移除叶结点\" class=\"headerlink\" title=\"移除叶结点\"></a>移除叶结点</h3><p>移除叶结点不会对树产生影响，所以直接移除即可：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/remove_0.png\" alt=\"\"></p>\n<h3 id=\"移除只有一个孩子的结点\"><a href=\"#移除只有一个孩子的结点\" class=\"headerlink\" title=\"移除只有一个孩子的结点\"></a>移除只有一个孩子的结点</h3><p>因为该结点只有一个孩子，所以将该结点移除后，需要用孩子来填补该结点的位置：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/remove_1.png\" alt=\"\"></p>\n<h3 id=\"移除有两个孩子的结点\"><a href=\"#移除有两个孩子的结点\" class=\"headerlink\" title=\"移除有两个孩子的结点\"></a>移除有两个孩子的结点</h3><p>这种情况相对以上两种要复杂一点，移除这个结点，需要执行三个步骤：</p>\n<ol>\n<li>找到该结点右子树的最小结点。</li>\n<li>用该结点右子树的最小结点的键更新该结点的键。</li>\n<li>移除该结点右子树的最小结点。</li>\n</ol>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/binary-search-tree/remove_2.png\" alt=\"\"></p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">remove(key) &#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">let</span> removeNode = (node, key) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(node == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(key &lt; node.key) &#123;</div><div class=\"line\">      node.left = removeNode(node.left, key);</div><div class=\"line\">      <span class=\"keyword\">return</span> node;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(key &gt; node.key) &#123;</div><div class=\"line\">      node.right = removeNode(node.right, key);</div><div class=\"line\">      <span class=\"keyword\">return</span> node;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(node.left == <span class=\"literal\">null</span> &amp;&amp; node.right == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        node = <span class=\"literal\">null</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span>(node.left == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        node = node.right;</div><div class=\"line\">        <span class=\"keyword\">return</span> node;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span>(node.right == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        node = node.left;</div><div class=\"line\">        <span class=\"keyword\">return</span> node;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// 找到右子树的最小结点</span></div><div class=\"line\">      <span class=\"keyword\">let</span> n = <span class=\"keyword\">this</span>.min(node.right);</div><div class=\"line\">      <span class=\"comment\">// 将该结点的值替换掉</span></div><div class=\"line\">      node.key = n.key;</div><div class=\"line\">      <span class=\"comment\">// 移除右子树的最小结点</span></div><div class=\"line\">      node.right = removeNode(node.right, n.key);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">return</span> node;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  removeNode(<span class=\"keyword\">this</span>.root, key);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"24点","date":"2016-07-19T09:15:34.000Z","_content":"\n从北戴河回来的时候，和水哥在火车上玩 24 点，玩着玩着就聊到了求 24 点的实现（可怕的程序猿\n\n先考虑简单实现，即只有加减乘除四则运算。很直接的思路就是列出所有可能的表达式，依次求和，最后找出结果等于 24 的情况。\n\n这里涉及到两个关键点，一个是通过数字求出所有表达式，另一个是根据式子计算结果。\n\n求所有表达式可以理解为求四个数字的排列，然后插入运算符即可；根据式子计算结果我们可以利用前缀表达式做到。\n\n<!-- more -->\n\n## 前缀表达式\n\n我们平常使用的式子比如 `3*(5+9)-4`，称为中缀表达式，运算符夹在数字的中间，是人类易于理解的表达式。而计算机很难识别这种表达式，一是括号改变了式子的运行顺序，另外各种运算符之间存在优先级大小关系。\n\n相比而言，前缀表达式是计算机容易计算的，像上面这个例子，如果用前缀表达式来描述则是 `-*3+594`。可以看到前缀表达式中去掉了括号，运算符跑到了计算数字的左边。\n\n### 中缀表达式转换为前缀表达式\n\n中缀表达式转换为前缀表达式需要经过以下步骤：\n1. 从右至左扫描中缀表达式，从右边第一个字符开始判断\n  - 如果当前字符是数字，则将数字直接输出。\n  - 如果是运算符，栈顶也是运算符，则比较优先级：如果当前运算符的优先级大于等于栈顶运算符的优先级，运算符入栈，如果当前运算符的优先级小于栈顶运算符的优先级，将栈顶运算符弹出并输出，直到当前运算符的优先级大于等于栈顶运算符的优先级。\n  - 如果是运算符，栈顶为括号或栈为空，入栈。\n  - 如果是右括号，则入栈。\n  - 如果是左括号，将所有的运算符全部出栈并输出，直到栈顶为右括号，最后将左右的两括号一起删除。\n2. 重复上述操作直至扫描结束，将栈内剩余运算符全部出栈并输出，最后逆序输出字符串。\n\n以 `3*(5+9)-4` 为例，过程如下：\n1. 字符为 4\n  > 如果当前字符是数字，则将数字直接输出。\n\n  - 输出序列：4\n  - 栈：[]\n\n2. 字符为 -\n  > 如果是运算符，栈顶为括号或栈为空，入栈。\n\n  - 输出序列：4\n  - 栈：[-]\n\n3. 字符为 )\n  > 如果是右括号，则入栈。\n\n  - 输出序列：4\n  - 栈：[-, )]\n\n4. 字符为 9\n\n  - 输出序列：49\n  - 栈：[-, )]\n\n5. 字符为 +\n  > 如果是运算符，栈顶为括号或栈为空，入栈。\n\n  - 输出序列：49\n  - 栈：[-, ), +]\n\n6. 字符为 5\n\n  - 输出序列：495\n  - 栈：[-, ), +]\n\n7. 字符为 (\n  > 如果是左括号，将所有的运算符全部出栈并输出，直到栈顶为右括号，最后将左右的两括号一起删除。\n\n  输出序列：495+\n  栈：[-]\n\n8. 字符为 *\n  > 如果当前运算符的优先级大于等于栈顶运算符的优先级，运算符入栈\n\n  - 输出序列：495+\n  - 栈：[-, \\*]\n\n9. 字符为 3\n  - 输出序列：495+3\n  - 栈：[-, \\*]\n\n10. 结束\n  > 将栈内剩余运算符全部出栈并输出，最后逆序输出字符串。\n\n  - 输出序列：`495+3*-`\n  - 逆序：`-*3+594`\n\n所以最后结果为 `-*3+594`。\n\njavascript实现如下：\n\n```javascript\n/**\n * 中缀表达式转前缀表达式\n * @param  {string} inExpress 中缀表达式\n * @return {string}           前缀表达式\n */\nfunction translate(inExpress) {\n  if(inExpress == '') {\n    throw new Error('表达式为空');\n  }\n  // 输出前缀表达式\n  let output = [];\n  // 反转\n  let chars = inExpress.match(/(\\d+)|[^\\d]/g).reverse();\n  // 存放运算符的栈\n  let stack = [];\n  for(let ele of chars) {\n    if(/\\d+/.test(ele)) {\n      // 如果是数字，直接输出\n      output.push(ele);\n    } else if(/[\\+\\-]/.test(ele)) {\n      // 栈顶元素\n      let topEle = stack[stack.length - 1];\n      if(/[\\*\\/]/.test(topEle)) {\n        // 如果栈顶元素优先级比加减高，依次将优先级高的运算符弹出\n        while(stack.length > 0 && /[\\*\\/]/.test(topEle)) {\n          output.push(stack.pop());\n          topEle = stack[stack.length - 1];\n        }\n      }\n      stack.push(ele);\n    } else if(/[\\*\\/\\)]/.test(ele)) {\n      // 如果是乘除或右括号，入栈\n      stack.push(ele);\n    } else {\n\n      // 如果是左括号，依次弹出至右括号\n      let topEle = stack.pop();\n      while(topEle !== ')') {\n        output.push(topEle);\n        topEle = stack.pop();\n      }\n    }\n  }\n\n  // 将栈剩余的元素依次弹出\n  while(stack.length > 0) {\n    output.push(stack.pop());\n  }\n\n  return output.reverse().join(',');\n}\n```\n\n### 计算前缀表达式\n\n前缀表达式的计算也使用到了栈，规则如下：\n\n1. 从右至左扫描表达式\n  - 如果当前字符是数字，入栈\n  - 如果当前字符是运算符，栈弹出两个元素，进行运算，并将结果入栈\n2. 重复上述过程，直到扫描结束\n\n继续以 `-*3+594` 为例，计算如下：\n\n1. 栈:[4]\n2. 栈:[4, 9]\n3. 栈:[4, 9, 5]\n4. 计算 `5 + 9`，得到结果 14 压入栈中。栈:[4, 14]\n5. 栈:[4, 14, 3]\n6. 计算 `3 * 14`，得到结果 42 压入栈中。栈:[4, 42]\n7. 计算 `42 - 4`，得到结果 38 压入栈中。栈:[38]\n\n最后结果即为 48。\n\njavascript 实现：\n```javascript\n/**\n * 计算前缀表达式\n * @param  {string} preExpress 前缀表达式\n * @return {number}            结果\n */\nfunction calculate(preExpress) {\n  let chars = preExpress.split(',');\n  let nums = [];\n  while(chars.length > 0) {\n    let ele = chars.pop();\n    if(/\\d+/.test(ele)) {\n      nums.push(ele);\n    } else {\n      let left = +nums.pop();\n      let right = +nums.pop();\n      switch (ele) {\n        case '+':\n          nums.push(left + right);\n          break;\n        case '-':\n          nums.push(left - right);\n          break;\n        case '*':\n          nums.push(left * right);\n          break;\n        case '/':\n          nums.push(left / right);\n          break;\n      }\n    }\n  }\n  return nums[0];\n}\n```\n\n## 排列\n对于 `1, 2, 3, 4`，四个数字，我们知道一共有 `4! = 24` 种排列。\n\n而事实上，这二十四种排列是从第一个数字开始，依次与后面的数字交换而来的。\n\n- 1, 2 交换: `2, 1, 3, 4`\n- 1, 3 交换：`2, 3, 1, 4`\n- 1, 4 交换：`2, 3, 4, 1`\n- 1, 2 交换：`1, 3, 4, 2`\n- 1, 3 交换：`3, 1, 4, 2`\n- ...依次类推\n\n所以只要在 `n!` 时间内，就能得出所有可能情况\n\njavascript 实现\n```javascript\nfunction createExpress(nums) {\n  let noBraket = [], oneBraket = [], twoBraket = [];\n\n  let swapIndex = 0;\n  for(let i = 0; i < 24; i++) {\n    swap(swapIndex);\n    swapIndex == nums.length - 1 ? swapIndex = 0 : swapIndex++;\n    // nums 即为一个排列\n  }\n\n  function swap(i) {\n    if(i < nums.length - 1) {\n      [nums[i], nums[i + 1]] = [nums[i + 1], nums[i]];\n    } else {\n      [nums[i], nums[0]] = [nums[0], nums[i]];\n    }\n  }\n}\n```\n\n## 添加括号\n\n式子列出之后，需要给表达式添加括号，实际上有括号的可能情况只有两种: 只有一个括号和有两个括号。而每种情况都只有 5 种情况。\n\n1. 一个括号\n  - (1 2) 3 4\n  - (1 2 3) 4\n  - 1 (2 3) 4\n  - 1 (2 3 4)\n  - 1 2 (3 4)\n2. 两个括号\n  - (1 2) (3 4)\n  - ((1 2) 3) 4\n  - (1 (2 3)) 4\n  - 1 ((2 3) 4)\n  - 1 (2 (3 4))\n\n## TODO\n\n解决了以上问题之后，基本能算出所有的可能情况了，剩下的问题在于如何去除重复，和判断重复情况。\n\n比如 `(1 + 2 + 3) * 5` 和 `5 * (1 + 2 + 3)` 应该判断为同一种情况。\n\n## 所有代码\n```javascript\nlet nums = process.argv.slice(2, 6);\n\ncreateExpress(nums);\n// translate('(3+(3+4)*5');\n\nfunction createExpress(nums) {\n  let noBraket = [], oneBraket = [], twoBraket = [];\n\n  let swapIndex = 0;\n  for(let i = 0; i < 24; i++) {\n    swap(swapIndex);\n    swapIndex == nums.length - 1 ? swapIndex = 0 : swapIndex++;\n\n    // 表达式\n    let operTypes = ['+', '-', '*', '/'];\n    for (let j = 0; j < operTypes.length; j++) {\n      for (let k = 0; k < operTypes.length; k++) {\n        for (let l = 0; l < operTypes.length; l++) {\n          let express = `${nums[0]}${operTypes[j]}${nums[1]}${operTypes[k]}${nums[2]}${operTypes[l]}${nums[3]}`;\n          // console.log(express)\n          noBraket.push(express);\n\n          // 当不是全部都是同样优先级时才加括号\n          if(!isSamePriority(operTypes[j], operTypes[k], operTypes[l])) {\n            // 加一个括号\n            oneBraket.push(addBraket(express, {\n              0: '(',\n              4: ')'\n            }));\n            oneBraket.push(addBraket(express, {\n              2: '(',\n              6: ')'\n            }));\n            oneBraket.push(addBraket(express, {\n              4: '(',\n              8: ')'\n            }));\n            oneBraket.push(addBraket(express, {\n              0: '(',\n              6: ')'\n            }));\n            oneBraket.push(addBraket(express, {\n              2: '(',\n              8: ')'\n            }));\n\n            // 加两个括号\n            twoBraket.push(addBraket(express, {\n              0: '(',\n              4: ')',\n              6: '(',\n              10: ')'\n            }));\n            twoBraket.push(addBraket(express, {\n              0: '(',\n              1: '(',\n              5: ')',\n              8: ')'\n            }));\n            twoBraket.push(addBraket(express, {\n              2: '(',\n              3: '(',\n              7: ')',\n              10: ')'\n            }));\n            twoBraket.push(addBraket(express, {\n              0: '(',\n              3: '(',\n              7: ')',\n              8: ')'\n            }));\n            twoBraket.push(addBraket(express, {\n              2: '(',\n              5: '(',\n              9: ')',\n              10: ')'\n            }));\n          }\n        }\n      }\n    }\n\n    let expresses = noBraket.concat(oneBraket).concat(twoBraket);\n    for (let i = 0; i < expresses.length; i++) {\n      // if(expresses[i] == '')\n      // console.log(expresses[i], calculate(translate(expresses[i])))\n      if(calculate(translate(expresses[i])) == 24) {\n        console.log(expresses[i]);\n      }\n    }\n  }\n\n  function isSamePriority() {\n    let opers = Array.from(arguments).join('');\n    if((opers.match(/[\\+\\-]/g) && opers.match(/[\\+\\-]/g).length == opers.length)\n      || (opers.match(/[\\*\\/]/g) && opers.match(/[\\*\\/]/g).length == opers.length)) {\n      return true;\n    }\n    return false;\n  }\n\n  function addBraket(express, param) {\n    let chars = express.match(/(\\d+)|[^\\d]/g);\n    for(let pos in param) {\n      chars.splice(+pos, 0, param[pos]);\n    }\n    return chars.join('');\n  }\n\n  function swap(i) {\n    if(i < nums.length - 1) {\n      [nums[i], nums[i + 1]] = [nums[i + 1], nums[i]];\n    } else {\n      [nums[i], nums[0]] = [nums[0], nums[i]];\n    }\n  }\n}\n\n/**\n * 中缀表达式转前缀表达式\n * @param  {string} inExpress 中缀表达式\n * @return {string}           前缀表达式\n */\nfunction translate(inExpress) {\n  if(inExpress == '') {\n    throw new Error('表达式为空');\n  }\n  // 输出前缀表达式\n  let output = [];\n  // 反转\n  let chars = inExpress.match(/(\\d+)|[^\\d]/g).reverse();\n  // 存放运算符的栈\n  let stack = [];\n  for(let ele of chars) {\n    if(/\\d+/.test(ele)) {\n      // 如果是数字，直接输出\n      output.push(ele);\n    } else if(/[\\+\\-]/.test(ele)) {\n      // 栈顶元素\n      let topEle = stack[stack.length - 1];\n      if(/[\\*\\/]/.test(topEle)) {\n        // 如果栈顶元素优先级比加减高，依次将优先级高的运算符弹出\n        while(stack.length > 0 && /[\\*\\/]/.test(topEle)) {\n          output.push(stack.pop());\n          topEle = stack[stack.length - 1];\n        }\n      }\n      stack.push(ele);\n    } else if(/[\\*\\/\\)]/.test(ele)) {\n      // 如果是乘除或右括号，入栈\n      stack.push(ele);\n    } else {\n\n      // 如果是左括号，依次弹出至右括号\n      let topEle = stack.pop();\n      while(topEle !== ')') {\n        output.push(topEle);\n        topEle = stack.pop();\n      }\n    }\n  }\n\n  // 将栈剩余的元素依次弹出\n  while(stack.length > 0) {\n    output.push(stack.pop());\n  }\n\n  return output.reverse().join(',');\n}\n\n/**\n * 计算前缀表达式\n * @param  {string} preExpress 前缀表达式\n * @return {number}            结果\n */\nfunction calculate(preExpress) {\n  let chars = preExpress.split(',');\n  let nums = [];\n  while(chars.length > 0) {\n    let ele = chars.pop();\n    if(/\\d+/.test(ele)) {\n      nums.push(ele);\n    } else {\n      let left = +nums.pop();\n      let right = +nums.pop();\n      switch (ele) {\n        case '+':\n          nums.push(left + right);\n          break;\n        case '-':\n          nums.push(left - right);\n          break;\n        case '*':\n          nums.push(left * right);\n          break;\n        case '/':\n          nums.push(left / right);\n          break;\n      }\n    }\n  }\n  return nums[0];\n}\n```\n","source":"_posts/calculate-24-game.md","raw":"---\ntitle: 24点\ndate: 2016-07-19 17:15:34\ntags: [每周总结]\n---\n\n从北戴河回来的时候，和水哥在火车上玩 24 点，玩着玩着就聊到了求 24 点的实现（可怕的程序猿\n\n先考虑简单实现，即只有加减乘除四则运算。很直接的思路就是列出所有可能的表达式，依次求和，最后找出结果等于 24 的情况。\n\n这里涉及到两个关键点，一个是通过数字求出所有表达式，另一个是根据式子计算结果。\n\n求所有表达式可以理解为求四个数字的排列，然后插入运算符即可；根据式子计算结果我们可以利用前缀表达式做到。\n\n<!-- more -->\n\n## 前缀表达式\n\n我们平常使用的式子比如 `3*(5+9)-4`，称为中缀表达式，运算符夹在数字的中间，是人类易于理解的表达式。而计算机很难识别这种表达式，一是括号改变了式子的运行顺序，另外各种运算符之间存在优先级大小关系。\n\n相比而言，前缀表达式是计算机容易计算的，像上面这个例子，如果用前缀表达式来描述则是 `-*3+594`。可以看到前缀表达式中去掉了括号，运算符跑到了计算数字的左边。\n\n### 中缀表达式转换为前缀表达式\n\n中缀表达式转换为前缀表达式需要经过以下步骤：\n1. 从右至左扫描中缀表达式，从右边第一个字符开始判断\n  - 如果当前字符是数字，则将数字直接输出。\n  - 如果是运算符，栈顶也是运算符，则比较优先级：如果当前运算符的优先级大于等于栈顶运算符的优先级，运算符入栈，如果当前运算符的优先级小于栈顶运算符的优先级，将栈顶运算符弹出并输出，直到当前运算符的优先级大于等于栈顶运算符的优先级。\n  - 如果是运算符，栈顶为括号或栈为空，入栈。\n  - 如果是右括号，则入栈。\n  - 如果是左括号，将所有的运算符全部出栈并输出，直到栈顶为右括号，最后将左右的两括号一起删除。\n2. 重复上述操作直至扫描结束，将栈内剩余运算符全部出栈并输出，最后逆序输出字符串。\n\n以 `3*(5+9)-4` 为例，过程如下：\n1. 字符为 4\n  > 如果当前字符是数字，则将数字直接输出。\n\n  - 输出序列：4\n  - 栈：[]\n\n2. 字符为 -\n  > 如果是运算符，栈顶为括号或栈为空，入栈。\n\n  - 输出序列：4\n  - 栈：[-]\n\n3. 字符为 )\n  > 如果是右括号，则入栈。\n\n  - 输出序列：4\n  - 栈：[-, )]\n\n4. 字符为 9\n\n  - 输出序列：49\n  - 栈：[-, )]\n\n5. 字符为 +\n  > 如果是运算符，栈顶为括号或栈为空，入栈。\n\n  - 输出序列：49\n  - 栈：[-, ), +]\n\n6. 字符为 5\n\n  - 输出序列：495\n  - 栈：[-, ), +]\n\n7. 字符为 (\n  > 如果是左括号，将所有的运算符全部出栈并输出，直到栈顶为右括号，最后将左右的两括号一起删除。\n\n  输出序列：495+\n  栈：[-]\n\n8. 字符为 *\n  > 如果当前运算符的优先级大于等于栈顶运算符的优先级，运算符入栈\n\n  - 输出序列：495+\n  - 栈：[-, \\*]\n\n9. 字符为 3\n  - 输出序列：495+3\n  - 栈：[-, \\*]\n\n10. 结束\n  > 将栈内剩余运算符全部出栈并输出，最后逆序输出字符串。\n\n  - 输出序列：`495+3*-`\n  - 逆序：`-*3+594`\n\n所以最后结果为 `-*3+594`。\n\njavascript实现如下：\n\n```javascript\n/**\n * 中缀表达式转前缀表达式\n * @param  {string} inExpress 中缀表达式\n * @return {string}           前缀表达式\n */\nfunction translate(inExpress) {\n  if(inExpress == '') {\n    throw new Error('表达式为空');\n  }\n  // 输出前缀表达式\n  let output = [];\n  // 反转\n  let chars = inExpress.match(/(\\d+)|[^\\d]/g).reverse();\n  // 存放运算符的栈\n  let stack = [];\n  for(let ele of chars) {\n    if(/\\d+/.test(ele)) {\n      // 如果是数字，直接输出\n      output.push(ele);\n    } else if(/[\\+\\-]/.test(ele)) {\n      // 栈顶元素\n      let topEle = stack[stack.length - 1];\n      if(/[\\*\\/]/.test(topEle)) {\n        // 如果栈顶元素优先级比加减高，依次将优先级高的运算符弹出\n        while(stack.length > 0 && /[\\*\\/]/.test(topEle)) {\n          output.push(stack.pop());\n          topEle = stack[stack.length - 1];\n        }\n      }\n      stack.push(ele);\n    } else if(/[\\*\\/\\)]/.test(ele)) {\n      // 如果是乘除或右括号，入栈\n      stack.push(ele);\n    } else {\n\n      // 如果是左括号，依次弹出至右括号\n      let topEle = stack.pop();\n      while(topEle !== ')') {\n        output.push(topEle);\n        topEle = stack.pop();\n      }\n    }\n  }\n\n  // 将栈剩余的元素依次弹出\n  while(stack.length > 0) {\n    output.push(stack.pop());\n  }\n\n  return output.reverse().join(',');\n}\n```\n\n### 计算前缀表达式\n\n前缀表达式的计算也使用到了栈，规则如下：\n\n1. 从右至左扫描表达式\n  - 如果当前字符是数字，入栈\n  - 如果当前字符是运算符，栈弹出两个元素，进行运算，并将结果入栈\n2. 重复上述过程，直到扫描结束\n\n继续以 `-*3+594` 为例，计算如下：\n\n1. 栈:[4]\n2. 栈:[4, 9]\n3. 栈:[4, 9, 5]\n4. 计算 `5 + 9`，得到结果 14 压入栈中。栈:[4, 14]\n5. 栈:[4, 14, 3]\n6. 计算 `3 * 14`，得到结果 42 压入栈中。栈:[4, 42]\n7. 计算 `42 - 4`，得到结果 38 压入栈中。栈:[38]\n\n最后结果即为 48。\n\njavascript 实现：\n```javascript\n/**\n * 计算前缀表达式\n * @param  {string} preExpress 前缀表达式\n * @return {number}            结果\n */\nfunction calculate(preExpress) {\n  let chars = preExpress.split(',');\n  let nums = [];\n  while(chars.length > 0) {\n    let ele = chars.pop();\n    if(/\\d+/.test(ele)) {\n      nums.push(ele);\n    } else {\n      let left = +nums.pop();\n      let right = +nums.pop();\n      switch (ele) {\n        case '+':\n          nums.push(left + right);\n          break;\n        case '-':\n          nums.push(left - right);\n          break;\n        case '*':\n          nums.push(left * right);\n          break;\n        case '/':\n          nums.push(left / right);\n          break;\n      }\n    }\n  }\n  return nums[0];\n}\n```\n\n## 排列\n对于 `1, 2, 3, 4`，四个数字，我们知道一共有 `4! = 24` 种排列。\n\n而事实上，这二十四种排列是从第一个数字开始，依次与后面的数字交换而来的。\n\n- 1, 2 交换: `2, 1, 3, 4`\n- 1, 3 交换：`2, 3, 1, 4`\n- 1, 4 交换：`2, 3, 4, 1`\n- 1, 2 交换：`1, 3, 4, 2`\n- 1, 3 交换：`3, 1, 4, 2`\n- ...依次类推\n\n所以只要在 `n!` 时间内，就能得出所有可能情况\n\njavascript 实现\n```javascript\nfunction createExpress(nums) {\n  let noBraket = [], oneBraket = [], twoBraket = [];\n\n  let swapIndex = 0;\n  for(let i = 0; i < 24; i++) {\n    swap(swapIndex);\n    swapIndex == nums.length - 1 ? swapIndex = 0 : swapIndex++;\n    // nums 即为一个排列\n  }\n\n  function swap(i) {\n    if(i < nums.length - 1) {\n      [nums[i], nums[i + 1]] = [nums[i + 1], nums[i]];\n    } else {\n      [nums[i], nums[0]] = [nums[0], nums[i]];\n    }\n  }\n}\n```\n\n## 添加括号\n\n式子列出之后，需要给表达式添加括号，实际上有括号的可能情况只有两种: 只有一个括号和有两个括号。而每种情况都只有 5 种情况。\n\n1. 一个括号\n  - (1 2) 3 4\n  - (1 2 3) 4\n  - 1 (2 3) 4\n  - 1 (2 3 4)\n  - 1 2 (3 4)\n2. 两个括号\n  - (1 2) (3 4)\n  - ((1 2) 3) 4\n  - (1 (2 3)) 4\n  - 1 ((2 3) 4)\n  - 1 (2 (3 4))\n\n## TODO\n\n解决了以上问题之后，基本能算出所有的可能情况了，剩下的问题在于如何去除重复，和判断重复情况。\n\n比如 `(1 + 2 + 3) * 5` 和 `5 * (1 + 2 + 3)` 应该判断为同一种情况。\n\n## 所有代码\n```javascript\nlet nums = process.argv.slice(2, 6);\n\ncreateExpress(nums);\n// translate('(3+(3+4)*5');\n\nfunction createExpress(nums) {\n  let noBraket = [], oneBraket = [], twoBraket = [];\n\n  let swapIndex = 0;\n  for(let i = 0; i < 24; i++) {\n    swap(swapIndex);\n    swapIndex == nums.length - 1 ? swapIndex = 0 : swapIndex++;\n\n    // 表达式\n    let operTypes = ['+', '-', '*', '/'];\n    for (let j = 0; j < operTypes.length; j++) {\n      for (let k = 0; k < operTypes.length; k++) {\n        for (let l = 0; l < operTypes.length; l++) {\n          let express = `${nums[0]}${operTypes[j]}${nums[1]}${operTypes[k]}${nums[2]}${operTypes[l]}${nums[3]}`;\n          // console.log(express)\n          noBraket.push(express);\n\n          // 当不是全部都是同样优先级时才加括号\n          if(!isSamePriority(operTypes[j], operTypes[k], operTypes[l])) {\n            // 加一个括号\n            oneBraket.push(addBraket(express, {\n              0: '(',\n              4: ')'\n            }));\n            oneBraket.push(addBraket(express, {\n              2: '(',\n              6: ')'\n            }));\n            oneBraket.push(addBraket(express, {\n              4: '(',\n              8: ')'\n            }));\n            oneBraket.push(addBraket(express, {\n              0: '(',\n              6: ')'\n            }));\n            oneBraket.push(addBraket(express, {\n              2: '(',\n              8: ')'\n            }));\n\n            // 加两个括号\n            twoBraket.push(addBraket(express, {\n              0: '(',\n              4: ')',\n              6: '(',\n              10: ')'\n            }));\n            twoBraket.push(addBraket(express, {\n              0: '(',\n              1: '(',\n              5: ')',\n              8: ')'\n            }));\n            twoBraket.push(addBraket(express, {\n              2: '(',\n              3: '(',\n              7: ')',\n              10: ')'\n            }));\n            twoBraket.push(addBraket(express, {\n              0: '(',\n              3: '(',\n              7: ')',\n              8: ')'\n            }));\n            twoBraket.push(addBraket(express, {\n              2: '(',\n              5: '(',\n              9: ')',\n              10: ')'\n            }));\n          }\n        }\n      }\n    }\n\n    let expresses = noBraket.concat(oneBraket).concat(twoBraket);\n    for (let i = 0; i < expresses.length; i++) {\n      // if(expresses[i] == '')\n      // console.log(expresses[i], calculate(translate(expresses[i])))\n      if(calculate(translate(expresses[i])) == 24) {\n        console.log(expresses[i]);\n      }\n    }\n  }\n\n  function isSamePriority() {\n    let opers = Array.from(arguments).join('');\n    if((opers.match(/[\\+\\-]/g) && opers.match(/[\\+\\-]/g).length == opers.length)\n      || (opers.match(/[\\*\\/]/g) && opers.match(/[\\*\\/]/g).length == opers.length)) {\n      return true;\n    }\n    return false;\n  }\n\n  function addBraket(express, param) {\n    let chars = express.match(/(\\d+)|[^\\d]/g);\n    for(let pos in param) {\n      chars.splice(+pos, 0, param[pos]);\n    }\n    return chars.join('');\n  }\n\n  function swap(i) {\n    if(i < nums.length - 1) {\n      [nums[i], nums[i + 1]] = [nums[i + 1], nums[i]];\n    } else {\n      [nums[i], nums[0]] = [nums[0], nums[i]];\n    }\n  }\n}\n\n/**\n * 中缀表达式转前缀表达式\n * @param  {string} inExpress 中缀表达式\n * @return {string}           前缀表达式\n */\nfunction translate(inExpress) {\n  if(inExpress == '') {\n    throw new Error('表达式为空');\n  }\n  // 输出前缀表达式\n  let output = [];\n  // 反转\n  let chars = inExpress.match(/(\\d+)|[^\\d]/g).reverse();\n  // 存放运算符的栈\n  let stack = [];\n  for(let ele of chars) {\n    if(/\\d+/.test(ele)) {\n      // 如果是数字，直接输出\n      output.push(ele);\n    } else if(/[\\+\\-]/.test(ele)) {\n      // 栈顶元素\n      let topEle = stack[stack.length - 1];\n      if(/[\\*\\/]/.test(topEle)) {\n        // 如果栈顶元素优先级比加减高，依次将优先级高的运算符弹出\n        while(stack.length > 0 && /[\\*\\/]/.test(topEle)) {\n          output.push(stack.pop());\n          topEle = stack[stack.length - 1];\n        }\n      }\n      stack.push(ele);\n    } else if(/[\\*\\/\\)]/.test(ele)) {\n      // 如果是乘除或右括号，入栈\n      stack.push(ele);\n    } else {\n\n      // 如果是左括号，依次弹出至右括号\n      let topEle = stack.pop();\n      while(topEle !== ')') {\n        output.push(topEle);\n        topEle = stack.pop();\n      }\n    }\n  }\n\n  // 将栈剩余的元素依次弹出\n  while(stack.length > 0) {\n    output.push(stack.pop());\n  }\n\n  return output.reverse().join(',');\n}\n\n/**\n * 计算前缀表达式\n * @param  {string} preExpress 前缀表达式\n * @return {number}            结果\n */\nfunction calculate(preExpress) {\n  let chars = preExpress.split(',');\n  let nums = [];\n  while(chars.length > 0) {\n    let ele = chars.pop();\n    if(/\\d+/.test(ele)) {\n      nums.push(ele);\n    } else {\n      let left = +nums.pop();\n      let right = +nums.pop();\n      switch (ele) {\n        case '+':\n          nums.push(left + right);\n          break;\n        case '-':\n          nums.push(left - right);\n          break;\n        case '*':\n          nums.push(left * right);\n          break;\n        case '/':\n          nums.push(left / right);\n          break;\n      }\n    }\n  }\n  return nums[0];\n}\n```\n","slug":"calculate-24-game","published":1,"updated":"2016-08-27T00:03:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscgyh160008gq2778thwsgp","content":"<p>从北戴河回来的时候，和水哥在火车上玩 24 点，玩着玩着就聊到了求 24 点的实现（可怕的程序猿</p>\n<p>先考虑简单实现，即只有加减乘除四则运算。很直接的思路就是列出所有可能的表达式，依次求和，最后找出结果等于 24 的情况。</p>\n<p>这里涉及到两个关键点，一个是通过数字求出所有表达式，另一个是根据式子计算结果。</p>\n<p>求所有表达式可以理解为求四个数字的排列，然后插入运算符即可；根据式子计算结果我们可以利用前缀表达式做到。</p>\n<a id=\"more\"></a>\n<h2 id=\"前缀表达式\"><a href=\"#前缀表达式\" class=\"headerlink\" title=\"前缀表达式\"></a>前缀表达式</h2><p>我们平常使用的式子比如 <code>3*(5+9)-4</code>，称为中缀表达式，运算符夹在数字的中间，是人类易于理解的表达式。而计算机很难识别这种表达式，一是括号改变了式子的运行顺序，另外各种运算符之间存在优先级大小关系。</p>\n<p>相比而言，前缀表达式是计算机容易计算的，像上面这个例子，如果用前缀表达式来描述则是 <code>-*3+594</code>。可以看到前缀表达式中去掉了括号，运算符跑到了计算数字的左边。</p>\n<h3 id=\"中缀表达式转换为前缀表达式\"><a href=\"#中缀表达式转换为前缀表达式\" class=\"headerlink\" title=\"中缀表达式转换为前缀表达式\"></a>中缀表达式转换为前缀表达式</h3><p>中缀表达式转换为前缀表达式需要经过以下步骤：</p>\n<ol>\n<li>从右至左扫描中缀表达式，从右边第一个字符开始判断<ul>\n<li>如果当前字符是数字，则将数字直接输出。</li>\n<li>如果是运算符，栈顶也是运算符，则比较优先级：如果当前运算符的优先级大于等于栈顶运算符的优先级，运算符入栈，如果当前运算符的优先级小于栈顶运算符的优先级，将栈顶运算符弹出并输出，直到当前运算符的优先级大于等于栈顶运算符的优先级。</li>\n<li>如果是运算符，栈顶为括号或栈为空，入栈。</li>\n<li>如果是右括号，则入栈。</li>\n<li>如果是左括号，将所有的运算符全部出栈并输出，直到栈顶为右括号，最后将左右的两括号一起删除。</li>\n</ul>\n</li>\n<li>重复上述操作直至扫描结束，将栈内剩余运算符全部出栈并输出，最后逆序输出字符串。</li>\n</ol>\n<p>以 <code>3*(5+9)-4</code> 为例，过程如下：</p>\n<ol>\n<li><p>字符为 4</p>\n<blockquote>\n<p>如果当前字符是数字，则将数字直接输出。</p>\n</blockquote>\n<ul>\n<li>输出序列：4</li>\n<li>栈：[]</li>\n</ul>\n</li>\n<li><p>字符为 -</p>\n<blockquote>\n<p>如果是运算符，栈顶为括号或栈为空，入栈。</p>\n</blockquote>\n<ul>\n<li>输出序列：4</li>\n<li>栈：[-]</li>\n</ul>\n</li>\n<li><p>字符为 )</p>\n<blockquote>\n<p>如果是右括号，则入栈。</p>\n</blockquote>\n<ul>\n<li>输出序列：4</li>\n<li>栈：[-, )]</li>\n</ul>\n</li>\n<li><p>字符为 9</p>\n<ul>\n<li>输出序列：49</li>\n<li>栈：[-, )]</li>\n</ul>\n</li>\n<li><p>字符为 +</p>\n<blockquote>\n<p>如果是运算符，栈顶为括号或栈为空，入栈。</p>\n</blockquote>\n<ul>\n<li>输出序列：49</li>\n<li>栈：[-, ), +]</li>\n</ul>\n</li>\n<li><p>字符为 5</p>\n<ul>\n<li>输出序列：495</li>\n<li>栈：[-, ), +]</li>\n</ul>\n</li>\n<li><p>字符为 (</p>\n<blockquote>\n<p>如果是左括号，将所有的运算符全部出栈并输出，直到栈顶为右括号，最后将左右的两括号一起删除。</p>\n</blockquote>\n<p>输出序列：495+<br>栈：[-]</p>\n</li>\n<li><p>字符为 *</p>\n<blockquote>\n<p>如果当前运算符的优先级大于等于栈顶运算符的优先级，运算符入栈</p>\n</blockquote>\n<ul>\n<li>输出序列：495+</li>\n<li>栈：[-, *]</li>\n</ul>\n</li>\n<li><p>字符为 3</p>\n<ul>\n<li>输出序列：495+3</li>\n<li>栈：[-, *]</li>\n</ul>\n</li>\n<li><p>结束</p>\n<blockquote>\n<p>将栈内剩余运算符全部出栈并输出，最后逆序输出字符串。</p>\n</blockquote>\n<ul>\n<li>输出序列：<code>495+3*-</code></li>\n<li>逆序：<code>-*3+594</code></li>\n</ul>\n</li>\n</ol>\n<p>所以最后结果为 <code>-*3+594</code>。</p>\n<p>javascript实现如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 中缀表达式转前缀表达式</div><div class=\"line\"> * @param  &#123;string&#125; inExpress 中缀表达式</div><div class=\"line\"> * @return &#123;string&#125;           前缀表达式</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">translate</span>(<span class=\"params\">inExpress</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(inExpress == <span class=\"string\">''</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'表达式为空'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 输出前缀表达式</span></div><div class=\"line\">  <span class=\"keyword\">let</span> output = [];</div><div class=\"line\">  <span class=\"comment\">// 反转</span></div><div class=\"line\">  <span class=\"keyword\">let</span> chars = inExpress.match(<span class=\"regexp\">/(\\d+)|[^\\d]/g</span>).reverse();</div><div class=\"line\">  <span class=\"comment\">// 存放运算符的栈</span></div><div class=\"line\">  <span class=\"keyword\">let</span> stack = [];</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> ele <span class=\"keyword\">of</span> chars) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"regexp\">/\\d+/</span>.test(ele)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果是数字，直接输出</span></div><div class=\"line\">      output.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"regexp\">/[\\+\\-]/</span>.test(ele)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 栈顶元素</span></div><div class=\"line\">      <span class=\"keyword\">let</span> topEle = stack[stack.length - <span class=\"number\">1</span>];</div><div class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"regexp\">/[\\*\\/]/</span>.test(topEle)) &#123;</div><div class=\"line\">        <span class=\"comment\">// 如果栈顶元素优先级比加减高，依次将优先级高的运算符弹出</span></div><div class=\"line\">        <span class=\"keyword\">while</span>(stack.length &gt; <span class=\"number\">0</span> &amp;&amp; <span class=\"regexp\">/[\\*\\/]/</span>.test(topEle)) &#123;</div><div class=\"line\">          output.push(stack.pop());</div><div class=\"line\">          topEle = stack[stack.length - <span class=\"number\">1</span>];</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      stack.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"regexp\">/[\\*\\/\\)]/</span>.test(ele)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果是乘除或右括号，入栈</span></div><div class=\"line\">      stack.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// 如果是左括号，依次弹出至右括号</span></div><div class=\"line\">      <span class=\"keyword\">let</span> topEle = stack.pop();</div><div class=\"line\">      <span class=\"keyword\">while</span>(topEle !== <span class=\"string\">')'</span>) &#123;</div><div class=\"line\">        output.push(topEle);</div><div class=\"line\">        topEle = stack.pop();</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 将栈剩余的元素依次弹出</span></div><div class=\"line\">  <span class=\"keyword\">while</span>(stack.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    output.push(stack.pop());</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> output.reverse().join(<span class=\"string\">','</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"计算前缀表达式\"><a href=\"#计算前缀表达式\" class=\"headerlink\" title=\"计算前缀表达式\"></a>计算前缀表达式</h3><p>前缀表达式的计算也使用到了栈，规则如下：</p>\n<ol>\n<li>从右至左扫描表达式<ul>\n<li>如果当前字符是数字，入栈</li>\n<li>如果当前字符是运算符，栈弹出两个元素，进行运算，并将结果入栈</li>\n</ul>\n</li>\n<li>重复上述过程，直到扫描结束</li>\n</ol>\n<p>继续以 <code>-*3+594</code> 为例，计算如下：</p>\n<ol>\n<li>栈:[4]</li>\n<li>栈:[4, 9]</li>\n<li>栈:[4, 9, 5]</li>\n<li>计算 <code>5 + 9</code>，得到结果 14 压入栈中。栈:[4, 14]</li>\n<li>栈:[4, 14, 3]</li>\n<li>计算 <code>3 * 14</code>，得到结果 42 压入栈中。栈:[4, 42]</li>\n<li>计算 <code>42 - 4</code>，得到结果 38 压入栈中。栈:[38]</li>\n</ol>\n<p>最后结果即为 48。</p>\n<p>javascript 实现：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 计算前缀表达式</div><div class=\"line\"> * @param  &#123;string&#125; preExpress 前缀表达式</div><div class=\"line\"> * @return &#123;number&#125;            结果</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">calculate</span>(<span class=\"params\">preExpress</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> chars = preExpress.split(<span class=\"string\">','</span>);</div><div class=\"line\">  <span class=\"keyword\">let</span> nums = [];</div><div class=\"line\">  <span class=\"keyword\">while</span>(chars.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> ele = chars.pop();</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"regexp\">/\\d+/</span>.test(ele)) &#123;</div><div class=\"line\">      nums.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> left = +nums.pop();</div><div class=\"line\">      <span class=\"keyword\">let</span> right = +nums.pop();</div><div class=\"line\">      <span class=\"keyword\">switch</span> (ele) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'+'</span>:</div><div class=\"line\">          nums.push(left + right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'-'</span>:</div><div class=\"line\">          nums.push(left - right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'*'</span>:</div><div class=\"line\">          nums.push(left * right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'/'</span>:</div><div class=\"line\">          nums.push(left / right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"排列\"><a href=\"#排列\" class=\"headerlink\" title=\"排列\"></a>排列</h2><p>对于 <code>1, 2, 3, 4</code>，四个数字，我们知道一共有 <code>4! = 24</code> 种排列。</p>\n<p>而事实上，这二十四种排列是从第一个数字开始，依次与后面的数字交换而来的。</p>\n<ul>\n<li>1, 2 交换: <code>2, 1, 3, 4</code></li>\n<li>1, 3 交换：<code>2, 3, 1, 4</code></li>\n<li>1, 4 交换：<code>2, 3, 4, 1</code></li>\n<li>1, 2 交换：<code>1, 3, 4, 2</code></li>\n<li>1, 3 交换：<code>3, 1, 4, 2</code></li>\n<li>…依次类推</li>\n</ul>\n<p>所以只要在 <code>n!</code> 时间内，就能得出所有可能情况</p>\n<p>javascript 实现<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createExpress</span>(<span class=\"params\">nums</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> noBraket = [], oneBraket = [], twoBraket = [];</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">let</span> swapIndex = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">24</span>; i++) &#123;</div><div class=\"line\">    swap(swapIndex);</div><div class=\"line\">    swapIndex == nums.length - <span class=\"number\">1</span> ? swapIndex = <span class=\"number\">0</span> : swapIndex++;</div><div class=\"line\">    <span class=\"comment\">// nums 即为一个排列</span></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span>(<span class=\"params\">i</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(i &lt; nums.length - <span class=\"number\">1</span>) &#123;</div><div class=\"line\">      [nums[i], nums[i + <span class=\"number\">1</span>]] = [nums[i + <span class=\"number\">1</span>], nums[i]];</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      [nums[i], nums[<span class=\"number\">0</span>]] = [nums[<span class=\"number\">0</span>], nums[i]];</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"添加括号\"><a href=\"#添加括号\" class=\"headerlink\" title=\"添加括号\"></a>添加括号</h2><p>式子列出之后，需要给表达式添加括号，实际上有括号的可能情况只有两种: 只有一个括号和有两个括号。而每种情况都只有 5 种情况。</p>\n<ol>\n<li>一个括号<ul>\n<li>(1 2) 3 4</li>\n<li>(1 2 3) 4</li>\n<li>1 (2 3) 4</li>\n<li>1 (2 3 4)</li>\n<li>1 2 (3 4)</li>\n</ul>\n</li>\n<li>两个括号<ul>\n<li>(1 2) (3 4)</li>\n<li>((1 2) 3) 4</li>\n<li>(1 (2 3)) 4</li>\n<li>1 ((2 3) 4)</li>\n<li>1 (2 (3 4))</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"TODO\"><a href=\"#TODO\" class=\"headerlink\" title=\"TODO\"></a>TODO</h2><p>解决了以上问题之后，基本能算出所有的可能情况了，剩下的问题在于如何去除重复，和判断重复情况。</p>\n<p>比如 <code>(1 + 2 + 3) * 5</code> 和 <code>5 * (1 + 2 + 3)</code> 应该判断为同一种情况。</p>\n<h2 id=\"所有代码\"><a href=\"#所有代码\" class=\"headerlink\" title=\"所有代码\"></a>所有代码</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> nums = process.argv.slice(<span class=\"number\">2</span>, <span class=\"number\">6</span>);</div><div class=\"line\"></div><div class=\"line\">createExpress(nums);</div><div class=\"line\"><span class=\"comment\">// translate('(3+(3+4)*5');</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createExpress</span>(<span class=\"params\">nums</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> noBraket = [], oneBraket = [], twoBraket = [];</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">let</span> swapIndex = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">24</span>; i++) &#123;</div><div class=\"line\">    swap(swapIndex);</div><div class=\"line\">    swapIndex == nums.length - <span class=\"number\">1</span> ? swapIndex = <span class=\"number\">0</span> : swapIndex++;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 表达式</span></div><div class=\"line\">    <span class=\"keyword\">let</span> operTypes = [<span class=\"string\">'+'</span>, <span class=\"string\">'-'</span>, <span class=\"string\">'*'</span>, <span class=\"string\">'/'</span>];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; operTypes.length; j++) &#123;</div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k = <span class=\"number\">0</span>; k &lt; operTypes.length; k++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> l = <span class=\"number\">0</span>; l &lt; operTypes.length; l++) &#123;</div><div class=\"line\">          <span class=\"keyword\">let</span> express = <span class=\"string\">`<span class=\"subst\">$&#123;nums[0]&#125;</span><span class=\"subst\">$&#123;operTypes[j]&#125;</span><span class=\"subst\">$&#123;nums[1]&#125;</span><span class=\"subst\">$&#123;operTypes[k]&#125;</span><span class=\"subst\">$&#123;nums[2]&#125;</span><span class=\"subst\">$&#123;operTypes[l]&#125;</span><span class=\"subst\">$&#123;nums[3]&#125;</span>`</span>;</div><div class=\"line\">          <span class=\"comment\">// console.log(express)</span></div><div class=\"line\">          noBraket.push(express);</div><div class=\"line\"></div><div class=\"line\">          <span class=\"comment\">// 当不是全部都是同样优先级时才加括号</span></div><div class=\"line\">          <span class=\"keyword\">if</span>(!isSamePriority(operTypes[j], operTypes[k], operTypes[l])) &#123;</div><div class=\"line\">            <span class=\"comment\">// 加一个括号</span></div><div class=\"line\">            oneBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">0</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">4</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            oneBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">2</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">6</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            oneBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">4</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">8</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            oneBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">0</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">6</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            oneBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">2</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">8</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// 加两个括号</span></div><div class=\"line\">            twoBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">0</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">4</span>: <span class=\"string\">')'</span>,</div><div class=\"line\">              <span class=\"number\">6</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">10</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            twoBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">0</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">1</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">5</span>: <span class=\"string\">')'</span>,</div><div class=\"line\">              <span class=\"number\">8</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            twoBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">2</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">3</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">7</span>: <span class=\"string\">')'</span>,</div><div class=\"line\">              <span class=\"number\">10</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            twoBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">0</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">3</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">7</span>: <span class=\"string\">')'</span>,</div><div class=\"line\">              <span class=\"number\">8</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            twoBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">2</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">5</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">9</span>: <span class=\"string\">')'</span>,</div><div class=\"line\">              <span class=\"number\">10</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">let</span> expresses = noBraket.concat(oneBraket).concat(twoBraket);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; expresses.length; i++) &#123;</div><div class=\"line\">      <span class=\"comment\">// if(expresses[i] == '')</span></div><div class=\"line\">      <span class=\"comment\">// console.log(expresses[i], calculate(translate(expresses[i])))</span></div><div class=\"line\">      <span class=\"keyword\">if</span>(calculate(translate(expresses[i])) == <span class=\"number\">24</span>) &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(expresses[i]);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isSamePriority</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> opers = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>).join(<span class=\"string\">''</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span>((opers.match(<span class=\"regexp\">/[\\+\\-]/g</span>) &amp;&amp; opers.match(<span class=\"regexp\">/[\\+\\-]/g</span>).length == opers.length)</div><div class=\"line\">      || (opers.match(<span class=\"regexp\">/[\\*\\/]/g</span>) &amp;&amp; opers.match(<span class=\"regexp\">/[\\*\\/]/g</span>).length == opers.length)) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addBraket</span>(<span class=\"params\">express, param</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> chars = express.match(<span class=\"regexp\">/(\\d+)|[^\\d]/g</span>);</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> pos <span class=\"keyword\">in</span> param) &#123;</div><div class=\"line\">      chars.splice(+pos, <span class=\"number\">0</span>, param[pos]);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> chars.join(<span class=\"string\">''</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span>(<span class=\"params\">i</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(i &lt; nums.length - <span class=\"number\">1</span>) &#123;</div><div class=\"line\">      [nums[i], nums[i + <span class=\"number\">1</span>]] = [nums[i + <span class=\"number\">1</span>], nums[i]];</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      [nums[i], nums[<span class=\"number\">0</span>]] = [nums[<span class=\"number\">0</span>], nums[i]];</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 中缀表达式转前缀表达式</div><div class=\"line\"> * @param  &#123;string&#125; inExpress 中缀表达式</div><div class=\"line\"> * @return &#123;string&#125;           前缀表达式</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">translate</span>(<span class=\"params\">inExpress</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(inExpress == <span class=\"string\">''</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'表达式为空'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 输出前缀表达式</span></div><div class=\"line\">  <span class=\"keyword\">let</span> output = [];</div><div class=\"line\">  <span class=\"comment\">// 反转</span></div><div class=\"line\">  <span class=\"keyword\">let</span> chars = inExpress.match(<span class=\"regexp\">/(\\d+)|[^\\d]/g</span>).reverse();</div><div class=\"line\">  <span class=\"comment\">// 存放运算符的栈</span></div><div class=\"line\">  <span class=\"keyword\">let</span> stack = [];</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> ele <span class=\"keyword\">of</span> chars) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"regexp\">/\\d+/</span>.test(ele)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果是数字，直接输出</span></div><div class=\"line\">      output.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"regexp\">/[\\+\\-]/</span>.test(ele)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 栈顶元素</span></div><div class=\"line\">      <span class=\"keyword\">let</span> topEle = stack[stack.length - <span class=\"number\">1</span>];</div><div class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"regexp\">/[\\*\\/]/</span>.test(topEle)) &#123;</div><div class=\"line\">        <span class=\"comment\">// 如果栈顶元素优先级比加减高，依次将优先级高的运算符弹出</span></div><div class=\"line\">        <span class=\"keyword\">while</span>(stack.length &gt; <span class=\"number\">0</span> &amp;&amp; <span class=\"regexp\">/[\\*\\/]/</span>.test(topEle)) &#123;</div><div class=\"line\">          output.push(stack.pop());</div><div class=\"line\">          topEle = stack[stack.length - <span class=\"number\">1</span>];</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      stack.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"regexp\">/[\\*\\/\\)]/</span>.test(ele)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果是乘除或右括号，入栈</span></div><div class=\"line\">      stack.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// 如果是左括号，依次弹出至右括号</span></div><div class=\"line\">      <span class=\"keyword\">let</span> topEle = stack.pop();</div><div class=\"line\">      <span class=\"keyword\">while</span>(topEle !== <span class=\"string\">')'</span>) &#123;</div><div class=\"line\">        output.push(topEle);</div><div class=\"line\">        topEle = stack.pop();</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 将栈剩余的元素依次弹出</span></div><div class=\"line\">  <span class=\"keyword\">while</span>(stack.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    output.push(stack.pop());</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> output.reverse().join(<span class=\"string\">','</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 计算前缀表达式</div><div class=\"line\"> * @param  &#123;string&#125; preExpress 前缀表达式</div><div class=\"line\"> * @return &#123;number&#125;            结果</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">calculate</span>(<span class=\"params\">preExpress</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> chars = preExpress.split(<span class=\"string\">','</span>);</div><div class=\"line\">  <span class=\"keyword\">let</span> nums = [];</div><div class=\"line\">  <span class=\"keyword\">while</span>(chars.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> ele = chars.pop();</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"regexp\">/\\d+/</span>.test(ele)) &#123;</div><div class=\"line\">      nums.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> left = +nums.pop();</div><div class=\"line\">      <span class=\"keyword\">let</span> right = +nums.pop();</div><div class=\"line\">      <span class=\"keyword\">switch</span> (ele) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'+'</span>:</div><div class=\"line\">          nums.push(left + right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'-'</span>:</div><div class=\"line\">          nums.push(left - right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'*'</span>:</div><div class=\"line\">          nums.push(left * right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'/'</span>:</div><div class=\"line\">          nums.push(left / right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"<p>从北戴河回来的时候，和水哥在火车上玩 24 点，玩着玩着就聊到了求 24 点的实现（可怕的程序猿</p>\n<p>先考虑简单实现，即只有加减乘除四则运算。很直接的思路就是列出所有可能的表达式，依次求和，最后找出结果等于 24 的情况。</p>\n<p>这里涉及到两个关键点，一个是通过数字求出所有表达式，另一个是根据式子计算结果。</p>\n<p>求所有表达式可以理解为求四个数字的排列，然后插入运算符即可；根据式子计算结果我们可以利用前缀表达式做到。</p>","more":"<h2 id=\"前缀表达式\"><a href=\"#前缀表达式\" class=\"headerlink\" title=\"前缀表达式\"></a>前缀表达式</h2><p>我们平常使用的式子比如 <code>3*(5+9)-4</code>，称为中缀表达式，运算符夹在数字的中间，是人类易于理解的表达式。而计算机很难识别这种表达式，一是括号改变了式子的运行顺序，另外各种运算符之间存在优先级大小关系。</p>\n<p>相比而言，前缀表达式是计算机容易计算的，像上面这个例子，如果用前缀表达式来描述则是 <code>-*3+594</code>。可以看到前缀表达式中去掉了括号，运算符跑到了计算数字的左边。</p>\n<h3 id=\"中缀表达式转换为前缀表达式\"><a href=\"#中缀表达式转换为前缀表达式\" class=\"headerlink\" title=\"中缀表达式转换为前缀表达式\"></a>中缀表达式转换为前缀表达式</h3><p>中缀表达式转换为前缀表达式需要经过以下步骤：</p>\n<ol>\n<li>从右至左扫描中缀表达式，从右边第一个字符开始判断<ul>\n<li>如果当前字符是数字，则将数字直接输出。</li>\n<li>如果是运算符，栈顶也是运算符，则比较优先级：如果当前运算符的优先级大于等于栈顶运算符的优先级，运算符入栈，如果当前运算符的优先级小于栈顶运算符的优先级，将栈顶运算符弹出并输出，直到当前运算符的优先级大于等于栈顶运算符的优先级。</li>\n<li>如果是运算符，栈顶为括号或栈为空，入栈。</li>\n<li>如果是右括号，则入栈。</li>\n<li>如果是左括号，将所有的运算符全部出栈并输出，直到栈顶为右括号，最后将左右的两括号一起删除。</li>\n</ul>\n</li>\n<li>重复上述操作直至扫描结束，将栈内剩余运算符全部出栈并输出，最后逆序输出字符串。</li>\n</ol>\n<p>以 <code>3*(5+9)-4</code> 为例，过程如下：</p>\n<ol>\n<li><p>字符为 4</p>\n<blockquote>\n<p>如果当前字符是数字，则将数字直接输出。</p>\n</blockquote>\n<ul>\n<li>输出序列：4</li>\n<li>栈：[]</li>\n</ul>\n</li>\n<li><p>字符为 -</p>\n<blockquote>\n<p>如果是运算符，栈顶为括号或栈为空，入栈。</p>\n</blockquote>\n<ul>\n<li>输出序列：4</li>\n<li>栈：[-]</li>\n</ul>\n</li>\n<li><p>字符为 )</p>\n<blockquote>\n<p>如果是右括号，则入栈。</p>\n</blockquote>\n<ul>\n<li>输出序列：4</li>\n<li>栈：[-, )]</li>\n</ul>\n</li>\n<li><p>字符为 9</p>\n<ul>\n<li>输出序列：49</li>\n<li>栈：[-, )]</li>\n</ul>\n</li>\n<li><p>字符为 +</p>\n<blockquote>\n<p>如果是运算符，栈顶为括号或栈为空，入栈。</p>\n</blockquote>\n<ul>\n<li>输出序列：49</li>\n<li>栈：[-, ), +]</li>\n</ul>\n</li>\n<li><p>字符为 5</p>\n<ul>\n<li>输出序列：495</li>\n<li>栈：[-, ), +]</li>\n</ul>\n</li>\n<li><p>字符为 (</p>\n<blockquote>\n<p>如果是左括号，将所有的运算符全部出栈并输出，直到栈顶为右括号，最后将左右的两括号一起删除。</p>\n</blockquote>\n<p>输出序列：495+<br>栈：[-]</p>\n</li>\n<li><p>字符为 *</p>\n<blockquote>\n<p>如果当前运算符的优先级大于等于栈顶运算符的优先级，运算符入栈</p>\n</blockquote>\n<ul>\n<li>输出序列：495+</li>\n<li>栈：[-, *]</li>\n</ul>\n</li>\n<li><p>字符为 3</p>\n<ul>\n<li>输出序列：495+3</li>\n<li>栈：[-, *]</li>\n</ul>\n</li>\n<li><p>结束</p>\n<blockquote>\n<p>将栈内剩余运算符全部出栈并输出，最后逆序输出字符串。</p>\n</blockquote>\n<ul>\n<li>输出序列：<code>495+3*-</code></li>\n<li>逆序：<code>-*3+594</code></li>\n</ul>\n</li>\n</ol>\n<p>所以最后结果为 <code>-*3+594</code>。</p>\n<p>javascript实现如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 中缀表达式转前缀表达式</div><div class=\"line\"> * @param  &#123;string&#125; inExpress 中缀表达式</div><div class=\"line\"> * @return &#123;string&#125;           前缀表达式</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">translate</span>(<span class=\"params\">inExpress</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(inExpress == <span class=\"string\">''</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'表达式为空'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 输出前缀表达式</span></div><div class=\"line\">  <span class=\"keyword\">let</span> output = [];</div><div class=\"line\">  <span class=\"comment\">// 反转</span></div><div class=\"line\">  <span class=\"keyword\">let</span> chars = inExpress.match(<span class=\"regexp\">/(\\d+)|[^\\d]/g</span>).reverse();</div><div class=\"line\">  <span class=\"comment\">// 存放运算符的栈</span></div><div class=\"line\">  <span class=\"keyword\">let</span> stack = [];</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> ele <span class=\"keyword\">of</span> chars) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"regexp\">/\\d+/</span>.test(ele)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果是数字，直接输出</span></div><div class=\"line\">      output.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"regexp\">/[\\+\\-]/</span>.test(ele)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 栈顶元素</span></div><div class=\"line\">      <span class=\"keyword\">let</span> topEle = stack[stack.length - <span class=\"number\">1</span>];</div><div class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"regexp\">/[\\*\\/]/</span>.test(topEle)) &#123;</div><div class=\"line\">        <span class=\"comment\">// 如果栈顶元素优先级比加减高，依次将优先级高的运算符弹出</span></div><div class=\"line\">        <span class=\"keyword\">while</span>(stack.length &gt; <span class=\"number\">0</span> &amp;&amp; <span class=\"regexp\">/[\\*\\/]/</span>.test(topEle)) &#123;</div><div class=\"line\">          output.push(stack.pop());</div><div class=\"line\">          topEle = stack[stack.length - <span class=\"number\">1</span>];</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      stack.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"regexp\">/[\\*\\/\\)]/</span>.test(ele)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果是乘除或右括号，入栈</span></div><div class=\"line\">      stack.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// 如果是左括号，依次弹出至右括号</span></div><div class=\"line\">      <span class=\"keyword\">let</span> topEle = stack.pop();</div><div class=\"line\">      <span class=\"keyword\">while</span>(topEle !== <span class=\"string\">')'</span>) &#123;</div><div class=\"line\">        output.push(topEle);</div><div class=\"line\">        topEle = stack.pop();</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 将栈剩余的元素依次弹出</span></div><div class=\"line\">  <span class=\"keyword\">while</span>(stack.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    output.push(stack.pop());</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> output.reverse().join(<span class=\"string\">','</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"计算前缀表达式\"><a href=\"#计算前缀表达式\" class=\"headerlink\" title=\"计算前缀表达式\"></a>计算前缀表达式</h3><p>前缀表达式的计算也使用到了栈，规则如下：</p>\n<ol>\n<li>从右至左扫描表达式<ul>\n<li>如果当前字符是数字，入栈</li>\n<li>如果当前字符是运算符，栈弹出两个元素，进行运算，并将结果入栈</li>\n</ul>\n</li>\n<li>重复上述过程，直到扫描结束</li>\n</ol>\n<p>继续以 <code>-*3+594</code> 为例，计算如下：</p>\n<ol>\n<li>栈:[4]</li>\n<li>栈:[4, 9]</li>\n<li>栈:[4, 9, 5]</li>\n<li>计算 <code>5 + 9</code>，得到结果 14 压入栈中。栈:[4, 14]</li>\n<li>栈:[4, 14, 3]</li>\n<li>计算 <code>3 * 14</code>，得到结果 42 压入栈中。栈:[4, 42]</li>\n<li>计算 <code>42 - 4</code>，得到结果 38 压入栈中。栈:[38]</li>\n</ol>\n<p>最后结果即为 48。</p>\n<p>javascript 实现：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 计算前缀表达式</div><div class=\"line\"> * @param  &#123;string&#125; preExpress 前缀表达式</div><div class=\"line\"> * @return &#123;number&#125;            结果</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">calculate</span>(<span class=\"params\">preExpress</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> chars = preExpress.split(<span class=\"string\">','</span>);</div><div class=\"line\">  <span class=\"keyword\">let</span> nums = [];</div><div class=\"line\">  <span class=\"keyword\">while</span>(chars.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> ele = chars.pop();</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"regexp\">/\\d+/</span>.test(ele)) &#123;</div><div class=\"line\">      nums.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> left = +nums.pop();</div><div class=\"line\">      <span class=\"keyword\">let</span> right = +nums.pop();</div><div class=\"line\">      <span class=\"keyword\">switch</span> (ele) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'+'</span>:</div><div class=\"line\">          nums.push(left + right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'-'</span>:</div><div class=\"line\">          nums.push(left - right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'*'</span>:</div><div class=\"line\">          nums.push(left * right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'/'</span>:</div><div class=\"line\">          nums.push(left / right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"排列\"><a href=\"#排列\" class=\"headerlink\" title=\"排列\"></a>排列</h2><p>对于 <code>1, 2, 3, 4</code>，四个数字，我们知道一共有 <code>4! = 24</code> 种排列。</p>\n<p>而事实上，这二十四种排列是从第一个数字开始，依次与后面的数字交换而来的。</p>\n<ul>\n<li>1, 2 交换: <code>2, 1, 3, 4</code></li>\n<li>1, 3 交换：<code>2, 3, 1, 4</code></li>\n<li>1, 4 交换：<code>2, 3, 4, 1</code></li>\n<li>1, 2 交换：<code>1, 3, 4, 2</code></li>\n<li>1, 3 交换：<code>3, 1, 4, 2</code></li>\n<li>…依次类推</li>\n</ul>\n<p>所以只要在 <code>n!</code> 时间内，就能得出所有可能情况</p>\n<p>javascript 实现<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createExpress</span>(<span class=\"params\">nums</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> noBraket = [], oneBraket = [], twoBraket = [];</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">let</span> swapIndex = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">24</span>; i++) &#123;</div><div class=\"line\">    swap(swapIndex);</div><div class=\"line\">    swapIndex == nums.length - <span class=\"number\">1</span> ? swapIndex = <span class=\"number\">0</span> : swapIndex++;</div><div class=\"line\">    <span class=\"comment\">// nums 即为一个排列</span></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span>(<span class=\"params\">i</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(i &lt; nums.length - <span class=\"number\">1</span>) &#123;</div><div class=\"line\">      [nums[i], nums[i + <span class=\"number\">1</span>]] = [nums[i + <span class=\"number\">1</span>], nums[i]];</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      [nums[i], nums[<span class=\"number\">0</span>]] = [nums[<span class=\"number\">0</span>], nums[i]];</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"添加括号\"><a href=\"#添加括号\" class=\"headerlink\" title=\"添加括号\"></a>添加括号</h2><p>式子列出之后，需要给表达式添加括号，实际上有括号的可能情况只有两种: 只有一个括号和有两个括号。而每种情况都只有 5 种情况。</p>\n<ol>\n<li>一个括号<ul>\n<li>(1 2) 3 4</li>\n<li>(1 2 3) 4</li>\n<li>1 (2 3) 4</li>\n<li>1 (2 3 4)</li>\n<li>1 2 (3 4)</li>\n</ul>\n</li>\n<li>两个括号<ul>\n<li>(1 2) (3 4)</li>\n<li>((1 2) 3) 4</li>\n<li>(1 (2 3)) 4</li>\n<li>1 ((2 3) 4)</li>\n<li>1 (2 (3 4))</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"TODO\"><a href=\"#TODO\" class=\"headerlink\" title=\"TODO\"></a>TODO</h2><p>解决了以上问题之后，基本能算出所有的可能情况了，剩下的问题在于如何去除重复，和判断重复情况。</p>\n<p>比如 <code>(1 + 2 + 3) * 5</code> 和 <code>5 * (1 + 2 + 3)</code> 应该判断为同一种情况。</p>\n<h2 id=\"所有代码\"><a href=\"#所有代码\" class=\"headerlink\" title=\"所有代码\"></a>所有代码</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> nums = process.argv.slice(<span class=\"number\">2</span>, <span class=\"number\">6</span>);</div><div class=\"line\"></div><div class=\"line\">createExpress(nums);</div><div class=\"line\"><span class=\"comment\">// translate('(3+(3+4)*5');</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createExpress</span>(<span class=\"params\">nums</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> noBraket = [], oneBraket = [], twoBraket = [];</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">let</span> swapIndex = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">24</span>; i++) &#123;</div><div class=\"line\">    swap(swapIndex);</div><div class=\"line\">    swapIndex == nums.length - <span class=\"number\">1</span> ? swapIndex = <span class=\"number\">0</span> : swapIndex++;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 表达式</span></div><div class=\"line\">    <span class=\"keyword\">let</span> operTypes = [<span class=\"string\">'+'</span>, <span class=\"string\">'-'</span>, <span class=\"string\">'*'</span>, <span class=\"string\">'/'</span>];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; operTypes.length; j++) &#123;</div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k = <span class=\"number\">0</span>; k &lt; operTypes.length; k++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> l = <span class=\"number\">0</span>; l &lt; operTypes.length; l++) &#123;</div><div class=\"line\">          <span class=\"keyword\">let</span> express = <span class=\"string\">`<span class=\"subst\">$&#123;nums[0]&#125;</span><span class=\"subst\">$&#123;operTypes[j]&#125;</span><span class=\"subst\">$&#123;nums[1]&#125;</span><span class=\"subst\">$&#123;operTypes[k]&#125;</span><span class=\"subst\">$&#123;nums[2]&#125;</span><span class=\"subst\">$&#123;operTypes[l]&#125;</span><span class=\"subst\">$&#123;nums[3]&#125;</span>`</span>;</div><div class=\"line\">          <span class=\"comment\">// console.log(express)</span></div><div class=\"line\">          noBraket.push(express);</div><div class=\"line\"></div><div class=\"line\">          <span class=\"comment\">// 当不是全部都是同样优先级时才加括号</span></div><div class=\"line\">          <span class=\"keyword\">if</span>(!isSamePriority(operTypes[j], operTypes[k], operTypes[l])) &#123;</div><div class=\"line\">            <span class=\"comment\">// 加一个括号</span></div><div class=\"line\">            oneBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">0</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">4</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            oneBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">2</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">6</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            oneBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">4</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">8</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            oneBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">0</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">6</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            oneBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">2</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">8</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// 加两个括号</span></div><div class=\"line\">            twoBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">0</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">4</span>: <span class=\"string\">')'</span>,</div><div class=\"line\">              <span class=\"number\">6</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">10</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            twoBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">0</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">1</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">5</span>: <span class=\"string\">')'</span>,</div><div class=\"line\">              <span class=\"number\">8</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            twoBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">2</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">3</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">7</span>: <span class=\"string\">')'</span>,</div><div class=\"line\">              <span class=\"number\">10</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            twoBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">0</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">3</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">7</span>: <span class=\"string\">')'</span>,</div><div class=\"line\">              <span class=\"number\">8</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">            twoBraket.push(addBraket(express, &#123;</div><div class=\"line\">              <span class=\"number\">2</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">5</span>: <span class=\"string\">'('</span>,</div><div class=\"line\">              <span class=\"number\">9</span>: <span class=\"string\">')'</span>,</div><div class=\"line\">              <span class=\"number\">10</span>: <span class=\"string\">')'</span></div><div class=\"line\">            &#125;));</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">let</span> expresses = noBraket.concat(oneBraket).concat(twoBraket);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; expresses.length; i++) &#123;</div><div class=\"line\">      <span class=\"comment\">// if(expresses[i] == '')</span></div><div class=\"line\">      <span class=\"comment\">// console.log(expresses[i], calculate(translate(expresses[i])))</span></div><div class=\"line\">      <span class=\"keyword\">if</span>(calculate(translate(expresses[i])) == <span class=\"number\">24</span>) &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(expresses[i]);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isSamePriority</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> opers = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>).join(<span class=\"string\">''</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span>((opers.match(<span class=\"regexp\">/[\\+\\-]/g</span>) &amp;&amp; opers.match(<span class=\"regexp\">/[\\+\\-]/g</span>).length == opers.length)</div><div class=\"line\">      || (opers.match(<span class=\"regexp\">/[\\*\\/]/g</span>) &amp;&amp; opers.match(<span class=\"regexp\">/[\\*\\/]/g</span>).length == opers.length)) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addBraket</span>(<span class=\"params\">express, param</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> chars = express.match(<span class=\"regexp\">/(\\d+)|[^\\d]/g</span>);</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> pos <span class=\"keyword\">in</span> param) &#123;</div><div class=\"line\">      chars.splice(+pos, <span class=\"number\">0</span>, param[pos]);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> chars.join(<span class=\"string\">''</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span>(<span class=\"params\">i</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(i &lt; nums.length - <span class=\"number\">1</span>) &#123;</div><div class=\"line\">      [nums[i], nums[i + <span class=\"number\">1</span>]] = [nums[i + <span class=\"number\">1</span>], nums[i]];</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      [nums[i], nums[<span class=\"number\">0</span>]] = [nums[<span class=\"number\">0</span>], nums[i]];</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 中缀表达式转前缀表达式</div><div class=\"line\"> * @param  &#123;string&#125; inExpress 中缀表达式</div><div class=\"line\"> * @return &#123;string&#125;           前缀表达式</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">translate</span>(<span class=\"params\">inExpress</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(inExpress == <span class=\"string\">''</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'表达式为空'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 输出前缀表达式</span></div><div class=\"line\">  <span class=\"keyword\">let</span> output = [];</div><div class=\"line\">  <span class=\"comment\">// 反转</span></div><div class=\"line\">  <span class=\"keyword\">let</span> chars = inExpress.match(<span class=\"regexp\">/(\\d+)|[^\\d]/g</span>).reverse();</div><div class=\"line\">  <span class=\"comment\">// 存放运算符的栈</span></div><div class=\"line\">  <span class=\"keyword\">let</span> stack = [];</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> ele <span class=\"keyword\">of</span> chars) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"regexp\">/\\d+/</span>.test(ele)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果是数字，直接输出</span></div><div class=\"line\">      output.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"regexp\">/[\\+\\-]/</span>.test(ele)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 栈顶元素</span></div><div class=\"line\">      <span class=\"keyword\">let</span> topEle = stack[stack.length - <span class=\"number\">1</span>];</div><div class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"regexp\">/[\\*\\/]/</span>.test(topEle)) &#123;</div><div class=\"line\">        <span class=\"comment\">// 如果栈顶元素优先级比加减高，依次将优先级高的运算符弹出</span></div><div class=\"line\">        <span class=\"keyword\">while</span>(stack.length &gt; <span class=\"number\">0</span> &amp;&amp; <span class=\"regexp\">/[\\*\\/]/</span>.test(topEle)) &#123;</div><div class=\"line\">          output.push(stack.pop());</div><div class=\"line\">          topEle = stack[stack.length - <span class=\"number\">1</span>];</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      stack.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"regexp\">/[\\*\\/\\)]/</span>.test(ele)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果是乘除或右括号，入栈</span></div><div class=\"line\">      stack.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// 如果是左括号，依次弹出至右括号</span></div><div class=\"line\">      <span class=\"keyword\">let</span> topEle = stack.pop();</div><div class=\"line\">      <span class=\"keyword\">while</span>(topEle !== <span class=\"string\">')'</span>) &#123;</div><div class=\"line\">        output.push(topEle);</div><div class=\"line\">        topEle = stack.pop();</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 将栈剩余的元素依次弹出</span></div><div class=\"line\">  <span class=\"keyword\">while</span>(stack.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    output.push(stack.pop());</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> output.reverse().join(<span class=\"string\">','</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 计算前缀表达式</div><div class=\"line\"> * @param  &#123;string&#125; preExpress 前缀表达式</div><div class=\"line\"> * @return &#123;number&#125;            结果</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">calculate</span>(<span class=\"params\">preExpress</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> chars = preExpress.split(<span class=\"string\">','</span>);</div><div class=\"line\">  <span class=\"keyword\">let</span> nums = [];</div><div class=\"line\">  <span class=\"keyword\">while</span>(chars.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> ele = chars.pop();</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"regexp\">/\\d+/</span>.test(ele)) &#123;</div><div class=\"line\">      nums.push(ele);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> left = +nums.pop();</div><div class=\"line\">      <span class=\"keyword\">let</span> right = +nums.pop();</div><div class=\"line\">      <span class=\"keyword\">switch</span> (ele) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'+'</span>:</div><div class=\"line\">          nums.push(left + right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'-'</span>:</div><div class=\"line\">          nums.push(left - right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'*'</span>:</div><div class=\"line\">          nums.push(left * right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'/'</span>:</div><div class=\"line\">          nums.push(left / right);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"数据抓取の经验","date":"2016-08-12T13:32:34.000Z","_content":"\n## 业务需求\n\n这里讨论的是给了用户名和密码，需要获取登陆之后页面内的某些数据。\n那么问题来了，\n**Q1. 用户名和密码都有了，直接登录不就完了吗！**\nA: 用机器去抓，省时又省力，关键是很酷。\n**Q2. 用户名和密码都有了，难道不是 so easy 吗！**\nA: 一般情况下都挺简单，但也有部分网站相当难抓，比如 [腾讯爸爸](http://tui.qq.com/)。\n**Q3. 用户名和密码都有了，登陆一次，以后携带 cookie 不就可以了吗！**\nA: cookie 很容易过期，让程序自己去拿 cookie，这样每次都是最新的 cookie，不是更酷吗？\n\n理想情况下，**构建请求参数 ---> 请求登陆接口 ---> 返回 SESSIONID ---> 携带 SESSIONID 请求目标接口**，就能拿到数据了，但是很可惜，一般的网站都不是理想情况，要成功干好这件事，需要非常非常地耐心和非常非常地仔细。\n<!--more-->\n## 第〇步 清空浏览器 Cookie\n\n这是最重要的一步，一定要清，不然哭一整天。另外在抓取过程中，只要重来，就清一次。因为如果不清 Cookie，浏览器会将上次保留的 Cookie 发送出去，干扰我们找真实的请求。\n下图是Chrome 清空 cookie 的地方：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/01.png)\n\n什么？你不是用 chrome？那你别往下看了\n\n## 第一步 从需要抓取的接口找起\n\n要抓取的数据肯定是来源于一个接口的，只是响应体内容可能有差异，比如是 JSON 格式返回的，或者是藏在 HTML 返回的，都有可能。首先要找到这个目标接口，然后重点关注它的请求头。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/02.png)\n\nCookie 是服务器判断用户有没有登陆的凭证，对应于服务器上的 Session，所以一般情况下，只要能拿到这个字段就大功告成了。请求的 cookie 都在请求体的 cookie 中，对应的响应的 cookie 都在响应体的 set-cookie 中。\n不同的后台语言对应不同的 Session 名字，常见的有： JSESSIONID (Java EE),、PHPSESSID (PHP)、 ASPSESSIONID (Microsoft ASP).。如上图可以大致推断这个网站是使用 JavaEE 开发的。\n\n## 第二步 从后往前推\n\n找到抓取数据所在的接口以后，一步一步往上找，点击请求，打开右侧的 Cookies 选项卡，可以看到这次请求的 Cookies 交互情况。**如果 Response Cookies 出现了目标请求中的 JSESSIONID**，没错！离成功近了一步，你需要拿小本子把这个请求记下来了。\n而这个请求在请求时很可能也需要一些 Cookies，所以以此类推，继续往上找。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/03.png)\n\n## 第三步 找到登陆请求\n\n要登录的网站必定是有个登录的请求的，登录请求一般有这么几种参数：\n1) 用户名、明文密码\n2) 用户名、加密密码\n3) 用户名、加密密码、加密其他参数\n（当然一般登陆还需要验证码，使用一些能够破解验证码的服务即可）\n\n碰到第一种，恭喜，今天可以提前下班了。登录的参数已经都有了，剩下的，一是请求登录接口可能需要 cookies，这个 cookies 如果包含 sessionid，sessionid 一定可以从登录之前的接口拿到，那么往前找就对了。二是请求登录接口之后一定会**直接或间接**返回**能够代表用户凭证的东西**，拿着这个东西，继续寻找能够**拿到目标接口需要的 sessionid** 即可。\n\n碰到第二种，还行，仔细的话还是能正常加班的。加密的过程一定是在 javascript 中完成的，打开源码，好好啃一下，这里有两个经验，一是可以先找一下这个按钮有没有 click 事件，如果有，八成在这个事件里写好了加密过程，如果没有，说明是表单提交。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/04.png)\n\n另外实在没有办法，就在源码里搜一下 cookie 等相关的字段，更容易命中一点。\n\n碰到第三种，去洗把脸准备准备加班了。其实不管是加密密码，还是加密其他参数，都是在 js 里面完成的，难度可能其实差不多，但是这体现了后台的重视程度。。。所以可能会更复杂一点，像腾讯里面使用了统一的登陆方式，所以也使用了统一的加密方法，加密的地方还蛮多的，看源码找了半天才找出来，这里就不展开了，有兴趣可以交流一下。\n\n## 一点人生经验\n\n抓取的方法其实在上面三步里说的差不多了，说白了就是仿照请求的过程，在不同的请求中寻找前后台交互的流程，下面是中间的一些经验：\n\n### 1) cookie 的作用域\n\n每个 cookie 都有自己的域，这可能在刚抓取的时候很容易被忽视，网页在登陆前后的跳转中，很可能会经历不同的域名，比如从 site.com/aaa 跳到 site.com/bbb，这两次返回的 cookie 域可能就会不同，重要的是这两个响应可能都返回 SESSIONID，但是两个是**不同**的，一定要分清接下来的请求携带的是哪一个。举个栗子：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/05.png)\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/06.png)\n\n同样是 JSESSIONID，不能搞混哦。\n\n### 2) 302 跳转\n你可能会碰到 302 重定向，可怕的是有的信息就藏在 302 请求中：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/07.png)\n\n这里就有个坑了，之前没有注意，我请求这个 url 的时候，想拿这个 cookie，写好代码之后，发现确实拿到 cookie 了，但是后面请求目标接口总是不成功，最后把响应头拿出来一看，发现！\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/08.png)\n\n尼玛！cookie 的作用域不同啊！（上面是 /ad/，而我的是 /hccas/）\n然后把响应状态打出来一看！\n200！\n擦擦擦擦，一下午就被这个干掉了，其实这是因为 request.js（我使用的是nodejs）对 302 请求作了自动重定向造成了，也就是碰到 302 就跟着跳了，但我们并不想它跳，这时需要设置一个参数：\n\n```\nfollowRedirect: false\n```\n\n然后就成功拿到了！\n","source":"_posts/data-capture.md","raw":"---\ntitle: 数据抓取の经验\ndate: 2016-08-12 21:32:34\ntags: [每周总结]\n---\n\n## 业务需求\n\n这里讨论的是给了用户名和密码，需要获取登陆之后页面内的某些数据。\n那么问题来了，\n**Q1. 用户名和密码都有了，直接登录不就完了吗！**\nA: 用机器去抓，省时又省力，关键是很酷。\n**Q2. 用户名和密码都有了，难道不是 so easy 吗！**\nA: 一般情况下都挺简单，但也有部分网站相当难抓，比如 [腾讯爸爸](http://tui.qq.com/)。\n**Q3. 用户名和密码都有了，登陆一次，以后携带 cookie 不就可以了吗！**\nA: cookie 很容易过期，让程序自己去拿 cookie，这样每次都是最新的 cookie，不是更酷吗？\n\n理想情况下，**构建请求参数 ---> 请求登陆接口 ---> 返回 SESSIONID ---> 携带 SESSIONID 请求目标接口**，就能拿到数据了，但是很可惜，一般的网站都不是理想情况，要成功干好这件事，需要非常非常地耐心和非常非常地仔细。\n<!--more-->\n## 第〇步 清空浏览器 Cookie\n\n这是最重要的一步，一定要清，不然哭一整天。另外在抓取过程中，只要重来，就清一次。因为如果不清 Cookie，浏览器会将上次保留的 Cookie 发送出去，干扰我们找真实的请求。\n下图是Chrome 清空 cookie 的地方：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/01.png)\n\n什么？你不是用 chrome？那你别往下看了\n\n## 第一步 从需要抓取的接口找起\n\n要抓取的数据肯定是来源于一个接口的，只是响应体内容可能有差异，比如是 JSON 格式返回的，或者是藏在 HTML 返回的，都有可能。首先要找到这个目标接口，然后重点关注它的请求头。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/02.png)\n\nCookie 是服务器判断用户有没有登陆的凭证，对应于服务器上的 Session，所以一般情况下，只要能拿到这个字段就大功告成了。请求的 cookie 都在请求体的 cookie 中，对应的响应的 cookie 都在响应体的 set-cookie 中。\n不同的后台语言对应不同的 Session 名字，常见的有： JSESSIONID (Java EE),、PHPSESSID (PHP)、 ASPSESSIONID (Microsoft ASP).。如上图可以大致推断这个网站是使用 JavaEE 开发的。\n\n## 第二步 从后往前推\n\n找到抓取数据所在的接口以后，一步一步往上找，点击请求，打开右侧的 Cookies 选项卡，可以看到这次请求的 Cookies 交互情况。**如果 Response Cookies 出现了目标请求中的 JSESSIONID**，没错！离成功近了一步，你需要拿小本子把这个请求记下来了。\n而这个请求在请求时很可能也需要一些 Cookies，所以以此类推，继续往上找。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/03.png)\n\n## 第三步 找到登陆请求\n\n要登录的网站必定是有个登录的请求的，登录请求一般有这么几种参数：\n1) 用户名、明文密码\n2) 用户名、加密密码\n3) 用户名、加密密码、加密其他参数\n（当然一般登陆还需要验证码，使用一些能够破解验证码的服务即可）\n\n碰到第一种，恭喜，今天可以提前下班了。登录的参数已经都有了，剩下的，一是请求登录接口可能需要 cookies，这个 cookies 如果包含 sessionid，sessionid 一定可以从登录之前的接口拿到，那么往前找就对了。二是请求登录接口之后一定会**直接或间接**返回**能够代表用户凭证的东西**，拿着这个东西，继续寻找能够**拿到目标接口需要的 sessionid** 即可。\n\n碰到第二种，还行，仔细的话还是能正常加班的。加密的过程一定是在 javascript 中完成的，打开源码，好好啃一下，这里有两个经验，一是可以先找一下这个按钮有没有 click 事件，如果有，八成在这个事件里写好了加密过程，如果没有，说明是表单提交。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/04.png)\n\n另外实在没有办法，就在源码里搜一下 cookie 等相关的字段，更容易命中一点。\n\n碰到第三种，去洗把脸准备准备加班了。其实不管是加密密码，还是加密其他参数，都是在 js 里面完成的，难度可能其实差不多，但是这体现了后台的重视程度。。。所以可能会更复杂一点，像腾讯里面使用了统一的登陆方式，所以也使用了统一的加密方法，加密的地方还蛮多的，看源码找了半天才找出来，这里就不展开了，有兴趣可以交流一下。\n\n## 一点人生经验\n\n抓取的方法其实在上面三步里说的差不多了，说白了就是仿照请求的过程，在不同的请求中寻找前后台交互的流程，下面是中间的一些经验：\n\n### 1) cookie 的作用域\n\n每个 cookie 都有自己的域，这可能在刚抓取的时候很容易被忽视，网页在登陆前后的跳转中，很可能会经历不同的域名，比如从 site.com/aaa 跳到 site.com/bbb，这两次返回的 cookie 域可能就会不同，重要的是这两个响应可能都返回 SESSIONID，但是两个是**不同**的，一定要分清接下来的请求携带的是哪一个。举个栗子：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/05.png)\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/06.png)\n\n同样是 JSESSIONID，不能搞混哦。\n\n### 2) 302 跳转\n你可能会碰到 302 重定向，可怕的是有的信息就藏在 302 请求中：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/07.png)\n\n这里就有个坑了，之前没有注意，我请求这个 url 的时候，想拿这个 cookie，写好代码之后，发现确实拿到 cookie 了，但是后面请求目标接口总是不成功，最后把响应头拿出来一看，发现！\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/08.png)\n\n尼玛！cookie 的作用域不同啊！（上面是 /ad/，而我的是 /hccas/）\n然后把响应状态打出来一看！\n200！\n擦擦擦擦，一下午就被这个干掉了，其实这是因为 request.js（我使用的是nodejs）对 302 请求作了自动重定向造成了，也就是碰到 302 就跟着跳了，但我们并不想它跳，这时需要设置一个参数：\n\n```\nfollowRedirect: false\n```\n\n然后就成功拿到了！\n","slug":"data-capture","published":1,"updated":"2016-08-27T00:03:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscgyh18000bgq27c0pyafru","content":"<h2 id=\"业务需求\"><a href=\"#业务需求\" class=\"headerlink\" title=\"业务需求\"></a>业务需求</h2><p>这里讨论的是给了用户名和密码，需要获取登陆之后页面内的某些数据。<br>那么问题来了，<br><strong>Q1. 用户名和密码都有了，直接登录不就完了吗！</strong><br>A: 用机器去抓，省时又省力，关键是很酷。<br><strong>Q2. 用户名和密码都有了，难道不是 so easy 吗！</strong><br>A: 一般情况下都挺简单，但也有部分网站相当难抓，比如 <a href=\"http://tui.qq.com/\" target=\"_blank\" rel=\"external\">腾讯爸爸</a>。<br><strong>Q3. 用户名和密码都有了，登陆一次，以后携带 cookie 不就可以了吗！</strong><br>A: cookie 很容易过期，让程序自己去拿 cookie，这样每次都是最新的 cookie，不是更酷吗？</p>\n<p>理想情况下，<strong>构建请求参数 —&gt; 请求登陆接口 —&gt; 返回 SESSIONID —&gt; 携带 SESSIONID 请求目标接口</strong>，就能拿到数据了，但是很可惜，一般的网站都不是理想情况，要成功干好这件事，需要非常非常地耐心和非常非常地仔细。<br><a id=\"more\"></a></p>\n<h2 id=\"第〇步-清空浏览器-Cookie\"><a href=\"#第〇步-清空浏览器-Cookie\" class=\"headerlink\" title=\"第〇步 清空浏览器 Cookie\"></a>第〇步 清空浏览器 Cookie</h2><p>这是最重要的一步，一定要清，不然哭一整天。另外在抓取过程中，只要重来，就清一次。因为如果不清 Cookie，浏览器会将上次保留的 Cookie 发送出去，干扰我们找真实的请求。<br>下图是Chrome 清空 cookie 的地方：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/01.png\" alt=\"\"></p>\n<p>什么？你不是用 chrome？那你别往下看了</p>\n<h2 id=\"第一步-从需要抓取的接口找起\"><a href=\"#第一步-从需要抓取的接口找起\" class=\"headerlink\" title=\"第一步 从需要抓取的接口找起\"></a>第一步 从需要抓取的接口找起</h2><p>要抓取的数据肯定是来源于一个接口的，只是响应体内容可能有差异，比如是 JSON 格式返回的，或者是藏在 HTML 返回的，都有可能。首先要找到这个目标接口，然后重点关注它的请求头。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/02.png\" alt=\"\"></p>\n<p>Cookie 是服务器判断用户有没有登陆的凭证，对应于服务器上的 Session，所以一般情况下，只要能拿到这个字段就大功告成了。请求的 cookie 都在请求体的 cookie 中，对应的响应的 cookie 都在响应体的 set-cookie 中。<br>不同的后台语言对应不同的 Session 名字，常见的有： JSESSIONID (Java EE),、PHPSESSID (PHP)、 ASPSESSIONID (Microsoft ASP).。如上图可以大致推断这个网站是使用 JavaEE 开发的。</p>\n<h2 id=\"第二步-从后往前推\"><a href=\"#第二步-从后往前推\" class=\"headerlink\" title=\"第二步 从后往前推\"></a>第二步 从后往前推</h2><p>找到抓取数据所在的接口以后，一步一步往上找，点击请求，打开右侧的 Cookies 选项卡，可以看到这次请求的 Cookies 交互情况。<strong>如果 Response Cookies 出现了目标请求中的 JSESSIONID</strong>，没错！离成功近了一步，你需要拿小本子把这个请求记下来了。<br>而这个请求在请求时很可能也需要一些 Cookies，所以以此类推，继续往上找。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/03.png\" alt=\"\"></p>\n<h2 id=\"第三步-找到登陆请求\"><a href=\"#第三步-找到登陆请求\" class=\"headerlink\" title=\"第三步 找到登陆请求\"></a>第三步 找到登陆请求</h2><p>要登录的网站必定是有个登录的请求的，登录请求一般有这么几种参数：<br>1) 用户名、明文密码<br>2) 用户名、加密密码<br>3) 用户名、加密密码、加密其他参数<br>（当然一般登陆还需要验证码，使用一些能够破解验证码的服务即可）</p>\n<p>碰到第一种，恭喜，今天可以提前下班了。登录的参数已经都有了，剩下的，一是请求登录接口可能需要 cookies，这个 cookies 如果包含 sessionid，sessionid 一定可以从登录之前的接口拿到，那么往前找就对了。二是请求登录接口之后一定会<strong>直接或间接</strong>返回<strong>能够代表用户凭证的东西</strong>，拿着这个东西，继续寻找能够<strong>拿到目标接口需要的 sessionid</strong> 即可。</p>\n<p>碰到第二种，还行，仔细的话还是能正常加班的。加密的过程一定是在 javascript 中完成的，打开源码，好好啃一下，这里有两个经验，一是可以先找一下这个按钮有没有 click 事件，如果有，八成在这个事件里写好了加密过程，如果没有，说明是表单提交。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/04.png\" alt=\"\"></p>\n<p>另外实在没有办法，就在源码里搜一下 cookie 等相关的字段，更容易命中一点。</p>\n<p>碰到第三种，去洗把脸准备准备加班了。其实不管是加密密码，还是加密其他参数，都是在 js 里面完成的，难度可能其实差不多，但是这体现了后台的重视程度。。。所以可能会更复杂一点，像腾讯里面使用了统一的登陆方式，所以也使用了统一的加密方法，加密的地方还蛮多的，看源码找了半天才找出来，这里就不展开了，有兴趣可以交流一下。</p>\n<h2 id=\"一点人生经验\"><a href=\"#一点人生经验\" class=\"headerlink\" title=\"一点人生经验\"></a>一点人生经验</h2><p>抓取的方法其实在上面三步里说的差不多了，说白了就是仿照请求的过程，在不同的请求中寻找前后台交互的流程，下面是中间的一些经验：</p>\n<h3 id=\"1-cookie-的作用域\"><a href=\"#1-cookie-的作用域\" class=\"headerlink\" title=\"1) cookie 的作用域\"></a>1) cookie 的作用域</h3><p>每个 cookie 都有自己的域，这可能在刚抓取的时候很容易被忽视，网页在登陆前后的跳转中，很可能会经历不同的域名，比如从 site.com/aaa 跳到 site.com/bbb，这两次返回的 cookie 域可能就会不同，重要的是这两个响应可能都返回 SESSIONID，但是两个是<strong>不同</strong>的，一定要分清接下来的请求携带的是哪一个。举个栗子：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/05.png\" alt=\"\"></p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/06.png\" alt=\"\"></p>\n<p>同样是 JSESSIONID，不能搞混哦。</p>\n<h3 id=\"2-302-跳转\"><a href=\"#2-302-跳转\" class=\"headerlink\" title=\"2) 302 跳转\"></a>2) 302 跳转</h3><p>你可能会碰到 302 重定向，可怕的是有的信息就藏在 302 请求中：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/07.png\" alt=\"\"></p>\n<p>这里就有个坑了，之前没有注意，我请求这个 url 的时候，想拿这个 cookie，写好代码之后，发现确实拿到 cookie 了，但是后面请求目标接口总是不成功，最后把响应头拿出来一看，发现！</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/08.png\" alt=\"\"></p>\n<p>尼玛！cookie 的作用域不同啊！（上面是 /ad/，而我的是 /hccas/）<br>然后把响应状态打出来一看！<br>200！<br>擦擦擦擦，一下午就被这个干掉了，其实这是因为 request.js（我使用的是nodejs）对 302 请求作了自动重定向造成了，也就是碰到 302 就跟着跳了，但我们并不想它跳，这时需要设置一个参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">followRedirect: false</div></pre></td></tr></table></figure>\n<p>然后就成功拿到了！</p>\n","excerpt":"<h2 id=\"业务需求\"><a href=\"#业务需求\" class=\"headerlink\" title=\"业务需求\"></a>业务需求</h2><p>这里讨论的是给了用户名和密码，需要获取登陆之后页面内的某些数据。<br>那么问题来了，<br><strong>Q1. 用户名和密码都有了，直接登录不就完了吗！</strong><br>A: 用机器去抓，省时又省力，关键是很酷。<br><strong>Q2. 用户名和密码都有了，难道不是 so easy 吗！</strong><br>A: 一般情况下都挺简单，但也有部分网站相当难抓，比如 <a href=\"http://tui.qq.com/\">腾讯爸爸</a>。<br><strong>Q3. 用户名和密码都有了，登陆一次，以后携带 cookie 不就可以了吗！</strong><br>A: cookie 很容易过期，让程序自己去拿 cookie，这样每次都是最新的 cookie，不是更酷吗？</p>\n<p>理想情况下，<strong>构建请求参数 —&gt; 请求登陆接口 —&gt; 返回 SESSIONID —&gt; 携带 SESSIONID 请求目标接口</strong>，就能拿到数据了，但是很可惜，一般的网站都不是理想情况，要成功干好这件事，需要非常非常地耐心和非常非常地仔细。<br>","more":"</p>\n<h2 id=\"第〇步-清空浏览器-Cookie\"><a href=\"#第〇步-清空浏览器-Cookie\" class=\"headerlink\" title=\"第〇步 清空浏览器 Cookie\"></a>第〇步 清空浏览器 Cookie</h2><p>这是最重要的一步，一定要清，不然哭一整天。另外在抓取过程中，只要重来，就清一次。因为如果不清 Cookie，浏览器会将上次保留的 Cookie 发送出去，干扰我们找真实的请求。<br>下图是Chrome 清空 cookie 的地方：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/01.png\" alt=\"\"></p>\n<p>什么？你不是用 chrome？那你别往下看了</p>\n<h2 id=\"第一步-从需要抓取的接口找起\"><a href=\"#第一步-从需要抓取的接口找起\" class=\"headerlink\" title=\"第一步 从需要抓取的接口找起\"></a>第一步 从需要抓取的接口找起</h2><p>要抓取的数据肯定是来源于一个接口的，只是响应体内容可能有差异，比如是 JSON 格式返回的，或者是藏在 HTML 返回的，都有可能。首先要找到这个目标接口，然后重点关注它的请求头。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/02.png\" alt=\"\"></p>\n<p>Cookie 是服务器判断用户有没有登陆的凭证，对应于服务器上的 Session，所以一般情况下，只要能拿到这个字段就大功告成了。请求的 cookie 都在请求体的 cookie 中，对应的响应的 cookie 都在响应体的 set-cookie 中。<br>不同的后台语言对应不同的 Session 名字，常见的有： JSESSIONID (Java EE),、PHPSESSID (PHP)、 ASPSESSIONID (Microsoft ASP).。如上图可以大致推断这个网站是使用 JavaEE 开发的。</p>\n<h2 id=\"第二步-从后往前推\"><a href=\"#第二步-从后往前推\" class=\"headerlink\" title=\"第二步 从后往前推\"></a>第二步 从后往前推</h2><p>找到抓取数据所在的接口以后，一步一步往上找，点击请求，打开右侧的 Cookies 选项卡，可以看到这次请求的 Cookies 交互情况。<strong>如果 Response Cookies 出现了目标请求中的 JSESSIONID</strong>，没错！离成功近了一步，你需要拿小本子把这个请求记下来了。<br>而这个请求在请求时很可能也需要一些 Cookies，所以以此类推，继续往上找。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/03.png\" alt=\"\"></p>\n<h2 id=\"第三步-找到登陆请求\"><a href=\"#第三步-找到登陆请求\" class=\"headerlink\" title=\"第三步 找到登陆请求\"></a>第三步 找到登陆请求</h2><p>要登录的网站必定是有个登录的请求的，登录请求一般有这么几种参数：<br>1) 用户名、明文密码<br>2) 用户名、加密密码<br>3) 用户名、加密密码、加密其他参数<br>（当然一般登陆还需要验证码，使用一些能够破解验证码的服务即可）</p>\n<p>碰到第一种，恭喜，今天可以提前下班了。登录的参数已经都有了，剩下的，一是请求登录接口可能需要 cookies，这个 cookies 如果包含 sessionid，sessionid 一定可以从登录之前的接口拿到，那么往前找就对了。二是请求登录接口之后一定会<strong>直接或间接</strong>返回<strong>能够代表用户凭证的东西</strong>，拿着这个东西，继续寻找能够<strong>拿到目标接口需要的 sessionid</strong> 即可。</p>\n<p>碰到第二种，还行，仔细的话还是能正常加班的。加密的过程一定是在 javascript 中完成的，打开源码，好好啃一下，这里有两个经验，一是可以先找一下这个按钮有没有 click 事件，如果有，八成在这个事件里写好了加密过程，如果没有，说明是表单提交。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/04.png\" alt=\"\"></p>\n<p>另外实在没有办法，就在源码里搜一下 cookie 等相关的字段，更容易命中一点。</p>\n<p>碰到第三种，去洗把脸准备准备加班了。其实不管是加密密码，还是加密其他参数，都是在 js 里面完成的，难度可能其实差不多，但是这体现了后台的重视程度。。。所以可能会更复杂一点，像腾讯里面使用了统一的登陆方式，所以也使用了统一的加密方法，加密的地方还蛮多的，看源码找了半天才找出来，这里就不展开了，有兴趣可以交流一下。</p>\n<h2 id=\"一点人生经验\"><a href=\"#一点人生经验\" class=\"headerlink\" title=\"一点人生经验\"></a>一点人生经验</h2><p>抓取的方法其实在上面三步里说的差不多了，说白了就是仿照请求的过程，在不同的请求中寻找前后台交互的流程，下面是中间的一些经验：</p>\n<h3 id=\"1-cookie-的作用域\"><a href=\"#1-cookie-的作用域\" class=\"headerlink\" title=\"1) cookie 的作用域\"></a>1) cookie 的作用域</h3><p>每个 cookie 都有自己的域，这可能在刚抓取的时候很容易被忽视，网页在登陆前后的跳转中，很可能会经历不同的域名，比如从 site.com/aaa 跳到 site.com/bbb，这两次返回的 cookie 域可能就会不同，重要的是这两个响应可能都返回 SESSIONID，但是两个是<strong>不同</strong>的，一定要分清接下来的请求携带的是哪一个。举个栗子：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/05.png\" alt=\"\"></p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/06.png\" alt=\"\"></p>\n<p>同样是 JSESSIONID，不能搞混哦。</p>\n<h3 id=\"2-302-跳转\"><a href=\"#2-302-跳转\" class=\"headerlink\" title=\"2) 302 跳转\"></a>2) 302 跳转</h3><p>你可能会碰到 302 重定向，可怕的是有的信息就藏在 302 请求中：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/07.png\" alt=\"\"></p>\n<p>这里就有个坑了，之前没有注意，我请求这个 url 的时候，想拿这个 cookie，写好代码之后，发现确实拿到 cookie 了，但是后面请求目标接口总是不成功，最后把响应头拿出来一看，发现！</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/08.png\" alt=\"\"></p>\n<p>尼玛！cookie 的作用域不同啊！（上面是 /ad/，而我的是 /hccas/）<br>然后把响应状态打出来一看！<br>200！<br>擦擦擦擦，一下午就被这个干掉了，其实这是因为 request.js（我使用的是nodejs）对 302 请求作了自动重定向造成了，也就是碰到 302 就跟着跳了，但我们并不想它跳，这时需要设置一个参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">followRedirect: false</div></pre></td></tr></table></figure>\n<p>然后就成功拿到了！</p>"},{"title":"函数柯里化","date":"2016-07-04T04:00:28.000Z","_content":"\n> 在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。   —— 维基百科\n\n<!-- more -->\n\n## 什么是柯里化\n\n先举个栗子：\n\n这里有个简单的求和方法 `add`\n\n```javascript\nfunction add(a, b) {\n  return a + b;\n}\n```\n\n调用它：\n\n```javascript\nadd(1, 2);  // 3\nadd(3, 3);  // 6\n```\n\n接下来我们使用柯里化的思想。\n\n> 柯里化声称 “如果你固定某些参数，你将得到接受余下参数的一个函数”。\n\n也就是说，如果满足柯里化思想，应该是这样的：\n```javascript\nfunction add(a, b) {\n  return a + b;\n}\n\nvar curryingAdd = currying(add, 5);\n\ncurryingAdd(1); // 6\ncurryingAdd(2); // 7\n```\n\n本来应该接收两个参数的 `add`，通过 `currying` 加工之后，可以用来接收余下的参数。\n\n上面的例子里面，其实就是把 `add` 接收的参数固定了一个，也就是 5，我们可以想到 `curryingAdd` 的一种简单实现。\n\n```javascript\nvar curryingAdd = function(a) {\n  return function(b) {\n    return a + b;\n  }\n}\n\ncurryingAdd(5)(1);  // 6\n```\n\n原理即是通过闭包保存了第一个变量。\n\n## currying 方法\n\n那么将普通函数转变为柯里化函数的 `currying` 是如何实现的呢，通过 `curringAdd`，可以想到使用闭包来实现。\n\n```javascript\nfunction currying(func) {\n  // 闭包保存固定参数\n  var firstArgs = Array.prototype.slice.call(arguments, 1);\n\n  return function() {\n    // 将固定参数和新参数一起传入原函数\n    var args = firstArgs.concat(Array.prototype.slice.call(arguments));\n    return func.apply(null, args);\n  }\n}\n\nfunction add(a, b) {\n  return a + b;\n}\n\ncurrying(add, 5)(1);  // 6\n```\n\n这种实现有一定的局限性，`curring` 方法的返回函数只能被执行一次，也就是我们不能这样调用：`currying(add)(1)(2)`\n\n要满足灵活的调用，需要判断接收的参数个数：\n\n```javascript\nfunction currying(func) {\n  // 闭包保存固定参数\n  var firstArgs = Array.prototype.slice.call(arguments, 1);\n\n  // 原函数接收的参数个数\n  var l = func.length;\n\n  return function inner() {\n    // 将固定参数和新参数一起传入原函数\n    firstArgs = firstArgs.concat(Array.prototype.slice.call(arguments));\n    if(firstArgs.length < l) {\n      return inner;\n    }\n    return func.apply(null, firstArgs);\n  }\n}\n\nfunction add(a, b) {\n  return a + b;\n}\n\ncurrying(add, 1)(5);  // 6\ncurrying(add)(1)(5);  // 6\ncurrying(add)(1, 5);  // 6\n```\n\n不过，我们还得考虑到原函数不用接收参数的情况，比如下面的 `sum`：\n```javascript\nfunction sum() {\n  var s = 0;\n  for (var i = 0, len = arguments.length; i < len; i++) {\n    s += arguments[i];\n  }\n  return s;\n}\n```\n\n`sum` 可以接收任意个参数并返回它们的和，我们通过调整 `currying` 的判断条件来覆盖这种情况。\n\n```javascript\nfunction currying(func) {\n  // 闭包保存固定参数\n  var firstArgs = Array.prototype.slice.call(arguments, 1);\n\n  // 原函数接收的参数个数\n  var l = func.length;\n\n  return function inner() {\n    // 将固定参数和新参数一起传入原函数\n    var newArgs = Array.prototype.slice.call(arguments);\n    firstArgs = firstArgs.concat(newArgs);\n\n    if((l == 0 && newArgs.length == 0) || (l > 0 && firstArgs.length == l)) {\n      // 调用完成\n      return func.apply(null, firstArgs);\n    }\n\n    return inner;\n  }\n}\n\ncurrying(sum, 1)(5)();  // 6\ncurrying(sum)(1)(5)(6)(7)();  // 19\ncurrying(sum)(1)(5)(6, 7)();  // 19\n\ncurrying(add, 1)(5);  // 6\ncurrying(add)(1)(5);  // 6\ncurrying(add)(1, 5);  // 6\n```\n","source":"_posts/currying.md","raw":"---\ntitle: 函数柯里化\ndate: 2016-07-04 12:00:28\ntags: [每周总结, javascript]\n---\n\n> 在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。   —— 维基百科\n\n<!-- more -->\n\n## 什么是柯里化\n\n先举个栗子：\n\n这里有个简单的求和方法 `add`\n\n```javascript\nfunction add(a, b) {\n  return a + b;\n}\n```\n\n调用它：\n\n```javascript\nadd(1, 2);  // 3\nadd(3, 3);  // 6\n```\n\n接下来我们使用柯里化的思想。\n\n> 柯里化声称 “如果你固定某些参数，你将得到接受余下参数的一个函数”。\n\n也就是说，如果满足柯里化思想，应该是这样的：\n```javascript\nfunction add(a, b) {\n  return a + b;\n}\n\nvar curryingAdd = currying(add, 5);\n\ncurryingAdd(1); // 6\ncurryingAdd(2); // 7\n```\n\n本来应该接收两个参数的 `add`，通过 `currying` 加工之后，可以用来接收余下的参数。\n\n上面的例子里面，其实就是把 `add` 接收的参数固定了一个，也就是 5，我们可以想到 `curryingAdd` 的一种简单实现。\n\n```javascript\nvar curryingAdd = function(a) {\n  return function(b) {\n    return a + b;\n  }\n}\n\ncurryingAdd(5)(1);  // 6\n```\n\n原理即是通过闭包保存了第一个变量。\n\n## currying 方法\n\n那么将普通函数转变为柯里化函数的 `currying` 是如何实现的呢，通过 `curringAdd`，可以想到使用闭包来实现。\n\n```javascript\nfunction currying(func) {\n  // 闭包保存固定参数\n  var firstArgs = Array.prototype.slice.call(arguments, 1);\n\n  return function() {\n    // 将固定参数和新参数一起传入原函数\n    var args = firstArgs.concat(Array.prototype.slice.call(arguments));\n    return func.apply(null, args);\n  }\n}\n\nfunction add(a, b) {\n  return a + b;\n}\n\ncurrying(add, 5)(1);  // 6\n```\n\n这种实现有一定的局限性，`curring` 方法的返回函数只能被执行一次，也就是我们不能这样调用：`currying(add)(1)(2)`\n\n要满足灵活的调用，需要判断接收的参数个数：\n\n```javascript\nfunction currying(func) {\n  // 闭包保存固定参数\n  var firstArgs = Array.prototype.slice.call(arguments, 1);\n\n  // 原函数接收的参数个数\n  var l = func.length;\n\n  return function inner() {\n    // 将固定参数和新参数一起传入原函数\n    firstArgs = firstArgs.concat(Array.prototype.slice.call(arguments));\n    if(firstArgs.length < l) {\n      return inner;\n    }\n    return func.apply(null, firstArgs);\n  }\n}\n\nfunction add(a, b) {\n  return a + b;\n}\n\ncurrying(add, 1)(5);  // 6\ncurrying(add)(1)(5);  // 6\ncurrying(add)(1, 5);  // 6\n```\n\n不过，我们还得考虑到原函数不用接收参数的情况，比如下面的 `sum`：\n```javascript\nfunction sum() {\n  var s = 0;\n  for (var i = 0, len = arguments.length; i < len; i++) {\n    s += arguments[i];\n  }\n  return s;\n}\n```\n\n`sum` 可以接收任意个参数并返回它们的和，我们通过调整 `currying` 的判断条件来覆盖这种情况。\n\n```javascript\nfunction currying(func) {\n  // 闭包保存固定参数\n  var firstArgs = Array.prototype.slice.call(arguments, 1);\n\n  // 原函数接收的参数个数\n  var l = func.length;\n\n  return function inner() {\n    // 将固定参数和新参数一起传入原函数\n    var newArgs = Array.prototype.slice.call(arguments);\n    firstArgs = firstArgs.concat(newArgs);\n\n    if((l == 0 && newArgs.length == 0) || (l > 0 && firstArgs.length == l)) {\n      // 调用完成\n      return func.apply(null, firstArgs);\n    }\n\n    return inner;\n  }\n}\n\ncurrying(sum, 1)(5)();  // 6\ncurrying(sum)(1)(5)(6)(7)();  // 19\ncurrying(sum)(1)(5)(6, 7)();  // 19\n\ncurrying(add, 1)(5);  // 6\ncurrying(add)(1)(5);  // 6\ncurrying(add)(1, 5);  // 6\n```\n","slug":"currying","published":1,"updated":"2016-08-27T00:03:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscgyh19000dgq27dswjx2ut","content":"<blockquote>\n<p>在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。   —— 维基百科</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"什么是柯里化\"><a href=\"#什么是柯里化\" class=\"headerlink\" title=\"什么是柯里化\"></a>什么是柯里化</h2><p>先举个栗子：</p>\n<p>这里有个简单的求和方法 <code>add</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用它：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">add(<span class=\"number\">1</span>, <span class=\"number\">2</span>);  <span class=\"comment\">// 3</span></div><div class=\"line\">add(<span class=\"number\">3</span>, <span class=\"number\">3</span>);  <span class=\"comment\">// 6</span></div></pre></td></tr></table></figure>\n<p>接下来我们使用柯里化的思想。</p>\n<blockquote>\n<p>柯里化声称 “如果你固定某些参数，你将得到接受余下参数的一个函数”。</p>\n</blockquote>\n<p>也就是说，如果满足柯里化思想，应该是这样的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> curryingAdd = currying(add, <span class=\"number\">5</span>);</div><div class=\"line\"></div><div class=\"line\">curryingAdd(<span class=\"number\">1</span>); <span class=\"comment\">// 6</span></div><div class=\"line\">curryingAdd(<span class=\"number\">2</span>); <span class=\"comment\">// 7</span></div></pre></td></tr></table></figure></p>\n<p>本来应该接收两个参数的 <code>add</code>，通过 <code>currying</code> 加工之后，可以用来接收余下的参数。</p>\n<p>上面的例子里面，其实就是把 <code>add</code> 接收的参数固定了一个，也就是 5，我们可以想到 <code>curryingAdd</code> 的一种简单实现。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> curryingAdd = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">curryingAdd(<span class=\"number\">5</span>)(<span class=\"number\">1</span>);  <span class=\"comment\">// 6</span></div></pre></td></tr></table></figure>\n<p>原理即是通过闭包保存了第一个变量。</p>\n<h2 id=\"currying-方法\"><a href=\"#currying-方法\" class=\"headerlink\" title=\"currying 方法\"></a>currying 方法</h2><p>那么将普通函数转变为柯里化函数的 <code>currying</code> 是如何实现的呢，通过 <code>curringAdd</code>，可以想到使用闭包来实现。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">currying</span>(<span class=\"params\">func</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 闭包保存固定参数</span></div><div class=\"line\">  <span class=\"keyword\">var</span> firstArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 将固定参数和新参数一起传入原函数</span></div><div class=\"line\">    <span class=\"keyword\">var</span> args = firstArgs.concat(<span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>));</div><div class=\"line\">    <span class=\"keyword\">return</span> func.apply(<span class=\"literal\">null</span>, args);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">currying(add, <span class=\"number\">5</span>)(<span class=\"number\">1</span>);  <span class=\"comment\">// 6</span></div></pre></td></tr></table></figure>\n<p>这种实现有一定的局限性，<code>curring</code> 方法的返回函数只能被执行一次，也就是我们不能这样调用：<code>currying(add)(1)(2)</code></p>\n<p>要满足灵活的调用，需要判断接收的参数个数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">currying</span>(<span class=\"params\">func</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 闭包保存固定参数</span></div><div class=\"line\">  <span class=\"keyword\">var</span> firstArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 原函数接收的参数个数</span></div><div class=\"line\">  <span class=\"keyword\">var</span> l = func.length;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inner</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 将固定参数和新参数一起传入原函数</span></div><div class=\"line\">    firstArgs = firstArgs.concat(<span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>));</div><div class=\"line\">    <span class=\"keyword\">if</span>(firstArgs.length &lt; l) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> inner;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> func.apply(<span class=\"literal\">null</span>, firstArgs);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">currying(add, <span class=\"number\">1</span>)(<span class=\"number\">5</span>);  <span class=\"comment\">// 6</span></div><div class=\"line\">currying(add)(<span class=\"number\">1</span>)(<span class=\"number\">5</span>);  <span class=\"comment\">// 6</span></div><div class=\"line\">currying(add)(<span class=\"number\">1</span>, <span class=\"number\">5</span>);  <span class=\"comment\">// 6</span></div></pre></td></tr></table></figure>\n<p>不过，我们还得考虑到原函数不用接收参数的情况，比如下面的 <code>sum</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> s = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = <span class=\"built_in\">arguments</span>.length; i &lt; len; i++) &#123;</div><div class=\"line\">    s += <span class=\"built_in\">arguments</span>[i];</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> s;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>sum</code> 可以接收任意个参数并返回它们的和，我们通过调整 <code>currying</code> 的判断条件来覆盖这种情况。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">currying</span>(<span class=\"params\">func</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 闭包保存固定参数</span></div><div class=\"line\">  <span class=\"keyword\">var</span> firstArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 原函数接收的参数个数</span></div><div class=\"line\">  <span class=\"keyword\">var</span> l = func.length;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inner</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 将固定参数和新参数一起传入原函数</span></div><div class=\"line\">    <span class=\"keyword\">var</span> newArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);</div><div class=\"line\">    firstArgs = firstArgs.concat(newArgs);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>((l == <span class=\"number\">0</span> &amp;&amp; newArgs.length == <span class=\"number\">0</span>) || (l &gt; <span class=\"number\">0</span> &amp;&amp; firstArgs.length == l)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 调用完成</span></div><div class=\"line\">      <span class=\"keyword\">return</span> func.apply(<span class=\"literal\">null</span>, firstArgs);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> inner;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">currying(sum, <span class=\"number\">1</span>)(<span class=\"number\">5</span>)();  <span class=\"comment\">// 6</span></div><div class=\"line\">currying(sum)(<span class=\"number\">1</span>)(<span class=\"number\">5</span>)(<span class=\"number\">6</span>)(<span class=\"number\">7</span>)();  <span class=\"comment\">// 19</span></div><div class=\"line\">currying(sum)(<span class=\"number\">1</span>)(<span class=\"number\">5</span>)(<span class=\"number\">6</span>, <span class=\"number\">7</span>)();  <span class=\"comment\">// 19</span></div><div class=\"line\"></div><div class=\"line\">currying(add, <span class=\"number\">1</span>)(<span class=\"number\">5</span>);  <span class=\"comment\">// 6</span></div><div class=\"line\">currying(add)(<span class=\"number\">1</span>)(<span class=\"number\">5</span>);  <span class=\"comment\">// 6</span></div><div class=\"line\">currying(add)(<span class=\"number\">1</span>, <span class=\"number\">5</span>);  <span class=\"comment\">// 6</span></div></pre></td></tr></table></figure>\n","excerpt":"<blockquote>\n<p>在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。   —— 维基百科</p>\n</blockquote>","more":"<h2 id=\"什么是柯里化\"><a href=\"#什么是柯里化\" class=\"headerlink\" title=\"什么是柯里化\"></a>什么是柯里化</h2><p>先举个栗子：</p>\n<p>这里有个简单的求和方法 <code>add</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用它：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">add(<span class=\"number\">1</span>, <span class=\"number\">2</span>);  <span class=\"comment\">// 3</span></div><div class=\"line\">add(<span class=\"number\">3</span>, <span class=\"number\">3</span>);  <span class=\"comment\">// 6</span></div></pre></td></tr></table></figure>\n<p>接下来我们使用柯里化的思想。</p>\n<blockquote>\n<p>柯里化声称 “如果你固定某些参数，你将得到接受余下参数的一个函数”。</p>\n</blockquote>\n<p>也就是说，如果满足柯里化思想，应该是这样的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> curryingAdd = currying(add, <span class=\"number\">5</span>);</div><div class=\"line\"></div><div class=\"line\">curryingAdd(<span class=\"number\">1</span>); <span class=\"comment\">// 6</span></div><div class=\"line\">curryingAdd(<span class=\"number\">2</span>); <span class=\"comment\">// 7</span></div></pre></td></tr></table></figure></p>\n<p>本来应该接收两个参数的 <code>add</code>，通过 <code>currying</code> 加工之后，可以用来接收余下的参数。</p>\n<p>上面的例子里面，其实就是把 <code>add</code> 接收的参数固定了一个，也就是 5，我们可以想到 <code>curryingAdd</code> 的一种简单实现。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> curryingAdd = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">curryingAdd(<span class=\"number\">5</span>)(<span class=\"number\">1</span>);  <span class=\"comment\">// 6</span></div></pre></td></tr></table></figure>\n<p>原理即是通过闭包保存了第一个变量。</p>\n<h2 id=\"currying-方法\"><a href=\"#currying-方法\" class=\"headerlink\" title=\"currying 方法\"></a>currying 方法</h2><p>那么将普通函数转变为柯里化函数的 <code>currying</code> 是如何实现的呢，通过 <code>curringAdd</code>，可以想到使用闭包来实现。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">currying</span>(<span class=\"params\">func</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 闭包保存固定参数</span></div><div class=\"line\">  <span class=\"keyword\">var</span> firstArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 将固定参数和新参数一起传入原函数</span></div><div class=\"line\">    <span class=\"keyword\">var</span> args = firstArgs.concat(<span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>));</div><div class=\"line\">    <span class=\"keyword\">return</span> func.apply(<span class=\"literal\">null</span>, args);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">currying(add, <span class=\"number\">5</span>)(<span class=\"number\">1</span>);  <span class=\"comment\">// 6</span></div></pre></td></tr></table></figure>\n<p>这种实现有一定的局限性，<code>curring</code> 方法的返回函数只能被执行一次，也就是我们不能这样调用：<code>currying(add)(1)(2)</code></p>\n<p>要满足灵活的调用，需要判断接收的参数个数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">currying</span>(<span class=\"params\">func</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 闭包保存固定参数</span></div><div class=\"line\">  <span class=\"keyword\">var</span> firstArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 原函数接收的参数个数</span></div><div class=\"line\">  <span class=\"keyword\">var</span> l = func.length;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inner</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 将固定参数和新参数一起传入原函数</span></div><div class=\"line\">    firstArgs = firstArgs.concat(<span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>));</div><div class=\"line\">    <span class=\"keyword\">if</span>(firstArgs.length &lt; l) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> inner;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> func.apply(<span class=\"literal\">null</span>, firstArgs);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">currying(add, <span class=\"number\">1</span>)(<span class=\"number\">5</span>);  <span class=\"comment\">// 6</span></div><div class=\"line\">currying(add)(<span class=\"number\">1</span>)(<span class=\"number\">5</span>);  <span class=\"comment\">// 6</span></div><div class=\"line\">currying(add)(<span class=\"number\">1</span>, <span class=\"number\">5</span>);  <span class=\"comment\">// 6</span></div></pre></td></tr></table></figure>\n<p>不过，我们还得考虑到原函数不用接收参数的情况，比如下面的 <code>sum</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> s = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = <span class=\"built_in\">arguments</span>.length; i &lt; len; i++) &#123;</div><div class=\"line\">    s += <span class=\"built_in\">arguments</span>[i];</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> s;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>sum</code> 可以接收任意个参数并返回它们的和，我们通过调整 <code>currying</code> 的判断条件来覆盖这种情况。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">currying</span>(<span class=\"params\">func</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 闭包保存固定参数</span></div><div class=\"line\">  <span class=\"keyword\">var</span> firstArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 原函数接收的参数个数</span></div><div class=\"line\">  <span class=\"keyword\">var</span> l = func.length;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inner</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 将固定参数和新参数一起传入原函数</span></div><div class=\"line\">    <span class=\"keyword\">var</span> newArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);</div><div class=\"line\">    firstArgs = firstArgs.concat(newArgs);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>((l == <span class=\"number\">0</span> &amp;&amp; newArgs.length == <span class=\"number\">0</span>) || (l &gt; <span class=\"number\">0</span> &amp;&amp; firstArgs.length == l)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 调用完成</span></div><div class=\"line\">      <span class=\"keyword\">return</span> func.apply(<span class=\"literal\">null</span>, firstArgs);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> inner;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">currying(sum, <span class=\"number\">1</span>)(<span class=\"number\">5</span>)();  <span class=\"comment\">// 6</span></div><div class=\"line\">currying(sum)(<span class=\"number\">1</span>)(<span class=\"number\">5</span>)(<span class=\"number\">6</span>)(<span class=\"number\">7</span>)();  <span class=\"comment\">// 19</span></div><div class=\"line\">currying(sum)(<span class=\"number\">1</span>)(<span class=\"number\">5</span>)(<span class=\"number\">6</span>, <span class=\"number\">7</span>)();  <span class=\"comment\">// 19</span></div><div class=\"line\"></div><div class=\"line\">currying(add, <span class=\"number\">1</span>)(<span class=\"number\">5</span>);  <span class=\"comment\">// 6</span></div><div class=\"line\">currying(add)(<span class=\"number\">1</span>)(<span class=\"number\">5</span>);  <span class=\"comment\">// 6</span></div><div class=\"line\">currying(add)(<span class=\"number\">1</span>, <span class=\"number\">5</span>);  <span class=\"comment\">// 6</span></div></pre></td></tr></table></figure>"},{"title":"基本数据结构（二）","date":"2016-07-26T15:39:57.000Z","_content":"\n通过 Javascript 实现各种基本数据结构。包括字典、散列表、图等。\n\n<!-- more -->\n\n## 字典\n\n字典存储一个键值对，相当于封装了对对象的操作，比较简单，不展开说明。\n\n### API\n- keys() 以数组形式返回字典包含的所有键名\n- has(key) 返回字典是否包含键值\n- set(key, value) 存储一个键值对\n- remove(key) 根据键值删除对应的键值对\n- get(key) 返回指定键名对应的值\n- values() 以数组形式返回字典内所有值\n- size() 返回字典内键值对的数量\n\n### 实现\n\n```javascript\nclass Dictionary {\n  constructor() {\n    this.items = {};\n  }\n\n  keys() {\n    return Object.keys(this.items);\n  }\n\n  has(key) {\n    return key in this.items;\n  }\n\n  set(key, value) {\n    this.items[key] = value;\n  }\n\n  remove(key) {\n    if(this.has(key)) {\n      delete this.items[key];\n      return true;\n    }\n    return false;\n  }\n\n  get(key) {\n    return this.has(key) ? this.items[key] : undefined;\n  }\n\n  values() {\n    let result = [];\n    for(let key in this.items) {\n      if(this.has(key)) {\n        result.push(this.items[key]);\n      }\n    }\n    return result;\n  }\n\n  size() {\n    return this.keys().length;\n  }\n}\n```\n\n## 散列表\n\n散列表是普通数组的推广，它是实现字典操作的一种有效数据结构。\n\n### API\n- put(key, value) 向散列表添加一个项\n- remove(key) 根据键值从散列表中移除值\n- get(key) 返回根据键值检索到的特定的值\n\n### 散列函数\n\n将数据插入到散列表的时候，需要通过散列函数来计算出这个数据存放的位置，这样每次取数据的时候，只需要再次通过散列函数计算便能知道数据的位置了。\n\n一个表现良好的散列函数是由几个方面构成的：插入和检索元素的时间（即性能），还包括较低的冲突可能性。比如如下散列函数：\n\n```javascript\nfunction djb2HashCode(key) {\n  let hash = 5381;\n  for(let i = 0; i < key.length; i++) {\n    hash = hash * 33 + key.charCodeAt(i);\n  }\n  return hash % 1013;\n}\n```\n\n当 key 为 `Gandalf` 时，该函数返回 `798`，代表该数据将存在数组下标为 798 的位置。\n\n显然，`put`、`remove` 和 `get` 方法都是围绕这个值来工作的。\n\n```javascript\nclass HashTable {\n  constructor() {\n    this.arr = [];\n  }\n\n  put(key, value) {\n    const position = djb2HashCode(key);\n    this.arr[position] = value;\n  }\n\n  remove(key) {\n    const position = djb2HashCode(key);\n    this.arr[position] = undefined;\n  }\n\n  get(key) {\n    const position = djb2HashCode(key);\n    return this.arr[position];\n  }\n}\n```\n\n### 解决冲突\n\n显然，这种方式存在一个致命的弱点：当两个 `key` 值计算出来的哈希值是相同的时候，两个元素将被插入同一个地方，后插入的元素将覆盖掉先插入的元素，这称为发生了冲突。\n\n处理冲突有几种方法：分离链接、线性探查和双散列法。\n\n#### 1. 分离链接\n\n分离链接在散列表的每个位置创建一个链表，存在相同位置的元素时，元素将被添加到链表的末尾。\n\n```javascript\nclass ValuePair {\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n  }\n\n  toString() {\n    return this.key + ',' + this.value;\n  }\n}\n\nclass HashTable {\n  constructor() {\n    this.arr = [];\n  }\n\n  put(key, value) {\n    const position = djb2HashCode(key);\n    let list = this.arr[position];\n    if(this.arr[position] == undefined) {\n      this.arr[position] = new LinkedList();\n    }\n    this.arr[position].append(new ValuePair(key, value));\n  }\n\n  remove(key) {\n    const position = djb2HashCode(key);\n    const list = this.arr[position];\n\n    if(list != undefined) {\n      let current = list.getHead();\n\n      while(current.next) {\n        if(current.element.key == key) {\n          list.remove(current.element);\n          if(list.isEmpty()) {\n            this.arr[position] = undefined;\n          }\n          return true;\n        }\n        current = current.next;\n      }\n\n      if(current.element.key == key) {\n        list.remove(current.element);\n        if(list.isEmpty()) {\n          this.arr[position] = undefined;\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n  get(key) {\n    const position = djb2HashCode(key);\n    const list = this.arr[position];\n\n    if(list != undefined) {\n      let current = list.getHead();\n      while(current.next) {\n        if(current.element.key == key) {\n          return current.element.value;\n        }\n        current = current.next;\n      }\n\n      if(current.element.key == key) {\n        return current.element.value;\n      }\n    }\n    return undefined;\n  }\n}\n```\n\n#### 2. 线性探查\n\n线性探查指当插入新元素时，如果索引为 `index` 的位置已经被占据了，就尝试 `index + 1` 的位置，如果 `index + 1` 的位置也被占据了，就尝试 `index + 2` 的位置，以此类推。\n\n```javascript\nclass HashTable {\n  constructor() {\n    this.arr = [];\n  }\n\n  put(key, value) {\n    const position = djb2HashCode(key);\n\n    if(this.arr[position] == undefined) {\n      this.arr[position] = new ValuePair(key, value);\n    } else {\n      let index = position + 1;\n      while(this.arr[index] != undefined) {\n        index++;\n      }\n      this.arr[index] = new ValuePair(key, value);\n    }\n  }\n\n  get(key) {\n    const position = djb2HashCode(key);\n\n    if(this.arr[position] != undefined) {\n      let index = position;\n      while(this.arr[index] != undefined) {\n        if(this.arr[index].key == key) {\n          return this.arr[index].value;\n        }\n        index++;\n      }\n    }\n\n    return undefined;\n  }\n\n  remove(key) {\n    const position = djb2HashCode(key);\n\n    if(this.arr[position] != undefined) {\n      let index = position;\n      while(this.arr[index] != undefined) {\n        if(this.arr[index].key == key) {\n          this.arr[index] = undefined;\n          // 重新调整散列表\n          for(let i = index; i < this.arr.length; i++) {\n            this.arr[i] = this.arr[i + 1];\n          }\n          this.arr.length--;\n          return true;\n        }\n        index++;\n      }\n    }\n\n    return false;\n  }\n}\n```\n\n使用线性探查需要注意的是：\n- 在一些语言中，需要定义数组的大小，当为占据的数据寻找下一个可用位置的时候，数组的可用位置可能会被用完，这就需要根据一些策略改变散列表的大小。但是 Javascript 里面不用担心这个问题，因为数组长度会根据需要自动改变大小。\n- 删除一个\n数据的时候，需要重新调整这个位置以及之后的数据，因为删除会使这个位置为空，造成之后查询这个位置时被认为没有这个数据。\n\n## 图\n\n### 基本概念\n- 相邻顶点：由一条边连接在一起的顶点\n- 度：一个顶点的度是其相邻顶点的数量\n- 路径：路径是顶点 v1, v2, ..., vk 的一个连续序列，其中 vi 和 v(i+1) 是相邻的\n- 简单路径：简单路径是不包含重复顶点的路径\n\n### 图的表示\n\n一个图 G=(V, E) 由以下元素组成：\n\n- V: 一组顶点\n- E: 一组边，连接 V 中的顶点\n\n![图](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/01.png)\n\n#### 邻接矩阵\n\n在矩阵中，索引为 i 的结点和索引为 j 的结点相邻，则 `arr[i][j] === 1`，否则 `arr[i][j] !== 1`。\n\n![邻接矩阵](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/02.png)\n\n在无向图中，矩阵是一个对称矩阵。\n\n#### 邻接表\n\n邻接表由图中每个顶点和每个顶点的相邻顶点列表组成。\n\n![邻接表](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/03.png)\n\n#### 关联矩阵\n\n关联矩阵中，矩阵的行表示顶点，列表示边。\n\n![关联矩阵](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/04.png)\n\n### 实现\n\n以邻接表描述图实现如下：\n\n```javascript\nclass Graph {\n  constructor() {\n    // 顶点集合\n    this.vertics = [];\n    // 邻接表\n    this.adjList = new Dictionary();\n  }\n\n  addVertex(v) {\n    this.vertics.push(v);\n    this.adjList.set(v, []);\n  }\n\n  addEdge(v, w) {\n    this.adjList.get(v).push(w);\n    this.adjList.get(w).push(v);\n  }\n\n  toString() {\n    let result = '';\n    for(let vertex of this.vertics) {\n      result += vertex + ' =>';\n      let neighbors = this.adjList.get(vertex);\n      for(let neighbor of neighbors) {\n        result += ' ' + neighbor;\n      }\n      result += '\\n';\n    }\n    return result;\n  }\n}\n```\n\n### 图的遍历\n\n图的遍历算法的思想是必须追踪每一个第一次访问的结点，并且追踪有哪些结点还没有被完全探索。对于图的两种遍历算法，都需要明确指定第一个被访问的结点。\n\n我们用三种颜色来标注顶点，用来表示它们的状态：\n\n- 白色：表示该顶点还没有被访问过\n- 灰色：表示该顶点被访问过，但没有被探索过\n- 黑色：表示该顶点被访问且已经被探索\n\n#### 广度优先搜索(Breadth-First Search, BFS)\n\n![广度优先搜索](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/05.png)\n\n广度优先搜素先宽后深访问顶点，从顶点 v 开始的 BFS 算法步骤如下：\n\n1. 创建一个队列 Q\n2. 将 v 标注为灰色，并将 v 入队列\n3. 如果 Q 非空，则运行以下步骤：\n   a) 队首 u 出队列\n   b) 将 u 标记为灰色\n   c) 将 u 所有白色相邻顶点入队列\n   d) 将 u 标注为黑色\n\n```javascript\nclass Graph {\n  //...\n\n  initColor() {\n    const colors = [];\n    for(let vertex of this.vertics) {\n      colors[vertex] = 'white';\n    }\n    return colors;\n  }\n\n  bfs(v, callback) {\n    const colors = this.initColor();\n    const queue = new Queue();\n\n    queue.enqueue(v);\n    colors[v] = 'gray';\n\n    while(!queue.isEmpty()) {\n      let curVertex = queue.dequeue();\n      let neighbors = this.adjList.get(curVertex);\n      // 遍历当前结点的相邻结点\n      for(let neighbor of neighbors) {\n        // 将未访问的结点插入队列并标记为未探索\n        if(colors[neighbor] == 'white') {\n          queue.enqueue(neighbor);\n          colors[neighbor] = 'gray';\n        }\n      }\n      // 当前结点已经探索完\n      colors[curVertex] = 'black';\n      callback && callback(curVertex);\n    }\n  }\n}\n```\n\n\n#### 深度优先搜索(Depth-First Search, DFS)\n\n![深度优先搜索](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/06.png)\n\n广度优先搜素先深后宽访问顶点，从顶点 v 开始的 DFS 算法步骤如下：\n\n1. 将 v 标注为灰色\n2. 对 v 的所有白色相邻顶点 w ：\n   a) 访问 w\n3. 将 v 标记为黑色\n\n```javascript\nclass Graph {\n  //...\n\n  initColor() {\n    const colors = [];\n    for(let vertex of this.vertics) {\n      colors[vertex] = 'white';\n    }\n    return colors;\n  }\n\n  dfs(v, callback) {\n    const colors = this.initColor();\n\n    var dfsVisit = (v) => {\n      // 访问当前结点\n      colors[v] = 'gray';\n\n      callback && callback(v);\n\n      let neighbors = this.adjList.get(v);\n      // 探索当前结点\n      for(let neighbor of neighbors) {\n        if(colors[neighbor] == 'white') {\n          dfsVisit(neighbor);\n        }\n      }\n      colors[v] = 'black';\n    }\n\n    dfsVisit(v);\n  }\n}\n```\n\n#### 结果\n\n```javascript\nvar graph = new Graph();\nvar vertics = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'];\nfor(let vertex of vertics) {\n  graph.addVertex(vertex);\n}\n\ngraph.addEdge('A', 'B');\ngraph.addEdge('A', 'C');\ngraph.addEdge('A', 'D');\ngraph.addEdge('C', 'D');\ngraph.addEdge('C', 'G');\ngraph.addEdge('D', 'G');\ngraph.addEdge('D', 'H');\ngraph.addEdge('B', 'E');\ngraph.addEdge('B', 'F');\ngraph.addEdge('E', 'I');\n\n/**\n * 广度优先\n * A\n * B\n * C\n * D\n * E\n * F\n * G\n * H\n * I\n */\ngraph.bfs('A', v => console.log(v))\n\n/**\n * 深度优先\n * A\n * B\n * E\n * I\n * F\n * C\n * D\n * H\n * G\n */\ngraph.dfs('A', v => console.log(v))\n```","source":"_posts/data-structures-2.md","raw":"---\ntitle: 基本数据结构（二）\ndate: 2016-07-26 23:39:57\ntags: [每周总结, 数据结构]\n---\n\n通过 Javascript 实现各种基本数据结构。包括字典、散列表、图等。\n\n<!-- more -->\n\n## 字典\n\n字典存储一个键值对，相当于封装了对对象的操作，比较简单，不展开说明。\n\n### API\n- keys() 以数组形式返回字典包含的所有键名\n- has(key) 返回字典是否包含键值\n- set(key, value) 存储一个键值对\n- remove(key) 根据键值删除对应的键值对\n- get(key) 返回指定键名对应的值\n- values() 以数组形式返回字典内所有值\n- size() 返回字典内键值对的数量\n\n### 实现\n\n```javascript\nclass Dictionary {\n  constructor() {\n    this.items = {};\n  }\n\n  keys() {\n    return Object.keys(this.items);\n  }\n\n  has(key) {\n    return key in this.items;\n  }\n\n  set(key, value) {\n    this.items[key] = value;\n  }\n\n  remove(key) {\n    if(this.has(key)) {\n      delete this.items[key];\n      return true;\n    }\n    return false;\n  }\n\n  get(key) {\n    return this.has(key) ? this.items[key] : undefined;\n  }\n\n  values() {\n    let result = [];\n    for(let key in this.items) {\n      if(this.has(key)) {\n        result.push(this.items[key]);\n      }\n    }\n    return result;\n  }\n\n  size() {\n    return this.keys().length;\n  }\n}\n```\n\n## 散列表\n\n散列表是普通数组的推广，它是实现字典操作的一种有效数据结构。\n\n### API\n- put(key, value) 向散列表添加一个项\n- remove(key) 根据键值从散列表中移除值\n- get(key) 返回根据键值检索到的特定的值\n\n### 散列函数\n\n将数据插入到散列表的时候，需要通过散列函数来计算出这个数据存放的位置，这样每次取数据的时候，只需要再次通过散列函数计算便能知道数据的位置了。\n\n一个表现良好的散列函数是由几个方面构成的：插入和检索元素的时间（即性能），还包括较低的冲突可能性。比如如下散列函数：\n\n```javascript\nfunction djb2HashCode(key) {\n  let hash = 5381;\n  for(let i = 0; i < key.length; i++) {\n    hash = hash * 33 + key.charCodeAt(i);\n  }\n  return hash % 1013;\n}\n```\n\n当 key 为 `Gandalf` 时，该函数返回 `798`，代表该数据将存在数组下标为 798 的位置。\n\n显然，`put`、`remove` 和 `get` 方法都是围绕这个值来工作的。\n\n```javascript\nclass HashTable {\n  constructor() {\n    this.arr = [];\n  }\n\n  put(key, value) {\n    const position = djb2HashCode(key);\n    this.arr[position] = value;\n  }\n\n  remove(key) {\n    const position = djb2HashCode(key);\n    this.arr[position] = undefined;\n  }\n\n  get(key) {\n    const position = djb2HashCode(key);\n    return this.arr[position];\n  }\n}\n```\n\n### 解决冲突\n\n显然，这种方式存在一个致命的弱点：当两个 `key` 值计算出来的哈希值是相同的时候，两个元素将被插入同一个地方，后插入的元素将覆盖掉先插入的元素，这称为发生了冲突。\n\n处理冲突有几种方法：分离链接、线性探查和双散列法。\n\n#### 1. 分离链接\n\n分离链接在散列表的每个位置创建一个链表，存在相同位置的元素时，元素将被添加到链表的末尾。\n\n```javascript\nclass ValuePair {\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n  }\n\n  toString() {\n    return this.key + ',' + this.value;\n  }\n}\n\nclass HashTable {\n  constructor() {\n    this.arr = [];\n  }\n\n  put(key, value) {\n    const position = djb2HashCode(key);\n    let list = this.arr[position];\n    if(this.arr[position] == undefined) {\n      this.arr[position] = new LinkedList();\n    }\n    this.arr[position].append(new ValuePair(key, value));\n  }\n\n  remove(key) {\n    const position = djb2HashCode(key);\n    const list = this.arr[position];\n\n    if(list != undefined) {\n      let current = list.getHead();\n\n      while(current.next) {\n        if(current.element.key == key) {\n          list.remove(current.element);\n          if(list.isEmpty()) {\n            this.arr[position] = undefined;\n          }\n          return true;\n        }\n        current = current.next;\n      }\n\n      if(current.element.key == key) {\n        list.remove(current.element);\n        if(list.isEmpty()) {\n          this.arr[position] = undefined;\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n  get(key) {\n    const position = djb2HashCode(key);\n    const list = this.arr[position];\n\n    if(list != undefined) {\n      let current = list.getHead();\n      while(current.next) {\n        if(current.element.key == key) {\n          return current.element.value;\n        }\n        current = current.next;\n      }\n\n      if(current.element.key == key) {\n        return current.element.value;\n      }\n    }\n    return undefined;\n  }\n}\n```\n\n#### 2. 线性探查\n\n线性探查指当插入新元素时，如果索引为 `index` 的位置已经被占据了，就尝试 `index + 1` 的位置，如果 `index + 1` 的位置也被占据了，就尝试 `index + 2` 的位置，以此类推。\n\n```javascript\nclass HashTable {\n  constructor() {\n    this.arr = [];\n  }\n\n  put(key, value) {\n    const position = djb2HashCode(key);\n\n    if(this.arr[position] == undefined) {\n      this.arr[position] = new ValuePair(key, value);\n    } else {\n      let index = position + 1;\n      while(this.arr[index] != undefined) {\n        index++;\n      }\n      this.arr[index] = new ValuePair(key, value);\n    }\n  }\n\n  get(key) {\n    const position = djb2HashCode(key);\n\n    if(this.arr[position] != undefined) {\n      let index = position;\n      while(this.arr[index] != undefined) {\n        if(this.arr[index].key == key) {\n          return this.arr[index].value;\n        }\n        index++;\n      }\n    }\n\n    return undefined;\n  }\n\n  remove(key) {\n    const position = djb2HashCode(key);\n\n    if(this.arr[position] != undefined) {\n      let index = position;\n      while(this.arr[index] != undefined) {\n        if(this.arr[index].key == key) {\n          this.arr[index] = undefined;\n          // 重新调整散列表\n          for(let i = index; i < this.arr.length; i++) {\n            this.arr[i] = this.arr[i + 1];\n          }\n          this.arr.length--;\n          return true;\n        }\n        index++;\n      }\n    }\n\n    return false;\n  }\n}\n```\n\n使用线性探查需要注意的是：\n- 在一些语言中，需要定义数组的大小，当为占据的数据寻找下一个可用位置的时候，数组的可用位置可能会被用完，这就需要根据一些策略改变散列表的大小。但是 Javascript 里面不用担心这个问题，因为数组长度会根据需要自动改变大小。\n- 删除一个\n数据的时候，需要重新调整这个位置以及之后的数据，因为删除会使这个位置为空，造成之后查询这个位置时被认为没有这个数据。\n\n## 图\n\n### 基本概念\n- 相邻顶点：由一条边连接在一起的顶点\n- 度：一个顶点的度是其相邻顶点的数量\n- 路径：路径是顶点 v1, v2, ..., vk 的一个连续序列，其中 vi 和 v(i+1) 是相邻的\n- 简单路径：简单路径是不包含重复顶点的路径\n\n### 图的表示\n\n一个图 G=(V, E) 由以下元素组成：\n\n- V: 一组顶点\n- E: 一组边，连接 V 中的顶点\n\n![图](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/01.png)\n\n#### 邻接矩阵\n\n在矩阵中，索引为 i 的结点和索引为 j 的结点相邻，则 `arr[i][j] === 1`，否则 `arr[i][j] !== 1`。\n\n![邻接矩阵](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/02.png)\n\n在无向图中，矩阵是一个对称矩阵。\n\n#### 邻接表\n\n邻接表由图中每个顶点和每个顶点的相邻顶点列表组成。\n\n![邻接表](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/03.png)\n\n#### 关联矩阵\n\n关联矩阵中，矩阵的行表示顶点，列表示边。\n\n![关联矩阵](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/04.png)\n\n### 实现\n\n以邻接表描述图实现如下：\n\n```javascript\nclass Graph {\n  constructor() {\n    // 顶点集合\n    this.vertics = [];\n    // 邻接表\n    this.adjList = new Dictionary();\n  }\n\n  addVertex(v) {\n    this.vertics.push(v);\n    this.adjList.set(v, []);\n  }\n\n  addEdge(v, w) {\n    this.adjList.get(v).push(w);\n    this.adjList.get(w).push(v);\n  }\n\n  toString() {\n    let result = '';\n    for(let vertex of this.vertics) {\n      result += vertex + ' =>';\n      let neighbors = this.adjList.get(vertex);\n      for(let neighbor of neighbors) {\n        result += ' ' + neighbor;\n      }\n      result += '\\n';\n    }\n    return result;\n  }\n}\n```\n\n### 图的遍历\n\n图的遍历算法的思想是必须追踪每一个第一次访问的结点，并且追踪有哪些结点还没有被完全探索。对于图的两种遍历算法，都需要明确指定第一个被访问的结点。\n\n我们用三种颜色来标注顶点，用来表示它们的状态：\n\n- 白色：表示该顶点还没有被访问过\n- 灰色：表示该顶点被访问过，但没有被探索过\n- 黑色：表示该顶点被访问且已经被探索\n\n#### 广度优先搜索(Breadth-First Search, BFS)\n\n![广度优先搜索](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/05.png)\n\n广度优先搜素先宽后深访问顶点，从顶点 v 开始的 BFS 算法步骤如下：\n\n1. 创建一个队列 Q\n2. 将 v 标注为灰色，并将 v 入队列\n3. 如果 Q 非空，则运行以下步骤：\n   a) 队首 u 出队列\n   b) 将 u 标记为灰色\n   c) 将 u 所有白色相邻顶点入队列\n   d) 将 u 标注为黑色\n\n```javascript\nclass Graph {\n  //...\n\n  initColor() {\n    const colors = [];\n    for(let vertex of this.vertics) {\n      colors[vertex] = 'white';\n    }\n    return colors;\n  }\n\n  bfs(v, callback) {\n    const colors = this.initColor();\n    const queue = new Queue();\n\n    queue.enqueue(v);\n    colors[v] = 'gray';\n\n    while(!queue.isEmpty()) {\n      let curVertex = queue.dequeue();\n      let neighbors = this.adjList.get(curVertex);\n      // 遍历当前结点的相邻结点\n      for(let neighbor of neighbors) {\n        // 将未访问的结点插入队列并标记为未探索\n        if(colors[neighbor] == 'white') {\n          queue.enqueue(neighbor);\n          colors[neighbor] = 'gray';\n        }\n      }\n      // 当前结点已经探索完\n      colors[curVertex] = 'black';\n      callback && callback(curVertex);\n    }\n  }\n}\n```\n\n\n#### 深度优先搜索(Depth-First Search, DFS)\n\n![深度优先搜索](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/06.png)\n\n广度优先搜素先深后宽访问顶点，从顶点 v 开始的 DFS 算法步骤如下：\n\n1. 将 v 标注为灰色\n2. 对 v 的所有白色相邻顶点 w ：\n   a) 访问 w\n3. 将 v 标记为黑色\n\n```javascript\nclass Graph {\n  //...\n\n  initColor() {\n    const colors = [];\n    for(let vertex of this.vertics) {\n      colors[vertex] = 'white';\n    }\n    return colors;\n  }\n\n  dfs(v, callback) {\n    const colors = this.initColor();\n\n    var dfsVisit = (v) => {\n      // 访问当前结点\n      colors[v] = 'gray';\n\n      callback && callback(v);\n\n      let neighbors = this.adjList.get(v);\n      // 探索当前结点\n      for(let neighbor of neighbors) {\n        if(colors[neighbor] == 'white') {\n          dfsVisit(neighbor);\n        }\n      }\n      colors[v] = 'black';\n    }\n\n    dfsVisit(v);\n  }\n}\n```\n\n#### 结果\n\n```javascript\nvar graph = new Graph();\nvar vertics = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'];\nfor(let vertex of vertics) {\n  graph.addVertex(vertex);\n}\n\ngraph.addEdge('A', 'B');\ngraph.addEdge('A', 'C');\ngraph.addEdge('A', 'D');\ngraph.addEdge('C', 'D');\ngraph.addEdge('C', 'G');\ngraph.addEdge('D', 'G');\ngraph.addEdge('D', 'H');\ngraph.addEdge('B', 'E');\ngraph.addEdge('B', 'F');\ngraph.addEdge('E', 'I');\n\n/**\n * 广度优先\n * A\n * B\n * C\n * D\n * E\n * F\n * G\n * H\n * I\n */\ngraph.bfs('A', v => console.log(v))\n\n/**\n * 深度优先\n * A\n * B\n * E\n * I\n * F\n * C\n * D\n * H\n * G\n */\ngraph.dfs('A', v => console.log(v))\n```","slug":"data-structures-2","published":1,"updated":"2016-08-27T00:03:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscgyh1b000fgq27n29vj4g8","content":"<p>通过 Javascript 实现各种基本数据结构。包括字典、散列表、图等。</p>\n<a id=\"more\"></a>\n<h2 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h2><p>字典存储一个键值对，相当于封装了对对象的操作，比较简单，不展开说明。</p>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>keys() 以数组形式返回字典包含的所有键名</li>\n<li>has(key) 返回字典是否包含键值</li>\n<li>set(key, value) 存储一个键值对</li>\n<li>remove(key) 根据键值删除对应的键值对</li>\n<li>get(key) 返回指定键名对应的值</li>\n<li>values() 以数组形式返回字典内所有值</li>\n<li>size() 返回字典内键值对的数量</li>\n</ul>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dictionary</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.items = &#123;&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  keys() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(<span class=\"keyword\">this</span>.items);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  has(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> key <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.items;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  set(key, value) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.items[key] = value;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  remove(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.has(key)) &#123;</div><div class=\"line\">      <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>.items[key];</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  get(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.has(key) ? <span class=\"keyword\">this</span>.items[key] : <span class=\"literal\">undefined</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  values() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> result = [];</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.items) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.has(key)) &#123;</div><div class=\"line\">        result.push(<span class=\"keyword\">this</span>.items[key]);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  size() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.keys().length;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h2><p>散列表是普通数组的推广，它是实现字典操作的一种有效数据结构。</p>\n<h3 id=\"API-1\"><a href=\"#API-1\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>put(key, value) 向散列表添加一个项</li>\n<li>remove(key) 根据键值从散列表中移除值</li>\n<li>get(key) 返回根据键值检索到的特定的值</li>\n</ul>\n<h3 id=\"散列函数\"><a href=\"#散列函数\" class=\"headerlink\" title=\"散列函数\"></a>散列函数</h3><p>将数据插入到散列表的时候，需要通过散列函数来计算出这个数据存放的位置，这样每次取数据的时候，只需要再次通过散列函数计算便能知道数据的位置了。</p>\n<p>一个表现良好的散列函数是由几个方面构成的：插入和检索元素的时间（即性能），还包括较低的冲突可能性。比如如下散列函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">djb2HashCode</span>(<span class=\"params\">key</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> hash = <span class=\"number\">5381</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; key.length; i++) &#123;</div><div class=\"line\">    hash = hash * <span class=\"number\">33</span> + key.charCodeAt(i);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> hash % <span class=\"number\">1013</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当 key 为 <code>Gandalf</code> 时，该函数返回 <code>798</code>，代表该数据将存在数组下标为 798 的位置。</p>\n<p>显然，<code>put</code>、<code>remove</code> 和 <code>get</code> 方法都是围绕这个值来工作的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTable</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr = [];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  put(key, value) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr[position] = value;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  remove(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr[position] = <span class=\"literal\">undefined</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  get(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr[position];</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"解决冲突\"><a href=\"#解决冲突\" class=\"headerlink\" title=\"解决冲突\"></a>解决冲突</h3><p>显然，这种方式存在一个致命的弱点：当两个 <code>key</code> 值计算出来的哈希值是相同的时候，两个元素将被插入同一个地方，后插入的元素将覆盖掉先插入的元素，这称为发生了冲突。</p>\n<p>处理冲突有几种方法：分离链接、线性探查和双散列法。</p>\n<h4 id=\"1-分离链接\"><a href=\"#1-分离链接\" class=\"headerlink\" title=\"1. 分离链接\"></a>1. 分离链接</h4><p>分离链接在散列表的每个位置创建一个链表，存在相同位置的元素时，元素将被添加到链表的末尾。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ValuePair</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(key, value) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.key = key;</div><div class=\"line\">    <span class=\"keyword\">this</span>.value = value;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.key + <span class=\"string\">','</span> + <span class=\"keyword\">this</span>.value;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTable</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr = [];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  put(key, value) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\">    <span class=\"keyword\">let</span> list = <span class=\"keyword\">this</span>.arr[position];</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.arr[position] == <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.arr[position] = <span class=\"keyword\">new</span> LinkedList();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr[position].append(<span class=\"keyword\">new</span> ValuePair(key, value));</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  remove(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\">    <span class=\"keyword\">const</span> list = <span class=\"keyword\">this</span>.arr[position];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(list != <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> current = list.getHead();</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">while</span>(current.next) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(current.element.key == key) &#123;</div><div class=\"line\">          list.remove(current.element);</div><div class=\"line\">          <span class=\"keyword\">if</span>(list.isEmpty()) &#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.arr[position] = <span class=\"literal\">undefined</span>;</div><div class=\"line\">          &#125;</div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        current = current.next;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span>(current.element.key == key) &#123;</div><div class=\"line\">        list.remove(current.element);</div><div class=\"line\">        <span class=\"keyword\">if</span>(list.isEmpty()) &#123;</div><div class=\"line\">          <span class=\"keyword\">this</span>.arr[position] = <span class=\"literal\">undefined</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  get(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\">    <span class=\"keyword\">const</span> list = <span class=\"keyword\">this</span>.arr[position];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(list != <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> current = list.getHead();</div><div class=\"line\">      <span class=\"keyword\">while</span>(current.next) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(current.element.key == key) &#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> current.element.value;</div><div class=\"line\">        &#125;</div><div class=\"line\">        current = current.next;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span>(current.element.key == key) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> current.element.value;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2-线性探查\"><a href=\"#2-线性探查\" class=\"headerlink\" title=\"2. 线性探查\"></a>2. 线性探查</h4><p>线性探查指当插入新元素时，如果索引为 <code>index</code> 的位置已经被占据了，就尝试 <code>index + 1</code> 的位置，如果 <code>index + 1</code> 的位置也被占据了，就尝试 <code>index + 2</code> 的位置，以此类推。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTable</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr = [];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  put(key, value) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.arr[position] == <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.arr[position] = <span class=\"keyword\">new</span> ValuePair(key, value);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> index = position + <span class=\"number\">1</span>;</div><div class=\"line\">      <span class=\"keyword\">while</span>(<span class=\"keyword\">this</span>.arr[index] != <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">        index++;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">this</span>.arr[index] = <span class=\"keyword\">new</span> ValuePair(key, value);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  get(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.arr[position] != <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> index = position;</div><div class=\"line\">      <span class=\"keyword\">while</span>(<span class=\"keyword\">this</span>.arr[index] != <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.arr[index].key == key) &#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr[index].value;</div><div class=\"line\">        &#125;</div><div class=\"line\">        index++;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  remove(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.arr[position] != <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> index = position;</div><div class=\"line\">      <span class=\"keyword\">while</span>(<span class=\"keyword\">this</span>.arr[index] != <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.arr[index].key == key) &#123;</div><div class=\"line\">          <span class=\"keyword\">this</span>.arr[index] = <span class=\"literal\">undefined</span>;</div><div class=\"line\">          <span class=\"comment\">// 重新调整散列表</span></div><div class=\"line\">          <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = index; i &lt; <span class=\"keyword\">this</span>.arr.length; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.arr[i] = <span class=\"keyword\">this</span>.arr[i + <span class=\"number\">1</span>];</div><div class=\"line\">          &#125;</div><div class=\"line\">          <span class=\"keyword\">this</span>.arr.length--;</div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        index++;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用线性探查需要注意的是：</p>\n<ul>\n<li>在一些语言中，需要定义数组的大小，当为占据的数据寻找下一个可用位置的时候，数组的可用位置可能会被用完，这就需要根据一些策略改变散列表的大小。但是 Javascript 里面不用担心这个问题，因为数组长度会根据需要自动改变大小。</li>\n<li>删除一个<br>数据的时候，需要重新调整这个位置以及之后的数据，因为删除会使这个位置为空，造成之后查询这个位置时被认为没有这个数据。</li>\n</ul>\n<h2 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul>\n<li>相邻顶点：由一条边连接在一起的顶点</li>\n<li>度：一个顶点的度是其相邻顶点的数量</li>\n<li>路径：路径是顶点 v1, v2, …, vk 的一个连续序列，其中 vi 和 v(i+1) 是相邻的</li>\n<li>简单路径：简单路径是不包含重复顶点的路径</li>\n</ul>\n<h3 id=\"图的表示\"><a href=\"#图的表示\" class=\"headerlink\" title=\"图的表示\"></a>图的表示</h3><p>一个图 G=(V, E) 由以下元素组成：</p>\n<ul>\n<li>V: 一组顶点</li>\n<li>E: 一组边，连接 V 中的顶点</li>\n</ul>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/01.png\" alt=\"图\"></p>\n<h4 id=\"邻接矩阵\"><a href=\"#邻接矩阵\" class=\"headerlink\" title=\"邻接矩阵\"></a>邻接矩阵</h4><p>在矩阵中，索引为 i 的结点和索引为 j 的结点相邻，则 <code>arr[i][j] === 1</code>，否则 <code>arr[i][j] !== 1</code>。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/02.png\" alt=\"邻接矩阵\"></p>\n<p>在无向图中，矩阵是一个对称矩阵。</p>\n<h4 id=\"邻接表\"><a href=\"#邻接表\" class=\"headerlink\" title=\"邻接表\"></a>邻接表</h4><p>邻接表由图中每个顶点和每个顶点的相邻顶点列表组成。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/03.png\" alt=\"邻接表\"></p>\n<h4 id=\"关联矩阵\"><a href=\"#关联矩阵\" class=\"headerlink\" title=\"关联矩阵\"></a>关联矩阵</h4><p>关联矩阵中，矩阵的行表示顶点，列表示边。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/04.png\" alt=\"关联矩阵\"></p>\n<h3 id=\"实现-1\"><a href=\"#实现-1\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>以邻接表描述图实现如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"comment\">// 顶点集合</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.vertics = [];</div><div class=\"line\">    <span class=\"comment\">// 邻接表</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.adjList = <span class=\"keyword\">new</span> Dictionary();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  addVertex(v) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.vertics.push(v);</div><div class=\"line\">    <span class=\"keyword\">this</span>.adjList.set(v, []);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  addEdge(v, w) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.adjList.get(v).push(w);</div><div class=\"line\">    <span class=\"keyword\">this</span>.adjList.get(w).push(v);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"string\">''</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> vertex <span class=\"keyword\">of</span> <span class=\"keyword\">this</span>.vertics) &#123;</div><div class=\"line\">      result += vertex + <span class=\"string\">' =&gt;'</span>;</div><div class=\"line\">      <span class=\"keyword\">let</span> neighbors = <span class=\"keyword\">this</span>.adjList.get(vertex);</div><div class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> neighbor <span class=\"keyword\">of</span> neighbors) &#123;</div><div class=\"line\">        result += <span class=\"string\">' '</span> + neighbor;</div><div class=\"line\">      &#125;</div><div class=\"line\">      result += <span class=\"string\">'\\n'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"图的遍历\"><a href=\"#图的遍历\" class=\"headerlink\" title=\"图的遍历\"></a>图的遍历</h3><p>图的遍历算法的思想是必须追踪每一个第一次访问的结点，并且追踪有哪些结点还没有被完全探索。对于图的两种遍历算法，都需要明确指定第一个被访问的结点。</p>\n<p>我们用三种颜色来标注顶点，用来表示它们的状态：</p>\n<ul>\n<li>白色：表示该顶点还没有被访问过</li>\n<li>灰色：表示该顶点被访问过，但没有被探索过</li>\n<li>黑色：表示该顶点被访问且已经被探索</li>\n</ul>\n<h4 id=\"广度优先搜索-Breadth-First-Search-BFS\"><a href=\"#广度优先搜索-Breadth-First-Search-BFS\" class=\"headerlink\" title=\"广度优先搜索(Breadth-First Search, BFS)\"></a>广度优先搜索(Breadth-First Search, BFS)</h4><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/05.png\" alt=\"广度优先搜索\"></p>\n<p>广度优先搜素先宽后深访问顶点，从顶点 v 开始的 BFS 算法步骤如下：</p>\n<ol>\n<li>创建一个队列 Q</li>\n<li>将 v 标注为灰色，并将 v 入队列</li>\n<li>如果 Q 非空，则运行以下步骤：<br>a) 队首 u 出队列<br>b) 将 u 标记为灰色<br>c) 将 u 所有白色相邻顶点入队列<br>d) 将 u 标注为黑色</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\"></div><div class=\"line\">  initColor() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> colors = [];</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> vertex <span class=\"keyword\">of</span> <span class=\"keyword\">this</span>.vertics) &#123;</div><div class=\"line\">      colors[vertex] = <span class=\"string\">'white'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> colors;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  bfs(v, callback) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> colors = <span class=\"keyword\">this</span>.initColor();</div><div class=\"line\">    <span class=\"keyword\">const</span> queue = <span class=\"keyword\">new</span> Queue();</div><div class=\"line\"></div><div class=\"line\">    queue.enqueue(v);</div><div class=\"line\">    colors[v] = <span class=\"string\">'gray'</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(!queue.isEmpty()) &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> curVertex = queue.dequeue();</div><div class=\"line\">      <span class=\"keyword\">let</span> neighbors = <span class=\"keyword\">this</span>.adjList.get(curVertex);</div><div class=\"line\">      <span class=\"comment\">// 遍历当前结点的相邻结点</span></div><div class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> neighbor <span class=\"keyword\">of</span> neighbors) &#123;</div><div class=\"line\">        <span class=\"comment\">// 将未访问的结点插入队列并标记为未探索</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(colors[neighbor] == <span class=\"string\">'white'</span>) &#123;</div><div class=\"line\">          queue.enqueue(neighbor);</div><div class=\"line\">          colors[neighbor] = <span class=\"string\">'gray'</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">// 当前结点已经探索完</span></div><div class=\"line\">      colors[curVertex] = <span class=\"string\">'black'</span>;</div><div class=\"line\">      callback &amp;&amp; callback(curVertex);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"深度优先搜索-Depth-First-Search-DFS\"><a href=\"#深度优先搜索-Depth-First-Search-DFS\" class=\"headerlink\" title=\"深度优先搜索(Depth-First Search, DFS)\"></a>深度优先搜索(Depth-First Search, DFS)</h4><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/06.png\" alt=\"深度优先搜索\"></p>\n<p>广度优先搜素先深后宽访问顶点，从顶点 v 开始的 DFS 算法步骤如下：</p>\n<ol>\n<li>将 v 标注为灰色</li>\n<li>对 v 的所有白色相邻顶点 w ：<br>a) 访问 w</li>\n<li>将 v 标记为黑色</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\"></div><div class=\"line\">  initColor() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> colors = [];</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> vertex <span class=\"keyword\">of</span> <span class=\"keyword\">this</span>.vertics) &#123;</div><div class=\"line\">      colors[vertex] = <span class=\"string\">'white'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> colors;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  dfs(v, callback) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> colors = <span class=\"keyword\">this</span>.initColor();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> dfsVisit = (v) =&gt; &#123;</div><div class=\"line\">      <span class=\"comment\">// 访问当前结点</span></div><div class=\"line\">      colors[v] = <span class=\"string\">'gray'</span>;</div><div class=\"line\"></div><div class=\"line\">      callback &amp;&amp; callback(v);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">let</span> neighbors = <span class=\"keyword\">this</span>.adjList.get(v);</div><div class=\"line\">      <span class=\"comment\">// 探索当前结点</span></div><div class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> neighbor <span class=\"keyword\">of</span> neighbors) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(colors[neighbor] == <span class=\"string\">'white'</span>) &#123;</div><div class=\"line\">          dfsVisit(neighbor);</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      colors[v] = <span class=\"string\">'black'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    dfsVisit(v);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> graph = <span class=\"keyword\">new</span> Graph();</div><div class=\"line\"><span class=\"keyword\">var</span> vertics = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>, <span class=\"string\">'D'</span>, <span class=\"string\">'E'</span>, <span class=\"string\">'F'</span>, <span class=\"string\">'G'</span>, <span class=\"string\">'H'</span>, <span class=\"string\">'I'</span>];</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> vertex <span class=\"keyword\">of</span> vertics) &#123;</div><div class=\"line\">  graph.addVertex(vertex);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">graph.addEdge(<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'A'</span>, <span class=\"string\">'C'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'A'</span>, <span class=\"string\">'D'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'C'</span>, <span class=\"string\">'D'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'C'</span>, <span class=\"string\">'G'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'D'</span>, <span class=\"string\">'G'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'D'</span>, <span class=\"string\">'H'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'B'</span>, <span class=\"string\">'E'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'B'</span>, <span class=\"string\">'F'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'E'</span>, <span class=\"string\">'I'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 广度优先</div><div class=\"line\"> * A</div><div class=\"line\"> * B</div><div class=\"line\"> * C</div><div class=\"line\"> * D</div><div class=\"line\"> * E</div><div class=\"line\"> * F</div><div class=\"line\"> * G</div><div class=\"line\"> * H</div><div class=\"line\"> * I</div><div class=\"line\"> */</div><div class=\"line\">graph.bfs(<span class=\"string\">'A'</span>, v =&gt; <span class=\"built_in\">console</span>.log(v))</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 深度优先</div><div class=\"line\"> * A</div><div class=\"line\"> * B</div><div class=\"line\"> * E</div><div class=\"line\"> * I</div><div class=\"line\"> * F</div><div class=\"line\"> * C</div><div class=\"line\"> * D</div><div class=\"line\"> * H</div><div class=\"line\"> * G</div><div class=\"line\"> */</div><div class=\"line\">graph.dfs(<span class=\"string\">'A'</span>, v =&gt; <span class=\"built_in\">console</span>.log(v))</div></pre></td></tr></table></figure>","excerpt":"<p>通过 Javascript 实现各种基本数据结构。包括字典、散列表、图等。</p>","more":"<h2 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h2><p>字典存储一个键值对，相当于封装了对对象的操作，比较简单，不展开说明。</p>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>keys() 以数组形式返回字典包含的所有键名</li>\n<li>has(key) 返回字典是否包含键值</li>\n<li>set(key, value) 存储一个键值对</li>\n<li>remove(key) 根据键值删除对应的键值对</li>\n<li>get(key) 返回指定键名对应的值</li>\n<li>values() 以数组形式返回字典内所有值</li>\n<li>size() 返回字典内键值对的数量</li>\n</ul>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dictionary</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.items = &#123;&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  keys() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(<span class=\"keyword\">this</span>.items);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  has(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> key <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.items;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  set(key, value) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.items[key] = value;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  remove(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.has(key)) &#123;</div><div class=\"line\">      <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>.items[key];</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  get(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.has(key) ? <span class=\"keyword\">this</span>.items[key] : <span class=\"literal\">undefined</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  values() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> result = [];</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.items) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.has(key)) &#123;</div><div class=\"line\">        result.push(<span class=\"keyword\">this</span>.items[key]);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  size() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.keys().length;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h2><p>散列表是普通数组的推广，它是实现字典操作的一种有效数据结构。</p>\n<h3 id=\"API-1\"><a href=\"#API-1\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>put(key, value) 向散列表添加一个项</li>\n<li>remove(key) 根据键值从散列表中移除值</li>\n<li>get(key) 返回根据键值检索到的特定的值</li>\n</ul>\n<h3 id=\"散列函数\"><a href=\"#散列函数\" class=\"headerlink\" title=\"散列函数\"></a>散列函数</h3><p>将数据插入到散列表的时候，需要通过散列函数来计算出这个数据存放的位置，这样每次取数据的时候，只需要再次通过散列函数计算便能知道数据的位置了。</p>\n<p>一个表现良好的散列函数是由几个方面构成的：插入和检索元素的时间（即性能），还包括较低的冲突可能性。比如如下散列函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">djb2HashCode</span>(<span class=\"params\">key</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> hash = <span class=\"number\">5381</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; key.length; i++) &#123;</div><div class=\"line\">    hash = hash * <span class=\"number\">33</span> + key.charCodeAt(i);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> hash % <span class=\"number\">1013</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当 key 为 <code>Gandalf</code> 时，该函数返回 <code>798</code>，代表该数据将存在数组下标为 798 的位置。</p>\n<p>显然，<code>put</code>、<code>remove</code> 和 <code>get</code> 方法都是围绕这个值来工作的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTable</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr = [];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  put(key, value) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr[position] = value;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  remove(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr[position] = <span class=\"literal\">undefined</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  get(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr[position];</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"解决冲突\"><a href=\"#解决冲突\" class=\"headerlink\" title=\"解决冲突\"></a>解决冲突</h3><p>显然，这种方式存在一个致命的弱点：当两个 <code>key</code> 值计算出来的哈希值是相同的时候，两个元素将被插入同一个地方，后插入的元素将覆盖掉先插入的元素，这称为发生了冲突。</p>\n<p>处理冲突有几种方法：分离链接、线性探查和双散列法。</p>\n<h4 id=\"1-分离链接\"><a href=\"#1-分离链接\" class=\"headerlink\" title=\"1. 分离链接\"></a>1. 分离链接</h4><p>分离链接在散列表的每个位置创建一个链表，存在相同位置的元素时，元素将被添加到链表的末尾。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ValuePair</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(key, value) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.key = key;</div><div class=\"line\">    <span class=\"keyword\">this</span>.value = value;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.key + <span class=\"string\">','</span> + <span class=\"keyword\">this</span>.value;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTable</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr = [];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  put(key, value) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\">    <span class=\"keyword\">let</span> list = <span class=\"keyword\">this</span>.arr[position];</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.arr[position] == <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.arr[position] = <span class=\"keyword\">new</span> LinkedList();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr[position].append(<span class=\"keyword\">new</span> ValuePair(key, value));</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  remove(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\">    <span class=\"keyword\">const</span> list = <span class=\"keyword\">this</span>.arr[position];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(list != <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> current = list.getHead();</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">while</span>(current.next) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(current.element.key == key) &#123;</div><div class=\"line\">          list.remove(current.element);</div><div class=\"line\">          <span class=\"keyword\">if</span>(list.isEmpty()) &#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.arr[position] = <span class=\"literal\">undefined</span>;</div><div class=\"line\">          &#125;</div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        current = current.next;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span>(current.element.key == key) &#123;</div><div class=\"line\">        list.remove(current.element);</div><div class=\"line\">        <span class=\"keyword\">if</span>(list.isEmpty()) &#123;</div><div class=\"line\">          <span class=\"keyword\">this</span>.arr[position] = <span class=\"literal\">undefined</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  get(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\">    <span class=\"keyword\">const</span> list = <span class=\"keyword\">this</span>.arr[position];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(list != <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> current = list.getHead();</div><div class=\"line\">      <span class=\"keyword\">while</span>(current.next) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(current.element.key == key) &#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> current.element.value;</div><div class=\"line\">        &#125;</div><div class=\"line\">        current = current.next;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span>(current.element.key == key) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> current.element.value;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2-线性探查\"><a href=\"#2-线性探查\" class=\"headerlink\" title=\"2. 线性探查\"></a>2. 线性探查</h4><p>线性探查指当插入新元素时，如果索引为 <code>index</code> 的位置已经被占据了，就尝试 <code>index + 1</code> 的位置，如果 <code>index + 1</code> 的位置也被占据了，就尝试 <code>index + 2</code> 的位置，以此类推。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTable</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr = [];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  put(key, value) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.arr[position] == <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.arr[position] = <span class=\"keyword\">new</span> ValuePair(key, value);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> index = position + <span class=\"number\">1</span>;</div><div class=\"line\">      <span class=\"keyword\">while</span>(<span class=\"keyword\">this</span>.arr[index] != <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">        index++;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">this</span>.arr[index] = <span class=\"keyword\">new</span> ValuePair(key, value);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  get(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.arr[position] != <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> index = position;</div><div class=\"line\">      <span class=\"keyword\">while</span>(<span class=\"keyword\">this</span>.arr[index] != <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.arr[index].key == key) &#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr[index].value;</div><div class=\"line\">        &#125;</div><div class=\"line\">        index++;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  remove(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> position = djb2HashCode(key);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.arr[position] != <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> index = position;</div><div class=\"line\">      <span class=\"keyword\">while</span>(<span class=\"keyword\">this</span>.arr[index] != <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.arr[index].key == key) &#123;</div><div class=\"line\">          <span class=\"keyword\">this</span>.arr[index] = <span class=\"literal\">undefined</span>;</div><div class=\"line\">          <span class=\"comment\">// 重新调整散列表</span></div><div class=\"line\">          <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = index; i &lt; <span class=\"keyword\">this</span>.arr.length; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.arr[i] = <span class=\"keyword\">this</span>.arr[i + <span class=\"number\">1</span>];</div><div class=\"line\">          &#125;</div><div class=\"line\">          <span class=\"keyword\">this</span>.arr.length--;</div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        index++;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用线性探查需要注意的是：</p>\n<ul>\n<li>在一些语言中，需要定义数组的大小，当为占据的数据寻找下一个可用位置的时候，数组的可用位置可能会被用完，这就需要根据一些策略改变散列表的大小。但是 Javascript 里面不用担心这个问题，因为数组长度会根据需要自动改变大小。</li>\n<li>删除一个<br>数据的时候，需要重新调整这个位置以及之后的数据，因为删除会使这个位置为空，造成之后查询这个位置时被认为没有这个数据。</li>\n</ul>\n<h2 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul>\n<li>相邻顶点：由一条边连接在一起的顶点</li>\n<li>度：一个顶点的度是其相邻顶点的数量</li>\n<li>路径：路径是顶点 v1, v2, …, vk 的一个连续序列，其中 vi 和 v(i+1) 是相邻的</li>\n<li>简单路径：简单路径是不包含重复顶点的路径</li>\n</ul>\n<h3 id=\"图的表示\"><a href=\"#图的表示\" class=\"headerlink\" title=\"图的表示\"></a>图的表示</h3><p>一个图 G=(V, E) 由以下元素组成：</p>\n<ul>\n<li>V: 一组顶点</li>\n<li>E: 一组边，连接 V 中的顶点</li>\n</ul>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/01.png\" alt=\"图\"></p>\n<h4 id=\"邻接矩阵\"><a href=\"#邻接矩阵\" class=\"headerlink\" title=\"邻接矩阵\"></a>邻接矩阵</h4><p>在矩阵中，索引为 i 的结点和索引为 j 的结点相邻，则 <code>arr[i][j] === 1</code>，否则 <code>arr[i][j] !== 1</code>。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/02.png\" alt=\"邻接矩阵\"></p>\n<p>在无向图中，矩阵是一个对称矩阵。</p>\n<h4 id=\"邻接表\"><a href=\"#邻接表\" class=\"headerlink\" title=\"邻接表\"></a>邻接表</h4><p>邻接表由图中每个顶点和每个顶点的相邻顶点列表组成。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/03.png\" alt=\"邻接表\"></p>\n<h4 id=\"关联矩阵\"><a href=\"#关联矩阵\" class=\"headerlink\" title=\"关联矩阵\"></a>关联矩阵</h4><p>关联矩阵中，矩阵的行表示顶点，列表示边。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/04.png\" alt=\"关联矩阵\"></p>\n<h3 id=\"实现-1\"><a href=\"#实现-1\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>以邻接表描述图实现如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"comment\">// 顶点集合</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.vertics = [];</div><div class=\"line\">    <span class=\"comment\">// 邻接表</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.adjList = <span class=\"keyword\">new</span> Dictionary();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  addVertex(v) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.vertics.push(v);</div><div class=\"line\">    <span class=\"keyword\">this</span>.adjList.set(v, []);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  addEdge(v, w) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.adjList.get(v).push(w);</div><div class=\"line\">    <span class=\"keyword\">this</span>.adjList.get(w).push(v);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"string\">''</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> vertex <span class=\"keyword\">of</span> <span class=\"keyword\">this</span>.vertics) &#123;</div><div class=\"line\">      result += vertex + <span class=\"string\">' =&gt;'</span>;</div><div class=\"line\">      <span class=\"keyword\">let</span> neighbors = <span class=\"keyword\">this</span>.adjList.get(vertex);</div><div class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> neighbor <span class=\"keyword\">of</span> neighbors) &#123;</div><div class=\"line\">        result += <span class=\"string\">' '</span> + neighbor;</div><div class=\"line\">      &#125;</div><div class=\"line\">      result += <span class=\"string\">'\\n'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"图的遍历\"><a href=\"#图的遍历\" class=\"headerlink\" title=\"图的遍历\"></a>图的遍历</h3><p>图的遍历算法的思想是必须追踪每一个第一次访问的结点，并且追踪有哪些结点还没有被完全探索。对于图的两种遍历算法，都需要明确指定第一个被访问的结点。</p>\n<p>我们用三种颜色来标注顶点，用来表示它们的状态：</p>\n<ul>\n<li>白色：表示该顶点还没有被访问过</li>\n<li>灰色：表示该顶点被访问过，但没有被探索过</li>\n<li>黑色：表示该顶点被访问且已经被探索</li>\n</ul>\n<h4 id=\"广度优先搜索-Breadth-First-Search-BFS\"><a href=\"#广度优先搜索-Breadth-First-Search-BFS\" class=\"headerlink\" title=\"广度优先搜索(Breadth-First Search, BFS)\"></a>广度优先搜索(Breadth-First Search, BFS)</h4><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/05.png\" alt=\"广度优先搜索\"></p>\n<p>广度优先搜素先宽后深访问顶点，从顶点 v 开始的 BFS 算法步骤如下：</p>\n<ol>\n<li>创建一个队列 Q</li>\n<li>将 v 标注为灰色，并将 v 入队列</li>\n<li>如果 Q 非空，则运行以下步骤：<br>a) 队首 u 出队列<br>b) 将 u 标记为灰色<br>c) 将 u 所有白色相邻顶点入队列<br>d) 将 u 标注为黑色</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\"></div><div class=\"line\">  initColor() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> colors = [];</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> vertex <span class=\"keyword\">of</span> <span class=\"keyword\">this</span>.vertics) &#123;</div><div class=\"line\">      colors[vertex] = <span class=\"string\">'white'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> colors;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  bfs(v, callback) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> colors = <span class=\"keyword\">this</span>.initColor();</div><div class=\"line\">    <span class=\"keyword\">const</span> queue = <span class=\"keyword\">new</span> Queue();</div><div class=\"line\"></div><div class=\"line\">    queue.enqueue(v);</div><div class=\"line\">    colors[v] = <span class=\"string\">'gray'</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(!queue.isEmpty()) &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> curVertex = queue.dequeue();</div><div class=\"line\">      <span class=\"keyword\">let</span> neighbors = <span class=\"keyword\">this</span>.adjList.get(curVertex);</div><div class=\"line\">      <span class=\"comment\">// 遍历当前结点的相邻结点</span></div><div class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> neighbor <span class=\"keyword\">of</span> neighbors) &#123;</div><div class=\"line\">        <span class=\"comment\">// 将未访问的结点插入队列并标记为未探索</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(colors[neighbor] == <span class=\"string\">'white'</span>) &#123;</div><div class=\"line\">          queue.enqueue(neighbor);</div><div class=\"line\">          colors[neighbor] = <span class=\"string\">'gray'</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">// 当前结点已经探索完</span></div><div class=\"line\">      colors[curVertex] = <span class=\"string\">'black'</span>;</div><div class=\"line\">      callback &amp;&amp; callback(curVertex);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"深度优先搜索-Depth-First-Search-DFS\"><a href=\"#深度优先搜索-Depth-First-Search-DFS\" class=\"headerlink\" title=\"深度优先搜索(Depth-First Search, DFS)\"></a>深度优先搜索(Depth-First Search, DFS)</h4><p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/data-structor-2/06.png\" alt=\"深度优先搜索\"></p>\n<p>广度优先搜素先深后宽访问顶点，从顶点 v 开始的 DFS 算法步骤如下：</p>\n<ol>\n<li>将 v 标注为灰色</li>\n<li>对 v 的所有白色相邻顶点 w ：<br>a) 访问 w</li>\n<li>将 v 标记为黑色</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\"></div><div class=\"line\">  initColor() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> colors = [];</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> vertex <span class=\"keyword\">of</span> <span class=\"keyword\">this</span>.vertics) &#123;</div><div class=\"line\">      colors[vertex] = <span class=\"string\">'white'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> colors;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  dfs(v, callback) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> colors = <span class=\"keyword\">this</span>.initColor();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> dfsVisit = (v) =&gt; &#123;</div><div class=\"line\">      <span class=\"comment\">// 访问当前结点</span></div><div class=\"line\">      colors[v] = <span class=\"string\">'gray'</span>;</div><div class=\"line\"></div><div class=\"line\">      callback &amp;&amp; callback(v);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">let</span> neighbors = <span class=\"keyword\">this</span>.adjList.get(v);</div><div class=\"line\">      <span class=\"comment\">// 探索当前结点</span></div><div class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> neighbor <span class=\"keyword\">of</span> neighbors) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(colors[neighbor] == <span class=\"string\">'white'</span>) &#123;</div><div class=\"line\">          dfsVisit(neighbor);</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      colors[v] = <span class=\"string\">'black'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    dfsVisit(v);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> graph = <span class=\"keyword\">new</span> Graph();</div><div class=\"line\"><span class=\"keyword\">var</span> vertics = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>, <span class=\"string\">'D'</span>, <span class=\"string\">'E'</span>, <span class=\"string\">'F'</span>, <span class=\"string\">'G'</span>, <span class=\"string\">'H'</span>, <span class=\"string\">'I'</span>];</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> vertex <span class=\"keyword\">of</span> vertics) &#123;</div><div class=\"line\">  graph.addVertex(vertex);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">graph.addEdge(<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'A'</span>, <span class=\"string\">'C'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'A'</span>, <span class=\"string\">'D'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'C'</span>, <span class=\"string\">'D'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'C'</span>, <span class=\"string\">'G'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'D'</span>, <span class=\"string\">'G'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'D'</span>, <span class=\"string\">'H'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'B'</span>, <span class=\"string\">'E'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'B'</span>, <span class=\"string\">'F'</span>);</div><div class=\"line\">graph.addEdge(<span class=\"string\">'E'</span>, <span class=\"string\">'I'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 广度优先</div><div class=\"line\"> * A</div><div class=\"line\"> * B</div><div class=\"line\"> * C</div><div class=\"line\"> * D</div><div class=\"line\"> * E</div><div class=\"line\"> * F</div><div class=\"line\"> * G</div><div class=\"line\"> * H</div><div class=\"line\"> * I</div><div class=\"line\"> */</span></div><div class=\"line\">graph.bfs(<span class=\"string\">'A'</span>, v =&gt; <span class=\"built_in\">console</span>.log(v))</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 深度优先</div><div class=\"line\"> * A</div><div class=\"line\"> * B</div><div class=\"line\"> * E</div><div class=\"line\"> * I</div><div class=\"line\"> * F</div><div class=\"line\"> * C</div><div class=\"line\"> * D</div><div class=\"line\"> * H</div><div class=\"line\"> * G</div><div class=\"line\"> */</span></div><div class=\"line\">graph.dfs(<span class=\"string\">'A'</span>, v =&gt; <span class=\"built_in\">console</span>.log(v))</div></pre></td></tr></table></figure>"},{"title":"基本数据结构（一）","date":"2016-07-24T05:39:57.000Z","_content":"\n通过 Javascript 实现各种基本数据结构。包括栈、队列、链表、集合等\n\n<!-- more -->\n\n## 栈\n\n栈算是相对来说最简单的数据结构了，遵循后进先出原则，可以通过维护一个数组来实现一个栈类。\n\n### API\n- push(ele1, [ele2, ...]) 添加一个或多个元素到栈顶\n- pop() 弹出栈顶元素\n- peek() 返回栈顶元素，但不弹出它\n- isEmpty() 如果栈为空，则返回 true，否则返回 false\n- clear() 清空栈\n- size() 返回栈中元素个数\n\n### 实现\n```javascript\nclass Stack {\n  constructor() {\n    this.arr = [];\n  }\n\n  /**\n   * 出栈\n   * @return 栈顶元素\n   */\n  pop() {\n    if(this.isEmpty()) {\n      throw new Error('stack underflow error');\n    }\n    return this.arr.pop();\n  }\n\n  /**\n   * 入栈\n   * @params  新元素\n   */\n  push() {\n    const args = Array.from(arguments);\n    if(args.length == 0) {\n      throw new Error('缺少参数');\n    }\n    for(let ele of args) {\n      this.arr.push(ele);\n    }\n  }\n\n  /**\n   * 返回栈顶元素但不出栈\n   * @return 栈顶元素\n   */\n  peek() {\n    if(this.isEmpty) {\n      throw new Error('该栈为空栈');\n    }\n    return this.arr[this.arr.length - 1];\n  }\n\n  /**\n   * 是否为空栈\n   * @return boolean 是否为空栈\n   */\n  isEmpty() {\n    return this.size() == 0;\n  }\n\n  /**\n   * 栈的大小\n   * @return number 栈的大小\n   */\n  size() {\n    return this.arr.length;\n  }\n\n  /**\n   * 清空栈\n   */\n  clear() {\n    this.arr = [];\n  }\n\n  /**\n   * 打印栈中元素\n   * @return string 栈中所有元素\n   */\n  print() {\n    console.log(this.arr.toString());\n  }\n}\n```\n\n### 应用\n\n#### 十进制转其他进制\n\n我们可以使用栈来解决进制转换的问题，从十进制转指定的进制实际上是让十进制数除以进制的基数，再将得到的结果继续作被除数，一直到商为 0 为止。将每次的余数压栈，最后让栈依次弹出，连接成的字符串即为转换后的数。\n\n```javascript\nfunction baseConverter(decNumber, base) {\n  const stack = new Stack();\n  const digits = '0123456789ABCDEF';\n  let result = '';\n\n  while(decNumber > 0) {\n    let rem = Math.floor(decNumber % base);\n    stack.push(digits[rem]);\n    decNumber = Math.floor(decNumber / base);\n  }\n\n  while(!stack.isEmpty()) {\n    result += stack.pop();\n  }\n\n  return result;\n}\n\nconsole.log(baseConverter(100345, 2)); // 11000011111111001\nconsole.log(baseConverter(100345, 8));  // 303771\nconsole.log(baseConverter(100345, 16)); // 187F9\n```\n\n## 队列\n\n队列和栈很类似，但遵循先进先出原则。\n\n### API\n- enqueue(ele1, [ele2, ...]) 向队尾添加一个或多个元素\n- dequeue() 移除队首元素，并返回\n- front() 返回队首元素，但不移除它\n- isEmpty() 队列为空时，返回 true，否则返回 false\n- size() 返回队列中元素个数\n- clear() 清空队列\n- print() 打印队列\n\n### 实现\n```javascript\nclass Queue {\n  constructor() {\n    this.arr = [];\n  }\n\n  enqueue() {\n    const args = Array.from(arguments);\n    if(args.length == 0) {\n      throw new Error('缺少参数');\n    }\n    for(let ele of args) {\n      this.arr.push(ele);\n    }\n  }\n\n  dequeue() {\n    if(this.isEmpty()) {\n      throw new Error('queue is empty');\n    }\n    return this.arr.shift();\n  }\n\n  front() {\n    if(this.isEmpty()) {\n      throw new Error('queue is empty');\n    }\n    return this.arr[0];\n  }\n\n  isEmpty() {\n    return this.size() == 0;\n  }\n\n  size() {\n    return this.arr.length;\n  }\n\n  clear() {\n    this.arr = [];\n  }\n\n  print() {\n    console.log(this.arr.toString());\n  }\n}\n```\n\n### 应用\n\n#### 优先队列\n\n优先队列中的每个元素都有一个优先级，优先级的数字越小，优先级越高。为了使优先级越高的元素越先出队列，添加该元素的时候，会根据它的优先级将它插入到合适的位置。\n\n```javascript\nclass PriorityQueue extends Queue{\n  constructor(...args) {\n    super(...args);\n  }\n\n  enqueue(element, priority) {\n    const ele = {\n      element: element,\n      priority: priority\n    };\n\n    if(this.isEmpty()) {\n      this.arr.push(ele);\n      return;\n    }\n\n    let added = false;\n    for(let i in this.arr) {\n      if(priority < this.arr[i].priority) {\n        this.arr.splice(i, 0, ele);\n        added = true;\n        break;\n      }\n    }\n\n    if(!added) {\n      this.arr.push(ele);\n    }\n  }\n\n  print() {\n    console.log(this.arr.map((item) => {\n      return item.element;\n    }).join(','));\n  }\n}\n\nlet priorityQueue = new PriorityQueue();\npriorityQueue.enqueue('john', 2);\npriorityQueue.enqueue('jack', 1);\npriorityQueue.enqueue('mark', 3);\npriorityQueue.enqueue('camila', 1); \npriorityQueue.print();  // jack,camila,john,mark\n```\n\n#### 循环队列——击鼓传花\n\n假设有一圈小孩围着坐，将一朵花交给队首的小孩，小孩依次将花传给下一个小孩，当传到队尾的时候，再将花传给队首的小孩，也就是队列首尾相连，形成了一个循环队列。\n\n在“击鼓传花”游戏中，给定一个数字，当传递次数达到这个次数时，淘汰掉此时拿花的小孩，再进行下一轮，直到只有一个小孩（胜者）。\n\n```javascript\nfunction hotPotato(nameList, num) {\n  const queue = new Queue();\n\n  // 小孩入列\n  for (let name of nameList) {\n    queue.enqueue(name);\n  }\n\n  while(queue.size() > 1) {\n    for(let i = 0; i < num; i++) {\n      // 将队首的小孩放到队尾\n      queue.enqueue(queue.dequeue());\n    }\n    // 淘汰\n    console.log(queue.dequeue() + ' 被淘汰了。');\n  }\n\n  return queue.dequeue();\n}\n\nlet nameList = ['John', 'Jack', 'Camila', 'Ingrid', 'Carl'];\nlet winner = hotPotato(nameList, 7);\n/**\n * Camila 被淘汰了。\n * Jack 被淘汰了。\n * Carl 被淘汰了。\n * Ingrid 被淘汰了。\n * winner: John\n */\nconsole.log('winner: ' + winner);\n```\n\n## 链表\n\n链表存储有序的元素集合，但不同于数组，链表中的元素在内存中不是连续放置的，每个元素由一个存储元素本身的结点和一个指向下一个元素的引用组成。\n\n### API\n- append(element) 在尾部添加一个新元素\n- insert(position, element) 在指定位置插入一个新元素\n- remove(element) 从链表中移除一个元素\n- indexOf(element) 返回元素在链表中的索引，如果没有返回 -1\n- removeAt(position) 从特定位置移除一个元素\n- isEmpty() 返回链表是否为空\n- size() 链表中元素的个数\n- toString() 输出所有元素的值\n\n### 实现\n```javascript\n/* 结点类 */\nclass Node {\n  constructor(element, next = null) {\n    this.element = element;\n    this.next = next;\n  }\n}\n\n/* 链表类 */\nclass LinkedList {\n  constructor() {\n    // 链表头\n    this.head = null;\n    // 链表长度\n    this.length = 0;\n  }\n\n  append(element) {\n    const node = new Node(element);\n\n    if(this.head == null) {\n      this.head = node;\n    } else {\n      let current = this.head;\n      while(current.next != null) {\n        current = current.next;\n      }\n      current.next = node;      \n    }\n\n    this.length++;\n  }\n\n  insert(position, element) {\n    if(position < 0 || position >= this.size()) {\n      throw new Error('illegal position');\n    }\n    const node = new Node(element);\n    let current = this.head, previous = null;\n    if(position == 0) {\n      node.next = this.head;\n      this.head = node;\n    } else {\n      let index = 0;\n      while(index < position) {\n        previous = current;\n        current = current.next;\n        index++;\n      }\n      node.next = current;\n      previous.next = node;\n    }\n    this.length++;\n  }\n\n  removeAt(position) {\n    if(this.isEmpty()) {\n      throw new Error('list is empty');\n    }\n    if(position < 0 || position >= this.size()) {\n      throw new Error('illegal position');\n    }\n    let current = this.head, previous = null;\n    if(position == 0) {\n      this.head = current.next;\n    } else {\n      let index = 0;\n      while(index < position) {\n        previous = current;\n        current = current.next;\n        index++;\n      }\n\n      previous.next = current.next;\n    }\n    this.length--;\n    return current.element;\n  }\n\n  remove(element) {\n    const index = this.indexOf(element);\n    this.removeAt(index);\n  }\n\n  indexOf(element) {\n    let current = this.head;\n    let index = -1;\n    while(current) {\n      index++;\n      if(current.element == element) {\n        return index;\n      }\n      current = current.next;\n    }\n    return -1;\n  }\n\n  isEmpty() {\n    return this.size() == 0;\n  }\n\n  size() {\n    return this.length;\n  }\n\n  toString() {\n    let result = '';\n    let current = this.head;\n    while(current) {\n      result += current.element;\n      current = current.next;\n    }\n    return result;\n  }\n}\n```\n\n## 集合\n\n集合由一组无序且唯一的项组成。\n\n### API\n- add(value) 向集合添加一个元素\n- remove(value) 从集合内移除一个元素 \n- has(value) 元素是否在集合中\n- clear() 清空集合\n- size() 返回集合所包含的元素数量\n- values() 返回包含集合中所有值的数组\n\n### 实现\n```javascript\nclass Set {\n  constructor() {\n    this.items = {};\n  }\n\n  has(value) {\n    return value in this.items;\n  }\n\n  add(value) {\n    if(!this.has(value)) {\n      this.items[value] = value;\n      return true;\n    }\n    return false;\n  }\n\n  remove(value) {\n    if(this.has(value)) {\n      delete this.items[value];\n      return true;\n    }\n    return false;\n  }\n\n  clear() {\n    this.items = {};\n  }\n\n  size() {\n    return Object.keys(this.items).length;\n  }\n\n  values() {\n    return Object.keys(this.items);\n  }\n}\n```\n\n### 集合操作\n```javascript\nclass Set {\n  constructor() {\n    this.items = {};\n  }\n\n  //...\n\n  /**\n   * 并集\n   */\n  union(otherSet) {\n    const union = new Set();\n\n    for(let item in this.items) {\n      union.add(item);\n    }\n\n    let values = otherSet.values();\n    for(let value of values) {\n      console.log(value);\n      union.add(value);\n    }\n\n    return union;\n  }\n\n  /**\n   * 交集\n   */\n  intersection(otherSet) {\n    const intersection = new Set();\n    for(let item in this.items) {\n      if(otherSet.has(item)) {\n        intersection.add(item);\n      }\n    }\n\n    return intersection;\n  }\n\n  /**\n   * 差集\n   */\n  difference(otherSet) {\n    const difference = new Set();\n\n    for(let item in this.items) {\n      if(!otherSet.has(item)) {\n        difference.add(item);\n      }\n    }\n\n    return difference;\n  }\n\n  /**\n   * 当前集合是否为给定集合的子集\n   */\n  subset(otherSet) {\n    if(this.size() > otherSet.size()) {\n      return false;\n    }\n    for(let item in this.items) {\n      if(!otherSet.has(item)) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n```","source":"_posts/data-structures.md","raw":"---\ntitle: 基本数据结构（一）\ndate: 2016-07-24 13:39:57\ntags: [每周总结, 数据结构]\n---\n\n通过 Javascript 实现各种基本数据结构。包括栈、队列、链表、集合等\n\n<!-- more -->\n\n## 栈\n\n栈算是相对来说最简单的数据结构了，遵循后进先出原则，可以通过维护一个数组来实现一个栈类。\n\n### API\n- push(ele1, [ele2, ...]) 添加一个或多个元素到栈顶\n- pop() 弹出栈顶元素\n- peek() 返回栈顶元素，但不弹出它\n- isEmpty() 如果栈为空，则返回 true，否则返回 false\n- clear() 清空栈\n- size() 返回栈中元素个数\n\n### 实现\n```javascript\nclass Stack {\n  constructor() {\n    this.arr = [];\n  }\n\n  /**\n   * 出栈\n   * @return 栈顶元素\n   */\n  pop() {\n    if(this.isEmpty()) {\n      throw new Error('stack underflow error');\n    }\n    return this.arr.pop();\n  }\n\n  /**\n   * 入栈\n   * @params  新元素\n   */\n  push() {\n    const args = Array.from(arguments);\n    if(args.length == 0) {\n      throw new Error('缺少参数');\n    }\n    for(let ele of args) {\n      this.arr.push(ele);\n    }\n  }\n\n  /**\n   * 返回栈顶元素但不出栈\n   * @return 栈顶元素\n   */\n  peek() {\n    if(this.isEmpty) {\n      throw new Error('该栈为空栈');\n    }\n    return this.arr[this.arr.length - 1];\n  }\n\n  /**\n   * 是否为空栈\n   * @return boolean 是否为空栈\n   */\n  isEmpty() {\n    return this.size() == 0;\n  }\n\n  /**\n   * 栈的大小\n   * @return number 栈的大小\n   */\n  size() {\n    return this.arr.length;\n  }\n\n  /**\n   * 清空栈\n   */\n  clear() {\n    this.arr = [];\n  }\n\n  /**\n   * 打印栈中元素\n   * @return string 栈中所有元素\n   */\n  print() {\n    console.log(this.arr.toString());\n  }\n}\n```\n\n### 应用\n\n#### 十进制转其他进制\n\n我们可以使用栈来解决进制转换的问题，从十进制转指定的进制实际上是让十进制数除以进制的基数，再将得到的结果继续作被除数，一直到商为 0 为止。将每次的余数压栈，最后让栈依次弹出，连接成的字符串即为转换后的数。\n\n```javascript\nfunction baseConverter(decNumber, base) {\n  const stack = new Stack();\n  const digits = '0123456789ABCDEF';\n  let result = '';\n\n  while(decNumber > 0) {\n    let rem = Math.floor(decNumber % base);\n    stack.push(digits[rem]);\n    decNumber = Math.floor(decNumber / base);\n  }\n\n  while(!stack.isEmpty()) {\n    result += stack.pop();\n  }\n\n  return result;\n}\n\nconsole.log(baseConverter(100345, 2)); // 11000011111111001\nconsole.log(baseConverter(100345, 8));  // 303771\nconsole.log(baseConverter(100345, 16)); // 187F9\n```\n\n## 队列\n\n队列和栈很类似，但遵循先进先出原则。\n\n### API\n- enqueue(ele1, [ele2, ...]) 向队尾添加一个或多个元素\n- dequeue() 移除队首元素，并返回\n- front() 返回队首元素，但不移除它\n- isEmpty() 队列为空时，返回 true，否则返回 false\n- size() 返回队列中元素个数\n- clear() 清空队列\n- print() 打印队列\n\n### 实现\n```javascript\nclass Queue {\n  constructor() {\n    this.arr = [];\n  }\n\n  enqueue() {\n    const args = Array.from(arguments);\n    if(args.length == 0) {\n      throw new Error('缺少参数');\n    }\n    for(let ele of args) {\n      this.arr.push(ele);\n    }\n  }\n\n  dequeue() {\n    if(this.isEmpty()) {\n      throw new Error('queue is empty');\n    }\n    return this.arr.shift();\n  }\n\n  front() {\n    if(this.isEmpty()) {\n      throw new Error('queue is empty');\n    }\n    return this.arr[0];\n  }\n\n  isEmpty() {\n    return this.size() == 0;\n  }\n\n  size() {\n    return this.arr.length;\n  }\n\n  clear() {\n    this.arr = [];\n  }\n\n  print() {\n    console.log(this.arr.toString());\n  }\n}\n```\n\n### 应用\n\n#### 优先队列\n\n优先队列中的每个元素都有一个优先级，优先级的数字越小，优先级越高。为了使优先级越高的元素越先出队列，添加该元素的时候，会根据它的优先级将它插入到合适的位置。\n\n```javascript\nclass PriorityQueue extends Queue{\n  constructor(...args) {\n    super(...args);\n  }\n\n  enqueue(element, priority) {\n    const ele = {\n      element: element,\n      priority: priority\n    };\n\n    if(this.isEmpty()) {\n      this.arr.push(ele);\n      return;\n    }\n\n    let added = false;\n    for(let i in this.arr) {\n      if(priority < this.arr[i].priority) {\n        this.arr.splice(i, 0, ele);\n        added = true;\n        break;\n      }\n    }\n\n    if(!added) {\n      this.arr.push(ele);\n    }\n  }\n\n  print() {\n    console.log(this.arr.map((item) => {\n      return item.element;\n    }).join(','));\n  }\n}\n\nlet priorityQueue = new PriorityQueue();\npriorityQueue.enqueue('john', 2);\npriorityQueue.enqueue('jack', 1);\npriorityQueue.enqueue('mark', 3);\npriorityQueue.enqueue('camila', 1); \npriorityQueue.print();  // jack,camila,john,mark\n```\n\n#### 循环队列——击鼓传花\n\n假设有一圈小孩围着坐，将一朵花交给队首的小孩，小孩依次将花传给下一个小孩，当传到队尾的时候，再将花传给队首的小孩，也就是队列首尾相连，形成了一个循环队列。\n\n在“击鼓传花”游戏中，给定一个数字，当传递次数达到这个次数时，淘汰掉此时拿花的小孩，再进行下一轮，直到只有一个小孩（胜者）。\n\n```javascript\nfunction hotPotato(nameList, num) {\n  const queue = new Queue();\n\n  // 小孩入列\n  for (let name of nameList) {\n    queue.enqueue(name);\n  }\n\n  while(queue.size() > 1) {\n    for(let i = 0; i < num; i++) {\n      // 将队首的小孩放到队尾\n      queue.enqueue(queue.dequeue());\n    }\n    // 淘汰\n    console.log(queue.dequeue() + ' 被淘汰了。');\n  }\n\n  return queue.dequeue();\n}\n\nlet nameList = ['John', 'Jack', 'Camila', 'Ingrid', 'Carl'];\nlet winner = hotPotato(nameList, 7);\n/**\n * Camila 被淘汰了。\n * Jack 被淘汰了。\n * Carl 被淘汰了。\n * Ingrid 被淘汰了。\n * winner: John\n */\nconsole.log('winner: ' + winner);\n```\n\n## 链表\n\n链表存储有序的元素集合，但不同于数组，链表中的元素在内存中不是连续放置的，每个元素由一个存储元素本身的结点和一个指向下一个元素的引用组成。\n\n### API\n- append(element) 在尾部添加一个新元素\n- insert(position, element) 在指定位置插入一个新元素\n- remove(element) 从链表中移除一个元素\n- indexOf(element) 返回元素在链表中的索引，如果没有返回 -1\n- removeAt(position) 从特定位置移除一个元素\n- isEmpty() 返回链表是否为空\n- size() 链表中元素的个数\n- toString() 输出所有元素的值\n\n### 实现\n```javascript\n/* 结点类 */\nclass Node {\n  constructor(element, next = null) {\n    this.element = element;\n    this.next = next;\n  }\n}\n\n/* 链表类 */\nclass LinkedList {\n  constructor() {\n    // 链表头\n    this.head = null;\n    // 链表长度\n    this.length = 0;\n  }\n\n  append(element) {\n    const node = new Node(element);\n\n    if(this.head == null) {\n      this.head = node;\n    } else {\n      let current = this.head;\n      while(current.next != null) {\n        current = current.next;\n      }\n      current.next = node;      \n    }\n\n    this.length++;\n  }\n\n  insert(position, element) {\n    if(position < 0 || position >= this.size()) {\n      throw new Error('illegal position');\n    }\n    const node = new Node(element);\n    let current = this.head, previous = null;\n    if(position == 0) {\n      node.next = this.head;\n      this.head = node;\n    } else {\n      let index = 0;\n      while(index < position) {\n        previous = current;\n        current = current.next;\n        index++;\n      }\n      node.next = current;\n      previous.next = node;\n    }\n    this.length++;\n  }\n\n  removeAt(position) {\n    if(this.isEmpty()) {\n      throw new Error('list is empty');\n    }\n    if(position < 0 || position >= this.size()) {\n      throw new Error('illegal position');\n    }\n    let current = this.head, previous = null;\n    if(position == 0) {\n      this.head = current.next;\n    } else {\n      let index = 0;\n      while(index < position) {\n        previous = current;\n        current = current.next;\n        index++;\n      }\n\n      previous.next = current.next;\n    }\n    this.length--;\n    return current.element;\n  }\n\n  remove(element) {\n    const index = this.indexOf(element);\n    this.removeAt(index);\n  }\n\n  indexOf(element) {\n    let current = this.head;\n    let index = -1;\n    while(current) {\n      index++;\n      if(current.element == element) {\n        return index;\n      }\n      current = current.next;\n    }\n    return -1;\n  }\n\n  isEmpty() {\n    return this.size() == 0;\n  }\n\n  size() {\n    return this.length;\n  }\n\n  toString() {\n    let result = '';\n    let current = this.head;\n    while(current) {\n      result += current.element;\n      current = current.next;\n    }\n    return result;\n  }\n}\n```\n\n## 集合\n\n集合由一组无序且唯一的项组成。\n\n### API\n- add(value) 向集合添加一个元素\n- remove(value) 从集合内移除一个元素 \n- has(value) 元素是否在集合中\n- clear() 清空集合\n- size() 返回集合所包含的元素数量\n- values() 返回包含集合中所有值的数组\n\n### 实现\n```javascript\nclass Set {\n  constructor() {\n    this.items = {};\n  }\n\n  has(value) {\n    return value in this.items;\n  }\n\n  add(value) {\n    if(!this.has(value)) {\n      this.items[value] = value;\n      return true;\n    }\n    return false;\n  }\n\n  remove(value) {\n    if(this.has(value)) {\n      delete this.items[value];\n      return true;\n    }\n    return false;\n  }\n\n  clear() {\n    this.items = {};\n  }\n\n  size() {\n    return Object.keys(this.items).length;\n  }\n\n  values() {\n    return Object.keys(this.items);\n  }\n}\n```\n\n### 集合操作\n```javascript\nclass Set {\n  constructor() {\n    this.items = {};\n  }\n\n  //...\n\n  /**\n   * 并集\n   */\n  union(otherSet) {\n    const union = new Set();\n\n    for(let item in this.items) {\n      union.add(item);\n    }\n\n    let values = otherSet.values();\n    for(let value of values) {\n      console.log(value);\n      union.add(value);\n    }\n\n    return union;\n  }\n\n  /**\n   * 交集\n   */\n  intersection(otherSet) {\n    const intersection = new Set();\n    for(let item in this.items) {\n      if(otherSet.has(item)) {\n        intersection.add(item);\n      }\n    }\n\n    return intersection;\n  }\n\n  /**\n   * 差集\n   */\n  difference(otherSet) {\n    const difference = new Set();\n\n    for(let item in this.items) {\n      if(!otherSet.has(item)) {\n        difference.add(item);\n      }\n    }\n\n    return difference;\n  }\n\n  /**\n   * 当前集合是否为给定集合的子集\n   */\n  subset(otherSet) {\n    if(this.size() > otherSet.size()) {\n      return false;\n    }\n    for(let item in this.items) {\n      if(!otherSet.has(item)) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n```","slug":"data-structures","published":1,"updated":"2016-08-27T00:03:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscgyh1c000ggq275yzxx1r5","content":"<p>通过 Javascript 实现各种基本数据结构。包括栈、队列、链表、集合等</p>\n<a id=\"more\"></a>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><p>栈算是相对来说最简单的数据结构了，遵循后进先出原则，可以通过维护一个数组来实现一个栈类。</p>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>push(ele1, [ele2, …]) 添加一个或多个元素到栈顶</li>\n<li>pop() 弹出栈顶元素</li>\n<li>peek() 返回栈顶元素，但不弹出它</li>\n<li>isEmpty() 如果栈为空，则返回 true，否则返回 false</li>\n<li>clear() 清空栈</li>\n<li>size() 返回栈中元素个数</li>\n</ul>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr = [];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</span></div><div class=\"line\">   * 出栈</div><div class=\"line\">   * @return 栈顶元素</div><div class=\"line\">   */</div><div class=\"line\">  pop() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.isEmpty()) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'stack underflow error'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr.pop();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</span></div><div class=\"line\">   * 入栈</div><div class=\"line\">   * @params  新元素</div><div class=\"line\">   */</div><div class=\"line\">  push() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> args = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span>(args.length == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'缺少参数'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> ele <span class=\"keyword\">of</span> args) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.arr.push(ele);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</span></div><div class=\"line\">   * 返回栈顶元素但不出栈</div><div class=\"line\">   * @return 栈顶元素</div><div class=\"line\">   */</div><div class=\"line\">  peek() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.isEmpty) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'该栈为空栈'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr[<span class=\"keyword\">this</span>.arr.length - <span class=\"number\">1</span>];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</span></div><div class=\"line\">   * 是否为空栈</div><div class=\"line\">   * @return boolean 是否为空栈</div><div class=\"line\">   */</div><div class=\"line\">  isEmpty() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.size() == <span class=\"number\">0</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</span></div><div class=\"line\">   * 栈的大小</div><div class=\"line\">   * @return number 栈的大小</div><div class=\"line\">   */</div><div class=\"line\">  size() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr.length;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</span></div><div class=\"line\">   * 清空栈</div><div class=\"line\">   */</div><div class=\"line\">  clear() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr = [];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</span></div><div class=\"line\">   * 打印栈中元素</div><div class=\"line\">   * @return string 栈中所有元素</div><div class=\"line\">   */</div><div class=\"line\">  print() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.arr.toString());</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><h4 id=\"十进制转其他进制\"><a href=\"#十进制转其他进制\" class=\"headerlink\" title=\"十进制转其他进制\"></a>十进制转其他进制</h4><p>我们可以使用栈来解决进制转换的问题，从十进制转指定的进制实际上是让十进制数除以进制的基数，再将得到的结果继续作被除数，一直到商为 0 为止。将每次的余数压栈，最后让栈依次弹出，连接成的字符串即为转换后的数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseConverter</span>(<span class=\"params\">decNumber, base</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> stack = <span class=\"keyword\">new</span> Stack();</div><div class=\"line\">  <span class=\"keyword\">const</span> digits = <span class=\"string\">'0123456789ABCDEF'</span>;</div><div class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"string\">''</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">while</span>(decNumber &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> rem = <span class=\"built_in\">Math</span>.floor(decNumber % base);</div><div class=\"line\">    stack.push(digits[rem]);</div><div class=\"line\">    decNumber = <span class=\"built_in\">Math</span>.floor(decNumber / base);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">while</span>(!stack.isEmpty()) &#123;</div><div class=\"line\">    result += stack.pop();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(baseConverter(<span class=\"number\">100345</span>, <span class=\"number\">2</span>)); <span class=\"comment\">// 11000011111111001</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(baseConverter(<span class=\"number\">100345</span>, <span class=\"number\">8</span>));  <span class=\"comment\">// 303771</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(baseConverter(<span class=\"number\">100345</span>, <span class=\"number\">16</span>)); <span class=\"comment\">// 187F9</span></div></pre></td></tr></table></figure>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><p>队列和栈很类似，但遵循先进先出原则。</p>\n<h3 id=\"API-1\"><a href=\"#API-1\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>enqueue(ele1, [ele2, …]) 向队尾添加一个或多个元素</li>\n<li>dequeue() 移除队首元素，并返回</li>\n<li>front() 返回队首元素，但不移除它</li>\n<li>isEmpty() 队列为空时，返回 true，否则返回 false</li>\n<li>size() 返回队列中元素个数</li>\n<li>clear() 清空队列</li>\n<li>print() 打印队列</li>\n</ul>\n<h3 id=\"实现-1\"><a href=\"#实现-1\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Queue</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr = [];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  enqueue() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> args = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span>(args.length == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'缺少参数'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> ele <span class=\"keyword\">of</span> args) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.arr.push(ele);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  dequeue() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.isEmpty()) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'queue is empty'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr.shift();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  front() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.isEmpty()) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'queue is empty'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr[<span class=\"number\">0</span>];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  isEmpty() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.size() == <span class=\"number\">0</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  size() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr.length;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  clear() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr = [];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  print() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.arr.toString());</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"应用-1\"><a href=\"#应用-1\" class=\"headerlink\" title=\"应用\"></a>应用</h3><h4 id=\"优先队列\"><a href=\"#优先队列\" class=\"headerlink\" title=\"优先队列\"></a>优先队列</h4><p>优先队列中的每个元素都有一个优先级，优先级的数字越小，优先级越高。为了使优先级越高的元素越先出队列，添加该元素的时候，会根据它的优先级将它插入到合适的位置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PriorityQueue</span> <span class=\"keyword\">extends</span> <span class=\"title\">Queue</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(...args) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(...args);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  enqueue(element, priority) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> ele = &#123;</div><div class=\"line\">      element: element,</div><div class=\"line\">      priority: priority</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.isEmpty()) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.arr.push(ele);</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">let</span> added = <span class=\"literal\">false</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.arr) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(priority &lt; <span class=\"keyword\">this</span>.arr[i].priority) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.arr.splice(i, <span class=\"number\">0</span>, ele);</div><div class=\"line\">        added = <span class=\"literal\">true</span>;</div><div class=\"line\">        <span class=\"keyword\">break</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(!added) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.arr.push(ele);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  print() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.arr.map((item) =&gt; &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> item.element;</div><div class=\"line\">    &#125;).join(<span class=\"string\">','</span>));</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> priorityQueue = <span class=\"keyword\">new</span> PriorityQueue();</div><div class=\"line\">priorityQueue.enqueue(<span class=\"string\">'john'</span>, <span class=\"number\">2</span>);</div><div class=\"line\">priorityQueue.enqueue(<span class=\"string\">'jack'</span>, <span class=\"number\">1</span>);</div><div class=\"line\">priorityQueue.enqueue(<span class=\"string\">'mark'</span>, <span class=\"number\">3</span>);</div><div class=\"line\">priorityQueue.enqueue(<span class=\"string\">'camila'</span>, <span class=\"number\">1</span>); </div><div class=\"line\">priorityQueue.print();  <span class=\"comment\">// jack,camila,john,mark</span></div></pre></td></tr></table></figure>\n<h4 id=\"循环队列——击鼓传花\"><a href=\"#循环队列——击鼓传花\" class=\"headerlink\" title=\"循环队列——击鼓传花\"></a>循环队列——击鼓传花</h4><p>假设有一圈小孩围着坐，将一朵花交给队首的小孩，小孩依次将花传给下一个小孩，当传到队尾的时候，再将花传给队首的小孩，也就是队列首尾相连，形成了一个循环队列。</p>\n<p>在“击鼓传花”游戏中，给定一个数字，当传递次数达到这个次数时，淘汰掉此时拿花的小孩，再进行下一轮，直到只有一个小孩（胜者）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hotPotato</span>(<span class=\"params\">nameList, num</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> queue = <span class=\"keyword\">new</span> Queue();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 小孩入列</span></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">of</span> nameList) &#123;</div><div class=\"line\">    queue.enqueue(name);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">while</span>(queue.size() &gt; <span class=\"number\">1</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</div><div class=\"line\">      <span class=\"comment\">// 将队首的小孩放到队尾</span></div><div class=\"line\">      queue.enqueue(queue.dequeue());</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 淘汰</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(queue.dequeue() + <span class=\"string\">' 被淘汰了。'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> queue.dequeue();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> nameList = [<span class=\"string\">'John'</span>, <span class=\"string\">'Jack'</span>, <span class=\"string\">'Camila'</span>, <span class=\"string\">'Ingrid'</span>, <span class=\"string\">'Carl'</span>];</div><div class=\"line\"><span class=\"keyword\">let</span> winner = hotPotato(nameList, <span class=\"number\">7</span>);</div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Camila 被淘汰了。</div><div class=\"line\"> * Jack 被淘汰了。</div><div class=\"line\"> * Carl 被淘汰了。</div><div class=\"line\"> * Ingrid 被淘汰了。</div><div class=\"line\"> * winner: John</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'winner: '</span> + winner);</div></pre></td></tr></table></figure>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><p>链表存储有序的元素集合，但不同于数组，链表中的元素在内存中不是连续放置的，每个元素由一个存储元素本身的结点和一个指向下一个元素的引用组成。</p>\n<h3 id=\"API-2\"><a href=\"#API-2\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>append(element) 在尾部添加一个新元素</li>\n<li>insert(position, element) 在指定位置插入一个新元素</li>\n<li>remove(element) 从链表中移除一个元素</li>\n<li>indexOf(element) 返回元素在链表中的索引，如果没有返回 -1</li>\n<li>removeAt(position) 从特定位置移除一个元素</li>\n<li>isEmpty() 返回链表是否为空</li>\n<li>size() 链表中元素的个数</li>\n<li>toString() 输出所有元素的值</li>\n</ul>\n<h3 id=\"实现-2\"><a href=\"#实现-2\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* 结点类 */</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(element, next = null) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.element = element;</div><div class=\"line\">    <span class=\"keyword\">this</span>.next = next;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 链表类 */</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkedList</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"comment\">// 链表头</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.head = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"comment\">// 链表长度</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.length = <span class=\"number\">0</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  append(element) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> Node(element);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.head == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.head = node;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> current = <span class=\"keyword\">this</span>.head;</div><div class=\"line\">      <span class=\"keyword\">while</span>(current.next != <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        current = current.next;</div><div class=\"line\">      &#125;</div><div class=\"line\">      current.next = node;      </div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">this</span>.length++;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  insert(position, element) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(position &lt; <span class=\"number\">0</span> || position &gt;= <span class=\"keyword\">this</span>.size()) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'illegal position'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> Node(element);</div><div class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"keyword\">this</span>.head, previous = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span>(position == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      node.next = <span class=\"keyword\">this</span>.head;</div><div class=\"line\">      <span class=\"keyword\">this</span>.head = node;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> index = <span class=\"number\">0</span>;</div><div class=\"line\">      <span class=\"keyword\">while</span>(index &lt; position) &#123;</div><div class=\"line\">        previous = current;</div><div class=\"line\">        current = current.next;</div><div class=\"line\">        index++;</div><div class=\"line\">      &#125;</div><div class=\"line\">      node.next = current;</div><div class=\"line\">      previous.next = node;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.length++;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  removeAt(position) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.isEmpty()) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'list is empty'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span>(position &lt; <span class=\"number\">0</span> || position &gt;= <span class=\"keyword\">this</span>.size()) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'illegal position'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"keyword\">this</span>.head, previous = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span>(position == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.head = current.next;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> index = <span class=\"number\">0</span>;</div><div class=\"line\">      <span class=\"keyword\">while</span>(index &lt; position) &#123;</div><div class=\"line\">        previous = current;</div><div class=\"line\">        current = current.next;</div><div class=\"line\">        index++;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      previous.next = current.next;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.length--;</div><div class=\"line\">    <span class=\"keyword\">return</span> current.element;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  remove(element) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> index = <span class=\"keyword\">this</span>.indexOf(element);</div><div class=\"line\">    <span class=\"keyword\">this</span>.removeAt(index);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  indexOf(element) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"keyword\">this</span>.head;</div><div class=\"line\">    <span class=\"keyword\">let</span> index = <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span>(current) &#123;</div><div class=\"line\">      index++;</div><div class=\"line\">      <span class=\"keyword\">if</span>(current.element == element) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">      &#125;</div><div class=\"line\">      current = current.next;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  isEmpty() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.size() == <span class=\"number\">0</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  size() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.length;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"string\">''</span>;</div><div class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"keyword\">this</span>.head;</div><div class=\"line\">    <span class=\"keyword\">while</span>(current) &#123;</div><div class=\"line\">      result += current.element;</div><div class=\"line\">      current = current.next;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h2><p>集合由一组无序且唯一的项组成。</p>\n<h3 id=\"API-3\"><a href=\"#API-3\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>add(value) 向集合添加一个元素</li>\n<li>remove(value) 从集合内移除一个元素 </li>\n<li>has(value) 元素是否在集合中</li>\n<li>clear() 清空集合</li>\n<li>size() 返回集合所包含的元素数量</li>\n<li>values() 返回包含集合中所有值的数组</li>\n</ul>\n<h3 id=\"实现-3\"><a href=\"#实现-3\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Set</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.items = &#123;&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  has(value) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> value <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.items;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  add(value) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>.has(value)) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.items[value] = value;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  remove(value) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.has(value)) &#123;</div><div class=\"line\">      <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>.items[value];</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  clear() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.items = &#123;&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  size() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(<span class=\"keyword\">this</span>.items).length;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  values() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(<span class=\"keyword\">this</span>.items);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"集合操作\"><a href=\"#集合操作\" class=\"headerlink\" title=\"集合操作\"></a>集合操作</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Set</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.items = &#123;&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</span></div><div class=\"line\">   * 并集</div><div class=\"line\">   */</div><div class=\"line\">  union(otherSet) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> union = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> item <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.items) &#123;</div><div class=\"line\">      union.add(item);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">let</span> values = otherSet.values();</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> value <span class=\"keyword\">of</span> values) &#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(value);</div><div class=\"line\">      union.add(value);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> union;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</span></div><div class=\"line\">   * 交集</div><div class=\"line\">   */</div><div class=\"line\">  intersection(otherSet) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> intersection = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> item <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.items) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(otherSet.has(item)) &#123;</div><div class=\"line\">        intersection.add(item);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> intersection;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</span></div><div class=\"line\">   * 差集</div><div class=\"line\">   */</div><div class=\"line\">  difference(otherSet) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> difference = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> item <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.items) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(!otherSet.has(item)) &#123;</div><div class=\"line\">        difference.add(item);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> difference;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</span></div><div class=\"line\">   * 当前集合是否为给定集合的子集</div><div class=\"line\">   */</div><div class=\"line\">  subset(otherSet) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.size() &gt; otherSet.size()) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> item <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.items) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(!otherSet.has(item)) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","excerpt":"<p>通过 Javascript 实现各种基本数据结构。包括栈、队列、链表、集合等</p>","more":"<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><p>栈算是相对来说最简单的数据结构了，遵循后进先出原则，可以通过维护一个数组来实现一个栈类。</p>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>push(ele1, [ele2, …]) 添加一个或多个元素到栈顶</li>\n<li>pop() 弹出栈顶元素</li>\n<li>peek() 返回栈顶元素，但不弹出它</li>\n<li>isEmpty() 如果栈为空，则返回 true，否则返回 false</li>\n<li>clear() 清空栈</li>\n<li>size() 返回栈中元素个数</li>\n</ul>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr = [];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">   * 出栈</div><div class=\"line\">   * @return 栈顶元素</div><div class=\"line\">   */</span></div><div class=\"line\">  pop() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.isEmpty()) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'stack underflow error'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr.pop();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">   * 入栈</div><div class=\"line\">   * @params  新元素</div><div class=\"line\">   */</span></div><div class=\"line\">  push() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> args = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span>(args.length == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'缺少参数'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> ele <span class=\"keyword\">of</span> args) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.arr.push(ele);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">   * 返回栈顶元素但不出栈</div><div class=\"line\">   * @return 栈顶元素</div><div class=\"line\">   */</span></div><div class=\"line\">  peek() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.isEmpty) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'该栈为空栈'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr[<span class=\"keyword\">this</span>.arr.length - <span class=\"number\">1</span>];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">   * 是否为空栈</div><div class=\"line\">   * @return boolean 是否为空栈</div><div class=\"line\">   */</span></div><div class=\"line\">  isEmpty() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.size() == <span class=\"number\">0</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">   * 栈的大小</div><div class=\"line\">   * @return number 栈的大小</div><div class=\"line\">   */</span></div><div class=\"line\">  size() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr.length;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">   * 清空栈</div><div class=\"line\">   */</span></div><div class=\"line\">  clear() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr = [];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">   * 打印栈中元素</div><div class=\"line\">   * @return string 栈中所有元素</div><div class=\"line\">   */</span></div><div class=\"line\">  print() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.arr.toString());</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><h4 id=\"十进制转其他进制\"><a href=\"#十进制转其他进制\" class=\"headerlink\" title=\"十进制转其他进制\"></a>十进制转其他进制</h4><p>我们可以使用栈来解决进制转换的问题，从十进制转指定的进制实际上是让十进制数除以进制的基数，再将得到的结果继续作被除数，一直到商为 0 为止。将每次的余数压栈，最后让栈依次弹出，连接成的字符串即为转换后的数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseConverter</span>(<span class=\"params\">decNumber, base</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> stack = <span class=\"keyword\">new</span> Stack();</div><div class=\"line\">  <span class=\"keyword\">const</span> digits = <span class=\"string\">'0123456789ABCDEF'</span>;</div><div class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"string\">''</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">while</span>(decNumber &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> rem = <span class=\"built_in\">Math</span>.floor(decNumber % base);</div><div class=\"line\">    stack.push(digits[rem]);</div><div class=\"line\">    decNumber = <span class=\"built_in\">Math</span>.floor(decNumber / base);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">while</span>(!stack.isEmpty()) &#123;</div><div class=\"line\">    result += stack.pop();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(baseConverter(<span class=\"number\">100345</span>, <span class=\"number\">2</span>)); <span class=\"comment\">// 11000011111111001</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(baseConverter(<span class=\"number\">100345</span>, <span class=\"number\">8</span>));  <span class=\"comment\">// 303771</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(baseConverter(<span class=\"number\">100345</span>, <span class=\"number\">16</span>)); <span class=\"comment\">// 187F9</span></div></pre></td></tr></table></figure>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><p>队列和栈很类似，但遵循先进先出原则。</p>\n<h3 id=\"API-1\"><a href=\"#API-1\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>enqueue(ele1, [ele2, …]) 向队尾添加一个或多个元素</li>\n<li>dequeue() 移除队首元素，并返回</li>\n<li>front() 返回队首元素，但不移除它</li>\n<li>isEmpty() 队列为空时，返回 true，否则返回 false</li>\n<li>size() 返回队列中元素个数</li>\n<li>clear() 清空队列</li>\n<li>print() 打印队列</li>\n</ul>\n<h3 id=\"实现-1\"><a href=\"#实现-1\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Queue</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr = [];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  enqueue() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> args = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span>(args.length == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'缺少参数'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> ele <span class=\"keyword\">of</span> args) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.arr.push(ele);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  dequeue() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.isEmpty()) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'queue is empty'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr.shift();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  front() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.isEmpty()) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'queue is empty'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr[<span class=\"number\">0</span>];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  isEmpty() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.size() == <span class=\"number\">0</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  size() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arr.length;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  clear() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr = [];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  print() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.arr.toString());</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"应用-1\"><a href=\"#应用-1\" class=\"headerlink\" title=\"应用\"></a>应用</h3><h4 id=\"优先队列\"><a href=\"#优先队列\" class=\"headerlink\" title=\"优先队列\"></a>优先队列</h4><p>优先队列中的每个元素都有一个优先级，优先级的数字越小，优先级越高。为了使优先级越高的元素越先出队列，添加该元素的时候，会根据它的优先级将它插入到合适的位置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PriorityQueue</span> <span class=\"keyword\">extends</span> <span class=\"title\">Queue</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(...args) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(...args);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  enqueue(element, priority) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> ele = &#123;</div><div class=\"line\">      element: element,</div><div class=\"line\">      priority: priority</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.isEmpty()) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.arr.push(ele);</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">let</span> added = <span class=\"literal\">false</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.arr) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(priority &lt; <span class=\"keyword\">this</span>.arr[i].priority) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.arr.splice(i, <span class=\"number\">0</span>, ele);</div><div class=\"line\">        added = <span class=\"literal\">true</span>;</div><div class=\"line\">        <span class=\"keyword\">break</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(!added) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.arr.push(ele);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  print() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.arr.map((item) =&gt; &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> item.element;</div><div class=\"line\">    &#125;).join(<span class=\"string\">','</span>));</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> priorityQueue = <span class=\"keyword\">new</span> PriorityQueue();</div><div class=\"line\">priorityQueue.enqueue(<span class=\"string\">'john'</span>, <span class=\"number\">2</span>);</div><div class=\"line\">priorityQueue.enqueue(<span class=\"string\">'jack'</span>, <span class=\"number\">1</span>);</div><div class=\"line\">priorityQueue.enqueue(<span class=\"string\">'mark'</span>, <span class=\"number\">3</span>);</div><div class=\"line\">priorityQueue.enqueue(<span class=\"string\">'camila'</span>, <span class=\"number\">1</span>); </div><div class=\"line\">priorityQueue.print();  <span class=\"comment\">// jack,camila,john,mark</span></div></pre></td></tr></table></figure>\n<h4 id=\"循环队列——击鼓传花\"><a href=\"#循环队列——击鼓传花\" class=\"headerlink\" title=\"循环队列——击鼓传花\"></a>循环队列——击鼓传花</h4><p>假设有一圈小孩围着坐，将一朵花交给队首的小孩，小孩依次将花传给下一个小孩，当传到队尾的时候，再将花传给队首的小孩，也就是队列首尾相连，形成了一个循环队列。</p>\n<p>在“击鼓传花”游戏中，给定一个数字，当传递次数达到这个次数时，淘汰掉此时拿花的小孩，再进行下一轮，直到只有一个小孩（胜者）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hotPotato</span>(<span class=\"params\">nameList, num</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> queue = <span class=\"keyword\">new</span> Queue();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 小孩入列</span></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">of</span> nameList) &#123;</div><div class=\"line\">    queue.enqueue(name);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">while</span>(queue.size() &gt; <span class=\"number\">1</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</div><div class=\"line\">      <span class=\"comment\">// 将队首的小孩放到队尾</span></div><div class=\"line\">      queue.enqueue(queue.dequeue());</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 淘汰</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(queue.dequeue() + <span class=\"string\">' 被淘汰了。'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> queue.dequeue();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> nameList = [<span class=\"string\">'John'</span>, <span class=\"string\">'Jack'</span>, <span class=\"string\">'Camila'</span>, <span class=\"string\">'Ingrid'</span>, <span class=\"string\">'Carl'</span>];</div><div class=\"line\"><span class=\"keyword\">let</span> winner = hotPotato(nameList, <span class=\"number\">7</span>);</div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Camila 被淘汰了。</div><div class=\"line\"> * Jack 被淘汰了。</div><div class=\"line\"> * Carl 被淘汰了。</div><div class=\"line\"> * Ingrid 被淘汰了。</div><div class=\"line\"> * winner: John</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'winner: '</span> + winner);</div></pre></td></tr></table></figure>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><p>链表存储有序的元素集合，但不同于数组，链表中的元素在内存中不是连续放置的，每个元素由一个存储元素本身的结点和一个指向下一个元素的引用组成。</p>\n<h3 id=\"API-2\"><a href=\"#API-2\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>append(element) 在尾部添加一个新元素</li>\n<li>insert(position, element) 在指定位置插入一个新元素</li>\n<li>remove(element) 从链表中移除一个元素</li>\n<li>indexOf(element) 返回元素在链表中的索引，如果没有返回 -1</li>\n<li>removeAt(position) 从特定位置移除一个元素</li>\n<li>isEmpty() 返回链表是否为空</li>\n<li>size() 链表中元素的个数</li>\n<li>toString() 输出所有元素的值</li>\n</ul>\n<h3 id=\"实现-2\"><a href=\"#实现-2\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* 结点类 */</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(element, next = null) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.element = element;</div><div class=\"line\">    <span class=\"keyword\">this</span>.next = next;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 链表类 */</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkedList</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"comment\">// 链表头</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.head = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"comment\">// 链表长度</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.length = <span class=\"number\">0</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  append(element) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> Node(element);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.head == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.head = node;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> current = <span class=\"keyword\">this</span>.head;</div><div class=\"line\">      <span class=\"keyword\">while</span>(current.next != <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        current = current.next;</div><div class=\"line\">      &#125;</div><div class=\"line\">      current.next = node;      </div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">this</span>.length++;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  insert(position, element) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(position &lt; <span class=\"number\">0</span> || position &gt;= <span class=\"keyword\">this</span>.size()) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'illegal position'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> Node(element);</div><div class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"keyword\">this</span>.head, previous = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span>(position == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      node.next = <span class=\"keyword\">this</span>.head;</div><div class=\"line\">      <span class=\"keyword\">this</span>.head = node;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> index = <span class=\"number\">0</span>;</div><div class=\"line\">      <span class=\"keyword\">while</span>(index &lt; position) &#123;</div><div class=\"line\">        previous = current;</div><div class=\"line\">        current = current.next;</div><div class=\"line\">        index++;</div><div class=\"line\">      &#125;</div><div class=\"line\">      node.next = current;</div><div class=\"line\">      previous.next = node;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.length++;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  removeAt(position) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.isEmpty()) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'list is empty'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span>(position &lt; <span class=\"number\">0</span> || position &gt;= <span class=\"keyword\">this</span>.size()) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'illegal position'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"keyword\">this</span>.head, previous = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span>(position == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.head = current.next;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> index = <span class=\"number\">0</span>;</div><div class=\"line\">      <span class=\"keyword\">while</span>(index &lt; position) &#123;</div><div class=\"line\">        previous = current;</div><div class=\"line\">        current = current.next;</div><div class=\"line\">        index++;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      previous.next = current.next;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.length--;</div><div class=\"line\">    <span class=\"keyword\">return</span> current.element;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  remove(element) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> index = <span class=\"keyword\">this</span>.indexOf(element);</div><div class=\"line\">    <span class=\"keyword\">this</span>.removeAt(index);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  indexOf(element) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"keyword\">this</span>.head;</div><div class=\"line\">    <span class=\"keyword\">let</span> index = <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span>(current) &#123;</div><div class=\"line\">      index++;</div><div class=\"line\">      <span class=\"keyword\">if</span>(current.element == element) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">      &#125;</div><div class=\"line\">      current = current.next;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  isEmpty() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.size() == <span class=\"number\">0</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  size() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.length;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"string\">''</span>;</div><div class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"keyword\">this</span>.head;</div><div class=\"line\">    <span class=\"keyword\">while</span>(current) &#123;</div><div class=\"line\">      result += current.element;</div><div class=\"line\">      current = current.next;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h2><p>集合由一组无序且唯一的项组成。</p>\n<h3 id=\"API-3\"><a href=\"#API-3\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>add(value) 向集合添加一个元素</li>\n<li>remove(value) 从集合内移除一个元素 </li>\n<li>has(value) 元素是否在集合中</li>\n<li>clear() 清空集合</li>\n<li>size() 返回集合所包含的元素数量</li>\n<li>values() 返回包含集合中所有值的数组</li>\n</ul>\n<h3 id=\"实现-3\"><a href=\"#实现-3\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Set</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.items = &#123;&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  has(value) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> value <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.items;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  add(value) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>.has(value)) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.items[value] = value;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  remove(value) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.has(value)) &#123;</div><div class=\"line\">      <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>.items[value];</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  clear() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.items = &#123;&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  size() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(<span class=\"keyword\">this</span>.items).length;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  values() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(<span class=\"keyword\">this</span>.items);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"集合操作\"><a href=\"#集合操作\" class=\"headerlink\" title=\"集合操作\"></a>集合操作</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Set</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.items = &#123;&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">   * 并集</div><div class=\"line\">   */</span></div><div class=\"line\">  union(otherSet) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> union = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> item <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.items) &#123;</div><div class=\"line\">      union.add(item);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">let</span> values = otherSet.values();</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> value <span class=\"keyword\">of</span> values) &#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(value);</div><div class=\"line\">      union.add(value);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> union;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">   * 交集</div><div class=\"line\">   */</span></div><div class=\"line\">  intersection(otherSet) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> intersection = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> item <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.items) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(otherSet.has(item)) &#123;</div><div class=\"line\">        intersection.add(item);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> intersection;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">   * 差集</div><div class=\"line\">   */</span></div><div class=\"line\">  difference(otherSet) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> difference = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> item <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.items) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(!otherSet.has(item)) &#123;</div><div class=\"line\">        difference.add(item);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> difference;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">   * 当前集合是否为给定集合的子集</div><div class=\"line\">   */</span></div><div class=\"line\">  subset(otherSet) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.size() &gt; otherSet.size()) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> item <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.items) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(!otherSet.has(item)) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"git 使用","date":"2016-08-15T13:54:34.000Z","_content":"\ngit 实际上有两个区，一个是工作区，另一个是版本库。在版本库里，又分为暂存区和当前分支。\n\ngit add 将工作区的文件提交到暂存区，此时添加到暂存区的文件都是被 track 的。\n\ngit commit 将暂存区的文件提交到本地当前分支，此时暂存区会被清空。\n\n\n?? 未跟踪\nA  新添加到暂存区\n_M 被修改但未放入暂存区\n\n\ngit init\n初始化 git 目录\n\n创建一个文件\n将文件添加到工作区，文件状态为 Untracked，此时使用 git status -s 显示为 ??。\n\ngit add\n将文件添加到暂存区，文件状态为 Staged，此时使用 git status -s 显示为 A\n\ngit commit\n将文件提交到当前分支，文件状态为 Unmodified，此时使用 git status -s 显示为 _M\n\n修改文件\n文件已经被跟踪，但是有修改，此时使用 git status -s 显示为 M_","source":"_posts/git.md","raw":"---\ntitle: git 使用\ndate: 2016-08-15 21:54:34\ntags: [git, 每周总结]\n---\n\ngit 实际上有两个区，一个是工作区，另一个是版本库。在版本库里，又分为暂存区和当前分支。\n\ngit add 将工作区的文件提交到暂存区，此时添加到暂存区的文件都是被 track 的。\n\ngit commit 将暂存区的文件提交到本地当前分支，此时暂存区会被清空。\n\n\n?? 未跟踪\nA  新添加到暂存区\n_M 被修改但未放入暂存区\n\n\ngit init\n初始化 git 目录\n\n创建一个文件\n将文件添加到工作区，文件状态为 Untracked，此时使用 git status -s 显示为 ??。\n\ngit add\n将文件添加到暂存区，文件状态为 Staged，此时使用 git status -s 显示为 A\n\ngit commit\n将文件提交到当前分支，文件状态为 Unmodified，此时使用 git status -s 显示为 _M\n\n修改文件\n文件已经被跟踪，但是有修改，此时使用 git status -s 显示为 M_","slug":"git","published":1,"updated":"2016-08-27T00:16:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscgyh1g000jgq27dpc6zv9w","content":"<p>git 实际上有两个区，一个是工作区，另一个是版本库。在版本库里，又分为暂存区和当前分支。</p>\n<p>git add 将工作区的文件提交到暂存区，此时添加到暂存区的文件都是被 track 的。</p>\n<p>git commit 将暂存区的文件提交到本地当前分支，此时暂存区会被清空。</p>\n<p>?? 未跟踪<br>A  新添加到暂存区<br>_M 被修改但未放入暂存区</p>\n<p>git init<br>初始化 git 目录</p>\n<p>创建一个文件<br>将文件添加到工作区，文件状态为 Untracked，此时使用 git status -s 显示为 ??。</p>\n<p>git add<br>将文件添加到暂存区，文件状态为 Staged，此时使用 git status -s 显示为 A</p>\n<p>git commit<br>将文件提交到当前分支，文件状态为 Unmodified，此时使用 git status -s 显示为 _M</p>\n<p>修改文件<br>文件已经被跟踪，但是有修改，此时使用 git status -s 显示为 M_</p>\n","excerpt":"","more":"<p>git 实际上有两个区，一个是工作区，另一个是版本库。在版本库里，又分为暂存区和当前分支。</p>\n<p>git add 将工作区的文件提交到暂存区，此时添加到暂存区的文件都是被 track 的。</p>\n<p>git commit 将暂存区的文件提交到本地当前分支，此时暂存区会被清空。</p>\n<p>?? 未跟踪<br>A  新添加到暂存区<br>_M 被修改但未放入暂存区</p>\n<p>git init<br>初始化 git 目录</p>\n<p>创建一个文件<br>将文件添加到工作区，文件状态为 Untracked，此时使用 git status -s 显示为 ??。</p>\n<p>git add<br>将文件添加到暂存区，文件状态为 Staged，此时使用 git status -s 显示为 A</p>\n<p>git commit<br>将文件提交到当前分支，文件状态为 Unmodified，此时使用 git status -s 显示为 _M</p>\n<p>修改文件<br>文件已经被跟踪，但是有修改，此时使用 git status -s 显示为 M_</p>\n"},{"title":"如何实现五子棋 AI","date":"2016-07-31T12:57:34.000Z","_content":"\n和水哥在北戴河回来的车上除了讨论 24 点的实现方式之外，还讨论了一下五子棋的算法。昨天趁着周末凭着自己的想法试着写了一下，很不幸的是五子棋没写出来，倒是写了个三子棋（orz），网上查了一些资料，其实这里面涉及两个主要的算法，一个是**极大极小搜索**，另一个是**alpha-beta剪枝**。\n\n<!-- more -->\n\n## 博弈树\n\n下过五子棋的人都应该知道，越厉害的人，对棋面的预测程度越深。换句话讲，就是当你下完一步棋，我就能在我的脑海里假设把我所有可能下的地方都下一遍，然后考虑我下完之后你又会下在哪里，最后我根据每次预测的局势好坏来判断我的下一步棋放哪最合适。当然这只是想了一层，一个专业的棋手思考的层数会多得多。\n\n作为一个难度较大的 AI，势必也需要能够对棋局进行深入分析，然而五子棋的棋盘大小一般是 15 * 15，可以落子的地方太多，在这种情况下，电脑的性能有限，我们需要满足 AI “思考”的层数不能太低，同时算法的效率要高。\n\n以三子棋为例，AI 思考的过程就如同下面这课树一样，我们用圆圈代表玩家，叉号代表 AI，根节点是用户的落子。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/01.png)\n\n如果继续画下一层，那么下一层就是玩家下一步的落子，这也就是 AI 思考的层数又多了一层。\n\n有了这棵树，我们就需要得出每个节点的得分是多少，以判断哪一步是最优的。\n\n### 得分\n\n要考虑这一步棋是不是最优的，我们需要给每一步棋都设定一个得分，然后找出最忧的。当前棋面的得分多少，需要同时考虑玩家和 AI 分别的得分。\n\n以三子棋为例，当玩家下在左上角的时候，我们考虑 AI 下在正中间时的得分。得分的计算方法是将棋面的空白地方用棋子填满，然后得出连成三个的个数有多少。（如果是五子棋，应该只需找出当前棋面上所有连子，然后根据每种连子的权重来计算得分）\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/04.png)\n\n如图，玩家一共有 4 个成三，而 AI 一共有 5 个，所以总得分是 `5 - 4 = 1`。\n\n这里需要指出的是，在博弈树中，一个节点的得分是取决于他的子节点的，也就是说，当 AI 只思考一层，也就是上图这样，这棵树的末尾就是只有两个棋子，那么这个节点的得分就是这样计算，而如果这个节点下还有子节点，那么我们只会计算叶子节点的得分，然后从叶子节点开始，一步步倒推出父节点的得分。下面来进行解释倒推的过程。\n\n### 博弈\n\n当 AI 下棋时，我们必定要让 AI 下在得分最高的位置，这毋庸置疑。但是以 AI 的角度来考虑玩家的落子，我们需要假设玩家是“聪明的”，他会下在对自己最有利的地方，也就是得分最低的地方（因为得分 = AI 分数 - 玩家分数）。\n\n这就造成每一层的性质是不同的，在玩家落子的层里，我们要选取得分最低的；在 AI 落子的层里，我们要选取得分最高的。所以我们称玩家层为 MIN 层，AI 层为 MAX 层。\n\n## 极大极小搜索\n\n上面提到了，计算出叶子节点之后，我们需要倒推出父节点的得分，倒推的原则其实就是上面说的：MAX\n层中的节点会从子节点中挑选最大得分的节点作为它的得分，MIN 层的节点会从子节点中挑选最小得分的节点作为它的得分。\n\n以下图举例：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/02.png)\n\n因为我们是根据子节点的得分来倒推父节点的得分的，所以我们是用深度优先来遍历博弈树的，在上面这棵树中，遍历顺序是 `ABCDEFGHIJ`，赋值过程如下：\n\n1. 遍历完 A B，因为 C 是 MIN 层，所以选取 AB 中最小的，即 8 作为 C 的得分\n2. 遍历完 D E，F 的得分为 6\n3. 遍历完 G H，I 的得分为 5\n4. 因为 J 在 MAX 层，所以选取 C F I 中得分最大的，即 8 作为 I 的得分\n\n## alpha-beta 剪枝\n\n从上面可以想到，像五子棋这种可能性很多的情况，这棵树会变得非常大，当层数增加的时候，计算量也会越来越大，如果不采取一些方法，我们只能靠牺牲层数来换取运行时间。\n\n那么 alpha-beta 剪枝就是一种行之有效的方法，顾名思义，采用这种方法，我们会剪去一些不必要的树枝，也就减少了运行的时间。\n\nalpha-beta 剪枝的定义很绕口，但是原理很简单，还是以上面那课树为例：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/03.png)\n\n当遍历到 C 的时候，计算出 C 的得分是 `8`，因为 J 的得分是 C、F、I 之中最大的，所以此时可以得出 `J >= 8`。\n\n接下来遍历到 D，D 的值为 `6`，因为 F 的值是 D 和 E 之中最小的，所以即使现在还没有遍历完 F 的子节点也可以得出 `F <= 6`，那么既然 J 已经大于等于 `8` 了，所以继续遍历 F 已经没有意义了，那么我们就将 F 这条枝剪掉。\n\n同理，当 G 为 `5` 时，遍历 I 已经没有意义了，因为 I 不可能再大于 `5`，所以直接得出 J 为 `8`；\n\n可以看出，当节点很多的情况下，使用 alpha-beta 剪枝是能在一定程度上提高运行效率的。","source":"_posts/five-in-a-row-game.md","raw":"---\ntitle: 如何实现五子棋 AI\ndate: 2016-07-31 20:57:34\ntags: [每周总结]\n---\n\n和水哥在北戴河回来的车上除了讨论 24 点的实现方式之外，还讨论了一下五子棋的算法。昨天趁着周末凭着自己的想法试着写了一下，很不幸的是五子棋没写出来，倒是写了个三子棋（orz），网上查了一些资料，其实这里面涉及两个主要的算法，一个是**极大极小搜索**，另一个是**alpha-beta剪枝**。\n\n<!-- more -->\n\n## 博弈树\n\n下过五子棋的人都应该知道，越厉害的人，对棋面的预测程度越深。换句话讲，就是当你下完一步棋，我就能在我的脑海里假设把我所有可能下的地方都下一遍，然后考虑我下完之后你又会下在哪里，最后我根据每次预测的局势好坏来判断我的下一步棋放哪最合适。当然这只是想了一层，一个专业的棋手思考的层数会多得多。\n\n作为一个难度较大的 AI，势必也需要能够对棋局进行深入分析，然而五子棋的棋盘大小一般是 15 * 15，可以落子的地方太多，在这种情况下，电脑的性能有限，我们需要满足 AI “思考”的层数不能太低，同时算法的效率要高。\n\n以三子棋为例，AI 思考的过程就如同下面这课树一样，我们用圆圈代表玩家，叉号代表 AI，根节点是用户的落子。\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/01.png)\n\n如果继续画下一层，那么下一层就是玩家下一步的落子，这也就是 AI 思考的层数又多了一层。\n\n有了这棵树，我们就需要得出每个节点的得分是多少，以判断哪一步是最优的。\n\n### 得分\n\n要考虑这一步棋是不是最优的，我们需要给每一步棋都设定一个得分，然后找出最忧的。当前棋面的得分多少，需要同时考虑玩家和 AI 分别的得分。\n\n以三子棋为例，当玩家下在左上角的时候，我们考虑 AI 下在正中间时的得分。得分的计算方法是将棋面的空白地方用棋子填满，然后得出连成三个的个数有多少。（如果是五子棋，应该只需找出当前棋面上所有连子，然后根据每种连子的权重来计算得分）\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/04.png)\n\n如图，玩家一共有 4 个成三，而 AI 一共有 5 个，所以总得分是 `5 - 4 = 1`。\n\n这里需要指出的是，在博弈树中，一个节点的得分是取决于他的子节点的，也就是说，当 AI 只思考一层，也就是上图这样，这棵树的末尾就是只有两个棋子，那么这个节点的得分就是这样计算，而如果这个节点下还有子节点，那么我们只会计算叶子节点的得分，然后从叶子节点开始，一步步倒推出父节点的得分。下面来进行解释倒推的过程。\n\n### 博弈\n\n当 AI 下棋时，我们必定要让 AI 下在得分最高的位置，这毋庸置疑。但是以 AI 的角度来考虑玩家的落子，我们需要假设玩家是“聪明的”，他会下在对自己最有利的地方，也就是得分最低的地方（因为得分 = AI 分数 - 玩家分数）。\n\n这就造成每一层的性质是不同的，在玩家落子的层里，我们要选取得分最低的；在 AI 落子的层里，我们要选取得分最高的。所以我们称玩家层为 MIN 层，AI 层为 MAX 层。\n\n## 极大极小搜索\n\n上面提到了，计算出叶子节点之后，我们需要倒推出父节点的得分，倒推的原则其实就是上面说的：MAX\n层中的节点会从子节点中挑选最大得分的节点作为它的得分，MIN 层的节点会从子节点中挑选最小得分的节点作为它的得分。\n\n以下图举例：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/02.png)\n\n因为我们是根据子节点的得分来倒推父节点的得分的，所以我们是用深度优先来遍历博弈树的，在上面这棵树中，遍历顺序是 `ABCDEFGHIJ`，赋值过程如下：\n\n1. 遍历完 A B，因为 C 是 MIN 层，所以选取 AB 中最小的，即 8 作为 C 的得分\n2. 遍历完 D E，F 的得分为 6\n3. 遍历完 G H，I 的得分为 5\n4. 因为 J 在 MAX 层，所以选取 C F I 中得分最大的，即 8 作为 I 的得分\n\n## alpha-beta 剪枝\n\n从上面可以想到，像五子棋这种可能性很多的情况，这棵树会变得非常大，当层数增加的时候，计算量也会越来越大，如果不采取一些方法，我们只能靠牺牲层数来换取运行时间。\n\n那么 alpha-beta 剪枝就是一种行之有效的方法，顾名思义，采用这种方法，我们会剪去一些不必要的树枝，也就减少了运行的时间。\n\nalpha-beta 剪枝的定义很绕口，但是原理很简单，还是以上面那课树为例：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/03.png)\n\n当遍历到 C 的时候，计算出 C 的得分是 `8`，因为 J 的得分是 C、F、I 之中最大的，所以此时可以得出 `J >= 8`。\n\n接下来遍历到 D，D 的值为 `6`，因为 F 的值是 D 和 E 之中最小的，所以即使现在还没有遍历完 F 的子节点也可以得出 `F <= 6`，那么既然 J 已经大于等于 `8` 了，所以继续遍历 F 已经没有意义了，那么我们就将 F 这条枝剪掉。\n\n同理，当 G 为 `5` 时，遍历 I 已经没有意义了，因为 I 不可能再大于 `5`，所以直接得出 J 为 `8`；\n\n可以看出，当节点很多的情况下，使用 alpha-beta 剪枝是能在一定程度上提高运行效率的。","slug":"five-in-a-row-game","published":1,"updated":"2016-08-27T00:03:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscgyh1j000lgq2733gd8y9h","content":"<p>和水哥在北戴河回来的车上除了讨论 24 点的实现方式之外，还讨论了一下五子棋的算法。昨天趁着周末凭着自己的想法试着写了一下，很不幸的是五子棋没写出来，倒是写了个三子棋（orz），网上查了一些资料，其实这里面涉及两个主要的算法，一个是<strong>极大极小搜索</strong>，另一个是<strong>alpha-beta剪枝</strong>。</p>\n<a id=\"more\"></a>\n<h2 id=\"博弈树\"><a href=\"#博弈树\" class=\"headerlink\" title=\"博弈树\"></a>博弈树</h2><p>下过五子棋的人都应该知道，越厉害的人，对棋面的预测程度越深。换句话讲，就是当你下完一步棋，我就能在我的脑海里假设把我所有可能下的地方都下一遍，然后考虑我下完之后你又会下在哪里，最后我根据每次预测的局势好坏来判断我的下一步棋放哪最合适。当然这只是想了一层，一个专业的棋手思考的层数会多得多。</p>\n<p>作为一个难度较大的 AI，势必也需要能够对棋局进行深入分析，然而五子棋的棋盘大小一般是 15 * 15，可以落子的地方太多，在这种情况下，电脑的性能有限，我们需要满足 AI “思考”的层数不能太低，同时算法的效率要高。</p>\n<p>以三子棋为例，AI 思考的过程就如同下面这课树一样，我们用圆圈代表玩家，叉号代表 AI，根节点是用户的落子。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/01.png\" alt=\"\"></p>\n<p>如果继续画下一层，那么下一层就是玩家下一步的落子，这也就是 AI 思考的层数又多了一层。</p>\n<p>有了这棵树，我们就需要得出每个节点的得分是多少，以判断哪一步是最优的。</p>\n<h3 id=\"得分\"><a href=\"#得分\" class=\"headerlink\" title=\"得分\"></a>得分</h3><p>要考虑这一步棋是不是最优的，我们需要给每一步棋都设定一个得分，然后找出最忧的。当前棋面的得分多少，需要同时考虑玩家和 AI 分别的得分。</p>\n<p>以三子棋为例，当玩家下在左上角的时候，我们考虑 AI 下在正中间时的得分。得分的计算方法是将棋面的空白地方用棋子填满，然后得出连成三个的个数有多少。（如果是五子棋，应该只需找出当前棋面上所有连子，然后根据每种连子的权重来计算得分）</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/04.png\" alt=\"\"></p>\n<p>如图，玩家一共有 4 个成三，而 AI 一共有 5 个，所以总得分是 <code>5 - 4 = 1</code>。</p>\n<p>这里需要指出的是，在博弈树中，一个节点的得分是取决于他的子节点的，也就是说，当 AI 只思考一层，也就是上图这样，这棵树的末尾就是只有两个棋子，那么这个节点的得分就是这样计算，而如果这个节点下还有子节点，那么我们只会计算叶子节点的得分，然后从叶子节点开始，一步步倒推出父节点的得分。下面来进行解释倒推的过程。</p>\n<h3 id=\"博弈\"><a href=\"#博弈\" class=\"headerlink\" title=\"博弈\"></a>博弈</h3><p>当 AI 下棋时，我们必定要让 AI 下在得分最高的位置，这毋庸置疑。但是以 AI 的角度来考虑玩家的落子，我们需要假设玩家是“聪明的”，他会下在对自己最有利的地方，也就是得分最低的地方（因为得分 = AI 分数 - 玩家分数）。</p>\n<p>这就造成每一层的性质是不同的，在玩家落子的层里，我们要选取得分最低的；在 AI 落子的层里，我们要选取得分最高的。所以我们称玩家层为 MIN 层，AI 层为 MAX 层。</p>\n<h2 id=\"极大极小搜索\"><a href=\"#极大极小搜索\" class=\"headerlink\" title=\"极大极小搜索\"></a>极大极小搜索</h2><p>上面提到了，计算出叶子节点之后，我们需要倒推出父节点的得分，倒推的原则其实就是上面说的：MAX<br>层中的节点会从子节点中挑选最大得分的节点作为它的得分，MIN 层的节点会从子节点中挑选最小得分的节点作为它的得分。</p>\n<p>以下图举例：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/02.png\" alt=\"\"></p>\n<p>因为我们是根据子节点的得分来倒推父节点的得分的，所以我们是用深度优先来遍历博弈树的，在上面这棵树中，遍历顺序是 <code>ABCDEFGHIJ</code>，赋值过程如下：</p>\n<ol>\n<li>遍历完 A B，因为 C 是 MIN 层，所以选取 AB 中最小的，即 8 作为 C 的得分</li>\n<li>遍历完 D E，F 的得分为 6</li>\n<li>遍历完 G H，I 的得分为 5</li>\n<li>因为 J 在 MAX 层，所以选取 C F I 中得分最大的，即 8 作为 I 的得分</li>\n</ol>\n<h2 id=\"alpha-beta-剪枝\"><a href=\"#alpha-beta-剪枝\" class=\"headerlink\" title=\"alpha-beta 剪枝\"></a>alpha-beta 剪枝</h2><p>从上面可以想到，像五子棋这种可能性很多的情况，这棵树会变得非常大，当层数增加的时候，计算量也会越来越大，如果不采取一些方法，我们只能靠牺牲层数来换取运行时间。</p>\n<p>那么 alpha-beta 剪枝就是一种行之有效的方法，顾名思义，采用这种方法，我们会剪去一些不必要的树枝，也就减少了运行的时间。</p>\n<p>alpha-beta 剪枝的定义很绕口，但是原理很简单，还是以上面那课树为例：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/03.png\" alt=\"\"></p>\n<p>当遍历到 C 的时候，计算出 C 的得分是 <code>8</code>，因为 J 的得分是 C、F、I 之中最大的，所以此时可以得出 <code>J &gt;= 8</code>。</p>\n<p>接下来遍历到 D，D 的值为 <code>6</code>，因为 F 的值是 D 和 E 之中最小的，所以即使现在还没有遍历完 F 的子节点也可以得出 <code>F &lt;= 6</code>，那么既然 J 已经大于等于 <code>8</code> 了，所以继续遍历 F 已经没有意义了，那么我们就将 F 这条枝剪掉。</p>\n<p>同理，当 G 为 <code>5</code> 时，遍历 I 已经没有意义了，因为 I 不可能再大于 <code>5</code>，所以直接得出 J 为 <code>8</code>；</p>\n<p>可以看出，当节点很多的情况下，使用 alpha-beta 剪枝是能在一定程度上提高运行效率的。</p>\n","excerpt":"<p>和水哥在北戴河回来的车上除了讨论 24 点的实现方式之外，还讨论了一下五子棋的算法。昨天趁着周末凭着自己的想法试着写了一下，很不幸的是五子棋没写出来，倒是写了个三子棋（orz），网上查了一些资料，其实这里面涉及两个主要的算法，一个是<strong>极大极小搜索</strong>，另一个是<strong>alpha-beta剪枝</strong>。</p>","more":"<h2 id=\"博弈树\"><a href=\"#博弈树\" class=\"headerlink\" title=\"博弈树\"></a>博弈树</h2><p>下过五子棋的人都应该知道，越厉害的人，对棋面的预测程度越深。换句话讲，就是当你下完一步棋，我就能在我的脑海里假设把我所有可能下的地方都下一遍，然后考虑我下完之后你又会下在哪里，最后我根据每次预测的局势好坏来判断我的下一步棋放哪最合适。当然这只是想了一层，一个专业的棋手思考的层数会多得多。</p>\n<p>作为一个难度较大的 AI，势必也需要能够对棋局进行深入分析，然而五子棋的棋盘大小一般是 15 * 15，可以落子的地方太多，在这种情况下，电脑的性能有限，我们需要满足 AI “思考”的层数不能太低，同时算法的效率要高。</p>\n<p>以三子棋为例，AI 思考的过程就如同下面这课树一样，我们用圆圈代表玩家，叉号代表 AI，根节点是用户的落子。</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/01.png\" alt=\"\"></p>\n<p>如果继续画下一层，那么下一层就是玩家下一步的落子，这也就是 AI 思考的层数又多了一层。</p>\n<p>有了这棵树，我们就需要得出每个节点的得分是多少，以判断哪一步是最优的。</p>\n<h3 id=\"得分\"><a href=\"#得分\" class=\"headerlink\" title=\"得分\"></a>得分</h3><p>要考虑这一步棋是不是最优的，我们需要给每一步棋都设定一个得分，然后找出最忧的。当前棋面的得分多少，需要同时考虑玩家和 AI 分别的得分。</p>\n<p>以三子棋为例，当玩家下在左上角的时候，我们考虑 AI 下在正中间时的得分。得分的计算方法是将棋面的空白地方用棋子填满，然后得出连成三个的个数有多少。（如果是五子棋，应该只需找出当前棋面上所有连子，然后根据每种连子的权重来计算得分）</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/04.png\" alt=\"\"></p>\n<p>如图，玩家一共有 4 个成三，而 AI 一共有 5 个，所以总得分是 <code>5 - 4 = 1</code>。</p>\n<p>这里需要指出的是，在博弈树中，一个节点的得分是取决于他的子节点的，也就是说，当 AI 只思考一层，也就是上图这样，这棵树的末尾就是只有两个棋子，那么这个节点的得分就是这样计算，而如果这个节点下还有子节点，那么我们只会计算叶子节点的得分，然后从叶子节点开始，一步步倒推出父节点的得分。下面来进行解释倒推的过程。</p>\n<h3 id=\"博弈\"><a href=\"#博弈\" class=\"headerlink\" title=\"博弈\"></a>博弈</h3><p>当 AI 下棋时，我们必定要让 AI 下在得分最高的位置，这毋庸置疑。但是以 AI 的角度来考虑玩家的落子，我们需要假设玩家是“聪明的”，他会下在对自己最有利的地方，也就是得分最低的地方（因为得分 = AI 分数 - 玩家分数）。</p>\n<p>这就造成每一层的性质是不同的，在玩家落子的层里，我们要选取得分最低的；在 AI 落子的层里，我们要选取得分最高的。所以我们称玩家层为 MIN 层，AI 层为 MAX 层。</p>\n<h2 id=\"极大极小搜索\"><a href=\"#极大极小搜索\" class=\"headerlink\" title=\"极大极小搜索\"></a>极大极小搜索</h2><p>上面提到了，计算出叶子节点之后，我们需要倒推出父节点的得分，倒推的原则其实就是上面说的：MAX<br>层中的节点会从子节点中挑选最大得分的节点作为它的得分，MIN 层的节点会从子节点中挑选最小得分的节点作为它的得分。</p>\n<p>以下图举例：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/02.png\" alt=\"\"></p>\n<p>因为我们是根据子节点的得分来倒推父节点的得分的，所以我们是用深度优先来遍历博弈树的，在上面这棵树中，遍历顺序是 <code>ABCDEFGHIJ</code>，赋值过程如下：</p>\n<ol>\n<li>遍历完 A B，因为 C 是 MIN 层，所以选取 AB 中最小的，即 8 作为 C 的得分</li>\n<li>遍历完 D E，F 的得分为 6</li>\n<li>遍历完 G H，I 的得分为 5</li>\n<li>因为 J 在 MAX 层，所以选取 C F I 中得分最大的，即 8 作为 I 的得分</li>\n</ol>\n<h2 id=\"alpha-beta-剪枝\"><a href=\"#alpha-beta-剪枝\" class=\"headerlink\" title=\"alpha-beta 剪枝\"></a>alpha-beta 剪枝</h2><p>从上面可以想到，像五子棋这种可能性很多的情况，这棵树会变得非常大，当层数增加的时候，计算量也会越来越大，如果不采取一些方法，我们只能靠牺牲层数来换取运行时间。</p>\n<p>那么 alpha-beta 剪枝就是一种行之有效的方法，顾名思义，采用这种方法，我们会剪去一些不必要的树枝，也就减少了运行的时间。</p>\n<p>alpha-beta 剪枝的定义很绕口，但是原理很简单，还是以上面那课树为例：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/03.png\" alt=\"\"></p>\n<p>当遍历到 C 的时候，计算出 C 的得分是 <code>8</code>，因为 J 的得分是 C、F、I 之中最大的，所以此时可以得出 <code>J &gt;= 8</code>。</p>\n<p>接下来遍历到 D，D 的值为 <code>6</code>，因为 F 的值是 D 和 E 之中最小的，所以即使现在还没有遍历完 F 的子节点也可以得出 <code>F &lt;= 6</code>，那么既然 J 已经大于等于 <code>8</code> 了，所以继续遍历 F 已经没有意义了，那么我们就将 F 这条枝剪掉。</p>\n<p>同理，当 G 为 <code>5</code> 时，遍历 I 已经没有意义了，因为 I 不可能再大于 <code>5</code>，所以直接得出 J 为 <code>8</code>；</p>\n<p>可以看出，当节点很多的情况下，使用 alpha-beta 剪枝是能在一定程度上提高运行效率的。</p>"},{"title":"自然语言处理（一）","date":"2016-07-10T15:28:24.000Z","_content":"\n如果想实现聊天机器人，必然要让程序能够正确响应用户的信息，而用户对机器输入的往往是我们平时使用的语言，也就是自然语言，想让机器能“理解”用户的信息，并能够返回用户需要的信息，这就涉及到了**自然语言处理**。从上个世纪50年代起，科学家们就已经开始着手研究这个问题，到现在为止，已经取得了非常大的突破。\n\n<!-- more -->\n\n## 自然语言处理的两个阶段\n\n在自然语言处理 60 多年的发展过程中，基本上可以分成两个阶段。早期的 20 多年，即从上个世纪 60 年代到70年代，是科学家们走弯路的阶段。当时，学术界对人工智能和自然语言理解的普遍认为：要让机器完成翻译或者语音识别等只有人类才能做到的事，就必须先让计算机理解自然语言，而做到这一点就必须让计算机拥有类似我们人类这样的智能。\n\n> 而事实上当然不是这样。对人类来讲，一个要把英文翻译成中文的人，必然要能很好地理解这两种语言，这就是直觉的作用。在人工智能领域，包括自然语言处理领域，这种方法论被称作“鸟飞派”，也就是看看鸟是怎么飞的就能模仿鸟造出的飞机，而不需要了解空气动力学。事实上，怀特兄弟发明飞机靠的是空气动力学而不是仿生学。\n\n### 基于规则的自然语言处理\n\n在 20 世纪 60 年代，当时普遍认识是首先做好两件事，即**分析语句**和**获取语义**。这是因为当时的语言学家们已经对各种自然语言进行了非常形式化的总结，形成了十分完备的体系。就好像学习西方语言，都要学习*语法规则*、*词性*和*构词法*等。而恰恰这些语法规则又很容易用计算机的算法描述，这就让大家对**基于规则的自然语言处理**充满了信心。\n\n当时对自然语言处理从研究到应用的依赖关系如下：\n\n- **应用层**：`语言识别`、`机器翻译`、`自动问答`、`自动摘要`等\n- **认知层**：`自然语言理解`\n- **基础层**：`句法分析`、`语义分析`\n\n首先我们关注句法分析。\n\n句法分析首先对一个句子进行拆分，得到一颗**文法分析树**，以` “徐志摩喜欢林徽因。”` 这句话来说，这句话分为主语、动词短语（即谓语）和句号三部分，得到的文法分析树如下：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/natural-language-processing-1/01.png)\n\n接下来分析出句子采用的文法规则，这个过程成为重写规则。具体到这个例子，重写规则包括：\n\n- 句子     --> 主语谓语句号\n- 主语     --> 名词\n- 谓语     --> 动词 名词短语\n- 名词短语 --> 名词\n- 名词     --> 徐志摩\n- 动词     --> 喜欢\n- 名词     --> 林徽因\n- 句号     --> 。\n\n从上面可以看出，短短几个字的句子，就需要一颗这么复杂的二维树结构和八条文法规则，而随着句子的复杂化，要处理起来就变得相当困难了，一个句子的文法分析树将变得非常巨大，也非常复杂。\n\n这里面至少有两个越不过去的坎。首先，想通过文法规则覆盖哪怕 20% 的真实语句，文法规则的数量也是几万条。随着覆盖语句的增加，文法规则的数量还会越来越多。\n\n其次，自然语言在演变的过程中，产生了词义和上下文相关的特性，因此，它的文法是**上下文有关文法**，而程序语言是人为设定的，是便于计算机解码的**上下文无关文法**，相比自然语言简单的多。两者计算量不可同日而语。\n\n> 在计算机科学中，图灵奖最高得主高德纳提出用计算复杂度来衡量算法的耗时。对于上下文无关语法，算法的复杂度基本上是语句长度的二次方，而对于上下文有关语法，计算复杂度基本上是语句长度的**六次方**。也就是说，长度同为 10 的程序语言语句和自然语言语句，计算机对它们进行文法分析的计算量，后者是前者的 10000 倍。而随着长度增加，这个差异会以非常快的速度扩大。所以在那个年代，即使是 IBM 公司，也几乎是不可能采用规则的方法来分析一些真实语句。\n\n在上个世纪 70 年代，基于规则的句法分析很快就走到了尽头，而对于语义处理则遇到了更大的麻烦，自然语言中的词的多义性很难用规则来描述，而是严重依赖于上下文，甚至是常识。\n\n举例来说，`the box is in the pen` 这句话，意思是 `盒子在围栏里`，但是 `pen` 到底翻译成钢笔还是围栏是取决于什么？是取决于常识：因为盒子不可能装在钢笔里，这个例子非常清晰地说明了自然语言处理研究方法上存在的问题。\n\n这时候，**基于统计的自然语言处理**重获了新生，并取得了今天的非凡成就。\n\n### 基于统计的自然语言处理\n\n(待续)\n","source":"_posts/natural-language-processing-1.md","raw":"---\ntitle: 自然语言处理（一）\ndate: 2016-07-10 23:28:24\ntags: [自然语言处理 读书笔记]\n---\n\n如果想实现聊天机器人，必然要让程序能够正确响应用户的信息，而用户对机器输入的往往是我们平时使用的语言，也就是自然语言，想让机器能“理解”用户的信息，并能够返回用户需要的信息，这就涉及到了**自然语言处理**。从上个世纪50年代起，科学家们就已经开始着手研究这个问题，到现在为止，已经取得了非常大的突破。\n\n<!-- more -->\n\n## 自然语言处理的两个阶段\n\n在自然语言处理 60 多年的发展过程中，基本上可以分成两个阶段。早期的 20 多年，即从上个世纪 60 年代到70年代，是科学家们走弯路的阶段。当时，学术界对人工智能和自然语言理解的普遍认为：要让机器完成翻译或者语音识别等只有人类才能做到的事，就必须先让计算机理解自然语言，而做到这一点就必须让计算机拥有类似我们人类这样的智能。\n\n> 而事实上当然不是这样。对人类来讲，一个要把英文翻译成中文的人，必然要能很好地理解这两种语言，这就是直觉的作用。在人工智能领域，包括自然语言处理领域，这种方法论被称作“鸟飞派”，也就是看看鸟是怎么飞的就能模仿鸟造出的飞机，而不需要了解空气动力学。事实上，怀特兄弟发明飞机靠的是空气动力学而不是仿生学。\n\n### 基于规则的自然语言处理\n\n在 20 世纪 60 年代，当时普遍认识是首先做好两件事，即**分析语句**和**获取语义**。这是因为当时的语言学家们已经对各种自然语言进行了非常形式化的总结，形成了十分完备的体系。就好像学习西方语言，都要学习*语法规则*、*词性*和*构词法*等。而恰恰这些语法规则又很容易用计算机的算法描述，这就让大家对**基于规则的自然语言处理**充满了信心。\n\n当时对自然语言处理从研究到应用的依赖关系如下：\n\n- **应用层**：`语言识别`、`机器翻译`、`自动问答`、`自动摘要`等\n- **认知层**：`自然语言理解`\n- **基础层**：`句法分析`、`语义分析`\n\n首先我们关注句法分析。\n\n句法分析首先对一个句子进行拆分，得到一颗**文法分析树**，以` “徐志摩喜欢林徽因。”` 这句话来说，这句话分为主语、动词短语（即谓语）和句号三部分，得到的文法分析树如下：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/natural-language-processing-1/01.png)\n\n接下来分析出句子采用的文法规则，这个过程成为重写规则。具体到这个例子，重写规则包括：\n\n- 句子     --> 主语谓语句号\n- 主语     --> 名词\n- 谓语     --> 动词 名词短语\n- 名词短语 --> 名词\n- 名词     --> 徐志摩\n- 动词     --> 喜欢\n- 名词     --> 林徽因\n- 句号     --> 。\n\n从上面可以看出，短短几个字的句子，就需要一颗这么复杂的二维树结构和八条文法规则，而随着句子的复杂化，要处理起来就变得相当困难了，一个句子的文法分析树将变得非常巨大，也非常复杂。\n\n这里面至少有两个越不过去的坎。首先，想通过文法规则覆盖哪怕 20% 的真实语句，文法规则的数量也是几万条。随着覆盖语句的增加，文法规则的数量还会越来越多。\n\n其次，自然语言在演变的过程中，产生了词义和上下文相关的特性，因此，它的文法是**上下文有关文法**，而程序语言是人为设定的，是便于计算机解码的**上下文无关文法**，相比自然语言简单的多。两者计算量不可同日而语。\n\n> 在计算机科学中，图灵奖最高得主高德纳提出用计算复杂度来衡量算法的耗时。对于上下文无关语法，算法的复杂度基本上是语句长度的二次方，而对于上下文有关语法，计算复杂度基本上是语句长度的**六次方**。也就是说，长度同为 10 的程序语言语句和自然语言语句，计算机对它们进行文法分析的计算量，后者是前者的 10000 倍。而随着长度增加，这个差异会以非常快的速度扩大。所以在那个年代，即使是 IBM 公司，也几乎是不可能采用规则的方法来分析一些真实语句。\n\n在上个世纪 70 年代，基于规则的句法分析很快就走到了尽头，而对于语义处理则遇到了更大的麻烦，自然语言中的词的多义性很难用规则来描述，而是严重依赖于上下文，甚至是常识。\n\n举例来说，`the box is in the pen` 这句话，意思是 `盒子在围栏里`，但是 `pen` 到底翻译成钢笔还是围栏是取决于什么？是取决于常识：因为盒子不可能装在钢笔里，这个例子非常清晰地说明了自然语言处理研究方法上存在的问题。\n\n这时候，**基于统计的自然语言处理**重获了新生，并取得了今天的非凡成就。\n\n### 基于统计的自然语言处理\n\n(待续)\n","slug":"natural-language-processing-1","published":1,"updated":"2016-08-27T00:03:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscgyh1n000ngq27049ubs4a","content":"<p>如果想实现聊天机器人，必然要让程序能够正确响应用户的信息，而用户对机器输入的往往是我们平时使用的语言，也就是自然语言，想让机器能“理解”用户的信息，并能够返回用户需要的信息，这就涉及到了<strong>自然语言处理</strong>。从上个世纪50年代起，科学家们就已经开始着手研究这个问题，到现在为止，已经取得了非常大的突破。</p>\n<a id=\"more\"></a>\n<h2 id=\"自然语言处理的两个阶段\"><a href=\"#自然语言处理的两个阶段\" class=\"headerlink\" title=\"自然语言处理的两个阶段\"></a>自然语言处理的两个阶段</h2><p>在自然语言处理 60 多年的发展过程中，基本上可以分成两个阶段。早期的 20 多年，即从上个世纪 60 年代到70年代，是科学家们走弯路的阶段。当时，学术界对人工智能和自然语言理解的普遍认为：要让机器完成翻译或者语音识别等只有人类才能做到的事，就必须先让计算机理解自然语言，而做到这一点就必须让计算机拥有类似我们人类这样的智能。</p>\n<blockquote>\n<p>而事实上当然不是这样。对人类来讲，一个要把英文翻译成中文的人，必然要能很好地理解这两种语言，这就是直觉的作用。在人工智能领域，包括自然语言处理领域，这种方法论被称作“鸟飞派”，也就是看看鸟是怎么飞的就能模仿鸟造出的飞机，而不需要了解空气动力学。事实上，怀特兄弟发明飞机靠的是空气动力学而不是仿生学。</p>\n</blockquote>\n<h3 id=\"基于规则的自然语言处理\"><a href=\"#基于规则的自然语言处理\" class=\"headerlink\" title=\"基于规则的自然语言处理\"></a>基于规则的自然语言处理</h3><p>在 20 世纪 60 年代，当时普遍认识是首先做好两件事，即<strong>分析语句</strong>和<strong>获取语义</strong>。这是因为当时的语言学家们已经对各种自然语言进行了非常形式化的总结，形成了十分完备的体系。就好像学习西方语言，都要学习<em>语法规则</em>、<em>词性</em>和<em>构词法</em>等。而恰恰这些语法规则又很容易用计算机的算法描述，这就让大家对<strong>基于规则的自然语言处理</strong>充满了信心。</p>\n<p>当时对自然语言处理从研究到应用的依赖关系如下：</p>\n<ul>\n<li><strong>应用层</strong>：<code>语言识别</code>、<code>机器翻译</code>、<code>自动问答</code>、<code>自动摘要</code>等</li>\n<li><strong>认知层</strong>：<code>自然语言理解</code></li>\n<li><strong>基础层</strong>：<code>句法分析</code>、<code>语义分析</code></li>\n</ul>\n<p>首先我们关注句法分析。</p>\n<p>句法分析首先对一个句子进行拆分，得到一颗<strong>文法分析树</strong>，以<code>“徐志摩喜欢林徽因。”</code> 这句话来说，这句话分为主语、动词短语（即谓语）和句号三部分，得到的文法分析树如下：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/natural-language-processing-1/01.png\" alt=\"\"></p>\n<p>接下来分析出句子采用的文法规则，这个过程成为重写规则。具体到这个例子，重写规则包括：</p>\n<ul>\n<li>句子     –&gt; 主语谓语句号</li>\n<li>主语     –&gt; 名词</li>\n<li>谓语     –&gt; 动词 名词短语</li>\n<li>名词短语 –&gt; 名词</li>\n<li>名词     –&gt; 徐志摩</li>\n<li>动词     –&gt; 喜欢</li>\n<li>名词     –&gt; 林徽因</li>\n<li>句号     –&gt; 。</li>\n</ul>\n<p>从上面可以看出，短短几个字的句子，就需要一颗这么复杂的二维树结构和八条文法规则，而随着句子的复杂化，要处理起来就变得相当困难了，一个句子的文法分析树将变得非常巨大，也非常复杂。</p>\n<p>这里面至少有两个越不过去的坎。首先，想通过文法规则覆盖哪怕 20% 的真实语句，文法规则的数量也是几万条。随着覆盖语句的增加，文法规则的数量还会越来越多。</p>\n<p>其次，自然语言在演变的过程中，产生了词义和上下文相关的特性，因此，它的文法是<strong>上下文有关文法</strong>，而程序语言是人为设定的，是便于计算机解码的<strong>上下文无关文法</strong>，相比自然语言简单的多。两者计算量不可同日而语。</p>\n<blockquote>\n<p>在计算机科学中，图灵奖最高得主高德纳提出用计算复杂度来衡量算法的耗时。对于上下文无关语法，算法的复杂度基本上是语句长度的二次方，而对于上下文有关语法，计算复杂度基本上是语句长度的<strong>六次方</strong>。也就是说，长度同为 10 的程序语言语句和自然语言语句，计算机对它们进行文法分析的计算量，后者是前者的 10000 倍。而随着长度增加，这个差异会以非常快的速度扩大。所以在那个年代，即使是 IBM 公司，也几乎是不可能采用规则的方法来分析一些真实语句。</p>\n</blockquote>\n<p>在上个世纪 70 年代，基于规则的句法分析很快就走到了尽头，而对于语义处理则遇到了更大的麻烦，自然语言中的词的多义性很难用规则来描述，而是严重依赖于上下文，甚至是常识。</p>\n<p>举例来说，<code>the box is in the pen</code> 这句话，意思是 <code>盒子在围栏里</code>，但是 <code>pen</code> 到底翻译成钢笔还是围栏是取决于什么？是取决于常识：因为盒子不可能装在钢笔里，这个例子非常清晰地说明了自然语言处理研究方法上存在的问题。</p>\n<p>这时候，<strong>基于统计的自然语言处理</strong>重获了新生，并取得了今天的非凡成就。</p>\n<h3 id=\"基于统计的自然语言处理\"><a href=\"#基于统计的自然语言处理\" class=\"headerlink\" title=\"基于统计的自然语言处理\"></a>基于统计的自然语言处理</h3><p>(待续)</p>\n","excerpt":"<p>如果想实现聊天机器人，必然要让程序能够正确响应用户的信息，而用户对机器输入的往往是我们平时使用的语言，也就是自然语言，想让机器能“理解”用户的信息，并能够返回用户需要的信息，这就涉及到了<strong>自然语言处理</strong>。从上个世纪50年代起，科学家们就已经开始着手研究这个问题，到现在为止，已经取得了非常大的突破。</p>","more":"<h2 id=\"自然语言处理的两个阶段\"><a href=\"#自然语言处理的两个阶段\" class=\"headerlink\" title=\"自然语言处理的两个阶段\"></a>自然语言处理的两个阶段</h2><p>在自然语言处理 60 多年的发展过程中，基本上可以分成两个阶段。早期的 20 多年，即从上个世纪 60 年代到70年代，是科学家们走弯路的阶段。当时，学术界对人工智能和自然语言理解的普遍认为：要让机器完成翻译或者语音识别等只有人类才能做到的事，就必须先让计算机理解自然语言，而做到这一点就必须让计算机拥有类似我们人类这样的智能。</p>\n<blockquote>\n<p>而事实上当然不是这样。对人类来讲，一个要把英文翻译成中文的人，必然要能很好地理解这两种语言，这就是直觉的作用。在人工智能领域，包括自然语言处理领域，这种方法论被称作“鸟飞派”，也就是看看鸟是怎么飞的就能模仿鸟造出的飞机，而不需要了解空气动力学。事实上，怀特兄弟发明飞机靠的是空气动力学而不是仿生学。</p>\n</blockquote>\n<h3 id=\"基于规则的自然语言处理\"><a href=\"#基于规则的自然语言处理\" class=\"headerlink\" title=\"基于规则的自然语言处理\"></a>基于规则的自然语言处理</h3><p>在 20 世纪 60 年代，当时普遍认识是首先做好两件事，即<strong>分析语句</strong>和<strong>获取语义</strong>。这是因为当时的语言学家们已经对各种自然语言进行了非常形式化的总结，形成了十分完备的体系。就好像学习西方语言，都要学习<em>语法规则</em>、<em>词性</em>和<em>构词法</em>等。而恰恰这些语法规则又很容易用计算机的算法描述，这就让大家对<strong>基于规则的自然语言处理</strong>充满了信心。</p>\n<p>当时对自然语言处理从研究到应用的依赖关系如下：</p>\n<ul>\n<li><strong>应用层</strong>：<code>语言识别</code>、<code>机器翻译</code>、<code>自动问答</code>、<code>自动摘要</code>等</li>\n<li><strong>认知层</strong>：<code>自然语言理解</code></li>\n<li><strong>基础层</strong>：<code>句法分析</code>、<code>语义分析</code></li>\n</ul>\n<p>首先我们关注句法分析。</p>\n<p>句法分析首先对一个句子进行拆分，得到一颗<strong>文法分析树</strong>，以<code>“徐志摩喜欢林徽因。”</code> 这句话来说，这句话分为主语、动词短语（即谓语）和句号三部分，得到的文法分析树如下：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/natural-language-processing-1/01.png\" alt=\"\"></p>\n<p>接下来分析出句子采用的文法规则，这个过程成为重写规则。具体到这个例子，重写规则包括：</p>\n<ul>\n<li>句子     –&gt; 主语谓语句号</li>\n<li>主语     –&gt; 名词</li>\n<li>谓语     –&gt; 动词 名词短语</li>\n<li>名词短语 –&gt; 名词</li>\n<li>名词     –&gt; 徐志摩</li>\n<li>动词     –&gt; 喜欢</li>\n<li>名词     –&gt; 林徽因</li>\n<li>句号     –&gt; 。</li>\n</ul>\n<p>从上面可以看出，短短几个字的句子，就需要一颗这么复杂的二维树结构和八条文法规则，而随着句子的复杂化，要处理起来就变得相当困难了，一个句子的文法分析树将变得非常巨大，也非常复杂。</p>\n<p>这里面至少有两个越不过去的坎。首先，想通过文法规则覆盖哪怕 20% 的真实语句，文法规则的数量也是几万条。随着覆盖语句的增加，文法规则的数量还会越来越多。</p>\n<p>其次，自然语言在演变的过程中，产生了词义和上下文相关的特性，因此，它的文法是<strong>上下文有关文法</strong>，而程序语言是人为设定的，是便于计算机解码的<strong>上下文无关文法</strong>，相比自然语言简单的多。两者计算量不可同日而语。</p>\n<blockquote>\n<p>在计算机科学中，图灵奖最高得主高德纳提出用计算复杂度来衡量算法的耗时。对于上下文无关语法，算法的复杂度基本上是语句长度的二次方，而对于上下文有关语法，计算复杂度基本上是语句长度的<strong>六次方</strong>。也就是说，长度同为 10 的程序语言语句和自然语言语句，计算机对它们进行文法分析的计算量，后者是前者的 10000 倍。而随着长度增加，这个差异会以非常快的速度扩大。所以在那个年代，即使是 IBM 公司，也几乎是不可能采用规则的方法来分析一些真实语句。</p>\n</blockquote>\n<p>在上个世纪 70 年代，基于规则的句法分析很快就走到了尽头，而对于语义处理则遇到了更大的麻烦，自然语言中的词的多义性很难用规则来描述，而是严重依赖于上下文，甚至是常识。</p>\n<p>举例来说，<code>the box is in the pen</code> 这句话，意思是 <code>盒子在围栏里</code>，但是 <code>pen</code> 到底翻译成钢笔还是围栏是取决于什么？是取决于常识：因为盒子不可能装在钢笔里，这个例子非常清晰地说明了自然语言处理研究方法上存在的问题。</p>\n<p>这时候，<strong>基于统计的自然语言处理</strong>重获了新生，并取得了今天的非凡成就。</p>\n<h3 id=\"基于统计的自然语言处理\"><a href=\"#基于统计的自然语言处理\" class=\"headerlink\" title=\"基于统计的自然语言处理\"></a>基于统计的自然语言处理</h3><p>(待续)</p>"},{"title":"红黑树","date":"2016-08-07T15:10:57.000Z","_content":"\n红黑树是二叉搜索树的一种，同时也是一种平衡搜索树，在红黑树中，没有一条路径会比其他路径长出 2 倍，因此它是近似平衡的。\n\n<!-- more -->\n\n红黑树中的每个结点都有一个颜色，颜色可以是黑色或者红色，红黑树根据结点的颜色对树进行约束，从而保持树的平衡。\n\n一颗红黑树是满足下面红黑性质的二叉搜索树：\n\n1. 每个结点要么是红色，要么是黑色\n2. 根结点是黑色的\n3. 每个叶结点是黑色的\n4. 如果一个结点是红色，则它的两个子结点都是黑色的\n5. 对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点\n\n由性质 2 和 4 可知，红黑树中最短的路径是结点全部为黑色的路径，最长的路径是红黑相间的路径，所以在红黑树中，不会出现一条路径比其他路径长 2 倍。\n\n相比于以前使用 null 来表示边界，在红黑树中，我们引入哨兵 `nil` 来处理边界条件。哨兵和普通结点拥有相同属性，但作为叶子结点的哨兵根据性质 3，它的颜色应该是黑色的。\n\n如下就是一颗红黑树：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/red-black-tree.png)\n\n## 旋转\n\n红黑树和二叉搜索树很类似，但因为引入了红黑性质，所以在对红黑树进行插入和删除等操作的时候，很可能破坏红黑性质，这时候需要对树进行调整，改变一些结点的位置。\n\n旋转是调整树结构的一种操作，分为左旋和右旋。如下\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/rotate.png)\n\n在旋转中，只有指针会改变，其他属性都保持不变。\n\n```javascript\nleftRotate(node) {\n  let rNode = node.right;\n  node.right = rNode.left;\n  if(rNode.left != this.nil) {\n    rNode.left.parent = node;\n  }\n\n  rNode.parent = node.parent;\n  rNode.left = node;\n  node.parent = rNode;\n\n  if(rNode.parent == this.nil) {\n    this.root = rNode;\n  } else {\n    if(rNode.key < rNode.parent.key) {\n      rNode.parent.left = rNode;\n    } else {\n      rNode.parent.right = rNode;\n    }\n  }\n}\n\nrightRotate(node) {\n  let lNode = node.left;\n  node.left = lNode.right;\n  if(lNode.right != this.nil) {\n    lNode.right.parent = node;\n  }\n\n  lNode.parent = node.parent;\n  lNode.right = node;\n  node.parent = lNode;\n\n  if(lNode.parent == this.nil) {\n    this.root = lNode;\n  } else {\n    if(lNode.key < lNode.parent.key) {\n      lNode.parent.left = lNode;\n    } else {\n      lNode.parent.right = lNode;\n    }\n  }\n}\n```\n\n## 插入\n\n将新结点插入到红黑树中时，如果新结点是黑色，则势必会破坏性质 5，而红色可能一条性质也不会破坏，所以我们选择红色为新结点的默认颜色。\n\n插入之前我们需要先找到要插入的位置，这里和二叉搜索树是一样的。\n\n```javascript\nclass TreeNode {\n  constructor() {\n    this.parent = null;\n    this.left = null;\n    this.right = null;\n    this.key = 'nil';\n    this.color = 'black';\n  }\n\n  toString() {\n    return this.key + ',' + this.color;\n  }\n}\n\nclass RedBlackTree {\n\n  constructor() {\n    this.nil = new TreeNode();\n    this.root = this.nil;\n  }\n\n  insert(key) {\n    let curNode = this.root;\n    let parent = this.nil;\n    // 找到要插入的位置\n    while(curNode != this.nil) {\n      parent = curNode;\n      if(key < curNode.key) {\n        curNode = curNode.left;\n      } else {\n        curNode = curNode.right;\n      }\n    }\n\n    let node = new TreeNode();\n    node.key = key;\n    node.parent = parent;\n    node.left = this.nil;\n    node.right = this.nil;\n\n    if(parent == this.nil) {\n      // 如果树中没有结点，插入结点为根结点\n      node.color = 'black';\n      this.root = node;\n    } else {\n      // 插入到正确的地方\n      node.color = 'red';\n      if(node.key < parent.key) {\n        parent.left = node;\n      } else {\n        parent.right = node;\n      }\n      // 调整树的结构\n      this.insertFix(node);\n    }\n  }\n}\n```\n\n`insertFix` 方法的作用是在插入结点后调整树的结构，在有新的红色结点插入到树中后，有哪些性质可能被破坏呢？\n\n- 性质 1 显然不会被破坏。\n\n- 如果插入元素是根结点时，会破坏性质 2。\n\n- 性质 3 不会被破坏，因为叶子结点始终是哨兵。\n\n- 如果插入元素的父结点是红色，那么性质 4 会被破坏。\n\n- 性质 5 不会被破坏，因为插入的结点是红色，不会影响路径中黑色结点的个数。\n\n所以在调整树的结构时，我们只需关注性质 2 和 4。\n\n### 情况一\n\n如果插入结点的父结点是黑色结点，那么性质 12345 全部继续成立，不需要调整树的结构。\n\n### 情况二\n\n如果插入结点的父结点是红色结点。\n\n因为插入之前这课树是一颗红黑树，那么插入结点的父结点的父结点（图中的 B 结点）必定是黑色（否则违反性质 4）。如下图，R 表示红色，B 表示黑色：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/01.png)\n\n但不确定 C 是什么颜色。\n\n#### a) C 是红色\n\n因为 D 和 B 的颜色起了冲突，必定需要改变其中一个结点的颜色，如果改变 D 的颜色，会破坏性质 5，而如果改变 B 的颜色，为了维持性质 5，我们可以选择将 A 和 C 的颜色也改变，即：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/02.png)\n\n这个时候性质 5 不会被破坏，但因为 A 的颜色变了，可能会与 A 的父结点颜色冲突，所以我们需要把 A 看作新插入结点，重新进行判断。\n\n#### b) C 是黑色或者 C 是 nil\n\n如果 C 是黑色，我们仍然改变 A 和 B 的颜色，但是为了保证性质 5 成立，所以可以对 A 和 B 进行右旋：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/03.png)\n\n当 D 是 B 的右子树时，先将 B 和 D 左旋，然后变成上面这种情况，再对 A、B 进行右旋。\n\n以上情况二是假设 D 和 B 是 A 的左子树，当 D 和 B 是 A 的右子树时，需要把方向换一下，原理是相同的。\n\n```Javascript\nclass RedBlackTree {\n\n  constructor() {\n    //...\n  }\n\n  insert(key) {\n    //...\n  }\n\n  insertFix(node) {\n    while(node.parent.color == 'red') {\n      if(node.parent == node.parent.parent.left) {\n        let uncle = node.parent.parent.right;\n        if(uncle.color == 'red') {\n          // 叔结点是红色\n          node.parent.color = 'black';\n          uncle.color = 'black';\n          node.parent.parent.color = 'red';\n          node = node.parent.parent;\n        } else {\n          // 旋转\n          if(node == node.parent.right) {\n            node = node.parent;\n            this.leftRotate(node);\n          }\n          node.parent.color = 'black';\n          node.parent.parent.color = 'red';\n          this.rightRotate(node.parent.parent); \n        }\n      } else {\n        let uncle = node.parent.parent.left;\n        if(uncle.color == 'red') {\n          // 叔结点是红色\n          node.parent.color = 'black';\n          uncle.color = 'black';\n          node.parent.parent.color = 'red';\n          node = node.parent.parent;\n        } else {\n          if(node == node.parent.left) {\n            node = node.parent;\n            this.rightRotate(node);\n          }\n          node.parent.color = 'black';\n          node.parent.parent.color = 'red';\n          this.leftRotate(node.parent.parent);\n        }\n      }\n    }\n    this.root.color = 'black';\n  }\n\n  leftRotate(node) {\n    //...\n  }\n\n  rightRotate(node) {\n    //...\n  }\n}\n```","source":"_posts/red-black-tree.md","raw":"---\ntitle: 红黑树\ndate: 2016-08-07 23:10:57\ntags: [每周总结, 数据结构]\n---\n\n红黑树是二叉搜索树的一种，同时也是一种平衡搜索树，在红黑树中，没有一条路径会比其他路径长出 2 倍，因此它是近似平衡的。\n\n<!-- more -->\n\n红黑树中的每个结点都有一个颜色，颜色可以是黑色或者红色，红黑树根据结点的颜色对树进行约束，从而保持树的平衡。\n\n一颗红黑树是满足下面红黑性质的二叉搜索树：\n\n1. 每个结点要么是红色，要么是黑色\n2. 根结点是黑色的\n3. 每个叶结点是黑色的\n4. 如果一个结点是红色，则它的两个子结点都是黑色的\n5. 对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点\n\n由性质 2 和 4 可知，红黑树中最短的路径是结点全部为黑色的路径，最长的路径是红黑相间的路径，所以在红黑树中，不会出现一条路径比其他路径长 2 倍。\n\n相比于以前使用 null 来表示边界，在红黑树中，我们引入哨兵 `nil` 来处理边界条件。哨兵和普通结点拥有相同属性，但作为叶子结点的哨兵根据性质 3，它的颜色应该是黑色的。\n\n如下就是一颗红黑树：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/red-black-tree.png)\n\n## 旋转\n\n红黑树和二叉搜索树很类似，但因为引入了红黑性质，所以在对红黑树进行插入和删除等操作的时候，很可能破坏红黑性质，这时候需要对树进行调整，改变一些结点的位置。\n\n旋转是调整树结构的一种操作，分为左旋和右旋。如下\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/rotate.png)\n\n在旋转中，只有指针会改变，其他属性都保持不变。\n\n```javascript\nleftRotate(node) {\n  let rNode = node.right;\n  node.right = rNode.left;\n  if(rNode.left != this.nil) {\n    rNode.left.parent = node;\n  }\n\n  rNode.parent = node.parent;\n  rNode.left = node;\n  node.parent = rNode;\n\n  if(rNode.parent == this.nil) {\n    this.root = rNode;\n  } else {\n    if(rNode.key < rNode.parent.key) {\n      rNode.parent.left = rNode;\n    } else {\n      rNode.parent.right = rNode;\n    }\n  }\n}\n\nrightRotate(node) {\n  let lNode = node.left;\n  node.left = lNode.right;\n  if(lNode.right != this.nil) {\n    lNode.right.parent = node;\n  }\n\n  lNode.parent = node.parent;\n  lNode.right = node;\n  node.parent = lNode;\n\n  if(lNode.parent == this.nil) {\n    this.root = lNode;\n  } else {\n    if(lNode.key < lNode.parent.key) {\n      lNode.parent.left = lNode;\n    } else {\n      lNode.parent.right = lNode;\n    }\n  }\n}\n```\n\n## 插入\n\n将新结点插入到红黑树中时，如果新结点是黑色，则势必会破坏性质 5，而红色可能一条性质也不会破坏，所以我们选择红色为新结点的默认颜色。\n\n插入之前我们需要先找到要插入的位置，这里和二叉搜索树是一样的。\n\n```javascript\nclass TreeNode {\n  constructor() {\n    this.parent = null;\n    this.left = null;\n    this.right = null;\n    this.key = 'nil';\n    this.color = 'black';\n  }\n\n  toString() {\n    return this.key + ',' + this.color;\n  }\n}\n\nclass RedBlackTree {\n\n  constructor() {\n    this.nil = new TreeNode();\n    this.root = this.nil;\n  }\n\n  insert(key) {\n    let curNode = this.root;\n    let parent = this.nil;\n    // 找到要插入的位置\n    while(curNode != this.nil) {\n      parent = curNode;\n      if(key < curNode.key) {\n        curNode = curNode.left;\n      } else {\n        curNode = curNode.right;\n      }\n    }\n\n    let node = new TreeNode();\n    node.key = key;\n    node.parent = parent;\n    node.left = this.nil;\n    node.right = this.nil;\n\n    if(parent == this.nil) {\n      // 如果树中没有结点，插入结点为根结点\n      node.color = 'black';\n      this.root = node;\n    } else {\n      // 插入到正确的地方\n      node.color = 'red';\n      if(node.key < parent.key) {\n        parent.left = node;\n      } else {\n        parent.right = node;\n      }\n      // 调整树的结构\n      this.insertFix(node);\n    }\n  }\n}\n```\n\n`insertFix` 方法的作用是在插入结点后调整树的结构，在有新的红色结点插入到树中后，有哪些性质可能被破坏呢？\n\n- 性质 1 显然不会被破坏。\n\n- 如果插入元素是根结点时，会破坏性质 2。\n\n- 性质 3 不会被破坏，因为叶子结点始终是哨兵。\n\n- 如果插入元素的父结点是红色，那么性质 4 会被破坏。\n\n- 性质 5 不会被破坏，因为插入的结点是红色，不会影响路径中黑色结点的个数。\n\n所以在调整树的结构时，我们只需关注性质 2 和 4。\n\n### 情况一\n\n如果插入结点的父结点是黑色结点，那么性质 12345 全部继续成立，不需要调整树的结构。\n\n### 情况二\n\n如果插入结点的父结点是红色结点。\n\n因为插入之前这课树是一颗红黑树，那么插入结点的父结点的父结点（图中的 B 结点）必定是黑色（否则违反性质 4）。如下图，R 表示红色，B 表示黑色：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/01.png)\n\n但不确定 C 是什么颜色。\n\n#### a) C 是红色\n\n因为 D 和 B 的颜色起了冲突，必定需要改变其中一个结点的颜色，如果改变 D 的颜色，会破坏性质 5，而如果改变 B 的颜色，为了维持性质 5，我们可以选择将 A 和 C 的颜色也改变，即：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/02.png)\n\n这个时候性质 5 不会被破坏，但因为 A 的颜色变了，可能会与 A 的父结点颜色冲突，所以我们需要把 A 看作新插入结点，重新进行判断。\n\n#### b) C 是黑色或者 C 是 nil\n\n如果 C 是黑色，我们仍然改变 A 和 B 的颜色，但是为了保证性质 5 成立，所以可以对 A 和 B 进行右旋：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/03.png)\n\n当 D 是 B 的右子树时，先将 B 和 D 左旋，然后变成上面这种情况，再对 A、B 进行右旋。\n\n以上情况二是假设 D 和 B 是 A 的左子树，当 D 和 B 是 A 的右子树时，需要把方向换一下，原理是相同的。\n\n```Javascript\nclass RedBlackTree {\n\n  constructor() {\n    //...\n  }\n\n  insert(key) {\n    //...\n  }\n\n  insertFix(node) {\n    while(node.parent.color == 'red') {\n      if(node.parent == node.parent.parent.left) {\n        let uncle = node.parent.parent.right;\n        if(uncle.color == 'red') {\n          // 叔结点是红色\n          node.parent.color = 'black';\n          uncle.color = 'black';\n          node.parent.parent.color = 'red';\n          node = node.parent.parent;\n        } else {\n          // 旋转\n          if(node == node.parent.right) {\n            node = node.parent;\n            this.leftRotate(node);\n          }\n          node.parent.color = 'black';\n          node.parent.parent.color = 'red';\n          this.rightRotate(node.parent.parent); \n        }\n      } else {\n        let uncle = node.parent.parent.left;\n        if(uncle.color == 'red') {\n          // 叔结点是红色\n          node.parent.color = 'black';\n          uncle.color = 'black';\n          node.parent.parent.color = 'red';\n          node = node.parent.parent;\n        } else {\n          if(node == node.parent.left) {\n            node = node.parent;\n            this.rightRotate(node);\n          }\n          node.parent.color = 'black';\n          node.parent.parent.color = 'red';\n          this.leftRotate(node.parent.parent);\n        }\n      }\n    }\n    this.root.color = 'black';\n  }\n\n  leftRotate(node) {\n    //...\n  }\n\n  rightRotate(node) {\n    //...\n  }\n}\n```","slug":"red-black-tree","published":1,"updated":"2016-08-27T00:03:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscgyh1p000ogq277zr40ov0","content":"<p>红黑树是二叉搜索树的一种，同时也是一种平衡搜索树，在红黑树中，没有一条路径会比其他路径长出 2 倍，因此它是近似平衡的。</p>\n<a id=\"more\"></a>\n<p>红黑树中的每个结点都有一个颜色，颜色可以是黑色或者红色，红黑树根据结点的颜色对树进行约束，从而保持树的平衡。</p>\n<p>一颗红黑树是满足下面红黑性质的二叉搜索树：</p>\n<ol>\n<li>每个结点要么是红色，要么是黑色</li>\n<li>根结点是黑色的</li>\n<li>每个叶结点是黑色的</li>\n<li>如果一个结点是红色，则它的两个子结点都是黑色的</li>\n<li>对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点</li>\n</ol>\n<p>由性质 2 和 4 可知，红黑树中最短的路径是结点全部为黑色的路径，最长的路径是红黑相间的路径，所以在红黑树中，不会出现一条路径比其他路径长 2 倍。</p>\n<p>相比于以前使用 null 来表示边界，在红黑树中，我们引入哨兵 <code>nil</code> 来处理边界条件。哨兵和普通结点拥有相同属性，但作为叶子结点的哨兵根据性质 3，它的颜色应该是黑色的。</p>\n<p>如下就是一颗红黑树：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/red-black-tree.png\" alt=\"\"></p>\n<h2 id=\"旋转\"><a href=\"#旋转\" class=\"headerlink\" title=\"旋转\"></a>旋转</h2><p>红黑树和二叉搜索树很类似，但因为引入了红黑性质，所以在对红黑树进行插入和删除等操作的时候，很可能破坏红黑性质，这时候需要对树进行调整，改变一些结点的位置。</p>\n<p>旋转是调整树结构的一种操作，分为左旋和右旋。如下</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/rotate.png\" alt=\"\"></p>\n<p>在旋转中，只有指针会改变，其他属性都保持不变。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">leftRotate(node) &#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> rNode = node.right;</div><div class=\"line\">  node.right = rNode.left;</div><div class=\"line\">  <span class=\"keyword\">if</span>(rNode.left != <span class=\"keyword\">this</span>.nil) &#123;</div><div class=\"line\">    rNode.left.parent = node;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  rNode.parent = node.parent;</div><div class=\"line\">  rNode.left = node;</div><div class=\"line\">  node.parent = rNode;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(rNode.parent == <span class=\"keyword\">this</span>.nil) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.root = rNode;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(rNode.key &lt; rNode.parent.key) &#123;</div><div class=\"line\">      rNode.parent.left = rNode;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      rNode.parent.right = rNode;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">rightRotate(node) &#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> lNode = node.left;</div><div class=\"line\">  node.left = lNode.right;</div><div class=\"line\">  <span class=\"keyword\">if</span>(lNode.right != <span class=\"keyword\">this</span>.nil) &#123;</div><div class=\"line\">    lNode.right.parent = node;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  lNode.parent = node.parent;</div><div class=\"line\">  lNode.right = node;</div><div class=\"line\">  node.parent = lNode;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(lNode.parent == <span class=\"keyword\">this</span>.nil) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.root = lNode;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(lNode.key &lt; lNode.parent.key) &#123;</div><div class=\"line\">      lNode.parent.left = lNode;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      lNode.parent.right = lNode;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h2><p>将新结点插入到红黑树中时，如果新结点是黑色，则势必会破坏性质 5，而红色可能一条性质也不会破坏，所以我们选择红色为新结点的默认颜色。</p>\n<p>插入之前我们需要先找到要插入的位置，这里和二叉搜索树是一样的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.parent = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.left = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.right = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.key = <span class=\"string\">'nil'</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.key + <span class=\"string\">','</span> + <span class=\"keyword\">this</span>.color;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedBlackTree</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.nil = <span class=\"keyword\">new</span> TreeNode();</div><div class=\"line\">    <span class=\"keyword\">this</span>.root = <span class=\"keyword\">this</span>.nil;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  insert(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.root;</div><div class=\"line\">    <span class=\"keyword\">let</span> parent = <span class=\"keyword\">this</span>.nil;</div><div class=\"line\">    <span class=\"comment\">// 找到要插入的位置</span></div><div class=\"line\">    <span class=\"keyword\">while</span>(curNode != <span class=\"keyword\">this</span>.nil) &#123;</div><div class=\"line\">      parent = curNode;</div><div class=\"line\">      <span class=\"keyword\">if</span>(key &lt; curNode.key) &#123;</div><div class=\"line\">        curNode = curNode.left;</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        curNode = curNode.right;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">let</span> node = <span class=\"keyword\">new</span> TreeNode();</div><div class=\"line\">    node.key = key;</div><div class=\"line\">    node.parent = parent;</div><div class=\"line\">    node.left = <span class=\"keyword\">this</span>.nil;</div><div class=\"line\">    node.right = <span class=\"keyword\">this</span>.nil;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(parent == <span class=\"keyword\">this</span>.nil) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果树中没有结点，插入结点为根结点</span></div><div class=\"line\">      node.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">      <span class=\"keyword\">this</span>.root = node;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 插入到正确的地方</span></div><div class=\"line\">      node.color = <span class=\"string\">'red'</span>;</div><div class=\"line\">      <span class=\"keyword\">if</span>(node.key &lt; parent.key) &#123;</div><div class=\"line\">        parent.left = node;</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        parent.right = node;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">// 调整树的结构</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.insertFix(node);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>insertFix</code> 方法的作用是在插入结点后调整树的结构，在有新的红色结点插入到树中后，有哪些性质可能被破坏呢？</p>\n<ul>\n<li><p>性质 1 显然不会被破坏。</p>\n</li>\n<li><p>如果插入元素是根结点时，会破坏性质 2。</p>\n</li>\n<li><p>性质 3 不会被破坏，因为叶子结点始终是哨兵。</p>\n</li>\n<li><p>如果插入元素的父结点是红色，那么性质 4 会被破坏。</p>\n</li>\n<li><p>性质 5 不会被破坏，因为插入的结点是红色，不会影响路径中黑色结点的个数。</p>\n</li>\n</ul>\n<p>所以在调整树的结构时，我们只需关注性质 2 和 4。</p>\n<h3 id=\"情况一\"><a href=\"#情况一\" class=\"headerlink\" title=\"情况一\"></a>情况一</h3><p>如果插入结点的父结点是黑色结点，那么性质 12345 全部继续成立，不需要调整树的结构。</p>\n<h3 id=\"情况二\"><a href=\"#情况二\" class=\"headerlink\" title=\"情况二\"></a>情况二</h3><p>如果插入结点的父结点是红色结点。</p>\n<p>因为插入之前这课树是一颗红黑树，那么插入结点的父结点的父结点（图中的 B 结点）必定是黑色（否则违反性质 4）。如下图，R 表示红色，B 表示黑色：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/01.png\" alt=\"\"></p>\n<p>但不确定 C 是什么颜色。</p>\n<h4 id=\"a-C-是红色\"><a href=\"#a-C-是红色\" class=\"headerlink\" title=\"a) C 是红色\"></a>a) C 是红色</h4><p>因为 D 和 B 的颜色起了冲突，必定需要改变其中一个结点的颜色，如果改变 D 的颜色，会破坏性质 5，而如果改变 B 的颜色，为了维持性质 5，我们可以选择将 A 和 C 的颜色也改变，即：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/02.png\" alt=\"\"></p>\n<p>这个时候性质 5 不会被破坏，但因为 A 的颜色变了，可能会与 A 的父结点颜色冲突，所以我们需要把 A 看作新插入结点，重新进行判断。</p>\n<h4 id=\"b-C-是黑色或者-C-是-nil\"><a href=\"#b-C-是黑色或者-C-是-nil\" class=\"headerlink\" title=\"b) C 是黑色或者 C 是 nil\"></a>b) C 是黑色或者 C 是 nil</h4><p>如果 C 是黑色，我们仍然改变 A 和 B 的颜色，但是为了保证性质 5 成立，所以可以对 A 和 B 进行右旋：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/03.png\" alt=\"\"></p>\n<p>当 D 是 B 的右子树时，先将 B 和 D 左旋，然后变成上面这种情况，再对 A、B 进行右旋。</p>\n<p>以上情况二是假设 D 和 B 是 A 的左子树，当 D 和 B 是 A 的右子树时，需要把方向换一下，原理是相同的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedBlackTree</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  insert(key) &#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  insertFix(node) &#123;</div><div class=\"line\">    <span class=\"keyword\">while</span>(node.parent.color == <span class=\"string\">'red'</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(node.parent == node.parent.parent.left) &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> uncle = node.parent.parent.right;</div><div class=\"line\">        <span class=\"keyword\">if</span>(uncle.color == <span class=\"string\">'red'</span>) &#123;</div><div class=\"line\">          <span class=\"comment\">// 叔结点是红色</span></div><div class=\"line\">          node.parent.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">          uncle.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">          node.parent.parent.color = <span class=\"string\">'red'</span>;</div><div class=\"line\">          node = node.parent.parent;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          <span class=\"comment\">// 旋转</span></div><div class=\"line\">          <span class=\"keyword\">if</span>(node == node.parent.right) &#123;</div><div class=\"line\">            node = node.parent;</div><div class=\"line\">            <span class=\"keyword\">this</span>.leftRotate(node);</div><div class=\"line\">          &#125;</div><div class=\"line\">          node.parent.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">          node.parent.parent.color = <span class=\"string\">'red'</span>;</div><div class=\"line\">          <span class=\"keyword\">this</span>.rightRotate(node.parent.parent); </div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> uncle = node.parent.parent.left;</div><div class=\"line\">        <span class=\"keyword\">if</span>(uncle.color == <span class=\"string\">'red'</span>) &#123;</div><div class=\"line\">          <span class=\"comment\">// 叔结点是红色</span></div><div class=\"line\">          node.parent.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">          uncle.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">          node.parent.parent.color = <span class=\"string\">'red'</span>;</div><div class=\"line\">          node = node.parent.parent;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          <span class=\"keyword\">if</span>(node == node.parent.left) &#123;</div><div class=\"line\">            node = node.parent;</div><div class=\"line\">            <span class=\"keyword\">this</span>.rightRotate(node);</div><div class=\"line\">          &#125;</div><div class=\"line\">          node.parent.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">          node.parent.parent.color = <span class=\"string\">'red'</span>;</div><div class=\"line\">          <span class=\"keyword\">this</span>.leftRotate(node.parent.parent);</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.root.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  leftRotate(node) &#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  rightRotate(node) &#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","excerpt":"<p>红黑树是二叉搜索树的一种，同时也是一种平衡搜索树，在红黑树中，没有一条路径会比其他路径长出 2 倍，因此它是近似平衡的。</p>","more":"<p>红黑树中的每个结点都有一个颜色，颜色可以是黑色或者红色，红黑树根据结点的颜色对树进行约束，从而保持树的平衡。</p>\n<p>一颗红黑树是满足下面红黑性质的二叉搜索树：</p>\n<ol>\n<li>每个结点要么是红色，要么是黑色</li>\n<li>根结点是黑色的</li>\n<li>每个叶结点是黑色的</li>\n<li>如果一个结点是红色，则它的两个子结点都是黑色的</li>\n<li>对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点</li>\n</ol>\n<p>由性质 2 和 4 可知，红黑树中最短的路径是结点全部为黑色的路径，最长的路径是红黑相间的路径，所以在红黑树中，不会出现一条路径比其他路径长 2 倍。</p>\n<p>相比于以前使用 null 来表示边界，在红黑树中，我们引入哨兵 <code>nil</code> 来处理边界条件。哨兵和普通结点拥有相同属性，但作为叶子结点的哨兵根据性质 3，它的颜色应该是黑色的。</p>\n<p>如下就是一颗红黑树：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/red-black-tree.png\" alt=\"\"></p>\n<h2 id=\"旋转\"><a href=\"#旋转\" class=\"headerlink\" title=\"旋转\"></a>旋转</h2><p>红黑树和二叉搜索树很类似，但因为引入了红黑性质，所以在对红黑树进行插入和删除等操作的时候，很可能破坏红黑性质，这时候需要对树进行调整，改变一些结点的位置。</p>\n<p>旋转是调整树结构的一种操作，分为左旋和右旋。如下</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/rotate.png\" alt=\"\"></p>\n<p>在旋转中，只有指针会改变，其他属性都保持不变。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">leftRotate(node) &#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> rNode = node.right;</div><div class=\"line\">  node.right = rNode.left;</div><div class=\"line\">  <span class=\"keyword\">if</span>(rNode.left != <span class=\"keyword\">this</span>.nil) &#123;</div><div class=\"line\">    rNode.left.parent = node;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  rNode.parent = node.parent;</div><div class=\"line\">  rNode.left = node;</div><div class=\"line\">  node.parent = rNode;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(rNode.parent == <span class=\"keyword\">this</span>.nil) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.root = rNode;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(rNode.key &lt; rNode.parent.key) &#123;</div><div class=\"line\">      rNode.parent.left = rNode;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      rNode.parent.right = rNode;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">rightRotate(node) &#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> lNode = node.left;</div><div class=\"line\">  node.left = lNode.right;</div><div class=\"line\">  <span class=\"keyword\">if</span>(lNode.right != <span class=\"keyword\">this</span>.nil) &#123;</div><div class=\"line\">    lNode.right.parent = node;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  lNode.parent = node.parent;</div><div class=\"line\">  lNode.right = node;</div><div class=\"line\">  node.parent = lNode;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(lNode.parent == <span class=\"keyword\">this</span>.nil) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.root = lNode;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(lNode.key &lt; lNode.parent.key) &#123;</div><div class=\"line\">      lNode.parent.left = lNode;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      lNode.parent.right = lNode;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h2><p>将新结点插入到红黑树中时，如果新结点是黑色，则势必会破坏性质 5，而红色可能一条性质也不会破坏，所以我们选择红色为新结点的默认颜色。</p>\n<p>插入之前我们需要先找到要插入的位置，这里和二叉搜索树是一样的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.parent = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.left = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.right = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.key = <span class=\"string\">'nil'</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.key + <span class=\"string\">','</span> + <span class=\"keyword\">this</span>.color;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedBlackTree</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.nil = <span class=\"keyword\">new</span> TreeNode();</div><div class=\"line\">    <span class=\"keyword\">this</span>.root = <span class=\"keyword\">this</span>.nil;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  insert(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.root;</div><div class=\"line\">    <span class=\"keyword\">let</span> parent = <span class=\"keyword\">this</span>.nil;</div><div class=\"line\">    <span class=\"comment\">// 找到要插入的位置</span></div><div class=\"line\">    <span class=\"keyword\">while</span>(curNode != <span class=\"keyword\">this</span>.nil) &#123;</div><div class=\"line\">      parent = curNode;</div><div class=\"line\">      <span class=\"keyword\">if</span>(key &lt; curNode.key) &#123;</div><div class=\"line\">        curNode = curNode.left;</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        curNode = curNode.right;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">let</span> node = <span class=\"keyword\">new</span> TreeNode();</div><div class=\"line\">    node.key = key;</div><div class=\"line\">    node.parent = parent;</div><div class=\"line\">    node.left = <span class=\"keyword\">this</span>.nil;</div><div class=\"line\">    node.right = <span class=\"keyword\">this</span>.nil;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(parent == <span class=\"keyword\">this</span>.nil) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果树中没有结点，插入结点为根结点</span></div><div class=\"line\">      node.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">      <span class=\"keyword\">this</span>.root = node;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 插入到正确的地方</span></div><div class=\"line\">      node.color = <span class=\"string\">'red'</span>;</div><div class=\"line\">      <span class=\"keyword\">if</span>(node.key &lt; parent.key) &#123;</div><div class=\"line\">        parent.left = node;</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        parent.right = node;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">// 调整树的结构</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.insertFix(node);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>insertFix</code> 方法的作用是在插入结点后调整树的结构，在有新的红色结点插入到树中后，有哪些性质可能被破坏呢？</p>\n<ul>\n<li><p>性质 1 显然不会被破坏。</p>\n</li>\n<li><p>如果插入元素是根结点时，会破坏性质 2。</p>\n</li>\n<li><p>性质 3 不会被破坏，因为叶子结点始终是哨兵。</p>\n</li>\n<li><p>如果插入元素的父结点是红色，那么性质 4 会被破坏。</p>\n</li>\n<li><p>性质 5 不会被破坏，因为插入的结点是红色，不会影响路径中黑色结点的个数。</p>\n</li>\n</ul>\n<p>所以在调整树的结构时，我们只需关注性质 2 和 4。</p>\n<h3 id=\"情况一\"><a href=\"#情况一\" class=\"headerlink\" title=\"情况一\"></a>情况一</h3><p>如果插入结点的父结点是黑色结点，那么性质 12345 全部继续成立，不需要调整树的结构。</p>\n<h3 id=\"情况二\"><a href=\"#情况二\" class=\"headerlink\" title=\"情况二\"></a>情况二</h3><p>如果插入结点的父结点是红色结点。</p>\n<p>因为插入之前这课树是一颗红黑树，那么插入结点的父结点的父结点（图中的 B 结点）必定是黑色（否则违反性质 4）。如下图，R 表示红色，B 表示黑色：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/01.png\" alt=\"\"></p>\n<p>但不确定 C 是什么颜色。</p>\n<h4 id=\"a-C-是红色\"><a href=\"#a-C-是红色\" class=\"headerlink\" title=\"a) C 是红色\"></a>a) C 是红色</h4><p>因为 D 和 B 的颜色起了冲突，必定需要改变其中一个结点的颜色，如果改变 D 的颜色，会破坏性质 5，而如果改变 B 的颜色，为了维持性质 5，我们可以选择将 A 和 C 的颜色也改变，即：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/02.png\" alt=\"\"></p>\n<p>这个时候性质 5 不会被破坏，但因为 A 的颜色变了，可能会与 A 的父结点颜色冲突，所以我们需要把 A 看作新插入结点，重新进行判断。</p>\n<h4 id=\"b-C-是黑色或者-C-是-nil\"><a href=\"#b-C-是黑色或者-C-是-nil\" class=\"headerlink\" title=\"b) C 是黑色或者 C 是 nil\"></a>b) C 是黑色或者 C 是 nil</h4><p>如果 C 是黑色，我们仍然改变 A 和 B 的颜色，但是为了保证性质 5 成立，所以可以对 A 和 B 进行右旋：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/red-black-tree/03.png\" alt=\"\"></p>\n<p>当 D 是 B 的右子树时，先将 B 和 D 左旋，然后变成上面这种情况，再对 A、B 进行右旋。</p>\n<p>以上情况二是假设 D 和 B 是 A 的左子树，当 D 和 B 是 A 的右子树时，需要把方向换一下，原理是相同的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedBlackTree</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  insert(key) &#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  insertFix(node) &#123;</div><div class=\"line\">    <span class=\"keyword\">while</span>(node.parent.color == <span class=\"string\">'red'</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(node.parent == node.parent.parent.left) &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> uncle = node.parent.parent.right;</div><div class=\"line\">        <span class=\"keyword\">if</span>(uncle.color == <span class=\"string\">'red'</span>) &#123;</div><div class=\"line\">          <span class=\"comment\">// 叔结点是红色</span></div><div class=\"line\">          node.parent.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">          uncle.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">          node.parent.parent.color = <span class=\"string\">'red'</span>;</div><div class=\"line\">          node = node.parent.parent;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          <span class=\"comment\">// 旋转</span></div><div class=\"line\">          <span class=\"keyword\">if</span>(node == node.parent.right) &#123;</div><div class=\"line\">            node = node.parent;</div><div class=\"line\">            <span class=\"keyword\">this</span>.leftRotate(node);</div><div class=\"line\">          &#125;</div><div class=\"line\">          node.parent.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">          node.parent.parent.color = <span class=\"string\">'red'</span>;</div><div class=\"line\">          <span class=\"keyword\">this</span>.rightRotate(node.parent.parent); </div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> uncle = node.parent.parent.left;</div><div class=\"line\">        <span class=\"keyword\">if</span>(uncle.color == <span class=\"string\">'red'</span>) &#123;</div><div class=\"line\">          <span class=\"comment\">// 叔结点是红色</span></div><div class=\"line\">          node.parent.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">          uncle.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">          node.parent.parent.color = <span class=\"string\">'red'</span>;</div><div class=\"line\">          node = node.parent.parent;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          <span class=\"keyword\">if</span>(node == node.parent.left) &#123;</div><div class=\"line\">            node = node.parent;</div><div class=\"line\">            <span class=\"keyword\">this</span>.rightRotate(node);</div><div class=\"line\">          &#125;</div><div class=\"line\">          node.parent.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">          node.parent.parent.color = <span class=\"string\">'red'</span>;</div><div class=\"line\">          <span class=\"keyword\">this</span>.leftRotate(node.parent.parent);</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.root.color = <span class=\"string\">'black'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  leftRotate(node) &#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  rightRotate(node) &#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"Javascript 中的线程与进程","date":"2016-08-26T23:43:34.000Z","_content":"\n写 javascript 写久了，就会对 javascript 的异步写法习以为常，反而不会好奇为什么在 javascript 里可以异步执行一个任务，是因为 javascript 是多线程吗？\n\n实际上，javascript 从来都是单线程的。目前 javascript 有两个主要的运行环境，一个是浏览器，一个是 nodejs，下面分别从这两个方面对这个问题进行解释。\n\n<!-- more -->\n\n## 浏览器\n\njavascript 的设计初衷，是为了解决一些简单的网页互动，也就是操作 DOM 元素。而如果采用多线程，那么大家都知道，多线程是可能会造成竞争资源的，很可能多个线程同时操作一个 DOM 元素，造成不必要的麻烦，所以 javascript 从诞生开始就选择了单线程执行。\n\n然而在前端开发中，会经常用到 `setTimeout` 这个函数，我们可以规定让一段逻辑在指定时间后执行：\n\n```javascript\nsetTimeout(function() {\n  console.log('timeout done');\n}, 3000);\n\nconsole.log('main task')\n```\n\n上面这段代码会先输出 `main task`，然后在 3 秒之后输出 `timeout done`。就好像 setTimeout 开启了一个新线程一样，实际上并不是这样。\n\n### Event loop\n\n实际上， JavaScript 运行时包含了一个待处理的消息队列，每一个消息都与一个函数相关联。同时有一个事件循环不停地在轮询这个队列，当队列不为空时，就从队列中取出一个消息进行处理。它的实现大概如此：\n\n```javascript\nwhile(queue.waitForMessage()){\n  queue.processNextMessage();\n}\n```\n\n所以，上面的例子调用 [setTimeout](https://developer.mozilla.org/en-US/docs/window.setTimeout) 函数会在一个时间段过去后在队列中添加一个消息，实际上没有创建一个新的线程，当时间到达时，如果在队列中它的前面还有其他消息没有处理，那么它也要先等前面的执行完才执行。所谓的异步执行，实际上是在主线程空闲的时候执行，可以看如下代码：\n\n```javascript\nvar startTime = new Date();\n\n// 第一个异步任务\nsetTimeout(function() {\n    console.log('task 1 start.');\n    while(true) {\n        var curTime = new Date();\n        if(curTime - startTime > 5000) {\n            break;\n        }\n    }\n    console.log('task 1 done.')\n}, 100);\n\n// 第二个异步任务\nsetTimeout(function() {\n    console.log('task 2 start.');\n}, 500);\n\nconsole.log('main');\n```\n\n程序第一个输出 `main`，这个毋庸置疑，但是第一个异步任务会执行 5 秒，而我们设置了第二个异步任务在 500 毫秒后执行，如果是多线程，`task 2 start` 会在 `task 1 done` 之前输出，然而结果是等 `task 1 done` 输出后才会输出 `task 2 done`。因为到 500 ms 时，task 2 被插入到消息队列中，然而此时task 1 还没有执行完，所以 task 2 紧接着 task 1 执行。示意图如下：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/thread-in-javascript/01.png)\n\n### webworker\n\n但是 javascript 能不能支持多线程呢，答案是可以的，在 HTML 5 规范中，新增了webworker 用来进行计算量大的操作，避免阻塞主线程，不过在webworker 创建的线程中，是不能操作 DOM 元素的，当 webworker 中的计算完成时可以通过事件与主线程进行通信。\n\n## Nodejs\n\n说完了浏览器端，现在说回 nodejs，nodejs 只是 javascript 的一个运行环境，实际上并不改变 javascript 是单线程执行的本质，但是 nodejs 可以提供一些方式来进行多线程和多进程开发。\n\n### 多线程\n\n#### [tagg](https://github.com/xk/node-threads-a-gogo)\n\nJorge Chamorro Bieling是 `tagg(Threads a gogo for Node.js)` 包的作者，他硬是利用 `phread` 库和C语言让Node.js支持了多线程的开发\n\n### libuvd\n\n`libuv` 是一个跨平台的异步I/O库，它主要用于Node.js的开发，同时他也被 `Mozilla's Rust language`,  `Luvit`, `Julia`,  `pyuv`等使用。它主要包括了 `Event loops` 事件循环， `Filesystem` 文件系统， `Networking` 网络支持，`Threads` 线程，`Processes` 进程，`Utilities` 其他工具。\n\n\n\n### 多进程\n\n#### child_process\n\n可以启动一个 nodejs 文件，将它作为 worker 进程，实现多进程解决主进程阻塞的问题。\n\n#### cluster\n\n`cluster`可以用来让Node.js充分利用多核cpu的性能，同时也可以让Node.js程序更加健壮，官网上的`cluster`示例已经告诉我们如何重新启动一个因为异常而奔溃的子进程。\n\n\n\n## 参考\n\n1. [Node.js的线程和进程](https://github.com/DoubleSpout/threadAndPackage/blob/master/chapter.7.thread_and_process.md)\n2. [Node.js 探秘：初识单线程的 Node.js](http://taobaofed.org/blog/2015/10/29/deep-into-node-1/)\n3. [细说JavaScript单线程的一些事](https://segmentfault.com/a/1190000004276027)\n4. [并发模型与Event Loop](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoo)","source":"_posts/thread-in-javascript.md","raw":"---\ntitle: Javascript 中的线程与进程\ndate: 2016-08-27 07:43:34\ntags: [每周总结, javascript]\n---\n\n写 javascript 写久了，就会对 javascript 的异步写法习以为常，反而不会好奇为什么在 javascript 里可以异步执行一个任务，是因为 javascript 是多线程吗？\n\n实际上，javascript 从来都是单线程的。目前 javascript 有两个主要的运行环境，一个是浏览器，一个是 nodejs，下面分别从这两个方面对这个问题进行解释。\n\n<!-- more -->\n\n## 浏览器\n\njavascript 的设计初衷，是为了解决一些简单的网页互动，也就是操作 DOM 元素。而如果采用多线程，那么大家都知道，多线程是可能会造成竞争资源的，很可能多个线程同时操作一个 DOM 元素，造成不必要的麻烦，所以 javascript 从诞生开始就选择了单线程执行。\n\n然而在前端开发中，会经常用到 `setTimeout` 这个函数，我们可以规定让一段逻辑在指定时间后执行：\n\n```javascript\nsetTimeout(function() {\n  console.log('timeout done');\n}, 3000);\n\nconsole.log('main task')\n```\n\n上面这段代码会先输出 `main task`，然后在 3 秒之后输出 `timeout done`。就好像 setTimeout 开启了一个新线程一样，实际上并不是这样。\n\n### Event loop\n\n实际上， JavaScript 运行时包含了一个待处理的消息队列，每一个消息都与一个函数相关联。同时有一个事件循环不停地在轮询这个队列，当队列不为空时，就从队列中取出一个消息进行处理。它的实现大概如此：\n\n```javascript\nwhile(queue.waitForMessage()){\n  queue.processNextMessage();\n}\n```\n\n所以，上面的例子调用 [setTimeout](https://developer.mozilla.org/en-US/docs/window.setTimeout) 函数会在一个时间段过去后在队列中添加一个消息，实际上没有创建一个新的线程，当时间到达时，如果在队列中它的前面还有其他消息没有处理，那么它也要先等前面的执行完才执行。所谓的异步执行，实际上是在主线程空闲的时候执行，可以看如下代码：\n\n```javascript\nvar startTime = new Date();\n\n// 第一个异步任务\nsetTimeout(function() {\n    console.log('task 1 start.');\n    while(true) {\n        var curTime = new Date();\n        if(curTime - startTime > 5000) {\n            break;\n        }\n    }\n    console.log('task 1 done.')\n}, 100);\n\n// 第二个异步任务\nsetTimeout(function() {\n    console.log('task 2 start.');\n}, 500);\n\nconsole.log('main');\n```\n\n程序第一个输出 `main`，这个毋庸置疑，但是第一个异步任务会执行 5 秒，而我们设置了第二个异步任务在 500 毫秒后执行，如果是多线程，`task 2 start` 会在 `task 1 done` 之前输出，然而结果是等 `task 1 done` 输出后才会输出 `task 2 done`。因为到 500 ms 时，task 2 被插入到消息队列中，然而此时task 1 还没有执行完，所以 task 2 紧接着 task 1 执行。示意图如下：\n\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/thread-in-javascript/01.png)\n\n### webworker\n\n但是 javascript 能不能支持多线程呢，答案是可以的，在 HTML 5 规范中，新增了webworker 用来进行计算量大的操作，避免阻塞主线程，不过在webworker 创建的线程中，是不能操作 DOM 元素的，当 webworker 中的计算完成时可以通过事件与主线程进行通信。\n\n## Nodejs\n\n说完了浏览器端，现在说回 nodejs，nodejs 只是 javascript 的一个运行环境，实际上并不改变 javascript 是单线程执行的本质，但是 nodejs 可以提供一些方式来进行多线程和多进程开发。\n\n### 多线程\n\n#### [tagg](https://github.com/xk/node-threads-a-gogo)\n\nJorge Chamorro Bieling是 `tagg(Threads a gogo for Node.js)` 包的作者，他硬是利用 `phread` 库和C语言让Node.js支持了多线程的开发\n\n### libuvd\n\n`libuv` 是一个跨平台的异步I/O库，它主要用于Node.js的开发，同时他也被 `Mozilla's Rust language`,  `Luvit`, `Julia`,  `pyuv`等使用。它主要包括了 `Event loops` 事件循环， `Filesystem` 文件系统， `Networking` 网络支持，`Threads` 线程，`Processes` 进程，`Utilities` 其他工具。\n\n\n\n### 多进程\n\n#### child_process\n\n可以启动一个 nodejs 文件，将它作为 worker 进程，实现多进程解决主进程阻塞的问题。\n\n#### cluster\n\n`cluster`可以用来让Node.js充分利用多核cpu的性能，同时也可以让Node.js程序更加健壮，官网上的`cluster`示例已经告诉我们如何重新启动一个因为异常而奔溃的子进程。\n\n\n\n## 参考\n\n1. [Node.js的线程和进程](https://github.com/DoubleSpout/threadAndPackage/blob/master/chapter.7.thread_and_process.md)\n2. [Node.js 探秘：初识单线程的 Node.js](http://taobaofed.org/blog/2015/10/29/deep-into-node-1/)\n3. [细说JavaScript单线程的一些事](https://segmentfault.com/a/1190000004276027)\n4. [并发模型与Event Loop](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoo)","slug":"thread-in-javascript","published":1,"updated":"2016-08-27T00:16:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscgyh1q000rgq27j9o567hq","content":"<p>写 javascript 写久了，就会对 javascript 的异步写法习以为常，反而不会好奇为什么在 javascript 里可以异步执行一个任务，是因为 javascript 是多线程吗？</p>\n<p>实际上，javascript 从来都是单线程的。目前 javascript 有两个主要的运行环境，一个是浏览器，一个是 nodejs，下面分别从这两个方面对这个问题进行解释。</p>\n<a id=\"more\"></a>\n<h2 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h2><p>javascript 的设计初衷，是为了解决一些简单的网页互动，也就是操作 DOM 元素。而如果采用多线程，那么大家都知道，多线程是可能会造成竞争资源的，很可能多个线程同时操作一个 DOM 元素，造成不必要的麻烦，所以 javascript 从诞生开始就选择了单线程执行。</p>\n<p>然而在前端开发中，会经常用到 <code>setTimeout</code> 这个函数，我们可以规定让一段逻辑在指定时间后执行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'timeout done'</span>);</div><div class=\"line\">&#125;, <span class=\"number\">3000</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'main task'</span>)</div></pre></td></tr></table></figure>\n<p>上面这段代码会先输出 <code>main task</code>，然后在 3 秒之后输出 <code>timeout done</code>。就好像 setTimeout 开启了一个新线程一样，实际上并不是这样。</p>\n<h3 id=\"Event-loop\"><a href=\"#Event-loop\" class=\"headerlink\" title=\"Event loop\"></a>Event loop</h3><p>实际上， JavaScript 运行时包含了一个待处理的消息队列，每一个消息都与一个函数相关联。同时有一个事件循环不停地在轮询这个队列，当队列不为空时，就从队列中取出一个消息进行处理。它的实现大概如此：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span>(queue.waitForMessage())&#123;</div><div class=\"line\">  queue.processNextMessage();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>所以，上面的例子调用 <a href=\"https://developer.mozilla.org/en-US/docs/window.setTimeout\" target=\"_blank\" rel=\"external\">setTimeout</a> 函数会在一个时间段过去后在队列中添加一个消息，实际上没有创建一个新的线程，当时间到达时，如果在队列中它的前面还有其他消息没有处理，那么它也要先等前面的执行完才执行。所谓的异步执行，实际上是在主线程空闲的时候执行，可以看如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> startTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 第一个异步任务</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'task 1 start.'</span>);</div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> curTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\">        <span class=\"keyword\">if</span>(curTime - startTime &gt; <span class=\"number\">5000</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'task 1 done.'</span>)</div><div class=\"line\">&#125;, <span class=\"number\">100</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 第二个异步任务</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'task 2 start.'</span>);</div><div class=\"line\">&#125;, <span class=\"number\">500</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'main'</span>);</div></pre></td></tr></table></figure>\n<p>程序第一个输出 <code>main</code>，这个毋庸置疑，但是第一个异步任务会执行 5 秒，而我们设置了第二个异步任务在 500 毫秒后执行，如果是多线程，<code>task 2 start</code> 会在 <code>task 1 done</code> 之前输出，然而结果是等 <code>task 1 done</code> 输出后才会输出 <code>task 2 done</code>。因为到 500 ms 时，task 2 被插入到消息队列中，然而此时task 1 还没有执行完，所以 task 2 紧接着 task 1 执行。示意图如下：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/thread-in-javascript/01.png\" alt=\"\"></p>\n<h3 id=\"webworker\"><a href=\"#webworker\" class=\"headerlink\" title=\"webworker\"></a>webworker</h3><p>但是 javascript 能不能支持多线程呢，答案是可以的，在 HTML 5 规范中，新增了webworker 用来进行计算量大的操作，避免阻塞主线程，不过在webworker 创建的线程中，是不能操作 DOM 元素的，当 webworker 中的计算完成时可以通过事件与主线程进行通信。</p>\n<h2 id=\"Nodejs\"><a href=\"#Nodejs\" class=\"headerlink\" title=\"Nodejs\"></a>Nodejs</h2><p>说完了浏览器端，现在说回 nodejs，nodejs 只是 javascript 的一个运行环境，实际上并不改变 javascript 是单线程执行的本质，但是 nodejs 可以提供一些方式来进行多线程和多进程开发。</p>\n<h3 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h3><h4 id=\"tagg\"><a href=\"#tagg\" class=\"headerlink\" title=\"tagg\"></a><a href=\"https://github.com/xk/node-threads-a-gogo\" target=\"_blank\" rel=\"external\">tagg</a></h4><p>Jorge Chamorro Bieling是 <code>tagg(Threads a gogo for Node.js)</code> 包的作者，他硬是利用 <code>phread</code> 库和C语言让Node.js支持了多线程的开发</p>\n<h3 id=\"libuvd\"><a href=\"#libuvd\" class=\"headerlink\" title=\"libuvd\"></a>libuvd</h3><p><code>libuv</code> 是一个跨平台的异步I/O库，它主要用于Node.js的开发，同时他也被 <code>Mozilla&#39;s Rust language</code>,  <code>Luvit</code>, <code>Julia</code>,  <code>pyuv</code>等使用。它主要包括了 <code>Event loops</code> 事件循环， <code>Filesystem</code> 文件系统， <code>Networking</code> 网络支持，<code>Threads</code> 线程，<code>Processes</code> 进程，<code>Utilities</code> 其他工具。</p>\n<h3 id=\"多进程\"><a href=\"#多进程\" class=\"headerlink\" title=\"多进程\"></a>多进程</h3><h4 id=\"child-process\"><a href=\"#child-process\" class=\"headerlink\" title=\"child_process\"></a>child_process</h4><p>可以启动一个 nodejs 文件，将它作为 worker 进程，实现多进程解决主进程阻塞的问题。</p>\n<h4 id=\"cluster\"><a href=\"#cluster\" class=\"headerlink\" title=\"cluster\"></a>cluster</h4><p><code>cluster</code>可以用来让Node.js充分利用多核cpu的性能，同时也可以让Node.js程序更加健壮，官网上的<code>cluster</code>示例已经告诉我们如何重新启动一个因为异常而奔溃的子进程。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://github.com/DoubleSpout/threadAndPackage/blob/master/chapter.7.thread_and_process.md\" target=\"_blank\" rel=\"external\">Node.js的线程和进程</a></li>\n<li><a href=\"http://taobaofed.org/blog/2015/10/29/deep-into-node-1/\" target=\"_blank\" rel=\"external\">Node.js 探秘：初识单线程的 Node.js</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000004276027\" target=\"_blank\" rel=\"external\">细说JavaScript单线程的一些事</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoo\" target=\"_blank\" rel=\"external\">并发模型与Event Loop</a></li>\n</ol>\n","excerpt":"<p>写 javascript 写久了，就会对 javascript 的异步写法习以为常，反而不会好奇为什么在 javascript 里可以异步执行一个任务，是因为 javascript 是多线程吗？</p>\n<p>实际上，javascript 从来都是单线程的。目前 javascript 有两个主要的运行环境，一个是浏览器，一个是 nodejs，下面分别从这两个方面对这个问题进行解释。</p>","more":"<h2 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h2><p>javascript 的设计初衷，是为了解决一些简单的网页互动，也就是操作 DOM 元素。而如果采用多线程，那么大家都知道，多线程是可能会造成竞争资源的，很可能多个线程同时操作一个 DOM 元素，造成不必要的麻烦，所以 javascript 从诞生开始就选择了单线程执行。</p>\n<p>然而在前端开发中，会经常用到 <code>setTimeout</code> 这个函数，我们可以规定让一段逻辑在指定时间后执行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'timeout done'</span>);</div><div class=\"line\">&#125;, <span class=\"number\">3000</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'main task'</span>)</div></pre></td></tr></table></figure>\n<p>上面这段代码会先输出 <code>main task</code>，然后在 3 秒之后输出 <code>timeout done</code>。就好像 setTimeout 开启了一个新线程一样，实际上并不是这样。</p>\n<h3 id=\"Event-loop\"><a href=\"#Event-loop\" class=\"headerlink\" title=\"Event loop\"></a>Event loop</h3><p>实际上， JavaScript 运行时包含了一个待处理的消息队列，每一个消息都与一个函数相关联。同时有一个事件循环不停地在轮询这个队列，当队列不为空时，就从队列中取出一个消息进行处理。它的实现大概如此：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span>(queue.waitForMessage())&#123;</div><div class=\"line\">  queue.processNextMessage();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>所以，上面的例子调用 <a href=\"https://developer.mozilla.org/en-US/docs/window.setTimeout\">setTimeout</a> 函数会在一个时间段过去后在队列中添加一个消息，实际上没有创建一个新的线程，当时间到达时，如果在队列中它的前面还有其他消息没有处理，那么它也要先等前面的执行完才执行。所谓的异步执行，实际上是在主线程空闲的时候执行，可以看如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> startTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 第一个异步任务</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'task 1 start.'</span>);</div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> curTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\">        <span class=\"keyword\">if</span>(curTime - startTime &gt; <span class=\"number\">5000</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'task 1 done.'</span>)</div><div class=\"line\">&#125;, <span class=\"number\">100</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 第二个异步任务</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'task 2 start.'</span>);</div><div class=\"line\">&#125;, <span class=\"number\">500</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'main'</span>);</div></pre></td></tr></table></figure>\n<p>程序第一个输出 <code>main</code>，这个毋庸置疑，但是第一个异步任务会执行 5 秒，而我们设置了第二个异步任务在 500 毫秒后执行，如果是多线程，<code>task 2 start</code> 会在 <code>task 1 done</code> 之前输出，然而结果是等 <code>task 1 done</code> 输出后才会输出 <code>task 2 done</code>。因为到 500 ms 时，task 2 被插入到消息队列中，然而此时task 1 还没有执行完，所以 task 2 紧接着 task 1 执行。示意图如下：</p>\n<p><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/thread-in-javascript/01.png\" alt=\"\"></p>\n<h3 id=\"webworker\"><a href=\"#webworker\" class=\"headerlink\" title=\"webworker\"></a>webworker</h3><p>但是 javascript 能不能支持多线程呢，答案是可以的，在 HTML 5 规范中，新增了webworker 用来进行计算量大的操作，避免阻塞主线程，不过在webworker 创建的线程中，是不能操作 DOM 元素的，当 webworker 中的计算完成时可以通过事件与主线程进行通信。</p>\n<h2 id=\"Nodejs\"><a href=\"#Nodejs\" class=\"headerlink\" title=\"Nodejs\"></a>Nodejs</h2><p>说完了浏览器端，现在说回 nodejs，nodejs 只是 javascript 的一个运行环境，实际上并不改变 javascript 是单线程执行的本质，但是 nodejs 可以提供一些方式来进行多线程和多进程开发。</p>\n<h3 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h3><h4 id=\"tagg\"><a href=\"#tagg\" class=\"headerlink\" title=\"tagg\"></a><a href=\"https://github.com/xk/node-threads-a-gogo\">tagg</a></h4><p>Jorge Chamorro Bieling是 <code>tagg(Threads a gogo for Node.js)</code> 包的作者，他硬是利用 <code>phread</code> 库和C语言让Node.js支持了多线程的开发</p>\n<h3 id=\"libuvd\"><a href=\"#libuvd\" class=\"headerlink\" title=\"libuvd\"></a>libuvd</h3><p><code>libuv</code> 是一个跨平台的异步I/O库，它主要用于Node.js的开发，同时他也被 <code>Mozilla&#39;s Rust language</code>,  <code>Luvit</code>, <code>Julia</code>,  <code>pyuv</code>等使用。它主要包括了 <code>Event loops</code> 事件循环， <code>Filesystem</code> 文件系统， <code>Networking</code> 网络支持，<code>Threads</code> 线程，<code>Processes</code> 进程，<code>Utilities</code> 其他工具。</p>\n<h3 id=\"多进程\"><a href=\"#多进程\" class=\"headerlink\" title=\"多进程\"></a>多进程</h3><h4 id=\"child-process\"><a href=\"#child-process\" class=\"headerlink\" title=\"child_process\"></a>child_process</h4><p>可以启动一个 nodejs 文件，将它作为 worker 进程，实现多进程解决主进程阻塞的问题。</p>\n<h4 id=\"cluster\"><a href=\"#cluster\" class=\"headerlink\" title=\"cluster\"></a>cluster</h4><p><code>cluster</code>可以用来让Node.js充分利用多核cpu的性能，同时也可以让Node.js程序更加健壮，官网上的<code>cluster</code>示例已经告诉我们如何重新启动一个因为异常而奔溃的子进程。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://github.com/DoubleSpout/threadAndPackage/blob/master/chapter.7.thread_and_process.md\">Node.js的线程和进程</a></li>\n<li><a href=\"http://taobaofed.org/blog/2015/10/29/deep-into-node-1/\">Node.js 探秘：初识单线程的 Node.js</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000004276027\">细说JavaScript单线程的一些事</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoo\">并发模型与Event Loop</a></li>\n</ol>"},{"title":"使用 svg 让线条动起来","date":"2016-06-28T12:43:19.000Z","_content":"[百度echarts3官网](http://echarts.baidu.com/index.html) 上有一个非常好看的绘制 logo 的效果，通过 svg 就能实现：\n![绘制logo](http://7xo08n.com1.z0.glb.clouddn.com/blog%2Fuse-svg-draw-line/02.gif)\n\n与此类似的还有绘制签名的过程：\n![绘制签名](http://7xo08n.com1.z0.glb.clouddn.com/blog/use-svg-draw-line/01.gif)\n\n其实原理很简单，只要充分发挥想象力，加上好看的设计，就能完成很多意想不到的效果了。\n\n<!-- more -->\n\n## 准备 svg\n首先要准备绘制的路径，SVG里用 path 来定义路径\n```html\n<svg width=\"580\" height=\"400\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"m149,123c0,1 -1.496231,3.907784 -2,8c-0.122177,0.992508 -2.206802,4.812653 -4,7c-2.285873,2.78833 -3.49295,5.234009 -6,10\" id=\"svg_27\" fill-opacity=\"null\" stroke-opacity=\"null\" stroke-width=\"1.5\" stroke=\"#000\" fill=\"none\"/>\n</svg>\n```\n网上可以找到很多在线的或客户端可以用来生成 svg，比如写这个 demo 用到的是 [这个在线编辑svg的网站](http://www.yyyweb.com/ctools/demo.php)。\n\n## 主要属性\n有了一段 path 之后，我们就可以开始让它动起来了，这里涉及到两个属性：\n- stroke-dasharray\n- stroke-dashoffset\n\n`stroke-dasharray` 可以让线条变成虚线，第一个值设置每段虚线的长度，第二个值设置虚线之间的间隔，如：\n\n原线条：\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/use-svg-draw-line/03.png)\n\n设置 `stroke-dasharray: 20 5` 之后：\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/use-svg-draw-line/04.png)\n\n`stroke-dashoffset` 用来设置虚线的偏移量\n\n## 原理\n可以想到，如果我们设置每段虚线的长度和虚线之间的间隔都大于整条路径的长度，那么虽然看起来没有变化，但实际上整个路径显示出来的只是一小段虚线。\n\n接着我们设置 `stroke-dashoffset` 让这条虚线偏移一个路径的长度，此时路径就不可见了，因为已经虚线已经偏移出路径了，而虚线间的空隙是大于一个路径长的。\n\n最后我们通过动画让 `stroke-dashoffset` 缓慢变为 0，这时就有绘制的效果了。\n\n代码示例：\n```javascript\nvar path = document.querySelector('path');\n// 获取路径的长度\nvar length = path.getTotalLength();\n// 设置起始点\npath.style.strokeDasharray = `${length} ${length}`;\npath.style.strokeDashoffset = length;\n// 获取一个区域，获取相关的样式，让浏览器寻找一个起始点。\npath.getBoundingClientRect();\n// 定义动作\npath.style.transition = 'stroke-dashoffset 2s ease-in-out';\n// 开始绘制\npath.style.strokeDashoffset = '0';\n```\n\n当要绘制签名这种有很多线条的图形时，只需要给每一段都设置好时间，通过 `transition` 的 `delay` 来控制开始时间即可。\n\n当要绘制本文一开始出现的闭合图形时，可以通过改变 `stroke-dasharray` 中的长度和间隔来控制。\n","source":"_posts/use-svg-to-draw-line.md","raw":"---\ntitle: 使用 svg 让线条动起来\ndate: 2016-06-28 20:43:19\ntags: [每周总结, svg]\n---\n[百度echarts3官网](http://echarts.baidu.com/index.html) 上有一个非常好看的绘制 logo 的效果，通过 svg 就能实现：\n![绘制logo](http://7xo08n.com1.z0.glb.clouddn.com/blog%2Fuse-svg-draw-line/02.gif)\n\n与此类似的还有绘制签名的过程：\n![绘制签名](http://7xo08n.com1.z0.glb.clouddn.com/blog/use-svg-draw-line/01.gif)\n\n其实原理很简单，只要充分发挥想象力，加上好看的设计，就能完成很多意想不到的效果了。\n\n<!-- more -->\n\n## 准备 svg\n首先要准备绘制的路径，SVG里用 path 来定义路径\n```html\n<svg width=\"580\" height=\"400\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"m149,123c0,1 -1.496231,3.907784 -2,8c-0.122177,0.992508 -2.206802,4.812653 -4,7c-2.285873,2.78833 -3.49295,5.234009 -6,10\" id=\"svg_27\" fill-opacity=\"null\" stroke-opacity=\"null\" stroke-width=\"1.5\" stroke=\"#000\" fill=\"none\"/>\n</svg>\n```\n网上可以找到很多在线的或客户端可以用来生成 svg，比如写这个 demo 用到的是 [这个在线编辑svg的网站](http://www.yyyweb.com/ctools/demo.php)。\n\n## 主要属性\n有了一段 path 之后，我们就可以开始让它动起来了，这里涉及到两个属性：\n- stroke-dasharray\n- stroke-dashoffset\n\n`stroke-dasharray` 可以让线条变成虚线，第一个值设置每段虚线的长度，第二个值设置虚线之间的间隔，如：\n\n原线条：\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/use-svg-draw-line/03.png)\n\n设置 `stroke-dasharray: 20 5` 之后：\n![](http://7xo08n.com1.z0.glb.clouddn.com/blog/use-svg-draw-line/04.png)\n\n`stroke-dashoffset` 用来设置虚线的偏移量\n\n## 原理\n可以想到，如果我们设置每段虚线的长度和虚线之间的间隔都大于整条路径的长度，那么虽然看起来没有变化，但实际上整个路径显示出来的只是一小段虚线。\n\n接着我们设置 `stroke-dashoffset` 让这条虚线偏移一个路径的长度，此时路径就不可见了，因为已经虚线已经偏移出路径了，而虚线间的空隙是大于一个路径长的。\n\n最后我们通过动画让 `stroke-dashoffset` 缓慢变为 0，这时就有绘制的效果了。\n\n代码示例：\n```javascript\nvar path = document.querySelector('path');\n// 获取路径的长度\nvar length = path.getTotalLength();\n// 设置起始点\npath.style.strokeDasharray = `${length} ${length}`;\npath.style.strokeDashoffset = length;\n// 获取一个区域，获取相关的样式，让浏览器寻找一个起始点。\npath.getBoundingClientRect();\n// 定义动作\npath.style.transition = 'stroke-dashoffset 2s ease-in-out';\n// 开始绘制\npath.style.strokeDashoffset = '0';\n```\n\n当要绘制签名这种有很多线条的图形时，只需要给每一段都设置好时间，通过 `transition` 的 `delay` 来控制开始时间即可。\n\n当要绘制本文一开始出现的闭合图形时，可以通过改变 `stroke-dasharray` 中的长度和间隔来控制。\n","slug":"use-svg-to-draw-line","published":1,"updated":"2016-08-27T00:03:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscgyh1s000tgq27mxcr4cg2","content":"<p><a href=\"http://echarts.baidu.com/index.html\" target=\"_blank\" rel=\"external\">百度echarts3官网</a> 上有一个非常好看的绘制 logo 的效果，通过 svg 就能实现：<br><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog%2Fuse-svg-draw-line/02.gif\" alt=\"绘制logo\"></p>\n<p>与此类似的还有绘制签名的过程：<br><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/use-svg-draw-line/01.gif\" alt=\"绘制签名\"></p>\n<p>其实原理很简单，只要充分发挥想象力，加上好看的设计，就能完成很多意想不到的效果了。</p>\n<a id=\"more\"></a>\n<h2 id=\"准备-svg\"><a href=\"#准备-svg\" class=\"headerlink\" title=\"准备 svg\"></a>准备 svg</h2><p>首先要准备绘制的路径，SVG里用 path 来定义路径<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span> <span class=\"attr\">width</span>=<span class=\"string\">\"580\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"400\"</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.w3.org/2000/svg\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">d</span>=<span class=\"string\">\"m149,123c0,1 -1.496231,3.907784 -2,8c-0.122177,0.992508 -2.206802,4.812653 -4,7c-2.285873,2.78833 -3.49295,5.234009 -6,10\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"svg_27\"</span> <span class=\"attr\">fill-opacity</span>=<span class=\"string\">\"null\"</span> <span class=\"attr\">stroke-opacity</span>=<span class=\"string\">\"null\"</span> <span class=\"attr\">stroke-width</span>=<span class=\"string\">\"1.5\"</span> <span class=\"attr\">stroke</span>=<span class=\"string\">\"#000\"</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"none\"</span>/&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>网上可以找到很多在线的或客户端可以用来生成 svg，比如写这个 demo 用到的是 <a href=\"http://www.yyyweb.com/ctools/demo.php\" target=\"_blank\" rel=\"external\">这个在线编辑svg的网站</a>。</p>\n<h2 id=\"主要属性\"><a href=\"#主要属性\" class=\"headerlink\" title=\"主要属性\"></a>主要属性</h2><p>有了一段 path 之后，我们就可以开始让它动起来了，这里涉及到两个属性：</p>\n<ul>\n<li>stroke-dasharray</li>\n<li>stroke-dashoffset</li>\n</ul>\n<p><code>stroke-dasharray</code> 可以让线条变成虚线，第一个值设置每段虚线的长度，第二个值设置虚线之间的间隔，如：</p>\n<p>原线条：<br><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/use-svg-draw-line/03.png\" alt=\"\"></p>\n<p>设置 <code>stroke-dasharray: 20 5</code> 之后：<br><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/use-svg-draw-line/04.png\" alt=\"\"></p>\n<p><code>stroke-dashoffset</code> 用来设置虚线的偏移量</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>可以想到，如果我们设置每段虚线的长度和虚线之间的间隔都大于整条路径的长度，那么虽然看起来没有变化，但实际上整个路径显示出来的只是一小段虚线。</p>\n<p>接着我们设置 <code>stroke-dashoffset</code> 让这条虚线偏移一个路径的长度，此时路径就不可见了，因为已经虚线已经偏移出路径了，而虚线间的空隙是大于一个路径长的。</p>\n<p>最后我们通过动画让 <code>stroke-dashoffset</code> 缓慢变为 0，这时就有绘制的效果了。</p>\n<p>代码示例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'path'</span>);</div><div class=\"line\"><span class=\"comment\">// 获取路径的长度</span></div><div class=\"line\"><span class=\"keyword\">var</span> length = path.getTotalLength();</div><div class=\"line\"><span class=\"comment\">// 设置起始点</span></div><div class=\"line\">path.style.strokeDasharray = <span class=\"string\">`<span class=\"subst\">$&#123;length&#125;</span> <span class=\"subst\">$&#123;length&#125;</span>`</span>;</div><div class=\"line\">path.style.strokeDashoffset = length;</div><div class=\"line\"><span class=\"comment\">// 获取一个区域，获取相关的样式，让浏览器寻找一个起始点。</span></div><div class=\"line\">path.getBoundingClientRect();</div><div class=\"line\"><span class=\"comment\">// 定义动作</span></div><div class=\"line\">path.style.transition = <span class=\"string\">'stroke-dashoffset 2s ease-in-out'</span>;</div><div class=\"line\"><span class=\"comment\">// 开始绘制</span></div><div class=\"line\">path.style.strokeDashoffset = <span class=\"string\">'0'</span>;</div></pre></td></tr></table></figure></p>\n<p>当要绘制签名这种有很多线条的图形时，只需要给每一段都设置好时间，通过 <code>transition</code> 的 <code>delay</code> 来控制开始时间即可。</p>\n<p>当要绘制本文一开始出现的闭合图形时，可以通过改变 <code>stroke-dasharray</code> 中的长度和间隔来控制。</p>\n","excerpt":"<p><a href=\"http://echarts.baidu.com/index.html\">百度echarts3官网</a> 上有一个非常好看的绘制 logo 的效果，通过 svg 就能实现：<br><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog%2Fuse-svg-draw-line/02.gif\" alt=\"绘制logo\"></p>\n<p>与此类似的还有绘制签名的过程：<br><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/use-svg-draw-line/01.gif\" alt=\"绘制签名\"></p>\n<p>其实原理很简单，只要充分发挥想象力，加上好看的设计，就能完成很多意想不到的效果了。</p>","more":"<h2 id=\"准备-svg\"><a href=\"#准备-svg\" class=\"headerlink\" title=\"准备 svg\"></a>准备 svg</h2><p>首先要准备绘制的路径，SVG里用 path 来定义路径<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span> <span class=\"attr\">width</span>=<span class=\"string\">\"580\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"400\"</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.w3.org/2000/svg\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">d</span>=<span class=\"string\">\"m149,123c0,1 -1.496231,3.907784 -2,8c-0.122177,0.992508 -2.206802,4.812653 -4,7c-2.285873,2.78833 -3.49295,5.234009 -6,10\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"svg_27\"</span> <span class=\"attr\">fill-opacity</span>=<span class=\"string\">\"null\"</span> <span class=\"attr\">stroke-opacity</span>=<span class=\"string\">\"null\"</span> <span class=\"attr\">stroke-width</span>=<span class=\"string\">\"1.5\"</span> <span class=\"attr\">stroke</span>=<span class=\"string\">\"#000\"</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"none\"</span>/&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>网上可以找到很多在线的或客户端可以用来生成 svg，比如写这个 demo 用到的是 <a href=\"http://www.yyyweb.com/ctools/demo.php\">这个在线编辑svg的网站</a>。</p>\n<h2 id=\"主要属性\"><a href=\"#主要属性\" class=\"headerlink\" title=\"主要属性\"></a>主要属性</h2><p>有了一段 path 之后，我们就可以开始让它动起来了，这里涉及到两个属性：</p>\n<ul>\n<li>stroke-dasharray</li>\n<li>stroke-dashoffset</li>\n</ul>\n<p><code>stroke-dasharray</code> 可以让线条变成虚线，第一个值设置每段虚线的长度，第二个值设置虚线之间的间隔，如：</p>\n<p>原线条：<br><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/use-svg-draw-line/03.png\" alt=\"\"></p>\n<p>设置 <code>stroke-dasharray: 20 5</code> 之后：<br><img src=\"http://7xo08n.com1.z0.glb.clouddn.com/blog/use-svg-draw-line/04.png\" alt=\"\"></p>\n<p><code>stroke-dashoffset</code> 用来设置虚线的偏移量</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>可以想到，如果我们设置每段虚线的长度和虚线之间的间隔都大于整条路径的长度，那么虽然看起来没有变化，但实际上整个路径显示出来的只是一小段虚线。</p>\n<p>接着我们设置 <code>stroke-dashoffset</code> 让这条虚线偏移一个路径的长度，此时路径就不可见了，因为已经虚线已经偏移出路径了，而虚线间的空隙是大于一个路径长的。</p>\n<p>最后我们通过动画让 <code>stroke-dashoffset</code> 缓慢变为 0，这时就有绘制的效果了。</p>\n<p>代码示例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'path'</span>);</div><div class=\"line\"><span class=\"comment\">// 获取路径的长度</span></div><div class=\"line\"><span class=\"keyword\">var</span> length = path.getTotalLength();</div><div class=\"line\"><span class=\"comment\">// 设置起始点</span></div><div class=\"line\">path.style.strokeDasharray = <span class=\"string\">`<span class=\"subst\">$&#123;length&#125;</span> <span class=\"subst\">$&#123;length&#125;</span>`</span>;</div><div class=\"line\">path.style.strokeDashoffset = length;</div><div class=\"line\"><span class=\"comment\">// 获取一个区域，获取相关的样式，让浏览器寻找一个起始点。</span></div><div class=\"line\">path.getBoundingClientRect();</div><div class=\"line\"><span class=\"comment\">// 定义动作</span></div><div class=\"line\">path.style.transition = <span class=\"string\">'stroke-dashoffset 2s ease-in-out'</span>;</div><div class=\"line\"><span class=\"comment\">// 开始绘制</span></div><div class=\"line\">path.style.strokeDashoffset = <span class=\"string\">'0'</span>;</div></pre></td></tr></table></figure></p>\n<p>当要绘制签名这种有很多线条的图形时，只需要给每一段都设置好时间，通过 <code>transition</code> 的 <code>delay</code> 来控制开始时间即可。</p>\n<p>当要绘制本文一开始出现的闭合图形时，可以通过改变 <code>stroke-dasharray</code> 中的长度和间隔来控制。</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ciscgyh0n0000gq27h845c0jm","tag_id":"ciscgyh0y0002gq27ko68jdw1","_id":"ciscgyh18000agq27fue674m0"},{"post_id":"ciscgyh0n0000gq27h845c0jm","tag_id":"ciscgyh120005gq275r3wraen","_id":"ciscgyh19000cgq27z34jrq89"},{"post_id":"ciscgyh0s0001gq2703h7otky","tag_id":"ciscgyh0y0002gq27ko68jdw1","_id":"ciscgyh1f000igq2766weptdj"},{"post_id":"ciscgyh0s0001gq2703h7otky","tag_id":"ciscgyh120005gq275r3wraen","_id":"ciscgyh1j000kgq27vnoxeev0"},{"post_id":"ciscgyh100003gq27e95dlw4n","tag_id":"ciscgyh0y0002gq27ko68jdw1","_id":"ciscgyh1q000qgq27mm9a6p4f"},{"post_id":"ciscgyh100003gq27e95dlw4n","tag_id":"ciscgyh120005gq275r3wraen","_id":"ciscgyh1s000sgq27mopci7hl"},{"post_id":"ciscgyh110004gq27tzy1xdwr","tag_id":"ciscgyh0y0002gq27ko68jdw1","_id":"ciscgyh1t000vgq27smm6lfui"},{"post_id":"ciscgyh110004gq27tzy1xdwr","tag_id":"ciscgyh120005gq275r3wraen","_id":"ciscgyh1u000wgq27khax1htw"},{"post_id":"ciscgyh130006gq27xc3x6zz5","tag_id":"ciscgyh0y0002gq27ko68jdw1","_id":"ciscgyh1v000ygq277nbhf05f"},{"post_id":"ciscgyh130006gq27xc3x6zz5","tag_id":"ciscgyh120005gq275r3wraen","_id":"ciscgyh1v000zgq27wnv1p12l"},{"post_id":"ciscgyh140007gq27zdeuvwdg","tag_id":"ciscgyh1u000xgq27jct5ir8x","_id":"ciscgyh1w0012gq274qrnaw7t"},{"post_id":"ciscgyh140007gq27zdeuvwdg","tag_id":"ciscgyh1v0010gq27cy5r5sku","_id":"ciscgyh1w0013gq27a6zmvafc"},{"post_id":"ciscgyh160008gq2778thwsgp","tag_id":"ciscgyh1u000xgq27jct5ir8x","_id":"ciscgyh1x0015gq27p0p8vgbk"},{"post_id":"ciscgyh18000bgq27c0pyafru","tag_id":"ciscgyh1u000xgq27jct5ir8x","_id":"ciscgyh1y0017gq27pltizyg5"},{"post_id":"ciscgyh19000dgq27dswjx2ut","tag_id":"ciscgyh1u000xgq27jct5ir8x","_id":"ciscgyh1y001agq2735fqeac7"},{"post_id":"ciscgyh19000dgq27dswjx2ut","tag_id":"ciscgyh1y0018gq27mziez7gf","_id":"ciscgyh1y001bgq27xa0jhi4v"},{"post_id":"ciscgyh1b000fgq27n29vj4g8","tag_id":"ciscgyh1u000xgq27jct5ir8x","_id":"ciscgyh1z001egq2726h2criw"},{"post_id":"ciscgyh1b000fgq27n29vj4g8","tag_id":"ciscgyh1v0010gq27cy5r5sku","_id":"ciscgyh1z001fgq27v33oeqoj"},{"post_id":"ciscgyh1c000ggq275yzxx1r5","tag_id":"ciscgyh1u000xgq27jct5ir8x","_id":"ciscgyh21001igq27rqvg1xco"},{"post_id":"ciscgyh1c000ggq275yzxx1r5","tag_id":"ciscgyh1v0010gq27cy5r5sku","_id":"ciscgyh22001jgq27qkxfjgn4"},{"post_id":"ciscgyh1g000jgq27dpc6zv9w","tag_id":"ciscgyh20001hgq278541g294","_id":"ciscgyh24001mgq27n4jqr1np"},{"post_id":"ciscgyh1g000jgq27dpc6zv9w","tag_id":"ciscgyh1u000xgq27jct5ir8x","_id":"ciscgyh24001ngq271nawscxm"},{"post_id":"ciscgyh1j000lgq2733gd8y9h","tag_id":"ciscgyh1u000xgq27jct5ir8x","_id":"ciscgyh25001pgq27tgjjbd1n"},{"post_id":"ciscgyh1n000ngq27049ubs4a","tag_id":"ciscgyh24001ogq27fquko9dg","_id":"ciscgyh26001rgq27wjtd9ghw"},{"post_id":"ciscgyh1p000ogq277zr40ov0","tag_id":"ciscgyh1u000xgq27jct5ir8x","_id":"ciscgyh28001ugq27yszef35p"},{"post_id":"ciscgyh1p000ogq277zr40ov0","tag_id":"ciscgyh1v0010gq27cy5r5sku","_id":"ciscgyh28001vgq27ubaz15g0"},{"post_id":"ciscgyh1q000rgq27j9o567hq","tag_id":"ciscgyh1u000xgq27jct5ir8x","_id":"ciscgyh2a001ygq27qc9nuh75"},{"post_id":"ciscgyh1q000rgq27j9o567hq","tag_id":"ciscgyh1y0018gq27mziez7gf","_id":"ciscgyh2a001zgq27p2oyi8vx"},{"post_id":"ciscgyh1s000tgq27mxcr4cg2","tag_id":"ciscgyh1u000xgq27jct5ir8x","_id":"ciscgyh2b0021gq27983502zf"},{"post_id":"ciscgyh1s000tgq27mxcr4cg2","tag_id":"ciscgyh2a0020gq2743emt511","_id":"ciscgyh2b0022gq27i01d1c7h"}],"Tag":[{"name":"读书笔记","_id":"ciscgyh0y0002gq27ko68jdw1"},{"name":"算法","_id":"ciscgyh120005gq275r3wraen"},{"name":"每周总结","_id":"ciscgyh1u000xgq27jct5ir8x"},{"name":"数据结构","_id":"ciscgyh1v0010gq27cy5r5sku"},{"name":"javascript","_id":"ciscgyh1y0018gq27mziez7gf"},{"name":"git","_id":"ciscgyh20001hgq278541g294"},{"name":"自然语言处理 读书笔记","_id":"ciscgyh24001ogq27fquko9dg"},{"name":"svg","_id":"ciscgyh2a0020gq2743emt511"}]}}
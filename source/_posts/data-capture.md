---
title: 数据抓取の经验
date: 2016-08-12 21:32:34
tags: [总结]
---

## 业务需求

这里讨论的是给了用户名和密码，需要获取登陆之后页面内的某些数据。
那么问题来了，
**Q1. 用户名和密码都有了，直接登录不就完了吗！**
A: 用机器去抓，省时又省力，关键是很酷。
**Q2. 用户名和密码都有了，难道不是 so easy 吗！**
A: 一般情况下都挺简单，但也有部分网站相当难抓，比如 [腾讯爸爸](http://tui.qq.com/)。
**Q3. 用户名和密码都有了，登陆一次，以后携带 cookie 不就可以了吗！**
A: cookie 很容易过期，让程序自己去拿 cookie，这样每次都是最新的 cookie，不是更酷吗？

理想情况下，**构建请求参数 ---> 请求登陆接口 ---> 返回 SESSIONID ---> 携带 SESSIONID 请求目标接口**，就能拿到数据了，但是很可惜，一般的网站都不是理想情况，要成功干好这件事，需要非常非常地耐心和非常非常地仔细。
<!--more-->
## 第〇步 清空浏览器 Cookie

这是最重要的一步，一定要清，不然哭一整天。另外在抓取过程中，只要重来，就清一次。因为如果不清 Cookie，浏览器会将上次保留的 Cookie 发送出去，干扰我们找真实的请求。
下图是Chrome 清空 cookie 的地方：

![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/01.png)

什么？你不是用 chrome？那你别往下看了

## 第一步 从需要抓取的接口找起

要抓取的数据肯定是来源于一个接口的，只是响应体内容可能有差异，比如是 JSON 格式返回的，或者是藏在 HTML 返回的，都有可能。首先要找到这个目标接口，然后重点关注它的请求头。

![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/02.png)

Cookie 是服务器判断用户有没有登陆的凭证，对应于服务器上的 Session，所以一般情况下，只要能拿到这个字段就大功告成了。请求的 cookie 都在请求体的 cookie 中，对应的响应的 cookie 都在响应体的 set-cookie 中。
不同的后台语言对应不同的 Session 名字，常见的有： JSESSIONID (Java EE),、PHPSESSID (PHP)、 ASPSESSIONID (Microsoft ASP).。如上图可以大致推断这个网站是使用 JavaEE 开发的。

## 第二步 从后往前推

找到抓取数据所在的接口以后，一步一步往上找，点击请求，打开右侧的 Cookies 选项卡，可以看到这次请求的 Cookies 交互情况。**如果 Response Cookies 出现了目标请求中的 JSESSIONID**，没错！离成功近了一步，你需要拿小本子把这个请求记下来了。
而这个请求在请求时很可能也需要一些 Cookies，所以以此类推，继续往上找。

![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/03.png)

## 第三步 找到登陆请求

要登录的网站必定是有个登录的请求的，登录请求一般有这么几种参数：
1) 用户名、明文密码
2) 用户名、加密密码
3) 用户名、加密密码、加密其他参数
（当然一般登陆还需要验证码，使用一些能够破解验证码的服务即可）

碰到第一种，恭喜，今天可以提前下班了。登录的参数已经都有了，剩下的，一是请求登录接口可能需要 cookies，这个 cookies 如果包含 sessionid，sessionid 一定可以从登录之前的接口拿到，那么往前找就对了。二是请求登录接口之后一定会**直接或间接**返回**能够代表用户凭证的东西**，拿着这个东西，继续寻找能够**拿到目标接口需要的 sessionid** 即可。

碰到第二种，还行，仔细的话还是能正常加班的。加密的过程一定是在 javascript 中完成的，打开源码，好好啃一下，这里有两个经验，一是可以先找一下这个按钮有没有 click 事件，如果有，八成在这个事件里写好了加密过程，如果没有，说明是表单提交。

![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/04.png)

另外实在没有办法，就在源码里搜一下 cookie 等相关的字段，更容易命中一点。

碰到第三种，去洗把脸准备准备加班了。其实不管是加密密码，还是加密其他参数，都是在 js 里面完成的，难度可能其实差不多，但是这体现了后台的重视程度。。。所以可能会更复杂一点，像腾讯里面使用了统一的登陆方式，所以也使用了统一的加密方法，加密的地方还蛮多的，看源码找了半天才找出来，这里就不展开了，有兴趣可以交流一下。

## 一点人生经验

抓取的方法其实在上面三步里说的差不多了，说白了就是仿照请求的过程，在不同的请求中寻找前后台交互的流程，下面是中间的一些经验：

### 1) cookie 的作用域

每个 cookie 都有自己的域，这可能在刚抓取的时候很容易被忽视，网页在登陆前后的跳转中，很可能会经历不同的域名，比如从 site.com/aaa 跳到 site.com/bbb，这两次返回的 cookie 域可能就会不同，重要的是这两个响应可能都返回 SESSIONID，但是两个是**不同**的，一定要分清接下来的请求携带的是哪一个。举个栗子：

![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/05.png)

![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/06.png)

同样是 JSESSIONID，不能搞混哦。

### 2) 302 跳转
你可能会碰到 302 重定向，可怕的是有的信息就藏在 302 请求中：

![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/07.png)

这里就有个坑了，之前没有注意，我请求这个 url 的时候，想拿这个 cookie，写好代码之后，发现确实拿到 cookie 了，但是后面请求目标接口总是不成功，最后把响应头拿出来一看，发现！

![](http://7xo08n.com1.z0.glb.clouddn.com/blog/data-capture/08.png)

尼玛！cookie 的作用域不同啊！（上面是 /ad/，而我的是 /hccas/）
然后把响应状态打出来一看！
200！
擦擦擦擦，一下午就被这个干掉了，其实这是因为 request.js（我使用的是nodejs）对 302 请求作了自动重定向造成了，也就是碰到 302 就跟着跳了，但我们并不想它跳，这时需要设置一个参数：

```
followRedirect: false
```

然后就成功拿到了！

---
title: 《算法导论》第八章：线性时间排序
date: 2016-07-09 21:59:26
tags: [读书笔记, 算法]
---

在前面几张总共介绍了*插入排序、归并排序、堆排序和快速排序*，这些算法都有一个有趣的性质：**在排序的最终结果中，各元素的次序依赖于它们之间的比较**。我们把这类排序算法成为比较排序。

接下来讨论三种线性时间复杂度的排序算法：计数排序、基数排序和桶排序，它们使用运算而不是比较来确定排序顺序。

## 排序顺序的下界
在一个比较排序中，我们只使用元素间的比较来获得输入序列 `<a1, a2, ..., an>` 中的元素间次序的信息。也就是给定两个元素 `ai` 和 `aj`，我们执行比较操作来确定它们之间的相对次序。

### 决策树模型
比较排序可以被抽象为一颗决策树。

决策树是一颗**完全二叉树**，它可以表示在给定输入规模情况下，某一特定排序算法对所有元素的比较操作。其中，控制、数据移动等其他操作都被忽略了。

在决策树中，每个内部结点都以 `i : j` 标记，其中，`i` 和 `j` 满足 `1 <= i <= j <= n`，`n` 是输入序列中的元素个数。每个叶结点上都标注一个序列 `<π(1), π(2), ..., π(n)`。

排序算法的执行对应于一条从树的根结点到叶结点的路径。每一个内部结点表示比较一次 `ai` 和 `aj`。

每当到达一个叶结点的时候，代表排序算法已经确定了一个顺序。对于一个正确的比较排序算法来说，`n` 个元素的 `n!` 种可能的排列都应该出现在决策树的叶结点上。而且，每一个叶结点都必须是可以从根结点经由某条路径到达的，该路径对应于比较排序的一次实际执行过程（我们称这种叶结点为“可达的”）。

![](http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-8/01.png)

如上图，这是一颗作用于三个元素的插入排序决策树。根节点表示第一个元素和第二个元素进行了比较，当第一个元素小于等于第二个元素时，进入根节点的左孩子，将第二个元素和第三个元素进行比较，以此类推。最后，如果第三个孩子小于第一个孩子小于第二个孩子，则排序结果是 `<3, 1, 2>`。

### 最坏情况的下界

对于一颗每个排列都是一个可达叶结点的决策树来说，树的高度完全可以被确定。考虑一颗高度为 `h`，具有 `l` 个可达叶结点的决策树，它对应一个对 `n` 个元素所做的比较排序。

因为输入数据的 `n!` 种可能的排列都是叶结点，所以有 `n! <= l`。

由于在一棵高度为 `h` 的二叉树中，叶结点的数目不多于 `2^h`，所以有 `l <= 2^h`。

我们即得到 `n! <= l <= 2^h`。

两边取对数，有

> h >= lg(n!) = Ω(nlgn)

我们即得到定理：*在最坏情况下，任何比较排序算法都需要做 Ω(nlgn) 次比较*

## 计数排序

上面说完比较排序的最坏下界，我们现在开始讨论线性时间复杂度的排序算法。

**计数排序假设 `n` 个输入元素中的每一个都是在 `0` 到 `k` 区间内的一个整数，其中 `k` 为某个整数**。当 `k = O(n)` 时，排序的运行时间为 `Θ(n)`。

### 思想

计数排序的思想是：对每一个输入元素 `x`，确定小于 `x` 的元素个数。这样，当需要排序元素 `x` 时，只需把 `x` 直接放到它在输出数组中的位置了。

比如如果有 `17` 个元素小于 `x`，则 `x` 应该被放到第十八个输出位置上。当有几个元素相同时，这一方案要略作修改，因为不能把它们放到同一个位置。

### 伪代码

在计数排序的算法中，假设输入是一个数组 `A[1 .. n]`，`A.length = n`。我们还需要两个数组：`B[1 .. n]` 存放输出数组， `C[0 .. k]` 存放个数信息。

*COUNTING-SORT(A, B, k)*
```
// C 数组长度为输入数组的最大值
let C[0 .. k] be a new array
// 将 C 数组的元素全部赋值为 0 
for i = 0 to k
  C[i] = 0
// 遍历输入数组，并将 C 元素中对应的值个数加一
for j = 1 to A.length
  C[A[j]] = C[A[j]] + 1
// 此时 C 数组中存放的是下标在输入数组中的个数
// C[i] now contains the number of elements equal to i
// 遍历 C 数组，将个数转变为小于等于下标的个数
for i = 1 to k
  C[i] = C[i] + C[i - 1]
// C[i] now contains the number of elements less than or equal to i
// 将输入数组中的元素放入输出数组中对应的位置
for j = A.length downto 1
  B[C[A[j]]] = A[j]
  C[A[j]] = C[A[j]] - 1
```

### 排序过程

假设数组 `A` 元素为：`2, 5, 3, 0, 2, 3, 0, 3`

1) 因为输入数组最大元素为 `5`，所以初始化 `C` 数组长度为 `5`。

2) 遍历 `A` 数组，将 `C` 数组中下标为遍历到的元素大小的元素加 1。

3) 步骤 2 结束后 `C` 数组元素为：`2, 0, 2, 3, 0, 1`，代表 `A` 数组中 `0` 个数为 `2`，'1' 个数为 `0`，以此类推。

4) 遍历 `C` 数组，将元素大小置为当前元素大小加前一元素大小。

5) 步骤 4 结束后，`C` 数组元素为：`2, 2, 4, 7, 7, 8`，代表 `A` 数组中小于等于 `0` 个数为 `2`，小于等于 '1' 个数为 `2`，小于等于 '2' 个数为 `4`，以此类推。

6) 遍历 `A` 数组，利用 `C` 数组中的信息将元素放置到对应的位置，需要注意每放置完一个元素需要将对应的小于等于个数减一。

计数排序的总时间代价是 `Θ(k + n)`，当 `k = O(n)` 时，我们一般采用计数排序，此时运行时间为 `Θ(n)`。

计数排序的另一个重要性质是它是**稳定的**：具有相同大小的元素，在输入数组中先出现的，在输出数组中也位于前面。

### javascript 实现
```javascript
unction countingSort(arr, k) {
  var B = [], C = [0];
  for(var i = 0; i < k; i++, C[i] = 0) {/*empty*/}
   
  for(var i = 0; i < arr.length; i++) {
    C[arr[i]] = C[arr[i]] + 1;
  }

  for(var i = 1; i < C.length; i++) {
    C[i] = C[i] + C[i - 1];
  }

  for(var i = arr.length - 1; i >= 0; i--) {
    // -1 是因为小于等于该元素的个数包括该元素
    B[C[arr[i]] - 1] = arr[i];
    C[arr[i]] = C[arr[i]] - 1;
  }
  
  return B;
}

var arr = [2, 5, 3, 0, 2, 3, 0, 3];
countingSort(arr, 5); // [0, 0, 2, 2, 3, 3, 3, 5]
```

## 基数排序

基数排序用于排序 `n` 个 `d` 位数，先按最低有效位进行排序，然后按次低有效位，直到对所有的 `d` 位数都进行了排序。

基数排序的代码是非常直观的，假设 `n` 个 `d` 位的元素存放在数组 `A` 中，其中第 `1` 位是最低位，第 `d` 位是最高位。如果我们希望元素排序完之后顺序不会被改变，那么在排序有效位过程中需要使用一种稳定的排序算法。

*RADIX-SORT(A, d)*
```
for i = 1 to d
  use a stable sort to sort array A on digit d
```

以 8 个 3 位数举例，排序过程如下：

![](http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-8/02.jpg)

对于 `n` 个 `d` 位数，其中每一个数位有 k 个可能的取值。如果 `RADIX-SORT` 使用的稳定排序方法耗时 `Θ(n + k)`，那么它就可以在 `Θ(d(n + k))` 时间内将这些数排好序。

## 桶排序

桶排序假设输入数据服从均匀分布，平均情况下它的时间代价为 `O(n)`。

桶排序将 `[0, 1)` 划分为 `n` 个相同大小的子区间，称为桶。然后，将 n 个输入数分别放到桶中，因为输入数据是均匀、独立地分布在 `[0, 1)` 上，所以一般不会出现很多数落在同一个桶中的情况。为了得到输出结果，我们先对每个桶中的数进行排序，然后遍历每个桶，按照次序把各个桶中的元素列出来即可。

算法需要一个临时数组 `B[0 .. n-1]` 来存放链表（即桶），并假设存在一种用于维护这些链表的机制。

### 排序过程
![](http://7xo08n.com1.z0.glb.clouddn.com/blog/Introduction-to-Algorithms-8/03.jpg)
---
title: 如何实现五子棋 AI
date: 2016-07-31 20:57:34
tags: [每周总结]
---

和水哥在北戴河回来的车上除了讨论 24 点的实现方式之外，还讨论了一下五子棋的算法。昨天趁着周末凭着自己的想法试着写了一下，很不幸的是五子棋没写出来，倒是写了个三子棋（orz），网上查了一些资料，其实这里面涉及两个主要的算法，一个是**极大极小搜索**，另一个是**alpha-beta剪枝**。

<!-- more -->

## 博弈树

下过五子棋的人都应该知道，越厉害的人，对棋面的预测程度越深。换句话讲，就是当你下完一步棋，我就能在我的脑海里假设把我所有可能下的地方都下一遍，然后考虑我下完之后你又会下在哪里，最后我根据每次预测的局势好坏来判断我的下一步棋放哪最合适。当然这只是想了一层，一个专业的棋手思考的层数会多得多。

作为一个难度较大的 AI，势必也需要能够对棋局进行深入分析，然而五子棋的棋盘大小一般是 15 * 15，可以落子的地方太多，在这种情况下，电脑的性能有限，我们需要满足 AI “思考”的层数不能太低，同时算法的效率要高。

以三子棋为例，AI 思考的过程就如同下面这课树一样，我们用圆圈代表玩家，叉号代表 AI，根节点是用户的落子。

![](http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/01.png)

如果继续画下一层，那么下一层就是玩家下一步的落子，这也就是 AI 思考的层数又多了一层。

有了这棵树，我们就需要得出每个节点的得分是多少，以判断哪一步是最优的。

### 得分

要考虑这一步棋是不是最优的，我们需要给每一步棋都设定一个得分，然后找出最忧的。当前棋面的得分多少，需要同时考虑玩家和 AI 分别的得分。

以三子棋为例，当玩家下在左上角的时候，我们考虑 AI 下在正中间时的得分。得分的计算方法是将棋面的空白地方用棋子填满，然后得出连成三个的个数有多少。（如果是五子棋，应该只需找出当前棋面上所有连子，然后根据每种连子的权重来计算得分）

![](http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/04.png)

如图，玩家一共有 4 个成三，而 AI 一共有 5 个，所以总得分是 `5 - 4 = 1`。

这里需要指出的是，在博弈树中，一个节点的得分是取决于他的子节点的，也就是说，当 AI 只思考一层，也就是上图这样，这棵树的末尾就是只有两个棋子，那么这个节点的得分就是这样计算，而如果这个节点下还有子节点，那么我们只会计算叶子节点的得分，然后从叶子节点开始，一步步倒推出父节点的得分。下面来进行解释倒推的过程。

### 博弈

当 AI 下棋时，我们必定要让 AI 下在得分最高的位置，这毋庸置疑。但是以 AI 的角度来考虑玩家的落子，我们需要假设玩家是“聪明的”，他会下在对自己最有利的地方，也就是得分最低的地方（因为得分 = AI 分数 - 玩家分数）。

这就造成每一层的性质是不同的，在玩家落子的层里，我们要选取得分最低的；在 AI 落子的层里，我们要选取得分最高的。所以我们称玩家层为 MIN 层，AI 层为 MAX 层。

## 极大极小搜索

上面提到了，计算出叶子节点之后，我们需要倒推出父节点的得分，倒推的原则其实就是上面说的：MAX
层中的节点会从子节点中挑选最大得分的节点作为它的得分，MIN 层的节点会从子节点中挑选最小得分的节点作为它的得分。

以下图举例：

![](http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/02.png)

因为我们是根据子节点的得分来倒推父节点的得分的，所以我们是用深度优先来遍历博弈树的，在上面这棵树中，遍历顺序是 `ABCDEFGHIJ`，赋值过程如下：

1. 遍历完 A B，因为 C 是 MIN 层，所以选取 AB 中最小的，即 8 作为 C 的得分
2. 遍历完 D E，F 的得分为 6
3. 遍历完 G H，I 的得分为 5
4. 因为 J 在 MAX 层，所以选取 C F I 中得分最大的，即 8 作为 I 的得分

## alpha-beta 剪枝

从上面可以想到，像五子棋这种可能性很多的情况，这棵树会变得非常大，当层数增加的时候，计算量也会越来越大，如果不采取一些方法，我们只能靠牺牲层数来换取运行时间。

那么 alpha-beta 剪枝就是一种行之有效的方法，顾名思义，采用这种方法，我们会剪去一些不必要的树枝，也就减少了运行的时间。

alpha-beta 剪枝的定义很绕口，但是原理很简单，还是以上面那课树为例：

![](http://7xo08n.com1.z0.glb.clouddn.com/blog/five-in-a-row/03.png)

当遍历到 C 的时候，计算出 C 的得分是 `8`，因为 J 的得分是 C、F、I 之中最大的，所以此时可以得出 `J >= 8`。

接下来遍历到 D，D 的值为 `6`，因为 F 的值是 D 和 E 之中最小的，所以即使现在还没有遍历完 F 的子节点也可以得出 `F <= 6`，那么既然 J 已经大于等于 `8` 了，所以继续遍历 F 已经没有意义了，那么我们就将 F 这条枝剪掉。

同理，当 G 为 `5` 时，遍历 I 已经没有意义了，因为 I 不可能再大于 `5`，所以直接得出 J 为 `8`；

可以看出，当节点很多的情况下，使用 alpha-beta 剪枝是能在一定程度上提高运行效率的。